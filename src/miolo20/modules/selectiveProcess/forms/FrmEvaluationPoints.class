<?php
/**
 * <--- Copyright 2005-2010 de Solis - Cooperativa de Soluções Livres Ltda.
 *
 * Este arquivo é parte do programa Sagu. 
 *
 * O Sagu é um software livre; você pode redistribuí-lo e/ou modificá-lo
 * dentro dos termos da Licença Pública Geral GNU como publicada pela Fundação
 * do Software Livre (FSF); na versão 2 da Licença.
 *
 * Este programa é distribuído na esperança que possa ser útil, mas SEM
 * NENHUMA GARANTIA; sem uma garantia implícita de ADEQUAÇÃO a qualquer MERCADO
 * ou APLICAÇÃO EM PARTICULAR. Veja a Licença Pública Geral GNU/GPL em
 * português para maiores detalhes.
 *
 * Você deve ter recebido uma cópia da Licença Pública Geral GNU, sob o título
 * "LICENCA.txt", junto com este programa, se não, acesse o Portal do Software
 * Público Brasileiro no endereço www.softwarepublico.gov.br ou escreva para a
 * Fundação do Software Livre (FSF) Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA --->
 *
 * Evaluation points form
 *
 * @author Jonas Gualberto Diel [jonas_diel@solis.coop.br]
 *
 * @version: $Id$
 *
 * \b Maintainers \n
 * Arthur Lehdermann [arthur@solis.coop.br]
 * Jonas Gualberto Diel [jonas_diel@solis.coop.br]
 *
 * @since
 * Class created on 03/01/2011
 */
/**
 * Form to manipulate a evaluation points
 */
class FrmEvaluationPoints extends SForm
{
    /**
     * Class constructor
     */
    public function __construct()
    {
        $module = MIOLO::getCurrentModule();

        parent::__construct( _M('Digitação de notas', $module), new SprEvaluationPoints(), array('evaluationId') );

        // Desabilita os botões novo, imprimir, salvar, deletar, pesquisar
        $this->toolbar->disableButton('tbBtnNew');
        $this->toolbar->disableButton('tbBtnPrint');
        $this->toolbar->disableButton('tbBtnSave');
        $this->toolbar->disableButton('tbBtnDelete');
        $this->toolbar->disableButton('tbBtnSearch');
    }

    /**
     * Default method to define fields
     */
    public function defineFields()
    {
        $MIOLO = MIOLO::getInstance();
        $module = MIOLO::getCurrentModule();
        $action = MIOLO::getCurrentAction();
        $function = MIOLO::_request('function');

        // Campo processo seletivo
        $selectiveProcessLabel = new MText('selectiveProcessLabel', _M('Processo seletivo', $module) . ':');
        $selectiveProcessLabel->setWidth(SAGU::getParameter('BASIC', 'FIELD_LABEL_SIZE'));
        $selectiveProcessLabel->setClass('m-caption m-caption-required');
        $selectiveProcessId = new MLookupTextField('selectiveProcessId', $this->getFormValue('selectiveProcessId', $data->selectiveProcessIdS), null, SAGU::getParameter('BASIC', 'FIELD_LOOKUPFIELD_SIZE'), null, null, 'selectiveProcessDescription', $module, 'selectiveProcess', null, null, true);
        $selectiveProcessId->setJsHint(_M('Informe o código do processo seletivo', $module));
        $selectiveProcessDescription = new MTextField('selectiveProcessDescription', $this->getFormValue('selectiveProcessDescription', $data->selectiveProcessDescription), null, SAGU::getParameter('BASIC', 'FIELD_DESCRIPTION_SIZE'));
        $selectiveProcessDescription->setReadOnly(true);
        $selectiveProcessDescription->setJsHint(_M('Descrição do processo seletivo',$module));
        $fields[] = $selectiveProcess = new MHContainer('selectiveProcessCnt',array($selectiveProcessLabel, $selectiveProcessId, $selectiveProcessDescription));
        $selectiveProcess->showLabel = true;
        $validators[] = new MIntegerValidator('selectiveProcessId', _M('Processo seletivo', $module), 'required');

        // Campo etapa
        $stepLabel = new MText('evaluationLabel', _M('Etapa', $module) . ':');
        $stepLabel->setWidth(SAGU::getParameter('BASIC', 'FIELD_LABEL_SIZE'));
        $stepLabel->setClass('m-caption m-caption-required');
        $stepId = new MLookupTextField('stepId', $this->getFormValue('stepId', $data->stepId), null, SAGU::getParameter('BASIC', 'FIELD_LOOKUPFIELD_SIZE'), null, null, 'stepDescription, selectiveProcessId, selectiveProcessDescription', $module, 'step', null, array('selectiveProcessId'=>'selectiveProcessId'), true);
        $stepId->setJsHint(_M('Informe o código da etapa', $module));
        $stepDescription = new MTextField('stepDescription', $this->getFormValue('stepDescription', $data->stepDescription), null, SAGU::getParameter('BASIC', 'FIELD_DESCRIPTION_SIZE'));
        $stepDescription->setReadOnly(true);
        $stepDescription->setJsHint(_M('Descrição da etapa',$module));
        $fields[] = $step = new MHContainer('stepCnt',array($stepLabel, $stepId, $stepDescription));
        $step->showLabel = true;
        $validators[] = new MIntegerValidator('stepId', _M('Etapa', $module), 'required');

        // Campo opção de curso
        $options = array(
            'label' => _M('Opção de curso', $module),
            'module' => SAGU::getFileModule(__FILE__),
            'item' => 'OptionCourseSelectiveProcess',
            'related' => 'optionIdDescription, selectiveProcessId, selectiveProcessDescription',
            'filter' => array('selectiveProcessId' => 'selectiveProcessId', 'optionId' => 'optionId')  );
        $fields[] = new SLookupContainer('optionId', $this->getFormValue('optionId', $data->optionId), $options);

        // Campo inscrição
        $subscriptionLabel = new MText('subscriptionLabel', _M('Inscrição', $module) . ':');
        $subscriptionLabel->setWidth(SAGU::getParameter('BASIC', 'FIELD_LABEL_SIZE'));
        $subscriptionId = new MLookupTextField('subscriptionId', $this->getFormValue('subscriptionId', $data->subscriptionIdS), null, SAGU::getParameter('BASIC', 'FIELD_LOOKUPFIELD_SIZE'), null, null, 'personId, personName', $module, 'subscription', null, null, true);
        $subscriptionId->setJsHint(_M('Informe o código da inscrição', $module));
        $personId = new MTextField('personId', $this->getFormValue('personId', $data->personId), null, SAGU::getParameter('BASIC', 'FIELD_ID_SIZE'));
        $personId->setReadOnly(true);
        $personId->setJsHint(_M('Código da pessoa',$module));
        $personName = new MTextField('personName', $this->getFormValue('personName', $data->personName), null, SAGU::getParameter('BASIC', 'FIELD_DESCRIPTION_SIZE'));
        $personName->setReadOnly(true);
        $personName->setJsHint(_M('Nome da pessoa',$module));
        $fields[] = $selectiveProcess = new MHContainer('subscriptionCnt',array($subscriptionLabel, $subscriptionId, $personId, $personName));
        $selectiveProcess->showLabel = true;
        $validators[] = new MIntegerValidator('personId', _M('Inscrição', $module), 'optional');
        
        //Selection  para escolha da ordenação: inscrição ou por pessoa
        $opt = array('INS' => _M('Inscrição'), 'PES' => _M('Pessoa'));        
        $order = new MSelection('order', SAGU::NVL($this->GetFormValue('order', $data->order), 'INS'),'Ordernar por', $opt);
        $fields[] =  $order;       

        $fields[] = new MButton('loadEvaluations', _M('Carregar avaliações'), $this->getAjaxAction('loadEvaluations', 'divData', true, array('searchClick' => 'true') ) );
        $fields[] = new MDiv('divData');
        
        parent::defineFields( array( 'fields' => $fields, 'validators' => $validators ) ); 
    }

    /**
     * Método para carregar as informações do processo seletivo
     * @param $args
     */
    public function loadEvaluations($args)
    {      
        $MIOLO = MIOLO::getInstance();
        $module = MIOLO::getCurrentModule();
        $selectiveProcessId = $args->selectiveProcessId;
        $session = $MIOLO->getSession();
        $evaluation = new SprEvaluationPoints(); 

        $filters = new stdClass(); 
        $filters->order = $args->order;
        $filters->stepId = $args->stepId;
        $filters->optionId = $args->optionId;        
        if ( strlen($args->subscriptionId) > 0 )
        {
            $filters->subscriptionId = $args->subscriptionId;
        }
        $filters->limit = 1;
        $filters->digitacaoDeNotas = true;

        // Obtém o total de registros a serem navegados
        $totalIndex = SprSubscriptionStepInfo::getTotalSubscriptions($filters);

        if ( !strlen($args->index) > 0 )
        {
            // Busca pelas informações da etapa
            $filters->offset = $args->index;
            $filters->optionId = $args->optionId;       
            $filters->digitacaoDeNotas = true;
            $data = SprSubscriptionStepInfo::search($filters);            
            if ( count($data) > 0)
            {
                if ( $totalIndex == 1 )
                {
                    $btns[] = new MButton('btnSave', _M('Salvar', $module), $this->getAjaxAction('loadEvaluations', 'divData', true, array('index' => 0)));
                }
                else
                {
                    $btns[] = new MButton('btnProx', _M('Próximo', $module), $this->getAjaxAction('loadEvaluations', 'divData', true, array('index' => $args->index+1, 'dir' => 'front')));                    
                }
            }

            // Compara a data atual com a data limite para registro das notas para liberar ou nao a edição das notas
            $scoreDate = $data[0]->step->scoreDate; // Data limite para registro das notas
            if (SAGU::dateDiff(SAGU::getDateNow(), $scoreDate) <= 0 )
            {
               $readOnly = false;
            }
            else
            {
                $readOnly =  true;
                $evalFlds[] = new MLabel(_M('O período para digitação de notas encerrou em: ', $module). SAGU::toDefaultDate($scoreDate, SAGU::getParameter('BASIC', 'MASK_DATE')));
            }
        }
        else
        {
            if ($args->dir == 'front')
            {
                $saveIndex = $args->index-1;
            }
            elseif($args->dir == 'back')
            {
                $saveIndex = $args->index+1;
            }
            else
            {
                $saveIndex = $args->index;
            }
            
            // Obtém os dados do próximo registro
            $filters->offset = $args->index;
            $filters->digitacaoDeNotas = true;
            $data = SprSubscriptionStepInfo::search($filters);

            // Obtém os dados do registro a ser salvo
            $filters->offset = $saveIndex;
            $filters->digitacaoDeNotas = true;
            $dataSave = SprSubscriptionStepInfo::search($filters);
           
            // Compara a data atual com a data limite para registro das notas para liberar ou nao a edição das notas
            $scoreDate = $data[0]->step->scoreDate; // Data limite para registro das notas
            if (SAGU::dateDiff(SAGU::getDateNow(), $scoreDate) <= 0 )
            {
               $readOnly = false;
            }
            else
            {
                $readOnly =  true;
                $evalFlds[] = new MLabel(_M('O período para digitação de notas encerrou em: ', $module). SAGU::toDefaultDate($scoreDate, SAGU::getParameter('BASIC', 'MASK_DATE')));
            }

            try
            {
                if (!$readOnly)
                {
                    // percorre e altera as notas de cada avaliação
                    foreach( (array)$dataSave[0]->step->evaluations as $ev )
                    {
                        $id = 'totalPoints'.$ev->evaluationId.'_'.$dataSave[0]->subscriptionId;
                        $idEnem = 'totalPointsEnem'.$ev->evaluationId.'_'.$dataSave[0]->subscriptionId;
                        $filter2 = new stdClass();
                        $filter2->evaluationId = $ev->evaluationId;
                        $filter2->subscriptionId = $dataSave[0]->subscriptionId;
                        $evaluationPoints = SprEvaluationPoints::search($filter2);
                        if ( count($evaluationPoints) > 0 )
                        {
                            $evaluationPoints[0]->totalPoints = $args->$id;
                            $evaluationPoints[0]->totalPointsEnem = $args->$idEnem;
                            $evaluationPoints[0]->save();
                        }
                        else
                        {
                            $evaluationPoints = new SprEvaluationPoints();
                            $evaluationPoints->evaluationId = $ev->evaluationId;
                            $evaluationPoints->subscriptionId = $dataSave[0]->subscriptionId;
                            $evaluationPoints->totalPoints = $args->$id;
                            $evaluationPoints->totalPointsEnem = $args->$idEnem;
                            $evaluationPoints->save();
                        }
                    }
                    $flds[] = MPrompt::Information(_M('Notas da inscrição ', $module).$dataSave[0]->subscriptionId.' - '.$dataSave[0]->personName._M(' salvas com sucesso!', $module), 'NONE');
                }
            }
            catch ( Exception $e )
            {
                $this->AddError($e->getMessage());
            }

            // Cria os botoes para avançar, voltar ou salvar
            if ( $args->dir == 'front' && $totalIndex > $args->index+1 )
            {
                $btns[] = new MButton('btnAnt', _M('Anterior', $module), $this->getAjaxAction('loadEvaluations', 'divData',  true, array('index' => $args->index-1, 'dir' => 'back')));
                $btns[] = new MButton('btnProx', _M('Próximo', $module), $this->getAjaxAction('loadEvaluations', 'divData',  true, array('index' => $args->index+1, 'dir' => 'front')));
            }
            elseif( $args->dir == 'back' && $args->index != 0 )
            {
                $btns[] = new MButton('btnAnt', _M('Anterior', $module), $this->getAjaxAction('loadEvaluations', 'divData',  true, array('index' => $args->index-1, 'dir' => 'back')));
                $btns[] = new MButton('btnProx', _M('Próximo', $module), $this->getAjaxAction('loadEvaluations', 'divData',  true, array('index' => $args->index+1, 'dir' => 'front')));
            }
            elseif( $args->dir == 'front' || $args->event == 'save')
            {
                $btns[] = new MButton('btnAnt', _M('Anterior', $module), $this->getAjaxAction('loadEvaluations', 'divData',  true, array('index' => $args->index-1, 'dir' => 'back')));
                $btns[] = new MButton('btnSave', _M('Salvar', $module), $this->getAjaxAction('loadEvaluations', 'divData', true, array('index' => $args->index, 'event'=>'save')));
            }
            elseif ( $args->dir == 'back' )
            {
                $btns[] = new MButton('btnProx', _M('Próximo', $module), $this->getAjaxAction('loadEvaluations', 'divData',  true, array('index' => $args->index+1, 'dir' => 'front')));
            }
            else
            {
                $btns[] = new MButton('btnSave', _M('Salvar', $module), $this->getAjaxAction('loadEvaluations', 'divData', true, array('index' => $args->index)));
            }
        }

        if ( count($data) > 0 )
        {
            // Cria os campos da posição atual
            $flds[] = new MSeparator();
            // FIXME Verficar problema no tema quanto a quebra de linha do MTextLavel dentro do basegroup
            $stepLabel = new MTextLabel('stepLabel', _M('Etapa:', $module));
            $stepLabel->setClass('m-caption');            
            $labelStep = new MTextLabel('labelStep'.$data[0]->step->stepId, $data[0]->step->stepId.' - '.$data[0]->step->description);            
            $personF[] = $container = new MHContainer('stepContainer', array($stepLabel, $labelStep));            
            $container->addAttribute('style', 'margin-left:17px;');
            
            $inscriptionLabel = new MTextLabel('inscriptionLabel', _M('Inscrição:', $module));
            $inscriptionLabel->setClass('m-caption');            
            $inscription = new MTextLabel('labelInscription'.$data[0]->subscriptionId, $data[0]->subscriptionId);
            $personF[] = new MHContainer('stepContainer', array($inscriptionLabel, $inscription));
            
            $personLabel = new MTextLabel('personLabel', _M('Pessoa:', $module));
            $personLabel->setClass('m-caption');
            $person = new MTextLabel('labelPerson'.$data[0]->personId, $data[0]->personId.' - '.$data[0]->personName);
            $personF[] = $personContainer = new MHContainer('personContainer', array($personLabel, $person));
            $personContainer->addAttribute('style', 'margin-left:8px;');
                        
            $flds[] = new MBaseGroup('bsgPerson', _M('Registro '.( strlen($args->index) > 0 ? $args->index+1 : 1 ).' de '.$totalIndex), $personF, 'vertical');
            
            foreach ( $data[0]->step->evaluations as $evaluations )
            {
                $filter3 = new stdClass();
                $filter3->evaluationId = $evaluations->evaluationId;
                $filter3->subscriptionId = $data[0]->subscriptionId;
                $evalP = SprEvaluationPoints::search($filter3);
                $label = new MText('evaluationLabel',  $evaluations->description. ':');
                $label->setClass('m-caption');
                $label->addAttribute('style', 'margin-top:5px;');
                $fieldEvaluation = new MTextField('totalPoints'.$evaluations->evaluationId.'_'.$data[0]->subscriptionId, $evalP[0]->totalPoints, null, SAGU::getParameter('BASIC', 'FIELD_ID_SIZE'), '', NULL, $readOnly );
                $validators[] = new MFloatValidator('totalPoints'.$evaluations->evaluationId.'_'.$data[0]->subscriptionId, $evaluations->description, '.');
                
                if( $data[0]->step->notasEnem == DB_TRUE )
                {
                    $labeEnem = new MText('evaluationEnemLabel', 'Nota no Enem:');
                    $labeEnem->setClass('m-caption');
                    $labeEnem->addAttribute('style', 'margin-top:5px;');
                    $fieldEvaluationEnem = new MTextField('totalPointsEnem'.$evaluations->evaluationId.'_'.$data[0]->subscriptionId, $evalP[0]->totalPointsEnem, null, SAGU::getParameter('BASIC', 'FIELD_ID_SIZE'), '', NULL, $readOnly );
                    $validators[] = new MFloatValidator('totalPointsEnem'.$evaluations->evaluationId.'_'.$data[0]->subscriptionId, $evaluations->totalPointsEnem, '.');
                }
                
                $sprSelectiveProcess = new SprSelectiveProcess($data[0]->step->selectiveProcessId);
                
                if ( $sprSelectiveProcess->generateFinance == DB_TRUE )
                {
                    $busInvoice = new BusinessFinanceBusInvoice();
                    $sprSubscription = new SprSubscription($data[0]->subscriptionId);
                    
                    if ( (strlen($sprSubscription->invoiceId) > 0) && ($busInvoice->getInvoiceBalance($sprSubscription->invoiceId) != 0) )
                    {
                        $fieldWarning = MMessage::getStaticMessage('warning_msg', _M('A taxa de inscrição do processo seletivo não foi paga e o status do candidato será atribuído <b>desistente</b> no momento da classificação da etapa.'), MMessage::TYPE_WARNING);
                        $separator = new MSeparator();
                    }
                }
                
                $evalFlds[] = new MHcontainer('ctnEvaluationFls', array( $fieldWarning, $separator, $label, $fieldEvaluation, $labeEnem, $fieldEvaluationEnem ));
            }

            // Basegroup e container
            $flds[] = new MBaseGroup('baseEvaluationsStep', _M('Notas', $module), $evalFlds, 'vertical' ); // Cria o basegroup com os campos das notas
            $flds[] = new MHContainer('contButtons', $btns); // cria o container com os botões

            // Validators
            $this->SetValidators($validators);
        }
        else
        {
             // "Nenhum registro foi encontrado"
            $static = MMessage::getStaticMessage(NULL, _M('Nenhum registro foi encontrado. <br> Para digitação de notas é necessário previamente fornecer o detalhamento da etapa, em "Processo -> Detalhamento de etapa".', $module), MMessage::TYPE_WARNING);
            $static->setWidth('100%');
            $flds[] = $static;
        }

        // Container com os campos
        $fields[] = new MVContainer('contV', $flds);

        return $fields;
    }
}
?>