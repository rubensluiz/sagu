<?php
/**
 * <--- Copyright 2005-2010 de Solis - Cooperativa de Soluções Livres Ltda.
 * 
 * Este arquivo é parte do programa Sagu.
 * 
 * O Sagu é um software livre; você pode redistribuí-lo e/ou modificá-lo
 * dentro dos termos da Licença Pública Geral GNU como publicada pela Fundação
 * do Software Livre (FSF); na versão 2 da Licença.
 * 
 * Este programa é distribuído na esperança que possa ser útil, mas SEM
 * NENHUMA GARANTIA; sem uma garantia implícita de ADEQUAÇÃO a qualquer MERCADO
 * ou APLICAÇÃO EM PARTICULAR. Veja a Licença Pública Geral GNU/GPL em
 * português para maiores detalhes.
 * 
 * Você deve ter recebido uma cópia da Licença Pública Geral GNU, sob o título
 * "LICENCA.txt", junto com este programa, se não, acesse o Portal do Software
 * Público Brasileiro no endereço www.softwarepublico.gov.br ou escreva para a
 * Fundação do Software Livre (FSF) Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA --->
 * 
 * Upload csv file subscription form
 *
 * @author Arthur Lehdermann [arthur@solis.coop.br]
 *
 * @version $Id$
 *
 * \b Maintainers: \n
 * Arthur Lehdermann [arthur@solis.coop.br]
 *
 * @since
 * Class created on 03/01/2011
 *
 **/

/**
 * Form to manipulate a uploadCsvFileNote
 **/
class FrmUploadCsvFileSubscription extends FrmUploadCsvPhysicalPerson
{
    protected $_selectiveProcessId;
    
    /*
     * @var SprSelectiveProcess
     */
    protected $selectiveProcess;
    
    protected $subscriptionIds;
    
    /**
     * Class constructor
     **/
    public function __construct($data)
    {
        $MIOLO = MIOLO::getInstance();
        $module = SAGU::getFileModule(__FILE__);

        // Pego o código do processo seletivo
        $this->_selectiveProcessId = MIOLO::_REQUEST('selectiveProcessId');
        
        // Busca na base de dados o processo seletivo
        if ( strlen($this->_selectiveProcessId) > 0 )
        {
            $this->selectiveProcess = new SprSelectiveProcess($this->_selectiveProcessId);
        }

        parent::__construct(_M('Importação de inscrições', $module), null, null);
    }


    /**
     * Numero maximo de caracteres
     *
     * @return array
     */
    public function getMaxChars()
    {
        return array_merge( parent::getMaxChars(), array(
            'proofZipCode' => 9,
            'proofCity' => 255,
            'proofState' => 2,
            'proofCountry' => 3,
            'isQuotaHolder' => 3
        ));
    }


    /**
     * Descricao humana dos campos
     *
     * @return array
     */
    public function getHumanDescription()
    {
        return array_merge( parent::getHumanDescription(), array(
            'proofZipCode'       => _M('CEP da prova', $module),
            'proofCity'          => _M('Cidade da prova', $module),
            'proofState'         => _M('Estado da prova', $module),
            'proofCountry'       => _M('País da prova', $module),
            'courseDescription'  => _M('Descrição dos cursos', $module),
            'isQuotaHolder'  => _M('É cotista', $module)
        ));
    }


    /**
     * Campos que sao obrigatorios
     *
     * @return array
     */
    public function getRequiredFields()
    {
        return array_merge( parent::getRequiredFields(), array('courseDescription') );
    }


    public function addSubscriptionFields()
    {
        $MIOLO = MIOLO::getInstance();
        $module = SAGU::getFileModule(__FILE__);

        // Field selective process (lookup selective process)
        $selectiveProcessLabel = new MText('selectiveProcessLabel', _M('Processo seletivo', $module) . ':');
        $selectiveProcessLabel->setWidth(SAGU::getParameter('BASIC', 'FIELD_LABEL_SIZE'));
        $selectiveProcessLabel->setClass('m-caption m-caption-required');
        $selectiveProcessId = new MLookupTextField('selectiveProcessId', $this->getFormValue('selectiveProcessId',$data->selectiveProcessId), null, SAGU::getParameter('BASIC', 'FIELD_LOOKUPFIELD_SIZE'), null, null, 'selectiveProcessDescription', $module, 'SelectiveProcess', null, null, true);
        $selectiveProcessId->setJsHint(_M('Informe o código do processo seletivo',$module));
        $selectiveProcessDescription = new MTextField('selectiveProcessDescription', $this->getFormValue('selectiveProcessDescription', $data->selectiveProcessDescription), null, SAGU::getParameter('BASIC', 'FIELD_DESCRIPTION_SIZE'));
        $selectiveProcessDescription->setReadOnly(true);
        $selectiveProcessDescription->setJsHint(_M('Descrição do processo seletivo',$module));
        $this->_fields[] = $selectiveProcess = new MHContainer('selectiveProcessCnt',array($selectiveProcessLabel, $selectiveProcessId, $selectiveProcessDescription));
        $selectiveProcess->showLabel = true;
        $this->_validators[] = new MIntegerValidator('selectiveProcessId', _M('Processo seletivo', $module), 'required');
    }


    public function getTypesData()
    {
        $data->selectiveProcessId = MIOLO::_REQUEST('selectiveProcessId');
        return $data;
    }


    public function checkSelectiveProcess()
    {
        if ( !$this->selectiveProcess )
        {
            throw new Exception(_M('Ocorreu um erro. Por favor, verifique se você selecionou o processo seletivo e tente novamente. O arquivo não foi importado, nenhuma alteração foi feita.', $module));
        }

        if ( !(count($this->selectiveProcess->options) > 0) )
        {
            throw new Exception(_M('Problema com o processo seletivo, não tem opções de curso. O arquivo não foi importado, nenhuma alteração foi feita.', $module));
        }
        
        if ( count($this->selectiveProcess->steps) <= 0 )
        {
            throw new Exception( _M('O processo seletivo selecionado não possui nenhuma etapa cadastrada.', $module) );
        }
    }


    /**
     * Verifica por erros na importacao dos dados
     */
    public function checkImportErrors()
    {
        $MIOLO = MIOLO::getInstance();
        $module = SAGU::getFileModule(__FILE__);

        $humanDescription = $this->getHumanDescription();

        // Descricao dos cursos
        $courseDescription = (array) explode('|', $this->importedData->courseDescription);
        $this->courseOptions = array();
        foreach ( $courseDescription as $cd )
        {
            $cd = trim($cd);
            $filters = (object) array('selectiveProcessId' => $this->_selectiveProcessId, 'description' => $cd);
            $rows = SprOption::search($filters);
            
            if ( count($rows) <= 0 )
            {
                $this->_errors[] = _M('A opção de curso "@1" não foi encontrada para o processo seletivo selecionado.', $module, $cd);
            }
            else if ( count($rows) > 1 )
            {
                $this->_errors[] = _M('Foi encontrado mais de uma opção de curso para "@1"', $module, $cd);
            }
            $this->courseOptions[] = $rows[0]->optionId;
        }
        $this->importedData->courseOptions = $this->courseOptions;

        // Caso tenha menos opções que o mínimo ou mais que o máximo, exibe erro
        // Número mínimo de opções
        $selectiveProcessMinimumOptions = $this->selectiveProcess->minimumNumberOfOptions;

        // Número máximo de opções
        $selectiveProcessNumberOptions = $this->selectiveProcess->numberOfOptions;

        if ( count($this->courseOptions) < $selectiveProcessMinimumOptions )
        {
            $this->_errors[] = _M('O número mínimo de opções de curso para este processo seletivo (@1) não foi atingido.', $module, $selectiveProcessMinimumOptions);
        }
        else if ( count($this->courseOptions) > $selectiveProcessNumberOptions )
        {
            $this->_errors[] = _M('O número máximo de opções de curso para este processo seletivo (@1) foi ultrapassado.', $module, $selectiveProcessNumberOptions);
        }

        // Cidade / estado / país
        $country = strtoupper($this->importedData->proofCountry);
        $state = strtoupper($this->importedData->proofState);
        $city = strtoupper($this->importedData->proofCity);
        if ( strlen($country) > 0 )
        {
            $this->getCountry($country);
        }
        if ( ( strlen($state) > 0 ) && ( strlen($country) > 0 ) )
        {
            $this->getState($state, $country);
        }
        if ( strlen($city) > 0 )
        {
            if ( ( strlen($state) <= 0 ) || ( strlen($country) <= 0 ) )
            {
                $this->_errors[] = _M('Foi detectado que uma cidade foi informada (campo @1), porém não seu estado ou país.', $modules, $humanDescription['proofCity']);
            }
            else
            {
                $this->importedData->proofCityId = $this->getCity($city, $state, $country);
            }
        }


        //
        // StepPlace (local da prova)
        //
        // Busca pelo location
        if ( strlen($this->importedData->proofCityId) > 0 )
        {
            $this->importedData->proofZipCode = str_replace('-', '', $this->importedData->proofZipCode);
            $filters = (object) array('cityId' => $this->importedData->proofCityId, 'zipCode' => $this->importedData->proofZipCode);
            $rows = $this->busLocation->searchLocation($filters);
            $locationId = $rows[0][0];

            // Caso nao tenha encontrado registro, insere
            if ( strlen($locationId) <= 0 )
            {
                $locationData = new stdClass();
                $locationData->name = $this->importedData->proofCity;
                $locationData->cityId = $this->importedData->proofCityId;
                $locationData->zipCode = $this->importedData->proofZipCode;
                $ok = $this->busLocation->insertLocation($locationData);
                $locationId = $this->busLocation->getLastInsertId();
            }

            // Se encontra, busca o stepPlace
            $stepPlaceId = null;
            if ( strlen($locationId) > 0 )
            {
                $filters = (object) array('selectiveProcessId' => $this->_selectiveProcessId, 'locationId' => $locationId);
                $rows = SprStepPlace::search($filters);
                $this->importedData->stepPlaceId = $stepPlaceId = $rows[0]->stepPlaceId;
            }
            if ( strlen($stepPlaceId) <= 0 )
            {
                $this->_errors[] = _M('Não foi encontrado um local de prova para este processo seletivo que confere com o local de prova no arquivo.', $module);
            }
        }

        parent::checkImportErrors();
    }


    /**
     * Salva dados da INSCRICAO (que ira salvar automaticamente a pessoa fisica)
     *
     * @param stdClass $physicalPerson
     * @return stdClass
     */
    public function savePhysicalPerson($physicalPerson)
    {
        $subscriptionId = null;
        
        // Se a pessoa já existe
        if ( !is_null($physicalPerson->personId) )
        {
            // E verifica se já não está inscrito(a) no processo seletivo
            $subscriptionId = SprSubscription::getSubscriptionId($this->_selectiveProcessId, $physicalPerson->personId);
        }

        $sprSubscription = new SprSubscription($subscriptionId);

        // Documentos
        $documents = array();
        //
        unset($_doc);
        $_doc->documentTypeId = SAGU::getParameter('BASIC', 'DEFAULT_DOCUMENT_TYPE_ID_CPF');
        $_doc->content = $physicalPerson->cpf;
        $_doc->isDelivered = DB_FALSE;
        $documents[] = $_doc;
        //
        $physicalPerson->documents = $documents;
        $sprSubscription->physicalPerson = $physicalPerson;
        unset($documents);

        //
        //Documentos
        //
        $stepList = SprStep::listRecords( (object) array('selectiveProcessId' => $this->_selectiveProcessId, 'orderByStepOrder' => true) );
        //
        $stepId = $stepList[0][0];
        if ( strlen($stepId) > 0 )
        {
            $sprStep = new SprStep($stepId);
            $_subscriptionDocument = array();
            foreach ( $sprStep->stepDocuments as $i => $document )
            {
                $subscriptionDocument = new SprSubscriptionDocument();
                $subscriptionDocument->contents = $documents[$i]->content;
                $subscriptionDocument->stepDocumentId = $document->stepDocumentId;
                $subscriptionDocument->isDelivered = DB_FALSE;

                $_subscriptionDocument[] = $subscriptionDocument;
            }
            $sprSubscription->subscriptionDocument = $_subscriptionDocument;
        }

        // Opcoes
        $_options = array();
        foreach ( $physicalPerson->courseOptions as $k => $optionId )
        {
            if ( strlen($optionId) > 0 )
            {
                $sprSubscriptionOption = new SprSubscriptionOption();
                $sprSubscriptionOption->optionId = $optionId;
                $sprSubscriptionOption->optionNumber = $k;
                $sprSubscriptionOption->position = $k + 1;
                $sprSubscriptionOption->subscriptionOptionOrder = $k;
                $sprSubscriptionOption->subscriptionStatusId = SAGU::getParameter('SELECTIVEPROCESS', 'SPR_NEW_SUBSCRIPTION_STATUS_ID_INITIAL');

                $_options[] = $sprSubscriptionOption;
            }
        }
        $sprSubscription->subscriptionOption = $_options;


        // StepPlace
        if ( strlen($physicalPerson->stepPlaceId) > 0 )
        {
            $ssp = new SprSubscriptionStepPlace();
            $ssp->stepPlaceId = $physicalPerson->stepPlaceId;
            $sprSubscription->subscriptionStepPlace = array($ssp);
        }
        
        // Inscreve candidato na primeira etapa do processo seletivo
        $ssi = new SprSubscriptionStepInfo();
        $ssi->stepId = $this->selectiveProcess->steps[0]->stepId;
        $ssi->subscriptionStatusId = SprSubscriptionStatus::INSCRIBED;
        $ssi->useInternalEvaluations = DB_TRUE;
        $sprSubscription->subscriptionStepInfo = array($ssi);
        
        // Define subscription data
        $sprSubscription->selectiveProcessId = $this->_selectiveProcessId;
        $sprSubscription->subscriptionStatusId = SAGU::getParameter('SELECTIVEPROCESS', 'SPR_NEW_SUBSCRIPTION_STATUS_ID_INITIAL');
        $sprSubscription->hasSubscriptionFee = DB_FALSE;
        $sprSubscription->finishedHighSchool = $physicalPerson->isHighSchool;
        $sprSubscription->isQuotaHolder = $physicalPerson->isQuotaHolder;
        $sprSubscription->save();

        $this->subscriptionIds[] = $sprSubscription->subscriptionId;

        return $sprSubscription->physicalPerson;
    }


    /**
     *
     * @param array
     * @return MTableRaw
     */
    public function getTableRaw($personsImported)
    {
        $tableColumns[] = _M('Código de inscrição', $module);
        $tableColumns[] = _M('Código da pessoa', $module);
        $tableColumns[] = _M('Nome da pessoa', $module);

        foreach ( (array) $personsImported as $count => $personData )
        {
            $importedValues[$count][] = '<center><font color="blue">'.$this->subscriptionIds[$count].'</font></center>';
            $importedValues[$count][] = '<center><font color="blue">'.$personData->personId.'</font></center>';
            $importedValues[$count][] = '<center><font color="blue">'.$personData->name.'</font></center>';
        }

        $inscriptionsImported = new MTableRaw(_M('Inscrições importadas com sucesso', $module), $importedValues, $tableColumns);

        return $inscriptionsImported;
    }
}
?>