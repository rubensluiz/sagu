<?php

/**
 * <--- Copyright 2005-2010 de Solis - Cooperativa de Soluções Livres Ltda.
 *
 * Este arquivo é parte do programa Sagu.
 *
 * O Sagu é um software livre; você pode redistribuí-lo e/ou modificá-lo
 * dentro dos termos da Licença Pública Geral GNU como publicada pela Fundação
 * do Software Livre (FSF); na versão 2 da Licença.
 *
 * Este programa é distribuído na esperança que possa ser útil, mas SEM
 * NENHUMA GARANTIA; sem uma garantia implícita de ADEQUAÇÃO a qualquer MERCADO
 * ou APLICAÇÃO EM PARTICULAR. Veja a Licença Pública Geral GNU/GPL em
 * português para maiores detalhes.
 *
 * Você deve ter recebido uma cópia da Licença Pública Geral GNU, sob o título
 * "LICENCA.txt", junto com este programa, se não, acesse o Portal do Software
 * Público Brasileiro no endereço www.softwarepublico.gov.br ou escreva para a
 * Fundação do Software Livre (FSF) Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA --->
 *
 * @author Moises Heberle [moises@solis.coop.br]
 *
 * @version $Id$
 *
 * \b Maintainers: \n
 * Alexandre Heitor Schmidt [alexsmith@solis.coop.br]
 * Arthur Lehdermann [arthur@solis.coop.br]
 * Samuel Koch [samuel@solis.coop.br]
 * Moises Heberle [moises@solis.coop.br]
 * Luís Felipe Wermann [luis_felipe@solis.com.br]
 *
 * @since
 * Class created on 20/12/2010
 */
MIOLO::uses('/types/SprSelectiveProcess.class', SAGU::getFileModule(__FILE__));

class FrmStep extends SStepByStepForm {

    public function __construct($steps = null)
    {
        if (!$steps->disableConstruct)
        {
            parent::__construct(null, $steps, __CLASS__);

            $this->toolbar->disableButton(MToolBar::BUTTON_SAVE);
        }
    }

    public function createFields()
    {
        $MIOLO = MIOLO::getInstance();
        $module = SAGU::getFileModule(__FILE__);
        $action = MIOLO::getCurrentAction();
        $function = MIOLO::_REQUEST('function');

        // Load data
        $stepData = $this->getStepData();

        $selectiveProcessId = $stepData->selectiveProcessId;
        $hasSubscriptions = false;
        if ($this->isFirstAccess())
        {
            MSubDetail::clearData('_steps');
            if (strlen($selectiveProcessId) > 0)
            {
                $sprSP = new SprSelectiveProcess($selectiveProcessId);
                $hasSubscriptions = $sprSP->hasSubscriptions();
            }
        }
        
        // Descrição
        $descriptionLabel = new MText('descriptionLabel', _M('Descrição', $module) . ':');
        $descriptionLabel->setWidth(SAGU::getParameter('BASIC', 'FIELD_CONTAINER_SIZE'));
        $descriptionLabel->setClass('m-caption m-caption-required');
        $description = new MTextField('description', null, null, SAGU::getParameter('BASIC', 'FIELD_DESCRIPTION_SIZE'));
        $description->setJsHint(_M('Informe a descrição da etapa', $module));
        $validators[] = new MRequiredValidator('description', _M('Descrição', $module));
        $fields[] = new MHContainer('descriptionCnt', array($descriptionLabel, $description));

        // Data inicial/final
        $options = array(
            'title' => null,
            'baseGroup' => false,
            'begin' => array(
                'dateId' => 'startDate',
                'timeId' => 'startTime',
                'dateHint' => _M('Informe a data inicial', $module),
                'timeHint' => _M('Informe a hora inicial', $module),
                'label' => _M('Data e hora inicial', $module),
                'timeInputHint' => 'hh:mm',
                'required' => true,
            ),
            'end' => array(
                'dateHint' => _M('Informe a data final', $module),
                'timeHint' => _M('Informe a hora final', $module),
                'label' => _M('Data e hora final', $module),
                'timeInputHint' => 'hh:mm',
                'required' => true,
            ),
            'type' => 'timestamp',
        );
        $validators[] = new MDateDMYValidator('startDate', _M('Data inicial', $module), 'required');
        $validators[] = new MDateDMYValidator('endDate', _M('Data final', $module), 'required');
        $validators[] = new MTIMEValidator('startTime', _M('Hora inicial', $module), 'required');
        $validators[] = new MTIMEValidator('endTime', _M('Hora final', $module), 'required');
        $fields[] = new SBeginEndPeriod($options);

        // Data limite para registros
        $scoreDateLabel = new MText('scoreDateLabel', _M('Data limite para registros', $module) . ':');
        $scoreDateLabel->setWidth(SAGU::getParameter('BASIC', 'FIELD_CONTAINER_SIZE'));
        $scoreDateLabel->setClass('m-caption m-caption-required');
        $scoreDate = new MCalendarField('scoreDate', null, null, SAGU::getParameter('BASIC', 'FIELD_DATE_SIZE'));
        $scoreDate->setJsHint(_M('Informe a data limite para para que a pontuação seja registrada', $module));
        $validators[] = new MDateDMYValidator('scoreDate', _M('Data limite para registros', $module), 'required');
        $fields[] = new MHContainer('scoreDateCnt', array($scoreDateLabel, $scoreDate));

        // Data de divulgação
        $disclosureDateLabel = new MText('disclosureDateLabel', _M('Data de divulgação', $module) . ':');
        $disclosureDateLabel->setWidth(SAGU::getParameter('BASIC', 'FIELD_CONTAINER_SIZE'));
        $disclosureDateLabel->setClass('m-caption m-caption-required');
        $disclosureDate = new MCalendarField('disclosureDate', null, null, SAGU::getParameter('BASIC', 'FIELD_DATE_SIZE'));
        $disclosureDate->setJsHint(_M('Informe a data de divulgação', $module));
        $validators[] = new MDateDMYValidator('disclosureDate', _M('Data de divulgação dos resultados', $module), 'required');
        $fields[] = new MHContainer('disclosureDateCnt', array($disclosureDateLabel, $disclosureDate));

        // Data para gerar aviso de classificação
        $classificationDateLabel = new MText('classificationDateLabel', _M('Data para gerar aviso de classificação', $module) . ':');
        $classificationDateLabel->setWidth(SAGU::getParameter('BASIC', 'FIELD_CONTAINER_SIZE'));
        $classificationDateLabel->setClass('m-caption m-caption-required');
        $classificationDate = new MCalendarField('classificationDate', null, null, SAGU::getParameter('BASIC', 'FIELD_DATE_SIZE'));
        $classificationDate->setJsHint(_M('Informe a data para gerar aviso de classificação', $module));
        $validators[] = new MDATEDMYValidator('classificationDate', _M('Data para gerar aviso de classificação', $module), 'required');
        $fields[] = new MHContainer('classificationDateCnt', array($classificationDateLabel, $classificationDate));

        // Vagas
        $vacanciesLabel = new MText('vacanciesLabel', _M('Vagas', $module) . ':');
        $vacanciesLabel->setWidth(SAGU::getParameter('BASIC', 'FIELD_CONTAINER_SIZE'));
        $vacancies = new MTextField('vacancies', null, null, SAGU::getParameter('BASIC', 'FIELD_ID_SIZE'));
        $vacancies->setJsHint(_M('Informe o número de vagas desta etapa', $module));
        $validators[] = new MIntegerValidator('vacancies', _M('Vagas', $module));
        $fields[] = new MHContainer('hctOption', array($vacanciesLabel, $vacancies));

        // Cotas
        /* $quotaLabel = new MText('quotaLabel', _M('Cotas', $module) . ':');
          $quotaLabel->setWidth(SAGU::getParameter('BASIC', 'FIELD_CONTAINER_SIZE'));
          $quota = new MTextField('quota', null, null, SAGU::getParameter('BASIC', 'FIELD_ID_SIZE'));
          $quota->setJsHint(_M('Informe o número de cotas desta etapa', $module));
          //$validators[] = new MIntegerValidator('quota', _M('Cotas', $module));
          $fields[] = new MHContainer('quotaOption', array($quotaLabel, $quota)); */

        // Mínimo de pontos
        $minPointsLabel = new MText('minPointsLabel', _M('Mínimo de pontos', $module) . ':');
        $minPointsLabel->setWidth(SAGU::getParameter('BASIC', 'FIELD_CONTAINER_SIZE'));
        $minPointsLabel->setClass('m-caption m-caption-required');
        $minPoints = new MTextField('minPoints', null, null, SAGU::getParameter('BASIC', 'FIELD_ID_SIZE'));
        $minPoints->setJsHint(_M('Informe o número mínimo de pontos que o aluno poderá atingir nesta etapa.', $module));
        $validators[] = new MFloatValidator('minPoints', _M('Mínimo de pontos', $module), SAGU::getParameter('BASIC', 'FLOAT_SEPARATOR'), SAGU::getParameter('BASIC', 'REAL_ROUND_VALUE'), 'required');
        $fields[] = new MHContainer('minPointsCnt', array($minPointsLabel, $minPoints));

        // Ordem do passo
        $stepOrderLabel = new MText('stepOrderLabel', _M('Ordem da etapa', $module) . ':');
        $stepOrderLabel->setWidth(SAGU::getParameter('BASIC', 'FIELD_CONTAINER_SIZE'));
        $stepOrderLabel->setClass('m-caption m-caption-required');
        $stepOrder = new MTextField('stepOrder', null, null, SAGU::getParameter('BASIC', 'FIELD_ID_SIZE'));
        $stepOrder->setJsHint(_M('Informe a ordem em que esta etapa irá ocorrer', $module));
        $validators[] = new MIntegerValidator('stepOrder', _M('Ordem do passo', $module), 'required');
        $fields[] = new MHContainer('stepOrderCnt', array($stepOrderLabel, $stepOrder));

        // Peso
        $weightLabel = new MText('weightLabel', _M('Peso', $module) . ':');
        $weightLabel->setWidth(SAGU::getParameter('BASIC', 'FIELD_CONTAINER_SIZE'));
        $weightLabel->setClass('m-caption m-caption-required');
        $weight = new MTextField('weight', null, _M('Peso', $module), SAGU::getParameter('BASIC', 'FIELD_ID_SIZE'), _M('Informe um valor maior que 0 para considerar a pontuação obtida nessa etapa.', $module));
        $weight->setJsHint(_M('Peso desta etapa em relação a todas as etapas.', $module));
        $validators[] = new MFloatValidator('weight', _M('Peso', $module));
        $validators[] = new MRequiredValidator('weight', _M('Peso', $module));
        $fields[] = $hct = new MHContainer('weightHct', array($weightLabel, $weight));
        $hct->setShowLabel(false);

        // Acúmulos de pontos de etapas anteriores
        $accumulatePreviousStepsLabel = new MText('accumulatePreviousStepsLabel', _M('Acúmulos de pontos de etapas anteriores', $module) . ':');
        $accumulatePreviousStepsLabel->setWidth(SAGU::getParameter('BASIC', 'FIELD_CONTAINER_SIZE'));
        $accumulatePreviousStepsValue = null;
        $optYes = new MRadioButton('accumulatePreviousSteps', DB_TRUE, null, true); // $accumulatePreviousStepsValue
        $optYes->text = _M('Sim', $module);
        $optNo = new MRadioButton('accumulatePreviousSteps', DB_FALSE, null);  // !$accumulatePreviousStepsValue
        $optNo->text = _M('Não', $module);
        $fields[] = new MHContainer('accumulatePreviousStepsCnt', array($accumulatePreviousStepsLabel, $optYes, $optNo));

        // Permite escolher local na inscrição
        $subscriberChoosesPlaceLabel = new MText('subscriberChoosesPlaceLabel', _M('Permite escolher local na inscrição', $module) . ':');
        $subscriberChoosesPlaceLabel->setWidth(SAGU::getParameter('BASIC', 'FIELD_CONTAINER_SIZE'));
        $subscriberChoosesPlaceValue = $this->GetFormValue('subscriberChoosesPlace', $data->subscriberChoosesPlace) ? DB_TRUE : DB_FALSE;
        $optYes = new MRadioButton('subscriberChoosesPlace', DB_TRUE, null); // $subscriberChoosesPlaceValue
        $optYes->text = _M('Sim', $module);
        $optNo = new MRadioButton('subscriberChoosesPlace', DB_FALSE, null, true); // !$subscriberChoosesPlaceValue
        $optNo->text = _M('Não', $module);
        $fields[] = new MHContainer('subscriberChoosesPlaceCnt', array($subscriberChoosesPlaceLabel, $optYes, $optNo));

        // Tem interação com o usuário
        $hasUserInteractionLabel = new MText('hasUserInteractionLabel', _M('Tem interação com o usuário', $module) . ':');
        $hasUserInteractionLabel->setWidth(SAGU::getParameter('BASIC', 'FIELD_CONTAINER_SIZE'));
        $hasUserInteractionValue = $this->GetFormValue('hasUserInteraction', $data->hasUserInteraction) ? DB_TRUE : DB_FALSE;
        $optYes = new MRadioButton('hasUserInteraction', DB_TRUE, null, true); // $hasUserInteractionValue
        $optYes->text = _M('Sim', $module);
        $optNo = new MRadioButton('hasUserInteraction', DB_FALSE, null); // !$hasUserInteractionValue
        $optNo->text = _M('Não', $module);
        $fields[] = new MHContainer('hasUserInteractionCnt', array($hasUserInteractionLabel, $optYes, $optNo));

        if ($stepData->permiteClassificarEnem == DB_TRUE)
        {
            $notasEnemLabel = new MText('notasEnemLabel', _M('Tem notas do ENEM', $module) . ':');
            $notasEnemLabel->setWidth(SAGU::getParameter('BASIC', 'FIELD_CONTAINER_SIZE'));
            $notasEnem = $this->GetFormValue('notasEnem', $data->notasEnem) == DB_TRUE ? true : false;
            $optYes = new MRadioButton('notasEnem', DB_TRUE, null, true);
            $optYes->text = _M('Sim', $module);
            $optNo = new MRadioButton('notasEnem', DB_FALSE, null);
            $optNo->text = _M('Não', $module);
            $fields[] = new MHContainer('notasEnemCnt', array($notasEnemLabel, $optYes, $optNo));
        }

        // E-mail de confirmação
        $confirmationEmailIdLabel = new MText('confirmationEmailIdLabel', _M('E-mail de confirmação', $module) . ':');
        $confirmationEmailIdLabel->setWidth(SAGU::getParameter('BASIC', 'FIELD_CONTAINER_SIZE'));
        $confirmationEmailId = new MLookupTextField('confirmationEmailId', null, '', SAGU::getParameter('BASIC', 'FIELD_ID_SIZE'), null, null, 'confirmationEmailIdName', 'basic', 'email', null, array('emailId' => 'confirmationEmailId'), true);
        $confirmationEmailId->setJsHint(_M('Informe o código do e-mail de confirmação', $module));
        $validators[] = new MIntegerValidator('confirmationEmailId', _M('E-mail de confirmação', $module));
        $confirmationEmailIdName = new MTextField('confirmationEmailIdName', null, '', SAGU::getParameter('BASIC', 'FIELD_DESCRIPTION_SIZE'));
        $confirmationEmailIdName->setJsHint(_M('Descrição do e-mail de confirmação', $module));
        $confirmationEmailIdName->setReadOnly(true);
        $fields[] = new MHContainer('confirmationEmailIdCnt', array($confirmationEmailIdLabel, $confirmationEmailId, $confirmationEmailIdName));

        // Classification method
        $sprStep = new SprStep();
        $classificationMethodLabel = new MText('classificationMethodLabel', _M('Método de classificação', $module) . ':');
        $classificationMethodLabel->setWidth(SAGU::getParameter('BASIC', 'FIELD_CONTAINER_SIZE'));
        $classificationMethodLabel->setClass('m-caption m-caption-required');
        $classificationMethod = new MComboBox('classificationMethod', null, '', $sprStep->listAutomaticManual(0));
        $classificationMethod->setJsHint(_M('Selecione o método que será utilizado para classificar os inscritos', $module));
        $validators[] = new MRequiredValidator('classificationMethod', _M('Método de classificação', $module));
        $fields[] = new MHContainer('classificationMethodCnt', array($classificationMethodLabel, $classificationMethod));

        // Mensagem inicial
        $initialMessageLabel = new MText('initialMessageLabel', _M('Mensagem inicial', $module) . ':');
        $initialMessageLabel->setWidth(SAGU::getParameter('BASIC', 'FIELD_CONTAINER_SIZE'));
        $initialMessage = new MEditor('initialMessage');
        $initialMessage->setWidth(SAGU::getParameter('BASIC', 'FIELD_EDITOR_SIZE'));
        $initialMessage->setJsHint(_M('Informe a mensagem que será exibida no início da etapa', $module));
        $fields[] = $initialMessageContainer = new MHContainer('hctInitialMessage', array($initialMessageLabel, $initialMessage));

        // Mensagem final
        $msg = _M('O campo abaixo admite a utilização das seguintes variáveis que serão substituídas no momento da sua exibição:', $module) . '<br />' .
                '$SUBSCRIPTIONID: ' . _M('Número da inscrição do candidato.', $module) . '<br />' .
                '$PERSONID: ' . _M('Código da pessoa associada à inscrição.', $module) . '<br />' .
                '$PERSONNAME: ' . _M('Nome da pessoa associada à inscrição.', $module) . '<br />' .
                '$PASSWORD: ' . _M('Senha de usuário da pessoa associada à inscrição.', $module) . '<br />' .
                '$SELECTIVEPROCESSID: ' . _M('Código do processo seletivo.', $module) . '<br />' .
                '$SELECTIVEPROCESSDESCRIPTION: ' . _M('Nome do processo seletivo.', $module) . '<br />' .
                '$SUBSCRIPTIONORDER: ' . _M('Ordem geral de inscrição.', $module) . '<br />' .
                '$OPTIONSCOURSE: ' . _M('Opções de curso na inscrição', $module);
        $fields[] = $leftText = new MText('txtFinalMessageInfo', $msg);
        $leftText->setClass('m-left-text');

        $finalMessageLabel = new MText('finalMessageLabel', _M('Mensagem final', $module) . ':');
        $finalMessageLabel->setWidth(SAGU::getParameter('BASIC', 'FIELD_CONTAINER_SIZE'));
        $finalMessage = new MEditor('finalMessage');
        $finalMessage->setWidth(SAGU::getParameter('BASIC', 'FIELD_EDITOR_SIZE'));
        $finalMessage->setJsHint(_M('Informe a mensagem que será exibida no final da etapa', $module));
        $fields[] = $finalMessageContainer = new MHContainer('hctFinalMessage', array($finalMessageLabel, $finalMessage));

        $data = $this->getStepData();
        if ($data->initialMessage == '' && $data->finalMessage == '')
        {
            $finalMessageContainer->addAttribute('style', 'display:none');
            $initialMessageContainer->addAttribute('style', 'display:none');
            $leftText->addAttribute('style', 'display:none');
        }

        $fields[] = new SHiddenField('stepId');
        // Subdetail etapas
        $cols[] = new MGridColumn(_M('Descrição', $module), 'left', true, '', true, 'description');
        $cols[] = new MGridColumn(_M('Data inicial', $module), 'left', true, '', true, 'startDate');
        $cols[] = new MGridColumn(_M('Data final', $module), 'left', true, '', true, 'endDate');
        $cols[] = new MGridColumn(_M('Data limite para registros', $module), 'left', true, '', true, 'scoreDate');
        $cols[] = new MGridColumn(_M('Data de divulgação', $module), 'left', true, '', true, 'disclosureDate');
        $cols[] = new MGridColumn(_M('Data para gerar aviso de classificação', $module), 'left', true, '', true, 'classificationDate');
        $cols[] = new MGridColumn(_M('Vagas', $module), 'left', true, '', true, 'vacancies');
        $cols[] = new MGridColumn(_M('Mínimo de pontos', $module), 'left', true, '', true, 'minPoints');
        $cols[] = new MGridColumn(_M('Ordem', $module), 'left', true, '', true, 'stepOrder');
        if ($stepData->permiteClassificarEnem == DB_TRUE)
        {
            $cols[] = new sSubDetailColumn('notasEnem', array('label' => _M('Tem notas do ENEM', $module), 'replace' => SAGU::listYesNo()));
        }
        $cols[] = new MGridColumn(_M('Peso', $module), 'left', true, '', true, 'weight');
        $cols[] = new MGridColumn(_M('Acúmulos de pontos de etapas anteriores', $module), 'left', true, '', false, 'accumulatePreviousSteps');
        $cols[] = new MGridColumn(_M('Permite escolher local na inscrição', $module), 'left', true, '', false, 'subscriberChoosesPlace');
        $cols[] = new MGridColumn(_M('Tem interação com o usuário', $module), 'left', true, '', false, 'hasUserInteraction');
        $cols[] = new MGridColumn(_M('E-mail de confirmação', $module), 'left', true, '', false, 'confirmationEmailId');
        $cols[] = new MGridColumn(_M('E-mail de confirmação', $module), 'left', true, '', false, 'confirmationEmailIdName');
        $cols[] = new MGridColumn(_M('Médodo de classificação', $module), 'left', true, '', true, 'classificationMethod', false, $sprStep->listAutomaticManual(0));
        $cols[] = new MGridColumn(_M('Mensagem inicial', $module), 'left', true, '', false, 'initialMessage');
        $cols[] = new MGridColumn(_M('Mensagem final', $module), 'left', true, '', false, 'finalMessage');
        $cols[] = new MGridColumn(_M('Código da etapa', $module), 'left', true, '', false, 'stepId');

        //Se tem inscricoes nao deve permitir edicao nas etapas
        //Por problemas na subdetail ele criará uma subdetail com nome diferente para nao ocorrer problemas de sessao
        $actions = array();
        if ($hasSubscriptions)
        {
            $actions[0] = 'edit';
            $f[] = $sub = new MSubDetail('_steps', _M('Etapas', $module), $cols, $fields, $actions);
            $sub->setValidators($validators);
        }
        else
        {
            $actions[0] = 'edit';
            $actions[1] = 'remove';
            $f[] = $sub = new MSubDetail('_steps', _M('Etapas', $module), $cols, $fields, $actions);
            $sub->setValidators($validators);
        }

        if (count($sprSP->steps) > 0)
        {
            $sub->setData(SAGU::convertSTypeToSubDetail($cols, $sprSP->steps));
        }
        
        $sub->addActionEvent(MSubDetail::EVENT_ADD, 'subDetailEventAdd', __CLASS__);
        $sub->addActionEvent(MSubDetail::EVENT_EDIT, 'subDetailEventEdit', __CLASS__);
        
        $this->setFields($f);

        if ($hasSubscriptions)
        {
            $this->addInfo(_M('As etapas não podem ser criadas/removidas pois possuem inscrições.', $module));
            $sub->addActionEvent(MSubDetail::EVENT_EDIT, 'subDetailEventEdit', __CLASS__);
        }
    }

    /**
     * Evento de adicionar na subdetail
     */
    public function subDetailEventAdd($args = null)
    {
        // Junta a data com o horário (monta o timestamp)
        $args->startDate .= " " . $args->startTime;
        $args->endDate .= " " . $args->endTime;
        
        return $args;
    }

    /**
     * Evento de editar da subdetail
     */
    public function subDetailEventEdit($args = null)
    {
        // Separa a data do horário
        list( $args->startDate,
                $args->startTime ) = explode(' ', $args->startDate);
        list( $args->endDate,
                $args->endTime ) = explode(' ', $args->endDate);

        return $args;
    }

}

?>