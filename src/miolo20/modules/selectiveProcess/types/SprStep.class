<?php
/**
 * <--- Copyright 2005-2010 de Solis - Cooperativa de Soluções Livres Ltda.
 *
 * Este arquivo é parte do programa Sagu.
 *
 * O Sagu é um software livre; você pode redistribuí-lo e/ou modificá-lo
 * dentro dos termos da Licença Pública Geral GNU como publicada pela Fundação
 * do Software Livre (FSF); na versão 2 da Licença.
 *
 * Este programa é distribuído na esperança que possa ser útil, mas SEM
 * NENHUMA GARANTIA; sem uma garantia implícita de ADEQUAÇÃO a qualquer MERCADO
 * ou APLICAÇÃO EM PARTICULAR. Veja a Licença Pública Geral GNU/GPL em
 * português para maiores detalhes.
 *
 * Você deve ter recebido uma cópia da Licença Pública Geral GNU, sob o título
 * "LICENCA.txt", junto com este programa, se não, acesse o Portal do Software
 * Público Brasileiro no endereço www.softwarepublico.gov.br ou escreva para a
 * Fundação do Software Livre (FSF) Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA --->
 *
 * Class definition for database entities
 *
 * @author Alexandre Heitor Schmidt [alexsmith@solis.coop.br]
 *
 * @version $Id$
 *
 * \b Maintainers: \n
 * Alexandre Heitor Schmidt [alexsmith@solis.coop.br]
 * Arthur Lehdermann [arthur@solis.coop.br]
 * Fabiano Tomasini [fabiano@solis.coop.br]
 * Luís Felipe Wermann [luis_felipe@solis.com.br]
 *
 * @since
 * Class created on 15/12/2010
 */
/**
 * Etapa do processo seletivo
 */
class SprStep extends SType
{
    const CLASSIFICATION_METHOD_AUTOMATIC = 'A';
    const CLASSIFICATION_METHOD_MANUAL = 'M';

    // Constantes relacionadas a ordenacao na alocacao por sala (as letras concatenadas servem para diferenciar dos evaluationId's no selection)
    const PRIORITY_SUBSCRIPTION_ORDER = 'SO';
    const PRIORITY_ALPHABETIC_ORDER = 'AO';
    const PRIORITY_HIGH_SCHOOL_ORDER = 'HS';
    
    // Constantes relacionadas ao método de calculo das avaliações
    const CALCULATION_METHOD_AVERAGE = '1';
    const CALCULATION_METHOD_SUM = '2';

    private static $isCurrentLogic = "(NOW() BETWEEN startDate AND endDate)";

    /**
     * @var (integer) Código único que identifica a etapa
     */
    protected $stepId;
    /**
     * @var (integer) Define a qual processo seletivo esta etapa pertence
     */
    protected $selectiveProcessId;
    /**
     * @var (string) Nome que identifica a etapa.
     */
    protected $description;
    /**
     * @var (integer) Se um candidato ficar com pontuação abaixo deste atributo, estará automaticamente desclassificado.
     */
    protected $minPoints;
    /**
     * @var (boolean) Indica se o resultado desta etapa será obtido levando-se em consideração os resultados de outras etapas, cada qual com seu peso.
     */
    protected $accumulatePreviousSteps;
    /**
     * @var (integer) Peso desta etapa em relação a todas as etapas.
     */
    protected $weight;
    /**
     * @var (char) Indica a forma de classificação (Manual ou Automática).
     */
    protected $classificationMethod;
    /**
     * @var (integer) Indica quantos candidatos serão selecionados nesta etapa. Exemplo: podem haver 1000 inscritos, mas a etapa selecionar apenas 50 destes 1000.
     */
    protected $vacancies;
    /**
     * @var (boolean) Indica se a pessoa que está se inscrevendo poderá escolher o local onde irá fazer a etapa.
     */
    protected $subscriberChoosesPlace;
    /**
     * @var (string) Mensagem exibida ao iniciar a inscrição na etapa.
     */
    protected $initialMessage;
    /**
     * @var (string) Mensagem exibida quando finalizar a inscrição na etapa.
     */
    protected $finalMessage;
    /**
     * @var (boolean) Indica se o candidato possui (TRUE) ou não (FALSE) alguma interação com esta etapa, tal como escolha da língua estrangeira, anexação de documentação, etc. ou se a etapa é realizada apenas internamente.
     */
    protected $hasUserInteraction;
    /**
     * @AttributeType date
     */
    protected $startDate;
    /**
     * @AttributeType date
     */
    protected $endDate;
    /**
     * @var (date) Data limite para que as pontuações sejam registradas. Será utilizado para gerar avisos de que existe esta pendência.
     */
    protected $scoreDate;
    /**
     * @var (date) Data em que os resultados da etapa (ou do processo como um todo) são publicadas. Este campo poderá ser utilizado para determinar as pessoas que desistiram da vaga.
     */
    protected $disclosureDate;
    /**
     * @var (date) Permite gerar avisos informando que a classificação deveria ter sido executada até a data informada, mas ainda não foi.
     */
    protected $classificationDate;
    /**
     * @var (array) Armazena as avaliações vinculadas a esta etapa.
     */
    protected $evaluations = array();
    /**
     * @var array Array contendo objetos SprExaminingBoard
     */
    protected $examiningBoards = array();
    /**
     * @var (array) Armazena os critérios de desempate vinculados a esta etapa.
     */
    protected $stepTiebreaks = array();
    /**
     * @var (array) Armazena os documentos vinculados a esta estapa.
     */
    protected $stepDocuments = array();
    /**
     * @var (array) Armazena os locais vinculados a esta estapa.
     */
    protected $stepPlaces = array();
    /**
     * @var (integer) E-mail de confirmação
     */
    protected $confirmationEmailId;
    /**
     * @var (integer)
     */
    protected $stepOrder;
    /**
     * @var (boolean) Atributo virtual: indica se a etapa está vigente
     */
    protected $isCurrent;
    /**
     * @var (boolean) Atributo virtual: indica se pode, ou não, rodar a classificação
     */
    protected $canRunClassification;
    
    /**
     * @var (int) Método para cálculo das avaliações na etapa, pondendo ser: 1 - Média ou 2 - Soma
     */
    protected $calculationMethod;
    
    /**
     * Notas (boolean) Possui notas do Enem
     * @var type 
     */
    protected $notasEnem;
    
    /**
     * Flag para indicar se aluno nao deve aparecer na digitacao de notas da etapa anterior, caso nao tenha sido aprovado na mesma
     *
     * @var boolean
     */
    protected $digitacaoNotasSomenteAprovados;

    /**
     * Construtor da classe
     *
     * @param (integer) $stepId Chave primária da tabela
     */
    public function __construct($stepId = null)
    {
        $this->evaluations = array();
        $this->stepTiebreaks = array();
        $this->stepDocuments = array();
        $this->stepPlaces = array();

        if ( is_numeric($stepId) )
        {
            $this->stepId = $stepId;
            $this->populate();
        }
    }

    /**
     * Data logic
     */
    public function __get($name)
    {
        $MIOLO = MIOLO::getInstance();

        //Filtro usado para instanciar os objetos relacionados
        $filters = new stdClass();
        $filters->stepId = $this->stepId;

        // Instancia as avaliações da etapa sob demanda
        if ( $name == 'evaluations' && !$this->evaluations && strlen($this->stepId) > 0 )
        {
            $this->evaluations = SprEvaluation::search($filters);
        }
        // Instancia as bancas avaliadoras
        if ( $name == 'examiningBoards' && !$this->examiningBoards && strlen($this->stepId) > 0 )
        {
            $this->examiningBoards = SprExaminingBoard::search($filters);
        }
        // Instancia os critérios de desempate da etapa sob demanda
        if ( $name == 'stepTiebreaks' && !$this->stepTiebreaks && strlen($this->stepId) > 0 )
        {
            $this->stepTiebreaks = SprStepTiebreak::search($filters);
        }
        // Instancia os locais de provas da etapa sob demanda
        if ( $name == 'stepPlaces' && !$this->stepPlaces && strlen($this->stepId) > 0 )
        {
            $this->stepPlaces = SprStepPlace::search($filters);
        }
        // Instancia os documentos da etapa sob demanda
        if ( $name == 'stepDocuments' && !$this->stepDocuments && strlen($this->stepId) > 0 )
        {
            $this->stepDocuments = SprStepDocument::search($filters);
        }
        
        return parent::__get($name);
    }

    public function __set($name, $value)
    {
        $this->$name = $value;
    }

    /*
     * Common methods
     */
    /**
     * Detecta se o salvar deve inserir um novo (no caso de chave primária não definida)
     * ou se deve apenas atualizar um registro já existente (no caso de chave primária já definida)
     *
     * @return TRUE no caso de sucesso. Caso contrário, FALSE.
     */
    public function save()
    {
        $module = SAGU::getFileModule(__FILE__);
        $maskDate = SAGU::getParameter('BASIC', 'MASK_DATE');
        $maskTimestamp = SAGU::getParameter('BASIC', 'MASK_TIMESTAMP_DEFAULT');

        $data = array(
            'selectiveProcessId' => $this->selectiveProcessId,
            'description' => $this->description,
            'minPoints' => strlen($this->minPoints) > 0 ? $this->minPoints : ':null',
            'accumulatePreviousSteps' => $this->accumulatePreviousSteps,
            'weight' => $this->weight,
            'classificationMethod' => $this->classificationMethod,
            'vacancies' => strlen($this->vacancies) > 0 ? $this->vacancies : ':null',
            'subscriberChoosesPlace' => $this->subscriberChoosesPlace,
            'initialMessage' => urlencode($this->initialMessage),
            'finalMessage' => urlencode($this->finalMessage),
            'hasUserInteraction' => SAGU::NVL($this->hasUserInteraction, DB_FALSE),
            'startDate' => ":TO_TIMESTAMP('{$this->startDate}', '{$maskTimestamp}')",
            'endDate' => ":TO_TIMESTAMP('{$this->endDate}', '{$maskTimestamp}')",
            'confirmationEmailId' => strlen($this->confirmationEmailId)>0?$this->confirmationEmailId:':null',
            'stepOrder' => $this->stepOrder,
            'calculationMethod' => $this->calculationMethod,
            'notasEnem' => strlen( $this->notasEnem ) > 0 ? $this->notasEnem : ':null',
            'digitacaoNotasSomenteAprovados' => SAGU::NVL($this->digitacaoNotasSomenteAprovados, DB_FALSE),
        );

        if ( strlen($this->scoreDate) > 0 )
        {
            $data['scoreDate'] = ":TO_DATE('{$this->scoreDate}', '{$maskDate}')";
        }

        if ( strlen($this->disclosureDate) > 0 )
        {
            $data['disclosureDate'] = ":TO_DATE('{$this->disclosureDate}', '{$maskDate}')";
        }

        if ( strlen($this->classificationDate)>0 )
        {
            $data['classificationDate'] = ":TO_DATE('{$this->classificationDate}', '{$maskDate}')";
        }

        foreach ($data as $key => $val)
        {
            if (!in_array($key, array('initialMessage', 'finalMessage')))
            {
                $data[$key] = strtoupper($val);
            }
        }

        // Se chave primária não está definida, assume que deva ser feito insert
        if ( strlen($this->stepId) <= 0 )
        {
            $result = SDatabase::query('SELECT nextval(\'spr.step_stepid_seq\')');
            $newId = $result[0][0];
            $data['stepId'] = $newId;

            $sql = new MSQL(implode(',', array_keys($data)), 'spr.step');
            $sql->SetParameters(array_values($data));
            
            $result = $retVal = SDatabase::execute($sql->Insert(), null, false);

            if ( $result )
            {
                $this->stepId = $newId;
            }
        }
        // Se chave primária definida, assume que deva ser feito update
        else
        {
            $sql = new MSQL(implode(',', array_keys($data)), 'spr.step');
            $sql->SetParameters(array_values($data));

            $sql->SetWhere('stepId = ?');
            $sql->addParameter($this->stepId);
            
            $result = $retVal = SDatabase::execute($sql->Update(), null, false);
        }

        if ( strlen($this->stepId) > 0 )
        {
            // salvar avaliações
            if ( count($this->evaluations)>0 )
            {
                foreach ( $this->evaluations as $evaluation )
                {
                    $evaluation->stepId = $this->stepId;
                    $evaluation->save();
                }
            }
            // salvar bancas avaliadoras
            if ( count($this->examiningBoards)>0 )
            {
                foreach ( $this->examiningBoards as $eb )
                {
                    $eb->stepId = $this->stepId;
                    $eb->save();
                }
            }
            // salvar critérios de desempate
            if ( count($this->stepTiebreaks)>0 )
            {
                foreach ( $this->stepTiebreaks as $stepTiebreak )
                {
                    $stepTiebreak->stepId = $this->stepId;
                    $stepTiebreak->save();
                }
            }
            // salvar documentos
            if ( count($this->stepDocuments) )
            {
                foreach ( $this->stepDocuments as $stepDocument )
                {
                    $stepDocument->stepId = $this->stepId;
                    $stepDocument->save();
                }
            }
            // salvar locais
            if ( count($this->stepPlaces)>0 )
            {
                foreach ( $this->stepPlaces as $stepPlace )
                {
                    $stepPlace->stepId = $this->stepId;
                    $stepPlace->save();
                }
            }
        }

        return $retVal;
    }

    /**
     * Exclui da base de dados o objeto atual
     *
     * @return TRUE no caso de sucesso. Caso contrário, FALSE.
     */
    public function delete()
    {

        //Obtém as avaliaçoes
        $this->__get('evaluations');
        
        //Obtem bancas avaliadoras
        $this->__get('examiningBoards');

        //Obtém os critérios de desempate
        $this->__get('stepTiebreaks');

        //Obtém os locais de prova
        $this->__get('stepPlaces');

        //Obtém os documentos
        $this->__get('stepDocuments');

        // excluir avaliações
        foreach ( $this->evaluations as $evaluation )
        {
            $evaluation instanceof SprEvaluation;
            $evaluation->delete();
        }

        // excluir bancas avaliadoras
        foreach ( $this->examiningBoards as $eb )
        {
            $eb instanceof SprExaminingBoard;
            $eb->delete();
        }
        
        // excluir critérios de desempate
        foreach ( $this->stepTiebreaks as $stepTiebreak )
        {
            $stepTiebreak instanceof SprStepTiebreak;
            $stepTiebreak->delete();
        }

        // excluir locais
        foreach ( $this->stepPlaces as $stepPlace )
        {
            $stepPlace instanceof SprStepPlace;
            $stepPlace->delete();
        }

        // excluir documentos
        foreach ( $this->stepDocuments as $stepDocument )
        {
            $stepDocument instanceof SprStepDocument;
            $stepDocument->delete();
        }

        $sql = 'DELETE FROM spr.step
                      WHERE stepId = ?';

        $params = array($this->stepId);

        $result = SDatabase::execute($sql, $params);

        if ( $result)
        {
            $this->stepId = null;
        }

        return $result;
    }

    /**
     * Duplica o registro atual.
     *
     * @return TRUE no caso de sucesso. Caso contrário, FALSE.
     */
    public function duplicate()
    {
        $step = clone($this);
        $step->stepId = null;

        $evaluations = array();
        $this->__get('evaluations');
        foreach ( $this->evaluations as $o )
        {
            $evaluations[] = $o->duplicate();
        }
        $step->evaluations = $evaluations;

        $examiningBoards = array();
        $this->__get('examiningBoards');
        foreach ( $this->examiningBoards as $o )
        {
            $examiningBoards[] = $o->duplicate();
        }
        $step->examiningBoards = $examiningBoards;
        
        $stepTiebreaks = array();
        $this->__get('stepTiebreaks');
        foreach ( $this->stepTiebreaks as $o )
        {
            $stepTiebreaks[] = $o->duplicate();
        }
        $step->stepTiebreaks = $stepTiebreaks;

        $stepPlaces = array();
        $this->__get('stepPlaces');
        foreach ( $this->stepPlaces as $o )
        {
            $stepPlaces[] = $o->duplicate();
        }
        $step->stepPlaces = $stepPlaces;

        $stepDocuments = array();
        $this->__get('stepDocuments');
        foreach ( $this->stepDocuments as $o )
        {
            $stepDocuments[] = $o->duplicate();
        }
        $step->stepDocuments = $stepDocuments;

        return $step;
    }

    /**
     * Retorna uma lista de objetos do tipo desta classe com os resultados da busca.
     *
     * @param (stdClass) $filters Objeto contendo todos os campos pesquisáveis do objeto atual
     */
    public function search($filters)
    {
        $sql = new MSQL("stepId", 'spr.step');
        $sql->setOrderBy('stepOrder');

        foreach ( $filters as $key => $value )
        {
            if ($key == 'isCurrent')
            {
                $sql->SetWhere(self::$isCurrentLogic . ' = ?');
                $sql->addParameter($value);
            }
            else if (strlen($value) > 0 && !is_array($value))
            {
                $sql->SetWhere("{$key} = ?");
                $sql->addParameter($value);
            }
        }

        $result = SDatabase::query($sql->select());

        $retVal = array();
        for ( $i=0; $i<count($result); $i++ )
        {
            $retVal[] = new SprStep($result[$i][0]);
        }

        return $retVal;
    }

    public static function listRecords($filters, $returnAssociative = false)
    {
        $sql = new MSQL();
        $sql->SetTables('spr.step');
        $sql->SetColumns('stepId, description');

        if (strlen($filters->selectiveProcessId) > 0)
        {
            $sql->SetWhere('selectiveProcessId = ?');
            $sql->addParameter($filters->selectiveProcessId);
        }
        if ( MUtil::getBooleanValue($filters->orderByStepOrder) )
        {
            $sql->SetOrderBy('stepOrder');
        }

        $result = SDatabase::query($sql->Select());
        $return = array();
        
        if ( $returnAssociative )
        {
            foreach ( $result as $key => $val )
            {
                $return[ $val[0] ] = $val[1];
            }
        }
        else
        {
            $return = $result;
        }
        
        return $return;
    }

    /*
     * Private methods
     */
    /*
     * Chamado pelo construtor, quando este recebe os dados de chave primária
     */
    private function populate()
    {
        $maskDate = SAGU::getParameter('BASIC', 'MASK_DATE');
        $maskTimestamp = SAGU::getParameter('BASIC', 'MASK_TIMESTAMP_DEFAULT');

        $sql = "SELECT stepId,
                       selectiveProcessId,
                       description,
                       minPoints,
                       accumulatePreviousSteps,
                       weight,
                       classificationMethod,
                       vacancies,
                       subscriberChoosesPlace,
                       initialMessage,
                       finalMessage,
                       hasUserInteraction,
                       TO_CHAR(startDate, '" . $maskTimestamp . "'),
                       TO_CHAR(endDate, '" . $maskTimestamp . "'),
                       TO_CHAR(scoreDate, '" . $maskDate . "'),
                       TO_CHAR(disclosureDate, '" . $maskDate . "'),
                       TO_CHAR(classificationDate, '" . $maskDate . "'),
                       confirmationEmailId,
                       stepOrder,
                       " . self::$isCurrentLogic . " AS isCurrent,
                       calculationMethod,
                       notasEnem,
                       digitacaoNotasSomenteAprovados
                  FROM spr.step
                 WHERE stepId = ?";

        $result = SDatabase::query($sql, $this->stepId);

        if ( strlen($result[0][0]) <= 0 )
        {
            $module = SAGU::getFileModule(__FILE__);
            throw new Exception(_M('Etapa @1 inexistente.', $module, $this->stepId));
        }

        list ( $this->stepId,
               $this->selectiveProcessId,
               $this->description,
               $this->minPoints,
               $this->accumulatePreviousSteps,
               $this->weight,
               $this->classificationMethod,
               $this->vacancies,
               $this->subscriberChoosesPlace,
               $this->initialMessage,
               $this->finalMessage,
               $this->hasUserInteraction,
               $this->startDate,
               $this->endDate,
               $this->scoreDate,
               $this->disclosureDate,
               $this->classificationDate,
               $this->confirmationEmailId,
               $this->stepOrder,
               $this->isCurrent,
               $this->calculationMethod,
               $this->notasEnem,
               $this->digitacaoNotasSomenteAprovados) = $result[0];

        $this->initialMessage = stripslashes(urldecode($this->initialMessage));
        $this->finalMessage = stripslashes(urldecode($this->finalMessage));
    }

    /*
     * Lista os métodos de classificação, manual e automático
     */
    public static function listAutomaticManual($type = 0)
    {
        if ( $type == 0 )
        {
            $data = array( self::CLASSIFICATION_METHOD_AUTOMATIC => _M('Automática', 'selectiveProcess'),
                           self::CLASSIFICATION_METHOD_MANUAL => _M('Manual', 'selectiveProcess')
                         );
        }
        elseif ( $type == 1 )
        {
            $data = array( array( _M('Automática', 'selectiveProcess'),
                                  self::CLASSIFICATION_METHOD_AUTOMATIC
                                ),
                           array( _M('Manual', 'selectiveProcess'),
                                  self::CLASSIFICATION_METHOD_MANUAL
                                )
                         );
        }

        return $data;
    }
    
    
    /*
     * Lista os métodos de cálculo das avaliações, podendo ser por média ou soma.
     */
    public static function listCalculationMethod($type = 0)
    {
        if ( $type == 0 )
        {
            $data = array( self::CALCULATION_METHOD_AVERAGE => _M('Média', 'selectiveProcess'),
                           self::CALCULATION_METHOD_SUM => _M('Soma', 'selectiveProcess')
                         );
        }
        elseif ( $type == 1 )
        {
            $data = array( array( _M('Média', 'selectiveProcess'),
                                  self::CALCULATION_METHOD_AVERAGE
                                ),
                           array( _M('Soma', 'selectiveProcess'),
                                  self::CALCULATION_METHOD_SUM
                                )
                         );
        }

        return $data;
    }

    /**
     * Generate Classification
     *
     * @param $stepId (integer):
     * @return (boolean):
     */
    public static function generateClassificationStep($stepId)
    {
        $sql = 'SELECT * FROM spr.CLASSIFICATION_IN_STEP(?)';
        $result = SDatabase::query($sql, array($stepId));

        return $result[0][0];
    }

    /**
     * Check if classification was generated in previous step
     *
     * @param $stepId (integer):
     * @return (boolean):
     */
    public static function checkIfClassificationWasGeneratedInPreviousStep($stepId)
    {
        $sql = 'SELECT (SELECT *
                          FROM spr.CHECK_IF_CLASSIFICATION_WAS_GENERATED_IN_STEP(A.stepId)) AS result
                  FROM spr.step A
                 WHERE A.selectiveProcessId = ?
                   AND A.stepOrder = ?';

        // Step
        $step = new SprStep($stepId);
        $previousStep = ($step->stepOrder -1);

        $params = array( $step->selectiveProcessId,
                       $previousStep );

        $result = SDatabase::query($sql, $params);
        $result = $result[0][0];

        if( !$result )
        {
            $result = true;
        }
        return $result;
    }

    /**
     * Otém os locais de uma etapa no formato necessário para a geração da ata de exame
     *
     * @param (integer) $stepId Código da etapa que se deseja pesquisar os locais
     */
    public function getStepPlacesDetail()
    {
        $sql = ' SELECT A.stepId,
                        A.physicalResourceId,
                        A.physicalResourceVersion,
                        A.locationId,
                        CASE WHEN A.isInternal IS TRUE
                            THEN F.cityId
                            ELSE C.cityId
                        END as cityId,
                        CASE WHEN A.isInternal IS TRUE
                            THEN F.name
                            ELSE C.name
                        END as cityName,
                        CASE WHEN A.isInternal IS TRUE
                            THEN D.building
                            ELSE A.building
                        END as building,
                        CASE WHEN A.isInternal IS TRUE
                            THEN D.room
                            ELSE A.room
                        END as room,
                        
                        (   SELECT COUNT(*)
                            FROM spr.subscription _A
                            INNER JOIN spr.selectiveProcess _B ON (_B.selectiveProcessId = _A.selectiveProcessId)
                            INNER JOIN spr.subscriptionStepPlace _C ON (_C.subscriptionId = _A.subscriptionId)
                            INNER JOIN spr.stepPlace _D ON (_D.stepPlaceId = _C.stepPlaceId)
                            WHERE _D.stepPlaceId = A.stepPlaceId
                            AND _A.selectiveProcessId = ?) as subscriptions,
                            
                        A.vacancies
                   FROM spr.stepPlace A
              LEFT JOIN basLocation B
                     ON (B.locationId = A.locationId)
              LEFT JOIN basCity C
                     ON (C.cityId = B.cityId)
              LEFT JOIN insPhysicalResource D
                     ON (D.physicalResourceId = A.physicalResourceId AND
                         D.physicalResourceVersion = A.physicalResourceVersion)
              LEFT JOIN basUnit E
                     ON (E.unitId = D.unitId)
              LEFT JOIN basLocation G
                     ON G.locationId = E.locationId
              LEFT JOIN basCity F
                     ON (F.cityId = G.cityId)
                  WHERE A.stepId = ?';
        
        $result = SDatabase::query($sql, array($this->selectiveProcessId, $this->stepId));

        return $result;
    }

    /**
     * Aloca alunos por sala.
     *
     * @param integer $stepId Código da etapa
     * @param array $options Opções
     * <br><b>priorities</b> (array) Array com os id's das prioridades<br>
     * Quando o id de uma prioridade for numérico, será considerado como sendo um evaluationId)<br>
     * Se contiver alguma letra, será considerado como sendo uma prioridade estática (vide constantes SprSubscription::PRIORITY_*)
     * <br><b>onlyPayed</b> (array) Alocar apenas inscrições cujo pagamento já tenha sido efetuado
     * <br><b>prioritySpecialNecessity</b> (boolean) Alocar inscrições priorizando pessoas com necessidades especiais
     * <br><b>groupByCourseOption</b> (boolean) Alocar inscrições priorizando opção de curso
     */
    public static function allocateByRoom($stepId, $options = array())
    {
        $MIOLO = MIOLO::getInstance();
        $module = MIOLO::getCurrentModule();
        
        $sprStep = current(SprStep::search( (object) array('selectiveProcessId' => $options->selectiveProcessId) ));        
        
        // Pega as localidades da etapa.
        $locations = self::getLocationsStep($stepId);
        
        if ( !count($locations) > 0 )
        {
            $prompt = new MPrompt('Ops', _M('Para executar o processo de alocação por sala, é necessário cadastrar os locais da prova para a etapa, no detalhamento de etapas.'));
            $prompt->SetType('error');

            $actionUrl = $MIOLO->getActionURL($module, 'main:process:detailedSteps');
            $prompt->AddButton(_M('Detalhamento de etapas'), $actionUrl);
            $prompt->AddButton(_M('Voltar'), $MIOLO->getActionURL($module, $MIOLO->getCurrentAction()));

            $MIOLO->prompt($prompt);
        }
        
        // Limpa a tabela stepplace. Isso garente que será feito uma nova alocação ao mudar os filtros.
        $ok = SprStep::cleanStepPlaces($stepId);
                
        foreach ( $locations as $location )
        {   
            // Defaults
            $options = array_merge(array(
                'priorities' => null,
                'onlyPayed' => null,
                'prioritySpecialNecessity' => null,
                'groupByCourseOption' => null
            ), $options);

            $priorities = $options['priorities'];
            $onlyPayed = $options['onlyPayed'];
            $prioritySpecialNecessity = $options['prioritySpecialNecessity'];
            $groupByCourseOption = $options['groupByCourseOption'];

            // SQL ORDER BY conditions
            $orderBy = array();

            $colNames = array(
                'subscriptionId',
                'personName',
                'hasSpecialNecessity'
            );
            $columns = array(
                'S.subscriptionId',
                'PP.name',
                '(CASE WHEN (PP.specialNecessityId IS NOT NULL AND PP.specialNecessityId <> 0) THEN TRUE ELSE FALSE END) AS hasSpecialNecessity',
            );

            // Priorizar necessidades especiais
            if ( $prioritySpecialNecessity == DB_TRUE )
            {
                $orderBy[] = 'hasSpecialNecessity DESC';
            }

            // spr.subscriptionoption.optionid
            if ( $groupByCourseOption == DB_TRUE )
            {
                // Opção de curso número 1
                $orderBy[] = "(SELECT SO.optionId
                                 FROM spr.subscriptionOption SO
                                WHERE SO.subscriptionId = S.subscriptionId
                             ORDER BY SO.optionNumber LIMIT 1)";
            }

            $staticOrders = array(
                self::PRIORITY_SUBSCRIPTION_ORDER => 'S.subscriptionOrder',
                self::PRIORITY_ALPHABETIC_ORDER => 'PP.name',
                self::PRIORITY_HIGH_SCHOOL_ORDER => 'S.finishedHighSchool DESC',
            );

            foreach ( (array)$priorities as $prop )
            {
                $order = strtr($prop, $staticOrders);
                if ( is_numeric($order) ) // É um evaluationId
                {
                    $orderBy[] = $colNames[] = "evaluationOption{$order}";

                    /*
                     * Subselect com a finalidade de fazer a ordenacao agrupando por opcao de avaliacao
                     * Ex: Agrupar todos alunos que estão com AVALIACAO X -> LINGUA ESTRANGEIRA em uma mesma sala.
                     */
                    $columns[] = "(SELECT SEO.evaluationOptionId
                                     FROM spr.evaluation E
                               INNER JOIN spr.evaluationOption EO
                                       ON (EO.evaluationId = E.evaluationId)
                               INNER JOIN spr.subscriptionEvaluationOption SEO
                                       ON (SEO.evaluationOptionId = EO.evaluationOptionId)
                                    WHERE E.evaluationId = ?
                                      AND SEO.subscriptionId = S.subscriptionId
                                      AND E.maxSelectableOptions = 1
                                    LIMIT 1) AS evaluationOption{$order}";

                    $params[] = $order; // evaluationId
                }
                else // É uma ordenacao estática (definida nas constantes)
                {
                    $orderBy[] = $order;
                }
            }
            
            unset($where);
            unset($params);
            // SQL WHERE conditions
            $where[] = 'SSI.stepId = ?';
            $params[] = $stepId;

            // Alocar apenas inscricoes cujo pagamento foi efetuado
            if  ( $onlyPayed == DB_TRUE )
            {
                $where[] = 'BALANCE(S.invoiceId) = 0';
            }
            
            //verifica se deve alocar por localidade
            if ( $sprStep->subscriberChoosesPlace == DB_TRUE )
            {
                $where[] = 'SSI.locationid = ?';
                $params[] = $location;
            }            
            
            // Converte no padrao SQL
            $columns = count($columns) > 0 ? implode(',', $columns) : '';
            $orderBy = count($orderBy) > 0 ? ' ORDER BY ' . implode(',', $orderBy) : '';
            $where = implode(' AND ', $where);
            
            // SQL final
            $sql = "SELECT {$columns}
                      FROM spr.subscription S
           INNER JOIN ONLY basPhysicalPerson PP
                        ON S.personId = PP.personId
                INNER JOIN spr.subscriptionStepInfo SSI
                        ON SSI.subscriptionId = S.subscriptionId
                     WHERE {$where} {$orderBy}";

            $rows = (array) SAGU::resultToObject(SDatabase::query($sql, $params), $colNames);

            if ( !(count($rows) > 0) )
            {
                throw new Exception(_M('Nenhuma inscrição encontrada para ser alocada. Verifique se não há dados faltando.', $module));
            }
            
            $filters = new stdClass();
            $filters->stepId = $stepId;
            $filters->orderBy = $prioritySpecialNecessity == DB_TRUE ? 'allowDisabledPeople DESC, allocationOrder' : 'allocationOrder';
            
            if ( $sprStep->subscriberChoosesPlace == DB_TRUE )
            {
                $filters->locationId = $location;
            }
            
            $stepPlaces = SprStepPlace::search($filters);
            
            // Caso a busca por location não retornar resultados faz a busca original sem locationid no filtro.
            if ( !(count($stepPlaces) > 0) )
            {
                $filters = new stdClass();
                $filters->stepId = $stepId;
                $filters->orderBy = $prioritySpecialNecessity == DB_TRUE ? 'allowDisabledPeople DESC, allocationOrder' : 'allocationOrder';
                
                $stepPlaces = SprStepPlace::search($filters);
            }

            // Se ainda assim não retornar resultados.
            if ( !(count($stepPlaces) > 0) )
            {
                throw new Exception(_M('Nenhum local de prova definido no detalhamento de etapas. Não há como alocar as inscrições.', $module));
            }

            /*
             * Caso nao haja vagas suficientes para deficientes, interrompe operacao
             */
            $totalVacanciesForSpecialNecessity = 0;
            $totalDisabledPeople = 0;

            foreach ( $stepPlaces as $stepPlace )
            {
                if ( $stepPlace->allowDisabledPeople == DB_TRUE ) // Se sala permite deficientes
                {
                    $totalVacanciesForSpecialNecessity += $stepPlace->vacancies;
                }
            }

            foreach ( $rows as $row )
            {
                if ( $row->hasSpecialNecessity == DB_TRUE ) // Se pessoa for deficiente
                {
                    $totalDisabledPeople ++;
                }
            }

            if  ( $totalDisabledPeople > $totalVacanciesForSpecialNecessity )
            {
                throw new Exception(_M('Não existem vagas suficientes para pessoas portadoras de necessidades especiais.', $module));
            }

            /*
             * Aloca pessoas
             */
            reset($stepPlaces);
            $currentVacanciesInUse = 0;
            foreach ( $rows as $row )
            {
                // Caso o numero de vagas chegar ao limite, move para o proximo local
                if ( $currentVacanciesInUse >= current($stepPlaces)->vacancies )
                {
                    $currentVacanciesInUse = 0;

                    /*
                     * Move o ponteiro do array $stepPlaces para o proximo objeto
                     * Caso nao exista proximo, causa um erro e aborta operacao
                     */
                    if ( !next($stepPlaces) )
                    {
                        throw new Exception(_M('Não há vagas suficientes para as inscrições serem alocadas. Defina mais locais de prova ou aumente o número de vagas por sala no detalhamento de etapas.', $module));
                    }
                }

                $filters = new stdClass();
                $filters->subscriptionId = $row->subscriptionId;
                $subscriptionStepPlace = current( SprSubscriptionStepPlace::search($filters) );
                $subscriptionStepPlace instanceof SprSubscriptionStepPlace;
                if ( $subscriptionStepPlace )
                {
                    $subscriptionStepPlace->delete();
                }

                $sprSubscriptionStepPlace = new SprSubscriptionStepPlace();
                $sprSubscriptionStepPlace->subscriptionId = $row->subscriptionId;
                $sprSubscriptionStepPlace->stepPlaceId = current($stepPlaces)->stepPlaceId;                
                $sprSubscriptionStepPlace->save();
                
                // Incrementa o número de vagas utilizado para o local da etapa atual
                $currentVacanciesInUse ++;
            }

            $count = $count + count($rows);
        }
        
        return $count;
    }
    
    /**
     * Pega todas as localidades onde irá ocorrer a etapa atual do processo seletivo
     * 
     * @param int $stepId
     * @return array $locations
     */
    public function getLocationsStep($stepId)
    {
        $MIOLO = MIOLO::getInstance();        
        $busPhysicalResources = new BusinessInstitutionalBusPhysicalResource();
        $busUnit = new BusinessBasicBusUnit();        
        
        $sprStepPlace = new SprStepPlace();
                
        $filters = new stdClass();
        $filters->stepId = $stepId;        
        $placeIds  = $sprStepPlace->search($filters);
        
        $locations = array();
        foreach ( $placeIds as $place )
        {
            if ( strlen($place->physicalResourceId) > 0 )
            {
                $physicalResource = $busPhysicalResources->getPhysicalResource($place->physicalResourceId, $place->physicalResourceVersion);
                $unit = $busUnit->getUnit($physicalResource->unitId);

                if ( !in_array($unit->locationId, $locations) )
                {
                    $locations[] = $unit->locationId;
                }
            }
            else
            {
                $locations[] = $place->locationId;
            }
        }
        
        return $locations;
    }

    /**
     * Otém os locais de uma etapa no formato necessário para a geração da ata de exame
     *
     * @param (integer) $stepId Código da etapa que se deseja pesquisar os locais
     */
    public static function cleanStepPlaces($stepId)
    {
        $sql = ' DELETE FROM spr.subscriptionstepplace
                       WHERE stepplaceid in (SELECT B.stepplaceid
                                               FROM spr.step A
                                         INNER JOIN spr.stepplace B
                                                 ON A.stepid = b.stepid
                                         INNER JOIN spr.subscriptionstepplace C
                                                 ON B.stepplaceid = C.stepplaceid
                                              WHERE B.stepid = ?)';

        $result = SDatabase::query($sql, $stepId);

        return $result;
    }

    /**
     * Verifica se pode ou não rodar o processo de classificação. A verificação consiste
     * em checar se existe alguma inscrição com pontuação pontuação desejada (registro na
     * sprSubscriptionEvaluationOption) que ainda não tenha sido ajustada, retornando
     * FALSE no caso de encontrar alguma.
     *
     * @return boolean
     */
    public function canRunClassification()
    {
        $filters = array('stepId' => $this->stepId);
        $subs = SprSubscription::search($filters);
        $retVal = true;
        try
        {
            foreach ( $subs as $s )
            {
                if ( is_array($s->subscriptionEvaluationOption) )
                {
                    foreach ( $s->subscriptionEvaluationOption as $subsEvOp )
                    {
                        $evaluation = new SprEvaluation($subsEvOp->evaluationOption->evaluationId);
                        if ( $evaluation->enableDesiredScoreField == DB_TRUE )
                        {
                            if ( strlen($subsEvOp->finalScore) == 0 )
                            {
                                throw new Exception();
                            }
                        }
                    }
                }
            }
        }
        catch ( Exception $e )
        {
            $retVal = false;
        }

        return $retVal;
    }
    
    
    /**
     * Retorna o id da ultima etapa
     *
     * @param integer $selectiveProcessId
     *
     * @return int
     */
    public static function getLastStep($selectiveProcessId)
    {
        $sql = 'select stepid from spr.step where selectiveprocessid = ? order by steporder desc limit 1';
        $result = SDatabase::query($sql, $selectiveProcessId);

        return $result[0][0];
    }
}
?>