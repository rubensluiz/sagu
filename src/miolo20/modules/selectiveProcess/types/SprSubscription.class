<?php
/**
 * <--- Copyright 2005-2010 de Solis - Cooperativa de Soluções Livres Ltda.
 *
 * Este arquivo é parte do programa Sagu.
 *
 * O Sagu é um software livre; você pode redistribuí-lo e/ou modificá-lo
 * dentro dos termos da Licença Pública Geral GNU como publicada pela Fundação
 * do Software Livre (FSF); na versão 2 da Licença.
 *
 * Este programa é distribuído na esperança que possa ser útil, mas SEM
 * NENHUMA GARANTIA; sem uma garantia implícita de ADEQUAÇÃO a qualquer MERCADO
 * ou APLICAÇÃO EM PARTICULAR. Veja a Licença Pública Geral GNU/GPL em
 * português para maiores detalhes.
 *
 * Você deve ter recebido uma cópia da Licença Pública Geral GNU, sob o título
 * "LICENCA.txt", junto com este programa, se não, acesse o Portal do Software
 * Público Brasileiro no endereço www.softwarepublico.gov.br ou escreva para a
 * Fundação do Software Livre (FSF) Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA --->
 *
 * Class definition for database entities
 *
 * @author Alexandre Heitor Schmidt [alexsmith@solis.coop.br]
 *
 * @version $Id$
 *
 * \b Maintainers: \n
 * Equipe solis [sagu2@solis.coop.br]
 *
 * @since
 * Class created on 15/12/2010
 */
/**
 * @access public
 * @package Processo_seletivo
 */
class SprSubscription extends SType
{
    /**
     * @AttributeType integer
     * Chave primaria da tabela
     */
    protected $subscriptionId;

    /**
     * @AttributeType integer
     * Indica a ordem de inscrição do candidato. Útil para processos seletivos que levam em conta a ordem de chegada (sorteio).
     */
    protected $subscriptionOrder;

    /**
     * @AttributeType boolean
     * Indica se o candidato desta inscrição já concluiu ou não o ensino médio.
     */
    protected $finishedHighSchool;

    /**
     * @AttributeType timestamp
     */
    protected $subscriptionDate;

    /**
     * @AssociationType Processo seletivo.SelectiveProcess
     * @AssociationMultiplicity 1
     */
    protected $selectiveProcess;

    /**
     * @AttributeType integer
     */
    protected $selectiveProcessId;

    /**
     * @AssociationType Processo seletivo.SubscriptionDocument
     * @AssociationMultiplicity 0..*
     */
    protected $subscriptionDocument = array();

    /**
     * @AssociationType Processo seletivo.SubscriptionEvaluationOption
     * @AssociationMultiplicity 0..*
     */
    protected $subscriptionEvaluationOption = array();

    /**
     * @AssociationType Processo seletivo.StepPlace
     * @AssociationMultiplicity 0..*
     */
    protected $subscriptionStepPlace = array();

    /**
     * @AssociationType Processo seletivo.basPhysicalPerson
     * @AssociationMultiplicity 1
     */
    protected $physicalPerson;
    protected $personId;

    /**
     * @AssociationType Processo seletivo.SubscriptionStatus
     * @AssociationMultiplicity 1
     */
    protected $status;

    /**
     * @AssociationType Processo seletivo.SubscriptionOption
     * @AssociationMultiplicity 0..*
     */
    protected $subscriptionOption = array();

    /**
     * Respostas da pessoa para o questionario socioeconomico
     */
    protected $answers = array();

    /**
     *
     * @var SprSubscriptionStepInfo Array
     */
    protected $subscriptionStepInfo = array();

    /**
     * Objeto utilizado na GrdSubscription para quando se deve obter informacoes da etapa
     *
     * @var <type>
     */
    protected $step;

    protected $invoiceId;
    protected $conclusionYear;
    protected $degreeName;
    protected $institutionName;
    protected $courseName;
    protected $formationLevelId;
    
    protected $isQuotaHolder;
    
    protected $anoEnem;
    protected $inscricaoEnem;
    protected $senhaEnem;
    
    
    /**
     * @var stdClass Instancia de get() BusFormationLevel
     */
    protected $formationLevel;

    public function __construct($subscriptionId = null)
    {
        if ( strlen($subscriptionId) > 0 )
        {
            $this->subscriptionId = $subscriptionId;
            $this->populate();
        }
    }

    /**
     * Data logic
     */
    public function __get($name)
    {
        $MIOLO = MIOLO::getInstance();
        
        //Filtro usado para instanciar os objetos relacionados
        $filters = new stdClass();
        $filters->subscriptionId = $this->subscriptionId;

        // Load on demand
        if ( strlen($this->subscriptionId) > 0 )
        {
            if ( $name == 'subscriptionDocument' && !$this->subscriptionDocument )
            {
                $this->subscriptionDocument = SprSubscriptionDocument::search($filters);
            }
            if ( $name == 'subscriptionEvaluationOption' && !$this->subscriptionEvaluationOption )
            {
                $this->subscriptionEvaluationOption = SprSubscriptionEvaluationOption::search($filters);
            }
            if ( $name == 'subscriptionStepPlace' && !$this->subscriptionStepPlace )
            {
                $this->subscriptionStepPlace = SprSubscriptionStepPlace::search($filters);
            }
            if ( $name == 'subscriptionStepInfo' && !$this->subscriptionStepInfo )
            {
                $this->subscriptionStepInfo = SprSubscriptionStepInfo::search($filters);
            }
            if ( $name == 'subscriptionOption' && !$this->subscriptionOption )
            {
                $this->subscriptionOption = SprSubscriptionOption::search($filters);
            }
            if ( $name == 'formationLevel' && ( strlen($this->formationLevelId) > 0 ) && $this->needCheckPopulate('formationLevel') )
            {
                $MIOLO = MIOLO::getInstance();
                $busFormationLevel = new BusinessAcademicBusFormationLevel();
                $this->formationLevel = $busFormationLevel->getFormationLevel($this->formationLevelId);
            }
        }
        
        // Load on demand
        if ( $name == 'selectiveProcess' && !$this->selectiveProcess && strlen($this->selectiveProcessId) > 0 )
        {
            $this->selectiveProcess = new SprSelectiveProcess($this->selectiveProcessId);
        }
        // Load on demand

        if ( $name == 'physicalPerson' && strlen($this->personId) > 0 )
        {
            //Instancia da pessoa física
            $busPhysicalPerson = new BusinessBasicBusPhysicalPerson();
            $this->physicalPerson = $busPhysicalPerson->getPhysicalPerson($this->personId);

            //Instancia dos documentos da pessoa
            $filters = new stdClass();
            $filters->personId = $this->personId;
            $busDocument = new BusinessBasicBusDocument();
            $this->physicalPerson->documents = $busDocument->searchDocument($filters, true);

            // Instancia o usuário da pessoa, se tiver
            if ( strlen($this->physicalPerson->mioloUserName) > 0 )
            {
                $busUser = new BusinessAdminBusUser();
                $this->physicalPerson->user = $busUser->getUserByLogin($this->physicalPerson->mioloUserName);
            }
        }
        // Load on demand
        if ( $name == 'selectiveProcess' && !$this->selectiveProcess && strlen($this->selectiveProcessId) > 0 )
        {
            $this->selectiveProcess = new SprSelectiveProcess($this->selectiveProcessId);
        }
        // Load on demand
        if ( $name == 'answers' && !$this->answers && (strlen($this->personId) > 0) && (strlen($this->selectiveProcessId)) )
        {
            $filters = new stdClass();
            $filters->personId = $this->personId;
            $filters->formId = $this->selectiveProcess->socialEconomicFormId;
            $busAnswer = new BusinessResearchBusAnswer();
            $this->answers = (array) $busAnswer->searchAnswer($filters, true);
        }

        return parent::__get($name);
    }

    public function __set($name, $value)
    {
        $this->$name = $value;
    }

    /**
     * Exclui da base de dados o objeto atual
     *
     * @return TRUE no caso de sucesso. Caso contrário, FALSE.
     */
    public function delete()
    {
        if ( strlen($this->selectiveProcessId) == 0 )
        {
            throw new Exception(_M('Não é possível excluir uma inscrição que ainda não foi salva.', $module));
        }

        //Obtém os objetos relacionados
        $this->__get('subscriptionOption');
        $this->__get('subscriptionStepPlace');
        $this->__get('subscriptionStepInfo');
        $this->__get('subscriptionEvaluationOption');
        $this->__get('subscriptionDocument');

        // excluir opções
        foreach ( $this->subscriptionOption as $option )
        {
            $option instanceof SprSubscriptionOption;
            $option->delete();
        }

        foreach ($this->subscriptionStepPlace as $place)
        {
            $place instanceof SprSubscriptionStepPlace;
            $place->delete();
        }

        foreach ($this->subscriptionStepInfo as $info)
        {
            $info instanceof SprSubscriptionStepInfo;
            $info->delete();
        }

        foreach ($this->subscriptionEvaluationOption as $opt)
        {
            $opt instanceof SprSubscriptionEvaluationOption;
            $opt->delete();
        }

        foreach ($this->subscriptionDocument as $doc)
        {
            $doc instanceof SprSubscriptionDocument;
            $doc->delete();
        }

        $sql = 'DELETE FROM spr.subscription
                      WHERE subscriptionId = ?';

        $params = array($this->subscriptionId);

        $result = SDatabase::execute($sql, $params);

        if ( $result)
        {
            $this->subscriptionId = null;
        }

        return $result;
    }

    /**
     * Retorna uma lista de objetos do tipo desta classe com os resultados da busca.
     *
     * @param (stdClass) $filters Objeto contendo todos os campos pesquisáveis do objeto atual
     */
    public static function search($filters)
    {
        $orderByLastSubscription = $filters->orderByLastSubscription == DB_TRUE;
        unset($filters->orderByLastSubscription);
        
        $sql = 'SELECT SUB.subscriptionId
                  FROM spr.subscription SUB
            INNER JOIN spr.selectiveProcess SPR
                    ON SUB.selectiveProcessId = SPR.selectiveProcessId
            INNER JOIN ONLY basPhysicalPerson PP
                    ON SUB.personId = PP.personId';
        
        $where = '';
        $args = array();
        foreach ( $filters as $key => $value )
        {
            switch ( $key )
            {
                case 'stepId':
                    $where .= ' AND EXISTS (SELECT 1
                                              FROM spr.subscriptionStepInfo X
                                             WHERE X.subscriptionId = SUB.subscriptionId
                                               AND X.stepId = ?)';
                    $args[] = $value;
                break;
                default:
                    if (is_scalar($value) && strlen($value) > 0)
                    {
                        if (is_numeric($value))
                        {
                            $where .= ' AND SUB.' . $key . ' = ?';
                            $args[] = $value;
                        }
                        else
                        {
                            $where .= ' AND SUB.' . $key . ' ILIKE ?';
                            $args[] = "%{$value}%";
                        }
                    }
                break;
            }
        }

        if ( strlen($where) > 0 )
        {
            $sql .= ' WHERE ' . substr($where, 5);
        }
        
        // Ordenacao
        $orderBy = 'SUB.subscriptionId';
        if ( $orderByLastSubscription )
        {
            $orderBy = 'SPR.subscriptionstartdate DESC';
        }
        $sql .= " ORDER BY {$orderBy}";

        $result = SDatabase::query($sql, $args);

        $retVal = array();
        for ( $i=0; $i<count($result); $i++ )
        {
            $retVal[] = $obj = new SprSubscription($result[$i][0]);
        }

        return $retVal;
    }

    public static function searchGrid($filters = null)
    {
        $maskDate = SAGU::getParameter('BASIC', 'MASK_DATE');
        $maskDateTime = SAGU::getParameter('BASIC', 'MASK_TIMESTAMP');

        $sql = "SELECT SUB.subscriptionId,
                       SUB.subscriptionOrder,
                       SPR.selectiveProcessId,
                       SPR.description AS selectiveProcessDescription,
                       PP.personId,
                       PP.name AS personName,
                       ARRAY_TO_STRING( ARRAY(
                        SELECT O.description || ': ' || COALESCE(C.name, OT.descricao)
                              FROM spr.subscriptionOption SO
                        INNER JOIN spr.option O
                                ON (SO.optionId = O.optionId)
                         LEFT JOIN spr.optionCourse OC
                                ON (OC.optionId = O.optionId)
                         LEFT JOIN acdCourse C
                                ON (C.courseId = OC.courseId)
                         LEFT JOIN sprOptionOfertaTurma OOT
			        ON OOT.optionId = O.optionId
                         LEFT JOIN acpOfertaTurma OT
				ON (OT.ofertaTurmaId = OOT.ofertaTurmaId)
                             WHERE SO.subscriptionId = SUB.subscriptionId
                          ORDER BY SO.optionNumber ), ', ') AS optionCourses,
                       TO_CHAR(PP.datebirth, '{$maskDate}'),
                       PP.sex,
                       CI.name,
                       PP.location,
                       PP.neighborhood,
                       PP.email,
                       DOC_CPF.content,
                       PHO_RES.phone,
                       PHO_PRO.phone,
                       PHO_CEL.phone,                       
                       DOC_RG.content,
                       DOC_RG.organ,
                       BLP.name,
                       COALESCE(PP.workemployername, 'NÃO INFORMADA'),
                       SPR.destinationmodule
                  FROM spr.subscription SUB
       INNER JOIN ONLY basPhysicalPerson PP
                    ON (PP.personId = SUB.personId)
       LEFT JOIN ONLY basPhysicalPersonStudent PPS
                    ON (PPS.personId = PP.personId)
             LEFT JOIN baslegalperson BLP
                    ON (BLP.personId = PPS.institutionidhs)
            INNER JOIN spr.selectiveProcess SPR
                    ON (SPR.selectiveProcessId = SUB.selectiveProcessId)
             LEFT JOIN spr.subscriptionStepInfo SSI
                    ON SSI.subscriptionId = SUB.subscriptionId
             LEFT JOIN bascity CI
                    ON (CI.cityId = PP.cityid)
             LEFT JOIN basdocument DOC_CPF
                    ON (DOC_CPF.personId = PP.personId
                        AND DOC_CPF.documenttypeid = (SELECT GETPARAMETER('BASIC', 'DEFAULT_DOCUMENT_TYPE_ID_CPF')::INTEGER))
             LEFT JOIN basdocument DOC_RG
                    ON (DOC_RG.personId = PP.personId
                        AND DOC_RG.documenttypeid = (SELECT GETPARAMETER('BASIC', 'DEFAULT_DOCUMENT_TYPE_ID_RG')::INTEGER)) 
             LEFT JOIN basphone PHO_RES
                    ON (PHO_RES.personId = PP.personId 
                        AND PHO_RES.type = 'RES')
            LEFT JOIN basphone PHO_PRO
                    ON (PHO_PRO.personId = PP.personId
                        AND PHO_PRO.type = 'PRO')
            LEFT JOIN basphone PHO_CEL
                    ON (PHO_CEL.personId = PP.personId
                       AND PHO_CEL.type = 'CEL')";

        $where = '';
        $params = array();
        if (strlen($filters->subscriptionId) > 0)
        {
            $where .= ' AND SUB.subscriptionId = ?';
            $params[] = $filters->subscriptionId;
        }

        if (strlen($filters->personId) > 0)
        {
            $where .= ' AND SUB.personId = ?';
            $params[] = $filters->personId;
        }

        if (strlen($filters->personName) > 0)
        {
            $where .= ' AND UNACCENT(PP.name) ILIKE UNACCENT(?) ';
            $params[] = $filters->personName . '%';
        }

        if (strlen($filters->selectiveProcessDescription) > 0)
        {
            $where .= ' AND SPR.description ILIKE ?';
            $params[] = "%{$filters->selectiveProcessDescription}%";
        }

        if (strlen($filters->selectiveProcessId) > 0)
        {
            $where .= ' AND SUB.selectiveProcessId = ?';
            $params[] = $filters->selectiveProcessId;
        }
        
        if ( strlen($filters->stepId) > 0 )
        {
            $where .= " AND SSI.stepId = ?";
            $params[] = $filters->stepId;
        }

        if ( strlen($filters->optionId) > 0 )
        {
            $where .= ' AND (SELECT COUNT(*)
                               FROM spr.subscriptionOption _A
                         INNER JOIN spr.option _B
                                 ON (_B.optionId = _A.optionId)
                              WHERE _A.optionId = ?
                                AND _A.subscriptionId = SUB.subscriptionId
                                AND _B.selectiveProcessId = SUB.selectiveProcessId) > 0';
            $params[] = $filters->optionId;
        }

        $result = array();
        if ( strlen($where) > 0 )
        {    
            $sql .= ' WHERE ' . substr($where, 4) . '
                   GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22
                   ORDER BY SPR.description, PP.name';
            
            $result = SDatabase::query($sql, $params);
        }
        
        return $result;
    }


   public static function searchResidentLinkObject($filters)
    {
        $vars = array(
            '',
        );
        return SAGU::resultToObject($this->searchResidentLink($filters), $vars);
    }

    /**
     * Busca para tela de Integracao com modulo de residencia
     *
     * @param stdClass $filters
     * <br><b>onlyWithoutLink</b> (boolean) Busca apenas por inscricoes que nao possuam vinculo
     * <br><b>subscriptionStatus</b> (array) Busca subscriptionStatusId's informados
     *
     * @return array
     */
    public static function searchResidentLink($filters)
    {
        $sqlSO = "  (SELECT optionId
                   FROM spr.subscriptionOption SO
                  WHERE SO.subscriptionId = S.subscriptionId
               ORDER BY SO.optionNumber
                  LIMIT 1)";
        
        $sqlPosition = "(SELECT position
                           FROM spr.subscriptionOption SO
                          WHERE SO.subscriptionId = S.subscriptionId
                            AND SO.optionId = {$sqlSO})";

        $sql =  "SELECT {$sqlPosition} AS position,
        
                        S.subscriptionId,
                        PP.personId,
                        PP.name,

                        '' AS null,

                        (SELECT COUNT(*)
                           FROM res.residente R
                          WHERE S.subscriptionId = R.subscriptionId) > 0 AS possuiVinculo,

                        {$sqlSO} AS selectedOption,

                        COALESCE( (
                            SELECT R.enfaseId::varchar || '_' || R.nucleoProfissionalId::varchar
                              FROM res.residente R
                             WHERE S.subscriptionId = R.subscriptionId), (
                            SELECT ONE.enfaseId::varchar || '_' || ONE.nucleoProfissionalId::varchar
                              FROM spr.optionnucleoenfase ONE
                             WHERE ONE.optionId = {$sqlSO}
                        ) ) AS residenteOption
                          
                   FROM spr.subscription S
        INNER JOIN ONLY basphysicalPerson PP
                     ON (S.personId = PP.personId)";
        $args = array( );

        if ( $filters->onlyWithoutLink == DB_TRUE )
        {
            $where.=' AND NOT EXISTS (
                         SELECT 1 FROM res.residente R
                          WHERE S.subscriptionId = R.subscriptionId) ';
        }

        if ( strlen($filters->personId) > 0 )
        {
            $where.=' AND PP.personId = ?';
            $args[] = $filters->personId;
        }

        if ( strlen($filters->selectiveProcessId) > 0 )
        {
            $where.=' AND S.selectiveProcessId = ?';
            $args[] = $filters->selectiveProcessId;
        }

        // Filtra por ocorrencia subscritionStatusId passado
        if ( count($filters->subscriptionStatus) > 0 )
        {
            //Converte PHP -> DB
            $subscriptionStatus = implode(',', $filters->subscriptionStatus);

            // Busca pelo status do inscrito na opcao
            $sqlIn = "SELECT _SO.subscriptionStatusId
                        FROM spr.subscriptionOption _SO
                       WHERE _SO.subscriptionId = S.subscriptionId
                         AND _SO.optionId = " . $sqlSO;
            
            
            $where .=    " AND ({$sqlIn}) IN ({$subscriptionStatus})";
        }

        //Aplica filtros de enfase e nucleoProfissional
        if ( (strlen($filters->enfaseId) > 0) || (strlen($filters->nucleoProfissionalId) > 0) )
        {
            $where.='AND EXISTS (SELECT 1
                                   FROM spr.optionNucleoEnfase ONE
                             INNER JOIN spr.option O
                                     ON O.optionId = ONE.optionId
                             INNER JOIN spr.subscriptionoption SO
                                     ON SO.optionid = O.optionid
                                    AND S.subscriptionId = SO.subscriptionId
                              LEFT JOIN res.residente _R
                                     ON _R.subscriptionId = S.subscriptionId
                                  WHERE 1=1';

            if ( strlen($filters->enfaseId) > 0 )
            {
                $where .= ' AND COALESCE(_R.enfaseId, ONE.enfaseId) = ?';
                $args[] = $filters->enfaseId;
            }
            if ( strlen($filters->nucleoProfissionalId) > 0 )
            {
                $where .= ' AND COALESCE(_R.nucleoProfissionalId, ONE.nucleoProfissionalId) = ?';
                $args[] = $filters->nucleoProfissionalId;
            }

            $where .= ')';
        }

        if ( strlen($where) > 0 )
        {
            $sql .= ' WHERE ' . substr($where, 4);
            $sql .= " ORDER BY {$sqlPosition}";

            $result = SDatabase::query(SAGU::prepare($sql, $args));
        }

        return $result;
    }


    /*
     * Private methods
     */
    /*
     * Chamado pelo construtor, quando este recebe os dados de chave primária
     */
    private function populate()
    {
        $MIOLO = MIOLO::getInstance();
        $module = SAGU::getFileModule(__FILE__);
        $maskDate = SAGU::getParameter('BASIC', 'MASK_DATE');
        $maskDateTime = SAGU::getParameter('BASIC', 'MASK_TIMESTAMP_DEFAULT');

        $sql = "SELECT subscriptionid,
                       selectiveprocessid,
                       personid,
                       subscriptionorder,
                       hassubscriptionfee,
                       finishedhighschool,
                       TO_CHAR(subscriptiondate, '{$maskDateTime}'),
                       invoiceId,
                       conclusionYear,
                       degreeName,
                       institutionName,
                       courseName,
                       formationLevelId,
                       anoEnem,
                       senhaEnem,
                       inscricaoEnem
                  FROM spr.subscription
                 WHERE subscriptionId = ?";

        $result = SDatabase::query($sql, $this->subscriptionId);

        if ( strlen($result[0][0]) <= 0 )
        {
            throw new Exception(_M('Inscrição @1 inexistente.', $module, $this->subscriptionId));
        }

        list ( $this->subscriptionId,
               $this->selectiveProcessId,
               $this->personId,
               $this->subscriptionOrder,
               $this->hasSubscriptionFee,
               $this->finishedHighSchool,
               $this->subscriptionDate,
               $this->invoiceId,
               $this->conclusionYear,
               $this->degreeName,
               $this->institutionName,
               $this->courseName,
               $this->formationLevelId,
               $this->anoEnem,
               $this->senhaEnem,
               $this->inscricaoEnem) = $result[0];
    }

    public function save()
    {
        $MIOLO = MIOLO::getInstance();
        $module = SAGU::getFileModule(__FILE__);

        // Salva dados da pessoa e documentos (deve salvar antes para ter o personId)
        $busPhysicalPerson = new BusinessBasicBusPhysicalPerson();
        $busDocument = new BusinessBasicBusDocument();

        if ( strlen($this->physicalPerson->personId) > 0 )
        {
            $busPhysicalPerson->updatePhysicalPerson($this->physicalPerson);
            $this->personId = $this->physicalPerson->personId;
        }
        else
        {
            $this->personId = $busPhysicalPerson->insertPhysicalPerson($this->physicalPerson);
        }

        //FIXME A inserção de documentos é feita aqui pela inscrição e é repetida pelo busphysicalPerson
        foreach ( (array)$this->physicalPerson->documents as $_doc )
        {
            $document = $busDocument->getDocument( $this->physicalPerson->personId, $_doc->documentTypeId );
            if (strlen($document->personId) > 0)
            {
                foreach ($_doc as $key => $val)
                {
                    $document->$key = $val;
                }

                $ok = $busDocument->updateDocument($document);
            }
            else
            {
                $_doc->personId = $this->physicalPerson->personId;
                $ok = $busDocument->insertDocument($_doc);
                $busPhysicalPerson->updatePhysicalPerson($this->physicalPerson);
            }
        }

        // spr.subscription
        $maskDate = SAGU::getParameter('BASIC', 'MASK_DATE');
        $maskTimestamp = SAGU::getParameter('BASIC', 'MASK_TIMESTAMP');

        $data = array( 'selectiveProcessId' => $this->selectiveProcessId,
                       'personId' => $this->personId,
                       'hasSubscriptionFee' => $this->hasSubscriptionFee,
                       'finishedHighSchool' => $this->finishedHighSchool,
                       'conclusionYear' => $this->conclusionYear,
                       'degreeName' => $this->degreeName,
                       'institutionName' => $this->institutionName,
                       'courseName' => $this->courseName,
                       'isQuotaHolder' => ($this->isQuotaHolder ? $this->isQuotaHolder : 'f'),
                       'formationLevelId' => strlen($this->formationLevelId) > 0 ? $this->formationLevelId : ':null',
                       'anoEnem' => strlen($this->anoEnem) > 0 ? $this->anoEnem : ':null',
                       'senhaEnem' => strlen($this->senhaEnem) > 0 ? $this->senhaEnem : ':null',
                       'inscricaoEnem' => strlen($this->inscricaoEnem) > 0 ? $this->inscricaoEnem : ':null',);
        
        

        if (strlen($this->subscriptionId) > 0)
        {
            $data['subscriptionDate'] = ":TO_TIMESTAMP('{$this->subscriptionDate}', '{$maskTimestamp}')";

            $sql = new MSQL(implode(',', array_keys($data)), 'spr.subscription');
            $sql->SetParameters(array_values($data));

            $sql->SetWhere('subscriptionId = ?');
            $sql->addParameter($this->subscriptionId);

            $retVal = SDatabase::execute($sql->Update());
        }
        else
        {
            $this->selectiveProcess = new SprSelectiveProcess($this->selectiveProcessId);
            if ( $this->selectiveProcess->generateFinance == DB_TRUE )
            {
                $sprFinInfo = new SprFinanceInformation($this->selectiveProcess->financeInformationId);
                $MIOLO->uses('types.class', 'finance');
                $busEntry = new BusinessFinanceBusEntry();
                $busInvoice = new BusinessFinanceBusInvoice();
                $busReceivableInvoice = new BusinessFinanceBusReceivableInvoice();

                if ( strlen($sprFinInfo->daysToMaturity) > 0 )
                {
                    $maturity = SAGU::addIntervalInDate(SAGU::getDateNow(), 'd', $sprFinInfo->daysToMaturity, '+'); //utilizar o $sprFinInfo->daysForMaturity
                }

                $parcelsValue  = $sprFinInfo->inscriptionFee / $sprFinInfo->parcelsNumber;
                $parcel = 1;

                $filters = new stdClass();
                $filters->parcelsValue = $parcelsValue;
                $filters->firstMaturityDate = ($maturity) ? $maturity : $sprFinInfo->dateToMaturity;
                $filters->parcelsNumber = $sprFinInfo->parcelsNumber . ' month -1 day';

                $maturityDates = $busReceivableInvoice->createMaturityDates($filters);

                foreach ( $maturityDates as $maturityDate )
                {
                    //Insere o titulo
                    $invoice = new FinReceivableInvoice();
                    $invoice->personId = $this->personId;
                    $invoice->costCenterId = $sprFinInfo->costCenterId;
                    $invoice->parcelNumber = $parcel;
                    $invoice->emissionDate = SAGU::getDateNow();
                    $invoice->policyId = $sprFinInfo->policyId;
                    $invoice->bankAccountId = $sprFinInfo->bankAccountId;
                    $invoice->isCanceled = DB_FALSE;
                    $invoice->isImported = DB_FALSE;
                    $invoice->incomeSourceId = SAGU::getParameter('SELECTIVEPROCESS', 'SPR_INSCRIPTION_INCOME_SOURCE_ID');
                    $invoice->emissionTypeId = SAGU::getParameter('BASIC', 'DEFAULT_EMISSION_TYPE_ID');
                    $invoice->maturityDate = $maturityDate[0];
                    $invoice->referenceMaturityDate = $invoice->maturityDate;
                    $invoice->value = 0;
                    $this->invoiceId = $busReceivableInvoice->insertReceivableInvoice($invoice);

                    // Insere o lancamento
                    $entry = new FinEntry();
                    $entry->invoiceId = $this->invoiceId;
                    $entry->isAccounted = DB_FALSE;
                    $entry->creationType = 'A'; // gerado automaticamente pelo sistema
                    $entry->costCenterId = $sprFinInfo->costCenterId;
                    $entry->entryDate = SAGU::getDateNow();
                    $entry->operationId = $sprFinInfo->operationId;
                    $entry->value = $maturityDate[1];
                    $busEntry->insertEntry($entry);

                    $busInvoice->updateInvoiceBalance($this->invoiceId);

                    if ( $parcel == 1 )
                    {
                        $referenceInvoice = $this->invoiceId;
                    }

                    $parcel++;
                }
            }

            $result = SDatabase::query("SELECT nextval('spr.subscription_subscriptionId_seq')");
            $newId = $result[0][0];

            $data['subscriptionId'] = $newId;
            $data['subscriptiondate'] = ':NOW()';
            $data['invoiceId'] = $referenceInvoice;
            $data['subscriptionOrder'] = ':(SELECT COALESCE(MAX(subscriptionOrder), 0)+1 FROM spr.subscription WHERE selectiveProcessId = '.$this->selectiveProcessId.')';

            $sql = new MSQL(implode(',', array_keys($data)), 'spr.subscription');
            $sql->SetParameters( array_values($data) );

            $result = $retVal = SDatabase::execute($sql->Insert());

            if ( $result )
            {
                $this->subscriptionId = $newId;
            }
        }

        if ( strlen($this->subscriptionId) > 0 )
        {
            foreach ( $this->subscriptionDocument as $obj )
            {
                $obj->subscriptionId = $this->subscriptionId;
                $obj->save();
            }

            foreach ( $this->subscriptionEvaluationOption as $obj )
            {
                $obj->subscriptionId = $this->subscriptionId;
                $obj->save();
            }

            foreach ( $this->subscriptionStepPlace as $obj )
            {
                $obj->subscriptionId = $this->subscriptionId;
                $obj->save();
            }

            foreach ( $this->subscriptionStepInfo as $obj )
            {
                $obj->subscriptionId = $this->subscriptionId;
                $obj->save();
            }

            // obtem opções atualmente existentes. as que sobrarem após o salvar
            // serão excluídas
            $filters = array('subscriptionId' => $this->subscriptionId);
            $existingOptions = SprSubscriptionOption::search($filters);

            // percorre novas opções definidas
            for ( $i=0; $i < count($this->subscriptionOption); $i++ )
            {
                // Se encontrar opções repetidas, deve abortar o processo, pois não é permitido
                // inscrever-se para a mesma opção mais de uma vez.
                for ( $j=$i+1; $j < count($this->subscriptionOption) && ! $duplicatesFound; $j++ )
                {
                    if ( (strlen($this->subscriptionOption[$i]->optionId) > 0)
                         && (strlen($this->subscriptionOption[$j]->optionId) > 0)
                         && ($this->subscriptionOption[$i]->optionId == $this->subscriptionOption[$j]->optionId) )
                    {
                        throw new Exception(_M('Há opções de curso repetidas.', $module));
                    }
                }

                // chegando neste ponto, não há opções repetidas para a opção atual
                // verificar, então, se a opção já está atualmente salva
                $optionExistsInDb = false;
                for ( $j=0; $j<count($existingOptions) && !$optionExistsInDb; $j++ )
                {
                    if ($existingOptions[$j]->optionId == $this->subscriptionOption[$i]->optionId )
                    {
                        // exclui do array a opção já existente
                        unset($existingOptions[$j]);
                        // reorganiza array
                        $existingOptions = array_values($existingOptions);
                        // aborta laço
                        $optionExistsInDb = true;
                    }
                }

                $this->subscriptionOption[$i]->subscriptionId = $this->subscriptionId;
                $this->subscriptionOption[$i]->save();
            }

            // excluir opções que ainda restaram no array de opções existentes na base
            for ( $i=0; $i<count($existingOptions); $i++ )
            {
                $existingOptions[$i]->delete();
            }

            $busAnswer = new BusinessResearchBusAnswer();

            foreach ($this->answers as $obj)
            {
                $obj->personId = $this->personId;
                $busAnswer->insertAnswer($obj);
            }
        }

        // se conseguiu inserir, recarregar todas as informações
        // para popular corretamente
        if ( $retVal )
        {
            $this->populate();
        }

        return $retVal;
    }

    /**
     * Seta o status final da inscrição para todos os inscritos no na ultima etapa
     * do processo seletivo
     *
     * @param $stepId (integer):
     * @return (boolean):
     */
    public static function setSubscriptionFinalStatus($stepId)
    {
        $sql = 'SELECT * FROM spr.SET_SUBSCRIPTION_FINAL_STATUS(?)';
        $result = SDatabase::query($sql, array($stepId));
        
        return $result[0][0];
    }

    /**
     * Função que recebe o código do processo seletivo e código da pessoa
     * e retorna o código de inscrição (se inscrito, ao contrário nulo)
     *
     * @param $selectiveProcessId (integer):
     * @param $personId (integer):
     * @return $subscriptionId (integer): Código de inscrição
     */
    public static function getSubscriptionId($selectiveProcessId, $personId)
    {
        $sql = 'SELECT subscriptionId
                  FROM spr.subscription
                 WHERE selectiveProcessId = ?
                   AND personId = ?';

        $result = SDatabase::query($sql, array($selectiveProcessId, $personId));

        return $result[0][0];
    }

    /**
     * Retorna um objeto com:
     *
     * personId;
     * personName;
     * personEmail;
     * selectiveProcessDescription;
     * stepDescription;
     * locationDescription;
     * cityDescription;
     * neighborhoodDescription;
     * number;
     * complement;
     * room;
     * building;
     */
    public static function personStepPlace($stepId, $onlyPayed = false)
    {
        $sql = "SELECT A.personId,
                       A.name AS personName,
                       A.email AS personEmail,
                       D.selectiveProcessId,
                       D.description AS selectiveProcessDescription,
                       E.description AS stepDescription,
                       CASE WHEN G.isInternal = TRUE THEN 
                           I.location
                       ELSE
                           M.name
                       END AS locationDescription,
                       CASE WHEN G.isInternal = TRUE THEN
                           J.name
                       ELSE
                           N.name
                       END AS cityDescription,
                       CASE WHEN G.isInternal = TRUE THEN
                           I.neighborhood
                       ELSE
                           O.name
                       END AS neighborhoodDescription,
                       CASE WHEN G.isInternal = TRUE THEN
                           I.number
                       ELSE
                           G.number
                       END,
                       CASE WHEN G.isInternal = TRUE THEN
                           I.complement
                       ELSE
                           G.complement
                       END,
                       CASE WHEN G.isInternal = TRUE THEN
                           K.room
                       ELSE
                          G.room
                       END,
                       CASE WHEN G.isInternal = TRUE THEN
                           K.building
                       ELSE
                           G.building
                       END
             FROM ONLY basperson A
            INNER JOIN spr.subscription B
                    ON (A.personId = B.personId)
            INNER JOIN spr.subscriptionStepInfo C
                    ON (B.subscriptionId = C.subscriptionId)
            INNER JOIN spr.selectiveProcess D
                    ON (B.selectiveProcessId = D.selectiveProcessId)
            INNER JOIN spr.step E
                    ON (C.stepId = E.stepId AND
                        D.selectiveProcessId = E.selectiveProcessId)
            INNER JOIN spr.subscriptionstepPlace F
                    ON (B.subscriptionid = F.subscriptionId)
            INNER JOIN spr.stepPlace G
                    ON (F.stepPlaceId = G.stepPlaceId)
            INNER JOIN basCompanyConf H
                    ON H.companyId = (SELECT value::int
                                        FROM basConfig
                                       WHERE parameter = 'DEFAULT_COMPANY_CONF')
        LEFT JOIN ONLY basLegalPerson I
                    ON H.personId = I.personId
             LEFT JOIN basCity J
                    ON I.cityId = J.cityId
             LEFT JOIN insPhysicalResource K
                    ON G.physicalResourceId = K.physicalResourceId
                   AND G.physicalResourceVersion = K.physicalResourceVersion
             LEFT JOIN basLocation M
                    ON G.locationId = M.locationId
	     LEFT JOIN basCity N
                    ON M.cityId = N.cityId
	     LEFT JOIN basNeighborhood O
                    ON M.neighborhoodId = O.neighborhoodId
                 WHERE LENGTH(A.email) > 0
                   AND A.sentEmail = TRUE
                   AND C.stepid = ?";

        if ( $onlyPayed )
        {
            $sql .=' AND (CASE WHEN B.invoiceId IS NOT NULL THEN balance(B.invoiceId) ELSE 0 END) = 0';
        }

        $params = array();
        $params[] = $stepId;

        $result = SDatabase::query($sql, $params);

        $dataResult = SAGU::resultToObject($result, array(
            'personId',
            'personName',
            'personEmail',
            'selectiveProcessId',
            'selectiveProcessDescription',
            'stepDescription',
            'locationDescription',
            'cityDescription',
            'neighborhoodDescription',
            'number',
            'complement',
            'room',
            'building'));

        return $dataResult;
    }

    /**
     * Se tiver autorização para tal, envia um email de confirmação de inscrição ao inscrito.
     *
     * @return (boolean) TRUE se conseguiu enviar. Senão, FALSE.
     */
    public function notifySubscriberAboutSubscription()
    {
        $MIOLO = MIOLO::getInstance();
        $this->__get('physicalPerson');
        $this->__get('subscriptionOption');
        $this->__get('selectiveProcess');

        $emailSent = false;

        if ( ( strlen($this->selectiveProcess->subscriptionEmailId) > 0 )
          && ( $this->physicalPerson->sentEmail == DB_TRUE )
          && ( SAGU::getParameter('SELECTIVEPROCESS', 'SPR_SEND_MAIL') == DB_TRUE ) )
        {
            // Enviar email de inscricao de matricula
            $busEmail = new BusinessBasicBusEmail();
            $busCompany = new BusinessBasicBusCompany();

            $dataEmail = $busEmail->getEmail($this->selectiveProcess->subscriptionEmailId);
            $dataCompany = $busCompany->getCompany(SAGU::getParameter('BASIC', 'DEFAULT_COMPANY_CONF'));

            $optionDescriptions = array();
            foreach ( $this->subscriptionOption as $subscriptionOption )
            {
                $option = new SprOption($subscriptionOption->optionId);
                $optionDescriptions[$subscriptionOption->optionNumber] = $subscriptionOption->optionNumber.' - '.$option->description;
            }
            ksort($optionDescriptions);

            $optionEvaluation = array();
            foreach( $this->subscriptionEvaluationOption as $subscriptionEvaluationOption )
            {
                $evaluationOption = new SprEvaluationOption($subscriptionEvaluationOption->evaluationOptionId);                
                //Adiciona a opção selecionada ou descrições das alternativas
                $optionEvaluation[] = $evaluationOption->description.(strlen($subscriptionEvaluationOption->description) > 0 ? ': '.$subscriptionEvaluationOption->description : '');
            }
            ksort($optionEvaluation);
            
            $tags = array(
                '$SUBSCRIPTIONID' => $this->subscriptionId,
                '$PERSONID' => $this->physicalPerson->personId,
                '$PERSONNAME' => $this->physicalPerson->name,
                '$PASSWORD' => $this->physicalPerson->user->password,
                '$SELECTIVEPROCESSID' => $this->selectiveProcess->selectiveProcessId,
                '$SELECTIVEPROCESSDESCRIPTION' => $this->selectiveProcess->description,
                '$SUBSCRIPTIONORDER' => $this->subscriptionOrder,
                '$OPTIONSCOURSE' => implode('<br />', $optionDescriptions),
                '$OPTIONSEVALUATION' => implode('<br />', $optionEvaluation)                
            );

            // Parameters
            $from = strtolower($dataEmail->from);
            $fromName = $dataCompany->acronym;
            $recipient[$this->physicalPerson->name] = strtolower($this->physicalPerson->email);
            $subject = $dataEmail->subject;
            $body = strtr($dataEmail->body, $tags);

            $mail = new sendEmail($from, $fromName, $recipient, $subject, $body, array());
            $emailSent = $mail->sendEmail();
        }

        return $emailSent;
    }
    
    
    /**
     * Obtem a pontuacao total obtida ate agora nas etapas 
     */
    public function getCurrentTotalPointsStep()
    {        
        $sql = 'SELECT getCurrentTotalPointsStep(?)';
        
        $result = SDatabase::query($sql, array($this->subscriptionId));
        
        return $result[0][0];
    }
    
    /**
     * Retorna todos inscritos que possuem algum 
     * tipo de necessidade especial.
     * 
     * @param integer $selectiveProcessId
     * @param integer $stepId
     */
    public function getSpecialNecessitySubscriptions($selectiveProcessId, $stepId = null)
    {
        $sql = "SELECT A.subscriptionid,
                       B.personid,
                       B.name,
                       C.description AS typenecessity,
                       B.specialnecessitydescription,
                       D.description AS step,       	        
                       F.description AS room
                  FROM spr.subscription A
       INNER JOIN ONLY basphysicalperson B
                    ON A.personId = B.personid
            INNER JOIN basSpecialNecessity C
                    ON B.specialnecessityid = C.specialnecessityid
            INNER JOIN spr.step D
                    ON D.selectiveprocessid = A.selectiveprocessid
             LEFT JOIN spr.subscriptionstepplace E
                    ON E.subscriptionid = A.subscriptionid
             LEFT JOIN spr.stepPlace G
                    ON G.stepplaceid = E.stepplaceid
             LEFT JOIN insphysicalresource F
                    ON G.physicalresourceid = F.physicalresourceid
                 WHERE B.specialnecessityid != 0
                   AND A.selectiveprocessid = ?
                   AND ( CASE WHEN ? IS NOT NULL 
                              THEN 
                                   D.stepid = ? 
                              ELSE 
                                   1=1 
                         END )";
        
        $params = array(
            $selectiveProcessId,
            $stepId,
            $stepId
        );
        
        return SDatabase::query(SAGU::prepare($sql, $params));
    }
    
      public static function obterInstituicao()
    {
        $result = SDatabase::query("SELECT acronym FROM bascompanyconf");

        return $result[0][0];
    }
    
    /**
     * Obtém a quantidade de inscritos que já foram classificados neste processo
     * seletivo.
     * 
     * @param int $selectiveProcessId
     * @return int
     */
    public function obterQuantidadeDeInscritosJaClassificados($selectiveProcessId)
    {
        $sql = " SELECT SB.subscriptionId
                   FROM spr.Subscription SB
             INNER JOIN spr.SubscriptionOption SO
                     ON (SO.subscriptionId = SB.subscriptionId)
                  WHERE SB.selectiveProcessId = ?
                    AND SO.subscriptionStatusId NOT IN (?, ?)
               GROUP BY SB.subscriptionId";
        
        $args[] = $selectiveProcessId;
        $args[] = SprSubscriptionStatus::INSCRIBED;
        $args[] = SprSubscriptionStatus::REFUSERS;
        
        $return = SDatabase::query($sql, $args);
        
        return count($return);
    }
}
?>