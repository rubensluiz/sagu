<?php

/**
 * <--- Copyright 2005-2010 de Solis - Cooperativa de Soluções Livres Ltda.
 *
 * Este arquivo é parte do programa Sagu.
 *
 * O Sagu é um software livre; você pode redistribuí-lo e/ou modificá-lo
 * dentro dos termos da Licença Pública Geral GNU como publicada pela Fundação
 * do Software Livre (FSF); na versão 2 da Licença.
 *
 * Este programa é distribuído na esperança que possa ser útil, mas SEM
 * NENHUMA GARANTIA; sem uma garantia implícita de ADEQUAÇÃO a qualquer MERCADO
 * ou APLICAÇÃO EM PARTICULAR. Veja a Licença Pública Geral GNU/GPL em
 * português para maiores detalhes.
 *
 * Você deve ter recebido uma cópia da Licença Pública Geral GNU, sob o título
 * "LICENCA.txt", junto com este programa, se não, acesse o Portal do Software
 * Público Brasileiro no endereço www.softwarepublico.gov.br ou escreva para a
 * Fundação do Software Livre (FSF) Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA --->
 *
 * Class definition for database entities
 *
 * @author Alexandre Heitor Schmidt [alexsmith@solis.coop.br]
 *
 * @version $Id$
 *
 * \b Maintainers: \n
 * Alexandre Heitor Schmidt [alexsmith@solis.coop.br]
 * Moises Heberle [moises@solis.coop.br]
 * Fabiano Tomasini [fabiano@solis.coop.br]
 * Luís Felipe Wermann [luis_felipe@solis.com.br]
 *
 * @since
 * Class created on 15/12/2010
 */

/**
 * Armazena um processo seletivo e todas suas informações
 */
class SprSelectiveProcess extends SType {

    /**
     * Constantes dos módulos de destino dos candidatos do processo seletivo
     */
    const DEST_MODULE_NONE = 1;      // Nenhum Módulo
    const DEST_MODULE_ACADEMIC = 2;  // Acadêmico
    const DEST_MODULE_RESIDENCY = 3; // Residência integrada em saúde
    const DEST_MODULE_PEDAGOGICO = 4;

    /**
     * @var int Código identificador do processo seletivo
     */
    protected $selectiveProcessId;

    /**
     * @var string Descrição que identifica este processo seletivo.
     */
    protected $description;

    /**
     * @var int Número de opções que o processo seletivo terá.
     */
    protected $numberOfOptions;

    /**
     * @var int Sempre deve ser 1 ou maior, indicando a quantidade de opções que o usuário que for fazer a inscrição é obrigado a selecionar. Deve ser sempre maior ou igual à quantidade de opções.
     */
    protected $minimumNumberOfOptions;

    /**
     * @var string Define o período em que as inscrições estarão disponíveis.
     */
    protected $subscriptionStartDate;

    /**
     * @var string Define o período em que as inscrições estarão disponíveis.
     */
    protected $subscriptionEndDate;

    /**
     * @var string Marca o fim do processo. A partir desta data, não são mais permitidas modificações no processo.
     */
    protected $endOfProcessDate;

    /**
     *
     * @var string Atributo virtual para ser usado no passo a passo.
     */
    protected $endOfProcessHour;
    
    /**
     * @var boolean Na conclusão de cada etapa, enviar um email avisando o usuário das próximas ações que devem ser tomadas.
     */
    protected $notifySubscribers;

    /**
     * @var boolean Indica se um usuário do sistema deve ser criado para cada candidato classificado.
     */
    protected $createUserForSubscribers;

    /**
     * @var string Mensagem de boas vindas do processo seletivo.
     */
    protected $initialMessage;

    /**
     * @var string Mensagem de finalização de inscrição no processo seletivo.
     */
    protected $finalMessage;

    /**
     * @var array Lista de etapas do processo seletivo.
     */
    protected $steps;

    /**
     * @var array Lista de opções do processo seletivo.
     */
    protected $options;

    /**
     * @var int Ligação com o questionário sócio-econômico, quando houver.
     */
    protected $socialEconomicFormId;

    /**
     * @var (FinanceInformation) Ligação com informações financeiras, quando houver.
     */
    protected $financeInformation;

    /**
     * @var int Armazena uma referência às informações financeiras, se existirem.
     */
    protected $financeInformationId;

    /**
     * @var boolean Indica se um mesmo candidato pode se inscrever em outro processo seletivo estando inscrito neste. Vale enquanto este processo seletivo estiver ativo.
     */
    protected $allowOtherSubscriptions;

    /**
     * @var int Formulário sócio econômico
     */
    protected $socialEconomicForm;

    /**
     * @var boolean Indica se será gerado financeiro para esse processo
     */
    protected $generateFinance;

    /**
     * @var int Código do email de confirmação de inscrição
     */
    protected $subscriptionEmailId;

    /**
     * @var boolean
     */
    protected $hasEmploymentInfo;

    /**
     * @var int Indica o módulo de destino dos candidatos do processo seletivo.
     */
    
        protected $exigirVinculoEmpregaticio;

    /**
     * @var int indica se o  vinculo será obrigatório.
     */
    protected $destinationModule;

    /**
     * @var boolean
     */
    protected $hasFormationLevelInfo;

    /**
     * Atributo virtual para ser utilizado no formulario de passo a passo
     * @var string
     */
    protected $subscriptionStartHour;

    /**
     * Atributo virtual para ser utilizado no formulario de passo a passo
     * @var string
     */
    protected $subscriptionEndHour;

    /**
     * Atributo que define se o processo seletivo requer autenticação para efetuar inscrição.
     * @var boolean
     */
    protected $requireAuthentication;

    /**
     * Atributo que define se a senha será exibida em tela ao finalizar inscrição
     * @var boolean
     */
    protected $showPasswordAfterSubscription;

    /**
     * Id do periodo.
     *
     * @var int
     */
    protected $periodId;

    /**
     *
     * @var int
     */
    protected $totalSteps;

    /**
     *
     * @var int
     */
    protected $totalOptions;

    /**
     *
     * @var int
     */
    protected $totalSubscriptions;

    /*
     * @var boolean default falsa
     */
    protected $permiteDadosBancarios;

    /**
     * Permite classificar pelo ENEM
     * @var boolean default false
     */
    protected $permiteClassificarEnem;

    /**
     * Anos válidos para ENEM
     * @var integer[]
     */
    /*
     * Atributos de oferta incial e final, pedagogico.
     */

    protected $periodoFinal;
    protected $periodoInicial;
    protected $anosEnemValidos;

    /**
     * Construtor da classe
     *
     * @param int $selectiveProcessId Chave primária da tabela
     */
    public function __construct($selectiveProcessId = null)
    {
        $this->steps = array();
        $this->options = array();

        if (strlen($selectiveProcessId) > 0)
        {
            $this->selectiveProcessId = $selectiveProcessId;
            $this->populate();
        }
    }

    /**
     * Data logic
     */
    public function __get($name)
    {
        $MIOLO = MIOLO::getInstance();

        //Filtro usado para instanciar os objetos relacionados
        $filters = new stdClass();
        $filters->selectiveProcessId = $this->selectiveProcessId;

        //Instancia as opções de curso do processo seletivo sob demanda
        if ($name == 'options' && !$this->options && strlen($this->selectiveProcessId) > 0)
        {
            $this->options = SprOption::search($filters);
        }
        //Instancia as etapas do processo seletivo sob demanda
        if ($name == 'steps' && !$this->steps && strlen($this->selectiveProcessId) > 0)
        {
            $this->steps = SprStep::search($filters);
        }

        //Instancia as informações financeiras do processo seletivo sob demanda
        if ($name == 'financeInformation' && !$this->financeInformation && strlen($this->financeInformationId) > 0)
        {
            $this->financeInformation = new SprFinanceInformation($this->financeInformationId);
        }

        //Instancia formulário sócio economico do processo seletivo sob demanda
        if ($name == 'socialEconomicForm' && !$this->socialEconomicForm && strlen($this->socialEconomicFormId) > 0)
        {
            $MIOLO = MIOLO::getInstance();
            $busForm = new BusinessResearchBusForm();
            $this->socialEconomicForm = $busForm->getForm($this->socialEconomicFormId);

            // Emulação de dados que deveriam vir do BusForm
            $busQuestion = new BusinessResearchBusQuestion();
            $filters = new stdClass();
            $filters->formId = $this->socialEconomicFormId;
            $this->socialEconomicForm->questions = $busQuestion->searchQuestion($filters, true);
        }

        return parent::__get($name);
    }

    public function __set($name, $value)
    {
        $this->$name = $value;
    }

    /*
     * Common methods
     */

    /**
     * Detecta se o salvar deve inserir um novo (no caso de chave primária não definida)
     * ou se deve apenas atualizar um registro já existente (no caso de chave primária já definida)
     *
     * @return boolean.
     */
    public function save()
    {
        $module = SAGU::getFileModule(__FILE__);
        $maskDate = SAGU::getParameter('BASIC', 'MASK_DATE');
        $maskTimestamp = SAGU::getParameter('BASIC', 'MASK_DATE') . ' ' . SAGU::getParameter('BASIC', 'MASK_TIME');

        $this->__get('options');

        if (count($this->anosEnemValidos) > 0)
        {
            $this->anosEnemValidos = '{' . implode(',', $this->anosEnemValidos) . '}';
        }

        // salvar informações financeiras, se existirem
        if (isset($this->financeInformation))
        {
            if ($this->generateFinance == DB_TRUE)
            {
                $this->financeInformation->allowInvoiceGeneration = $this->generateFinance;
                
                $this->financeInformation->save();
                $this->financeInformationId = $this->financeInformation->financeInformationId;
            }
        }
        
        // Save data
        $data = array(
            'financeInformationId' => strlen($this->financeInformationId) > 0 ? $this->financeInformationId : ':null',
            'socialEconomicFormId' => strlen($this->socialEconomicFormId) > 0 ? $this->socialEconomicFormId : ':null',
            'description' => $this->description,
            'numberOfOptions' => $this->numberOfOptions,
            'minimumNumberOfOptions' => $this->minimumNumberOfOptions,
            'subscriptionStartDate' => strlen($this->subscriptionStartDate) > 0 ? ":TO_TIMESTAMP('{$this->subscriptionStartDate}', '{$maskTimestamp}')" : null,
            'subscriptionEndDate' => strlen($this->subscriptionEndDate) > 0 ? ":TO_TIMESTAMP('{$this->subscriptionEndDate}', '{$maskTimestamp}')" : null,
            'endOfProcessDate' => strlen($this->endOfProcessDate) > 0 ? ":TO_TIMESTAMP('{$this->endOfProcessDate}', '{$maskTimestamp}')" : null,
            'notifySubscribers' => $this->notifySubscribers,
            'createUserForSubscribers' => DB_TRUE, // Sempre cria usuários, ticket #38999
            'initialMessage' => urlencode($this->initialMessage),
            'finalMessage' => urlencode($this->finalMessage),
            'allowOtherSubscriptions' => $this->allowOtherSubscriptions,
            'generateFinance' => $this->generateFinance,
            'subscriptionEmailId' => strlen($this->subscriptionEmailId) > 0 ? $this->subscriptionEmailId : ':null',
            'hasFormationLevelInfo' => $this->hasFormationLevelInfo,
            'hasEmploymentInfo' => $this->hasEmploymentInfo,
            'exigirVinculoEmpregaticio' => strlen($this->exigirVinculoEmpregaticio) > 0 ? $this->exigirVinculoEmpregaticio : 'f',
            'destinationModule' => $this->destinationModule,
            'requireAuthentication' => $this->requireAuthentication,
            'showPasswordAfterSubscription' => $this->showPasswordAfterSubscription,
            'periodId' => strlen($this->periodId) > 0 ? $this->periodId : ':null',
            'permiteDadosBancarios' => strlen($this->permiteDadosBancarios) > 0 ? $this->permiteDadosBancarios : 'f',
            'permiteClassificarEnem' => strlen($this->permiteClassificarEnem) > 0 ? $this->permiteClassificarEnem : 'f',
            'anosEnemValidos' => strlen($this->anosEnemValidos) > 0 ? $this->anosEnemValidos : ':null',
            'periodoInicial' => strlen($this->periodoInicial) > 0 ? $this->periodoInicial : ':null',
            'periodoFinal' => strlen($this->periodoFinal) > 0 ? $this->periodoFinal : ':null',
        );

        // upper all without someone
        foreach ($data as $key => $val)
        {
            if (!in_array($key, array('initialMessage', 'finalMessage')))
            {
                $data[$key] = strtoupper($val);
            }
        }

        // se chave primária definida, assume que deva ser feito update
        if (strlen($this->selectiveProcessId) > 0) // update
        {
            $sql = new MSQL(implode(',', array_keys($data)), 'spr.selectiveProcess');
            $sql->SetParameters(array_values($data));

            $sql->SetWhere('selectiveProcessId = ?');
            $sql->addParameter($this->selectiveProcessId);

            $retVal = SDatabase::execute($sql->update(), null, false);
        }
        // se chave primária não está definida, assume que deva ser feito insert
        else // insert
        {
            $result = SDatabase::query('SELECT nextval(\'spr.selectiveProcess_selectiveProcessid_seq\')');
            $newId = $result[0][0];

            $data['selectiveProcessId'] = $newId;

            $sql = new MSQL(implode(',', array_keys($data)), 'spr.selectiveProcess');
            $sql->SetParameters(array_values($data));

            $result = $retVal = SDatabase::execute($sql->Insert(), null, false);

            if ($result)
            {
                $this->selectiveProcessId = $newId;
            }
        }


        if (strlen($this->selectiveProcessId) > 0)
        {
            // salvar opções
            if (count($this->options) == 0)
            {
                throw new Exception(_M('O processo seletivo exige ao menos uma opção.', $module));
            }

            foreach ($this->options as $option)
            {
                $option->selectiveProcessId = $this->selectiveProcessId;
                $option->save();
            }

            // salvar etapas
            if (count($this->steps) == 0)
            {
                throw new Exception(_M('O processo seletivo exige ao menos uma etapa.', $module));
            }

            foreach ($this->steps as $step)
            {
                // Default na base é 1, porém para montar o sql não pode receber integer = ''
                $step->calculationMethod = ($step->calculationMethod) ? $step->calculationMethod : 1;
                $step->selectiveProcessId = $this->selectiveProcessId;
                $step->save();
            }            
        }

        return $retVal;
    }

    /**
     * Exclui da base de dados o objeto atual
     *
     * @return TRUE no caso de sucesso. Caso contrário, FALSE.
     */
    public function delete()
    {
        if (strlen($this->selectiveProcessId) == 0)
        {
            throw new Exception(_M('Não é possível excluir um processo seletivo que ainda não foi salvo.', $module));
        }

        //Obtem as opções de curso
        $this->__get('options');

        //Obtem as etapas do processo seletivo
        $this->__get('steps');

        // excluir opções
        foreach ($this->options as $option)
        {
            $option instanceof SprOption;
            $option->delete();
        }

        // excluir etapas
        foreach ($this->steps as $step)
        {
            $step instanceof SprStep;
            $step->delete();
        }

        $sql = new MSQL(null, 'spr.selectiveProcess');
        $sql->SetWhere('selectiveProcessId = ?');
        $sql->addParameter($this->selectiveProcessId);

        $result = SDatabase::execute($sql->Delete(), $args);

        if ($result)
        {
            $this->selectiveProcessId = null;
        }

        return $result;
    }

    /**
     * Duplica o registro atual.
     *
     * @return SprSelectiveProcess Uma nova instância do objeto atual.
     */
    public function duplicate()
    {
        $selectiveProcess = clone($this);
        $selectiveProcess->selectiveProcessId = null;

        $options = array();
        $this->__get('options');
        foreach ($this->options as $o)
        {
            $options[] = $o->duplicate();
        }
        $selectiveProcess->options = $options;

        $steps = array();
        $this->__get('steps');
        foreach ($this->steps as $o)
        {
            $steps[] = $o->duplicate();
        }
        $selectiveProcess->steps = $steps;

        $this->__get('financeInformation');
        if (!is_null($this->financeInformation))
        {
            $selectiveProcess->financeInformation = $this->financeInformation->duplicate();
        }

        return $selectiveProcess;
    }

    /**
     * Obtém query para search.
     * 
     * @param stdClass $filters
     * @return string
     */
    public function getSearchGridSQL($filters = null)
    {
        $sql = 'SELECT selectiveProcessId,
                       description,
                       subscriptionStartDate,
                       subscriptionEndDate,
                       endOfProcessDate,
                       numberOfOptions,
                       minimumNumberOfOptions,
                       (SELECT COUNT(*)
                          FROM spr.Step
                         WHERE selectiveProcessId = spr.selectiveProcess.selectiveProcessId) AS totalSteps,
                       (SELECT COUNT(*)
                          FROM spr.Subscription
                         WHERE selectiveProcessId = spr.selectiveProcess.selectiveProcessId) AS totalSubscriptions
                  FROM spr.selectiveProcess';
        
        $where = '';
        foreach ($filters as $key => $value)
        {
            if (is_scalar($value) && strlen($value) > 0)
            {
                if (is_numeric($value))
                {
                    $where .= " AND {$key} = '{$value}'";
                }
                else
                {
                    $where .= " AND {$key} ILIKE '%{$value}%'";
                }
            }
        }

        if (strlen($where) > 0)
        {
            $sql .= ' WHERE ' . substr($where, 5);
        }

        $sql .= ' ORDER BY spr.SelectiveProcess.selectiveProcessId ';
        
        return $sql;
    }
    
    /**
     * Retorna uma lista de objetos do tipo desta classe com os resultados da busca.
     *
     * @param (stdClass) $filters Objeto contendo todos os campos pesquisáveis do objeto atual
     */
    public function search($filters = null)
    {
        $result = SDatabase::query($this->getSearchGridSQL($filters));

        $retVal = array();
        for ($i = 0; $i < count($result); $i++)
        {
            $retVal[] = new SprSelectiveProcess($result[$i][0]);
        }
        
        return $retVal;
    }

    /*
     * Private methods
     */

    /**
     * Chamado pelo construtor, quando este recebe os dados de chave primária
     */
    private function populate()
    {
        $maskDate = SAGU::getParameter('BASIC', 'MASK_DATE');
        $maskDateTime = SAGU::getParameter('BASIC', 'MASK_DATE') . ' ' . SAGU::getParameter('BASIC', 'MASK_TIME');
        $sql = "SELECT A.selectiveProcessId,
                       A.financeInformationId,
                       A.socialEconomicFormId,
                       A.description,
                       A.numberOfOptions,
                       A.minimumNumberOfOptions,
                       TO_CHAR(A.subscriptionStartDate, '{$maskDateTime}'),
                       TO_CHAR(A.subscriptionEndDate, '{$maskDateTime}'),
                       TO_CHAR(A.endOfProcessDate, '{$maskDateTime}'),
                       A.notifySubscribers,
                       A.createUserForSubscribers,
                       A.initialMessage,
                       A.finalMessage,
                       A.allowOtherSubscriptions,
                       A.generateFinance,
                       A.subscriptionEmailId,
                       A.hasFormationLevelInfo,
                       A.hasEmploymentInfo,
                       A.exigirVinculoEmpregaticio,
                       A.destinationModule,
                       A.requireAuthentication,
                       A.showPasswordAfterSubscription,
                       A.periodId,
                       (SELECT COUNT(*) FROM spr.step S WHERE S.selectiveProcessId = A.selectiveProcessId),
                       (SELECT COUNT(*) FROM spr.option O WHERE O.selectiveProcessId = A.selectiveProcessId),
                       (SELECT COUNT(*) FROM spr.subscription SUB WHERE SUB.selectiveProcessId = A.selectiveProcessId),
                       A.permiteDadosBancarios,
                       A.permiteClassificarEnem,
                       array_to_string(A.anosEnemValidos,',') as anosEnemValidos
                  FROM spr.selectiveProcess A
                 WHERE A.selectiveProcessId = ?";

        $result = SDatabase::query($sql, $this->selectiveProcessId);

        if (strlen($result[0][0]) <= 0)
        {
            $module = SAGU::getFileModule(__FILE__);
            throw new Exception(_M('Processo seletivo @1 inexistente.', $module, $this->selectiveProcessId));
        }

        list ( $this->selectiveProcessId,
                $this->financeInformationId,
                $this->socialEconomicFormId,
                $this->description,
                $this->numberOfOptions,
                $this->minimumNumberOfOptions,
                $this->subscriptionStartDate,
                $this->subscriptionEndDate,
                $this->endOfProcessDate,
                $this->notifySubscribers,
                $this->createUserForSubscribers,
                $this->initialMessage,
                $this->finalMessage,
                $this->allowOtherSubscriptions,
                $this->generateFinance,
                $this->subscriptionEmailId,
                $this->hasFormationLevelInfo,
                $this->hasEmploymentInfo,
                $this->exigirVinculoEmpregaticio,
                $this->destinationModule,
                $this->requireAuthentication,
                $this->showPasswordAfterSubscription,
                $this->periodId,
                $this->totalSteps,
                $this->totalOptions,
                $this->totalSubscriptions,
                $this->permiteDadosBancarios,
                $this->permiteClassificarEnem,
                $this->anosEnemValidos) = $result[0];

        //Mensagem inicial e final do processo seletivo(aparece no momento das inscrições dos candidatos)
        $this->initialMessage = stripslashes(urldecode($this->initialMessage));
        $this->finalMessage = stripslashes(urldecode($this->finalMessage));
        $this->anosEnemValidos = explode(',', str_replace('{', '', str_replace('}', '', $this->anosEnemValidos)));
    }

    /**
     * Lista os processos seletivos em aberto
     * @return array
     */
    public static function _list()
    {
        $filters = new stdClass();
        $sql = 'SELECT DISTINCT A.selectiveProcessId,
                                A.description
                           FROM spr.selectiveprocess A
                     INNER JOIN spr.step B
                             ON (A.selectiveProcessId = B.selectiveProcessId)
                          WHERE (now() BETWEEN B.startDate AND B.endDate)
                            AND B.hasuserinteraction = \'t\' 
                       ORDER BY A.description';

        $result = SDatabase::query($sql);

        return $result;
    }

    /**
     * Listagem normal, sem verificação de ativos
     */
    public static function listNormal($orderBy = null)
    {
        $sql = ' SELECT DISTINCT selectiveProcessId,
                                 description
                            FROM spr.selectiveprocess';
        
        if ( strlen($orderBy) > 0 )
        {
            $sql .= ' ORDER BY ' . $orderBy;
        }

        return (array) SDatabase::query($sql);
    }

    /**
     * Obtém os classificados no processo seletivo e seus respectivos cursos
     * na coluna courseOccurrence retorna a occorrência apenas quando tiver apenas
     * uma, caso contrario retorna NULL.
     * @param object $filters
     * @return array
     */
    public static function getClassified($filters)
    {
        $sql = "SELECT A.subscriptionId,
                       A.position,
                       B.personId,
                       C.name as personName,
                       A.subscriptionStatusId,
                       J.description as subscriptionStatusDescription,
                       D.optionId,
                       D.description descriptionOption,
                       (CASE WHEN (SELECT COUNT(*)
                                     FROM spr.optioncourse F
                                    WHERE F.optionId = E.optionId) = 1
                          THEN G.name ||' / '|| E.courseVersion ||' - '|| H.description ||' - '|| I.description
                          ELSE NULL
                        END) AS courseOccurrence,
                       ( SELECT totalpoints
                           FROM spr.subscriptionstepinfo
                          WHERE subscriptionId = A.subscriptionId
                            AND stepid = (SELECT B.stepid 
                                            FROM spr.subscriptionstepinfo A
                                      INNER JOIN spr.step B
                                              ON a.stepid = b.stepid
                                           WHERE selectiveprocessid::text = ( CASE WHEN '{$filters->selectiveProcessId}' != ''
                                                                             THEN
                                                                                  '{$filters->selectiveProcessId}'
                                                                             ELSE
                                                                                  o.selectiveprocessid::text
                                                                        END )
                                             AND totalpoints IS NOT null
                                        ORDER BY  steporder DESC
                                           LIMIT 1) ) AS totalPoints,
                       (L.subscriptionId IS NOT NULL) AS possui_vinculo
                  FROM spr.subscriptionoption A
            INNER JOIN spr.subscription B
                    ON A.subscriptionId = B.subscriptionId
       INNER JOIN ONLY basphysicalperson C
                    ON C.personId = B.personId
            INNER JOIN spr.option D
                    ON A.optionId = D.optionId
            INNER JOIN spr.optionCourse E
                    ON E.optionId = D.optionId
            INNER JOIN acdCourse G
                    ON E.courseId = G.courseId
            INNER JOIN basTurn H
                    ON E.turnId = H.turnId
            INNER JOIN basUnit I
                    ON E.unitId = I.unitId
            INNER JOIN spr.subscriptionStatus J
                    ON J.subscriptionStatusId = A.subscriptionStatusId
             LEFT JOIN acdContract L
                    ON L.subscriptionId = A.subscriptionId
            INNER JOIN spr.subscription O
	            ON O.subscriptionid = A.subscriptionId";

        $where = '';
        if (!is_null($filters))
        {
            foreach ($filters as $key => $value)
            {
                if (strlen($value) > 0)
                {
                    if ($key == 'personId')
                    {
                        $where .= ' AND C.' . $key . ' = ' . $value;
                    }
                    else if ($key == 'subscriptionStatusId')
                    {
                        $where .= ' AND A.' . $key . ' IN(' . $value . ')';
                    }
                    else if ($key == 'selectiveProcessId' || $key == 'optionId')
                    {
                        $where .= ' AND D.' . $key . ' = ' . $value;
                    }
                    else if ($key == 'orderType')
                    {
                        $order = $value;
                    }
                    else
                    {
                        $where .= ' AND ' . $key . ' = ' . $value;
                    }
                }
            }
        }

        if (strlen($where) > 0)
        {
            $sql .= ' WHERE ' . substr($where, 5);
        }

        if ($order == 'inscricao')
        {
            $orderType = 'D.description, A.subscriptionId';
        }
        if ($order == 'nome')
        {
            $orderType = 'D.description, C.name';
        }
        if ($order == 'pontos')
        {
            $orderType = 'D.description, totalPoints DESC';
        }

        $sql .= ' ORDER BY ' . $orderType;

        $result = SDatabase::query($sql);

        return $result;
    }

    /*
     * Obtém os classificados no processo seletivo e suas respectivas turmas
     * na opç?o de módulo pedagógico para gerar inscriç?es
     * 
     * @param object $filters
     * @return array
     */

    public static function getClassifiedPedagogico($filters)
    {
        $sql = "SELECT A.subscriptionId,
                       A.position,
                       B.personId,
                       C.name as personName,
                       A.subscriptionStatusId,
                       J.description as subscriptionStatusDescription,
                       D.optionId,
                       D.description descriptionOption,
                       (CASE WHEN (SELECT COUNT(*)
                                     FROM sproptionofertaturma F
                                    WHERE F.optionId = E.optionId) = 1
                          THEN G.descricao ||' - '|| I.description
                          ELSE NULL
                        END) AS courseOccurrence,
                       ( SELECT totalpoints
                           FROM spr.subscriptionstepinfo
                          WHERE subscriptionId = A.subscriptionId
                            AND stepid = (SELECT B.stepid 
                                            FROM spr.subscriptionstepinfo A
                                      INNER JOIN spr.step B
                                              ON a.stepid = b.stepid
                                           WHERE selectiveprocessid::text = ( CASE WHEN '{$filters->selectiveProcessId}' != ''
                                                                             THEN
                                                                                  '{$filters->selectiveProcessId}'
                                                                             ELSE
                                                                                  o.selectiveprocessid::text
                                                                        END )
                                             AND totalpoints IS NOT null
                                        ORDER BY  steporder DESC
                                           LIMIT 1) ) AS totalPoints,
                       (L.subscriptionId IS NOT NULL) AS possui_vinculo
                  FROM spr.subscriptionoption A
            INNER JOIN spr.subscription B
                    ON A.subscriptionId = B.subscriptionId
       INNER JOIN ONLY basphysicalperson C
                    ON C.personId = B.personId
            INNER JOIN spr.option D
                    ON A.optionId = D.optionId
            INNER JOIN sproptionofertaturma E
                    ON E.optionId = D.optionId
            INNER JOIN acpofertaturma G
                    ON E.ofertaturmaid = G.ofertaturmaid
             LEFT JOIN basUnit I
                    ON E.unitId = I.unitId
            INNER JOIN spr.subscriptionStatus J
                    ON J.subscriptionStatusId = A.subscriptionStatusId
             LEFT JOIN acpinscricao L
                    ON L.subscriptionId = A.subscriptionId
            INNER JOIN spr.subscription O
	            ON O.subscriptionid = A.subscriptionId ";        

        $where = '';
        if (!is_null($filters))
        {
            foreach ($filters as $key => $value)
            {
                if (strlen($value) > 0)
                {
                    if ($key == 'personId')
                    {
                        $where .= ' AND C.' . $key . ' = ' . $value;
                    }
                    else if ($key == 'subscriptionStatusId')
                    {
                        $where .= ' AND A.' . $key . ' IN(' . $value . ')';
                    }
                    else if ($key == 'selectiveProcessId' || $key == 'optionId')
                    {
                        $where .= ' AND D.' . $key . ' = ' . $value;
                    }
                    else if ($key == 'orderType')
                    {
                        $order = $value;
                    }
                    else
                    {
                        $where .= ' AND ' . $key . ' = ' . $value;
                    }
                }
            }
        }

        if (strlen($where) > 0)
        {
            $sql .= ' WHERE ' . substr($where, 5);
        }

        if ($order == 'inscricao')
        {
            $orderType = 'D.description, A.subscriptionId';
        }
        if ($order == 'nome')
        {
            $orderType = 'D.description, C.name';
        }
        if ($order == 'pontos')
        {
            $orderType = 'D.description, totalPoints DESC';
        }

        $sql .= ' ORDER BY ' . $orderType;
        
        $result = SDatabase::query($sql);

        return $result;
    }

    /**
     * Obtém os classificados no processo seletivo e seus respectivos cursos
     * na opçao de módulo nenhum para confirmar a matrícula
     * @param object $filters
     * @return array
     */
    public static function getClassifiedEnrollConfirm($filters)
    {
        $sql = "SELECT A.subscriptionId,
                       A.position,
                       B.personId,
                       C.name as personName,
                       A.subscriptionStatusId,
                       J.description as subscriptionStatusDescription,
                       D.optionId,
                       D.description descriptionOption,
                       D.description AS courseOccurrence
                  FROM spr.subscriptionoption A
            INNER JOIN spr.subscription B
                    ON A.subscriptionId = B.subscriptionId
       INNER JOIN ONLY basphysicalperson C
                    ON C.personId = B.personId
            INNER JOIN spr.option D
                    ON A.optionId = D.optionId
            INNER JOIN spr.subscriptionStatus J
                    ON J.subscriptionStatusId = A.subscriptionStatusId
              LEFT JOIN acdcontract K
                    ON K.subscriptionid = b.subscriptionid";

        $where = " AND A.canenroll = 't' ";

        if (!is_null($filters))
        {
            foreach ($filters as $key => $value)
            {
                if (strlen($value) > 0 && $key != 'order')
                {
                    // Lista somente os que ainda não possuem contrato
                    if (($key == 'notContract') && ($value))
                    {
                        $where .= ' AND k.subscriptionId IS NULL';
                    }
                    else if ($key == 'personId')
                    {
                        $where .= ' AND C.' . $key . ' = ' . $value;
                    }
                    else if ($key == 'subscriptionStatusId')
                    {
                        $where .= ' AND A.' . $key . ' IN(' . $value . ')';
                    }
                    else if ($key == 'selectiveProcessId' || $key == 'optionId')
                    {
                        $where .= ' AND D.' . $key . ' = ' . $value;
                    }
                    else
                    {
                        $where .= ' AND ' . $key . ' = ' . $value;
                    }
                }
            }
        }

        if (strlen($where) > 0)
        {
            $sql .= ' WHERE ' . substr($where, 5);
        }

        $sql .= ' ORDER BY ';

        if ($filters->order == 'Nome')
        {
            $sql .= 'C.name, A.position ';
        }
        else
        {
            $sql .= 'A.position, C.name ';
        }

        $result = SDatabase::query($sql);

        return $result;
    }

    /**
     * Retorna a lista de opções disponíveis para o módulo de destino do processo seletivo.
     * @return array
     */
    public static function destinationModuleOptions()
    {
        $destinationOptions = array();

        $destinationOptions[self::DEST_MODULE_NONE] = _M('Nenhum Módulo', $module);
        if (SAGU::getParameter('basic', 'MODULE_ACADEMIC_INSTALLED') == 'YES')
        {
            $destinationOptions[self::DEST_MODULE_ACADEMIC] = _M('Acadêmico', $module);
        }
        if (SAGU::getParameter('basic', 'MODULE_RESIDENCY_INSTALLED') == 'YES')
        {
            $destinationOptions[self::DEST_MODULE_RESIDENCY] = _M('Residência', $module);
        }
        if (SAGU::getParameter('BASIC', 'MODULE_PEDAGOGICO_INSTALLED') == 'YES')
        {
            $destinationOptions[self::DEST_MODULE_PEDAGOGICO] = _M('Pedagógico', $module);
        }

        return $destinationOptions;
    }

    /**
     * Obtem objeto contendo a etapa vigente
     * 
     * @return SprStep
     */
    public function getCurrentStep()
    {
        $currentStep = new SprStep();
        foreach ((array) $this->__get('steps') as $step)
        {
            if ($step->isCurrent == DB_TRUE)
            {
                $currentStep = $step;
                break;
            }
        }

        return $currentStep;
    }

    /**
     * Retorna se tela deve estar em modo readOnly
     */
    public function hasActiveStep()
    {
        return ( strlen($this->getCurrentStep()->stepId) > 0 );
    }

    public function hasSubscriptions()
    {
        $hasSubscriptions = false;

        if (strlen($this->selectiveProcessId) > 0)
        {
            $filters = new stdClass();
            $filters->selectiveProcessId = $this->selectiveProcessId;
            $hasSubscriptions = ( count(SprSubscription::searchGrid($filters)) > 0 );
        }

        return $hasSubscriptions;
    }

    /*
     * Funcao que obtem os periodos do processo, caso seja pedagogico
     */

    public function encontrarPeriodos($selectiveProcessId)
    {
        $sql = "SELECT periodoInicial, 
                       periodoFinal
                  FROM spr.selectiveprocess
                 WHERE selectiveProcessId = ? ";
        $params[] = $selectiveProcessId;

        $return = SDatabase::query($sql, $params);

        return $return;
    }

    /*
     * Funcao que obtem o modulo de destino do processo.
     */

    public function obterDestinationModule($selectiveProcessId)
    {
        $sql = "SELECT destinationModule
                  FROM spr.selectiveProcess
                 WHERE selectiveProcessId = ? ";
        $params[] = $selectiveProcessId;

        $return = SDatabase::query($sql, $params);

        return $return[0][0];
    }
    
    /*
     * Retorna se tem ou nao mensagem incial para demonstrar ao usuário.
     * 
     * @param int stepId - identificador da etapa
     */
    public static function verificarExisteMensagemInicial($stepId)
    {
        $sql = "SELECT A.initialmessage
                  FROM spr.selectiveprocess A
            INNER JOIN spr.step B on A.selectiveprocessid = B.selectiveprocessid
                 WHERE B.stepid = ?";
        $params[] = $stepId;
        
        $return= SDatabase::query($sql, $params);
        
        strlen($return[0][0]) > 0 ? $result = true : $result = false;
        
        return $result;
    }

}

?>
