<?php
/**
 * <--- Copyright 2005-2010 de Solis - Cooperativa de Soluções Livres Ltda.
 *
 * Este arquivo é parte do programa Sagu.
 *
 * O Sagu é um software livre; você pode redistribuí-lo e/ou modificá-lo
 * dentro dos termos da Licença Pública Geral GNU como publicada pela Fundação
 * do Software Livre (FSF); na versão 2 da Licença.
 *
 * Este programa é distribuído na esperança que possa ser útil, mas SEM
 * NENHUMA GARANTIA; sem uma garantia implícita de ADEQUAÇÃO a qualquer MERCADO
 * ou APLICAÇÃO EM PARTICULAR. Veja a Licença Pública Geral GNU/GPL em
 * português para maiores detalhes.
 *
 * Você deve ter recebido uma cópia da Licença Pública Geral GNU, sob o título
 * "LICENCA.txt", junto com este programa, se não, acesse o Portal do Software
 * Público Brasileiro no endereço www.softwarepublico.gov.br ou escreva para a
 * Fundação do Software Livre (FSF) Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA --->
 *
 *
 * This file handles the connection and actions for acdEnroll table
 *
 * @author Daniel Afonso Heisler [daniel@solis.coop.br]
 *
 * $version: $Id$
 *
 * \b Maintainers \n
 * Alexandre Heitor Schmidt [alexsmith@solis.coop.br]
 * Arthur Lehdermann [arthur@solis.coop.br]
 * Daniel Afonso Heisler [daniel@solis.coop.br]
 * Jamiel Spezia [jamiel@solis.coop.br]
 * Samuel Koch [samuel@solis.coop.br]
 * William Prigol Lopes [william@solis.coop.br]
 * Luís Felipe Wermann [luis_felipe@solis.com.br]
 * Joao Francisco Padilha Souza [joao@solis.com.br]
 *
 * @since
 * Class created on 13/10/2005
 */



/**
 * Para implementação do webServices tivemos que negar o uso dos includes
 * validacao herdada do miolo.class
 * 
 * O problema ocorreu para a implementacao #37869 
 * No metodo "wsfecharDisciplinaOferecida" da classe "webServicesBasic.class"
 * 
 */
$uri = $_SERVER['SCRIPT_NAME'];
//
if  ( !(!isset($_REQUEST['webservice']) && !isset($_REQUEST['WSDL']) && strpos($uri, 'wsdl.php') === FALSE) )
{

    $MIOLO = MIOLO::getInstance();
    $MIOLO->uses('classes/sTypeAssociation.class', 'basic');
    $MIOLO->uses('classes/sform.class', 'basic');
    $MIOLO->uses('classes/Matricula.class', 'academic');
}

/**
 * Class to pass information back to the form
 */
class EnrollCurriculumStatus
{
    // text describing the status
    public $status;

    // translated text describing the status
    public $text;

    // color to be used when displaying status
    public $color;

    // a boolean to indicate whether to display or not the groups for a curriculum entry
    public $showGroup;
}

/**
 * Class to manipulate the acdEnroll table
 */
class BusinessAcademicBusEnroll extends sBusiness
{
    /**
     * @var $enrollData Object created on-the-fly during the enroll process. Contains
     *                  the enrolled groups and the income forecasts
     */
    public $enrollData;

    /**
     * @var (array) $errors Stores all errors that happened during the use of this class
     */
    public $errors;

    /**
     * @var (string) $module Module where this file resides in.
     */
    private $module;

    /**
     * @var (integer) $enrollsDeleted Armazena a quantidade de matrículas excluídas pelo
     *                                método deleteUnpaidEnrolls
     */
    public $enrollsDeleted;
    /**
     * @var (integer) $invoicesDeleted Armazena a quantidade de títulos excluídos pelo
     *                                 método deleteUnpaidEnrolls
     */
    public $invoicesDeleted;
    
    /**
     * @var int
     */
    private $tipoDeMatriculaAtual;
    
    /**
     *
     * @var int
     */
    public $numberHourCondition;

    /**
     * Class constructor. Automatically instantiate a new connection to the database and stores it in $this->db.
     */
    public function __construct()
    {
        $this->errors = array();
        $this->module = 'academic';

        parent::__construct();
    }

    /**
     * This method behaves the same as $db->execute(), with only one difference: when an array of SQLs
     * is passed by parameter, it does NOT start a transaction to execute them.
     *
     * @param $sqls array containing the SQLs to be executed.
     * @return (boolean) True if suceed. Otherwise, False.
     */
    public function execute($sqls)
    {
        // If $sqls is not an array, convert it to an array
        if ( ! is_array($sqls) )
        {
            $sqls = array($sqls);
        }

        // Execute all SQLs independently. This is to avoid the behavior of $db->execute(), which
        // starts a new transaction when an array of SQLs is passed by parameter.
        $result = true;
        for ( $i=0; $i<count($sqls) && $result; $i++ )
        {
            $this->getDatabase()->execute($sqls[$i]);
        }

        return $result;
    }

    /*****************************************************
     *
     * Functions to manipulate the acdenroll table data
     *
     **************************************************/
    /**
     * Return a specific record from the database
     *
     * @param $enrollId (integer): Primary key of the record to be retrieved
     * @return (object): Return an object of the type handled by the class
     */
    public function getEnroll($enrollId, $isWebServices = false)
    {
        $acdEnroll = "unit_acdEnroll";
        
        // Para webservices.
        if ( $isWebServices )
        {
            $acdEnroll = "acdEnroll";
        }          

        $sql = "SELECT A.enrollId,
                       A.contractId,
                       A.groupId,
                       A.curriculumId,
                       TO_CHAR(A.dateEnroll,'" . SAGU::getParameter('BASIC', 'MASK_DATE') . "'),
                       TO_CHAR(A.hourEnroll,'" . SAGU::getParameter('BASIC', 'MASK_TIME') . "'),
                       TO_CHAR(A.dateCancellation,'" . SAGU::getParameter('BASIC', 'MASK_DATE') . "'),
                       TO_CHAR(A.hourCancellation,'" . SAGU::getParameter('BASIC', 'MASK_TIME') . "'),
                       A.reasonCancellationId,
                       A.note,
                       A.examNote,
                       COALESCE(A.finalNote::TEXT, (SELECT DE.note
                             FROM acdDegreeEnroll DE
                            WHERE DE.enrollid = A.enrollId
                              AND DE.degreeid = ( SELECT degreeId
                        FROM acdDegree
                       WHERE learningPeriodId = GRP.learningPeriodId
                         AND degreeNumber IN (0, 1)
                         AND parentDegreeId IS NULL 
                       LIMIT 1 ) ORDER BY recorddate DESC LIMIT 1 )::TEXT) AS finalNote,
                       A.concept,
                       A.textEvaluation,
                       A.frequency,
                       A.obsExploitation,
                       A.exploitationInstitutionId,
                       A.numberHourExploitation,
                       A.creditsExploitation,
                       A.isShowDocumentEndCourse,
                       A.statusId,
                       B.description AS statusDescription,
                       A.frequencyAlertEmail,
                       A.isInternet,
                       A.ip,
                       A.isConfirm,
                       A.isSetFree,
                       A.complement,
                       A.obsExploitation,
                       A.userName,
                       TO_CHAR(A.dateTime,'" . SAGU::getParameter('BASIC', 'MASK_TIMESTAMP') . "'),
                       A.ipAddress,
                       A.isExploitation,
                       A.learningPeriodId,
                       A.subclassId,
                       A.finalExaminationTheme,
                       A.detailEnrollStatusId,
                       DES.description AS detailEnrollStatusDescription,
                       DES.shortDescription AS detailEnrollStatusShortDescription,
                       TO_CHAR(A.examiningBoard,'" . SAGU::getParameter('BASIC', 'MASK_DATE') . "')
                  FROM {$acdEnroll} A
            INNER JOIN acdEnrollStatus B
                    ON B.statusId = A.statusId
             LEFT JOIN acdDetailEnrollStatus DES
                    ON DES.detailEnrollStatusId = A.detailEnrollStatusId
             LEFT JOIN acdExploitation EXP 
                    ON EXP.enrollId = A.enrollId
             LEFT JOIN acdGroup GRP
                    ON GRP.groupId = A.groupId
                 WHERE A.enrollId = ?";

        $result = $this->getDatabase()->query(SAGU::prepare($sql, array($enrollId)));

        $enroll = new AcdEnroll();
        list( $enroll->enrollId,
              $enroll->contractId,
              $enroll->groupId,
              $enroll->curriculumId,
              $enroll->dateEnroll,
              $enroll->hourEnroll,
              $enroll->dateCancellation,
              $enroll->hourCancellation,
              $enroll->reasonCancellationId,
              $enroll->note,
              $enroll->examNote,
              $enroll->finalNote,
              $enroll->concept,
              $enroll->textEvaluation,
              $enroll->frequency,
              $enroll->obsExploitation,
              $enroll->exploitationInstitutionId,
              $enroll->numberHourExploitation,
              $enroll->creditsExploitation,
              $enroll->isShowDocumentEndCourse,
              $enroll->statusId,
              $enroll->statusDescription,
              $enroll->frequencyAlertEmail,
              $enroll->isInternet,
              $enroll->ip,
              $enroll->isConfirm,
              $enroll->isSetFree,
              $enroll->complement,
              $enroll->obsExploitation,
              $enroll->userName,
              $enroll->dateTime,
              $enroll->ipAddress,
              $enroll->isExploitation,
              $enroll->learningPeriodId,
              $enroll->subclassId,
              $enroll->finalExaminationTheme,
              $enroll->detailEnrollStatusId,
              $enroll->detailEnrollStatusDescription,
              $enroll->detailEnrollStatusShortDescription,
              $enroll->examiningBoard) = $result[0];

        return $enroll;
    }
    
    
    /**
     *  Zera as frequencias voltando para o estado de NULL
     *
     * @param $enrollId Integer
     *
     */
    public function clearFrequency($enrollId)
    {
        $sql = 'UPDATE acdenroll 
                   SET frequency = NULL 
                 WHERE enrollid = ?';
        
        $result = $this->getDatabase()->execute(SAGU::prepare($sql, array($enrollId)));
        return $result;
    }

    /**
     *  Seach Enroll
     *
     * @param $filters (Object): Object containing the filters
     *
     */
    public function searchEnroll($filters, $isWebServices = false)
    {
        $acdGroup = "unit_acdGroup";
        $acdLearningPeriod = "unit_acdlearningperiod";
        $acdEnroll = "unit_acdEnroll"; 
        
        // Para webservices.
        if ( $isWebServices )
        {
            $acdGroup = "acdGroup";
            $acdLearningPeriod = "acdlearningperiod";
            $acdEnroll = "acdEnroll";            
        } 
        
        $sql = "SELECT A.enrollId,
                       A.contractId,
                       A.groupId,
                       A.curriculumId,
                       TO_CHAR(A.dateEnroll,'" . SAGU::getParameter('BASIC', 'MASK_DATE') . "'),
                       TO_CHAR(A.hourEnroll,'" . SAGU::getParameter('BASIC', 'MASK_TIME') . "'),
                       TO_CHAR(A.dateCancellation,'" . SAGU::getParameter('BASIC', 'MASK_DATE') . "'),
                       TO_CHAR(A.hourCancellation,'" . SAGU::getParameter('BASIC', 'MASK_TIME') . "'),
                       A.reasonCancellationId,
                       A.note,
                       A.examNote,
                       A.finalNote,
                       A.concept,
                       A.textEvaluation,
                       A.frequency,
                       A.obsExploitation,
                       A.exploitationInstitutionId,
                       A.numberHourExploitation,
                       A.creditsExploitation,
                       A.isShowDocumentEndCourse,
                       A.statusId,
                       B.description AS statusDescription,
                       A.frequencyAlertEmail,
                       A.isInternet,
                       A.ip,
                       A.isConfirm,
                       A.isSetFree,
                       A.complement,
                       A.obsExploitation,
                       A.userName,
                       TO_CHAR(A.dateTime,'" . SAGU::getParameter('BASIC', 'MASK_TIMESTAMP') . "'),
                       A.ipAddress,
                       A.isExploitation,
                       D.learningPeriodId,
                       A.subclassId,
                       A.finalExaminationTheme
                  FROM {$acdEnroll} A
            INNER JOIN acdEnrollStatus B
                    ON B.statusId = A.statusId
             LEFT JOIN {$acdGroup} C
                    ON (C.groupId = A.groupId)
             LEFT JOIN {$acdLearningPeriod} D
                    ON (D.learningPeriodId = C.learningPeriodId) ";
             
        if ( strlen($filters->enrollId) > 0 )
        {
            $where .= ' AND A.enrollId = ? ';
            $params[] = $filters->enrollId;
        }
        if ( strlen($filters->contractId) > 0 )
        {
            $where .= ' AND A.contractId = ? ';
            $params[] = $filters->contractId;
        }
        if ( strlen($filters->groupId) > 0 )
        {
            $where .= ' AND A.groupId = ? ';
            $params[] = $filters->groupId;
        }
        if ( isset($filters->curriculumId) )
        {
            if ( is_array($filters->curriculumId) )
            {
                $curriculums = implode(',', $filters->curriculumId);
                $where .= " AND A.curriculumId IN ({$curriculums}) ";
            }
            else if ( strlen($filters->curriculumId) > 0 )
            {
                $where .= ' AND A.curriculumId = ? ';
                $params[] = $filters->curriculumId;
            }
        }
        if ( isset($filters->learningPeriodIdInPeriod) )
        {
            $where .=  " AND D.periodId IN (SELECT periodId FROM acdlearningperiod WHERE learningPeriodId = ?) ";
            $params[] = $filters->learningPeriodIdInPeriod;
        }
        if ( strlen($filters->reasonCancellationId) > 0 )
        {
            $where .= ' AND A.reasonCancellationId = ? ';
            $params[] = $filters->reasonCancellationId;
        }
        if ( strlen($filters->learningPeriodId) > 0 )
        {
            $where .= ' AND C.learningPeriodId = ? ';
            $params[] = $filters->learningPeriodId;
        }
        if ( strlen($filters->classId) > 0 )
        {
            $where .= ' AND C.classId = ? ';
            $params[] = $filters->classId;
        }
        if ( strlen($filters->statusId) > 0 )
        {
            $where .= ' AND A.statusId = ? ';
            $params[] = $filters->statusId;
        }
        if ( count($filters->notStatusId) > 0 )
        {
            foreach ( $filters->notStatusId as $notStatus )
            {
                $where .= ' AND A.statusId != ? ';            
                $params[] = $notStatus;
            }
        }
        
        if ( count($filters->inStatusId) > 0 )
        {            
            $where .= ' AND A.statusId in ( ' . implode(',', $filters->inStatusId)  . ')';            
        }
        
        if ( strlen($filters->periodId) > 0 )
        {
            $where .= ' AND D.periodId = ? ';
            $params[] = $filters->periodId;
        }
                
        if ( MUtil::getBooleanValue($filters->finalExamination) )
        {
            $where .= ' AND A.groupId IN (
                SELECT G.groupId 
                  FROM acdgroup G 
             LEFT JOIN acdcurriculum CUR ON (G.curriculumid = CUR.curriculumid) 
             LEFT JOIN acdcurricularcomponenttype T ON (CUR.curricularcomponenttypeid = T.curricularcomponenttypeid) 
                 WHERE T.curricularcomponenttypeid = ' . SAGU::getParameter('ACADEMIC', 'ACD_CURRICULUM_TYPE_FINAL_EXAMINATION') . ') ';
        }
        
        if ( MUtil::getBooleanValue($filters->finalExaminationExaminingBoard) )
        {
            $where .= ' AND A.enrollId IN (SELECT enrollId 
                                             FROM acdfinalexaminationexaminingboard
                                            WHERE personId = ?) ';
            $params[] = $filters->personId;
        }
        
        if ( $filters->curriculumTypeComplementaryActivity == DB_FALSE )
        {
            $where .= " AND EXISTS (SELECT 1 
                                 FROM acdCurriculum
                                WHERE curriculumId = A.curriculumId
                                  AND curriculumTypeId != '" . SAGU::getParameter('ACADEMIC', 'ACD_CURRICULUM_TYPE_COMPLEMENTARY_ACTIVITY') . "') ";
        }
        
        if ( strlen($filters->professorId) > 0 )
        {
            $where .= " AND D.courseId IN (SELECT G.courseId
                       FROM basPhysicalPersonProfessor H
                 INNER JOIN acdScheduleProfessor I
                         ON H.personId = I.professorId
                 INNER JOIN acdSchedule C
                         ON I.scheduleId = C.scheduleId
                 INNER JOIN unit_acdGroup D
                         ON C.groupId = D.groupId
                 INNER JOIN unit_acdcurriculum E
                         ON D.curriculumId = E.curriculumId
                 INNER JOIN unit_acdcourseoccurrence F
                         ON F.courseId = E.courseId
                        AND F.courseVersion = E.courseVersion
                        AND F.turnId = E.turnId
                        AND F.unitId = E.unitId
                 INNER JOIN  acdcourse G
                         ON G.courseId=F.courseId
                      WHERE (H.personId = ?)) ";
            
            $params[] = $filters->professorId;
        }

        if ( $where != '' )
        {
            $sql .= ' WHERE ' . substr($where, 5);
            
            if ( $filters->exploitation )
            {
                $sql .= " UNION SELECT DISTINCT A.enrollId, 
                                                A.contractId, 
                                                A.groupId, 
                                                A.curriculumId, 
                                                TO_CHAR(A.dateEnroll,'dd/mm/yyyy'), 
                                                TO_CHAR(A.hourEnroll,'hh24:mi'), 
                                                TO_CHAR(A.dateCancellation,'dd/mm/yyyy'), 
                                                TO_CHAR(A.hourCancellation,'hh24:mi'), 
                                                A.reasonCancellationId, 
                                                A.note, 
                                                A.examNote, 
                                                A.finalNote, 
                                                A.concept, 
                                                A.textEvaluation, 
                                                A.frequency, 
                                                A.obsExploitation, 
                                                A.exploitationInstitutionId, 
                                                A.numberHourExploitation, 
                                                A.creditsExploitation, 
                                                A.isShowDocumentEndCourse, 
                                                A.statusId, 
                                                B.description AS statusDescription, 
                                                A.frequencyAlertEmail, 
                                                A.isInternet, 
                                                A.ip, 
                                                A.isConfirm, 
                                                A.isSetFree, 
                                                A.complement, 
                                                A.obsExploitation, 
                                                A.userName, 
                                                TO_CHAR(A.dateTime,'dd-mm-yyyy hh24:mi:ss'), 
                                                A.ipAddress, 
                                                A.isExploitation, 
                                                NULL::int, 
                                                A.subclassId, 
                                                A.finalExaminationTheme 
                                           FROM unit_acdEnroll A 
                                     INNER JOIN acdEnrollStatus B ON B.statusId = A.statusId 
                                          WHERE A.enrollid IN (SELECT enrollid FROM acdexploitation WHERE enrollid IN ( SELECT enrollid from acdenroll WHERE contractid = ? )) ";
                
                $params[] = $filters->contractId;
            }

            $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));
        }
        return $result;
    }
    
    /**
     * Utilizado no FrmEnroll.class
     */
    public function updateEnrollEdit($data)
    {
        $sql = 'UPDATE acdEnroll
                   SET curriculumId = COALESCE(?, curriculumId),
                       groupId = COALESCE(?, groupId),
                       textEvaluation = ?,
                       frequency = ?,
                       isShowDocumentEndCourse = ?,
                       statusId = ?,
                       frequencyAlertEmail = ?,
                       isInternet = ?,
                       isConfirm = ?,
                       isSetFree = ?,
                       complement = ?,
                       detailEnrollStatusId = ?
                 WHERE enrollId = ?';

        $params = array(
                       $data->curriculumId,
                       $data->groupId,
                       $data->textEvaluation,
                       $data->frequency,
                       $data->isShowDocumentEndCourse,
                       SAGU::NVL($data->forceStatusId, $data->statusId),
                       $data->frequencyAlertEmail,
                       $data->isInternet,
                       $data->isConfirm,
                       $data->isSetFree,
                       $data->complement,
                       $data->detailEnrollStatusId,
                       $data->enrollId);

        $result = $this->execute(SAGU::prepare($sql, $params));

        return $result;
    }

    /**
     * Update enroll
     *
     * @param $data (Object): Object containing all data
     * @return (boolean): True if succeed, otherwise False
     */
    public function updateEnroll($data)
    {
        
                $sql = 'UPDATE acdEnroll
                   SET curriculumId = COALESCE(?, curriculumId),
                       groupId = COALESCE(?, groupId),
                       contractId = COALESCE(?, contractId),
                       dateEnroll = dateToDb(?),
                       note = ?,
                       examNote = ?,
                       finalNote = ?,
                       concept = ?,
                       textEvaluation = ?,
                       frequency = ?,
                       obsExploitation = ?,
                       exploitationInstitutionId = ?,
                       numberHourExploitation = ?,
                       creditsExploitation = ?,
                       isShowDocumentEndCourse = ?,
                       statusId = ?,
                       frequencyAlertEmail = ?,
                       isInternet = ?,
                       isConfirm = ?,
                       isSetFree = ?,
                       complement = ?,
                       subclassId = ?,
                       finalExaminationTheme = ?,
                       detailEnrollStatusId = ?,
                       examiningBoard = ?,
                       reasonCancellationId = ?
                 WHERE enrollId = ?';

        $params = array(
            $data->curriculumId,
            $data->groupId,
            $data->contractId,
            $data->dateEnroll,
            $data->note,
            $data->examNote,
            $data->finalNote,
            $data->concept,
            $data->textEvaluation,
            $data->frequency,
            $data->obsExploitation,
            $data->exploitationInstitutionId,
            $data->numberHourExploitation,
            $data->creditsExploitation,
            $data->isShowDocumentEndCourse,
            SAGU::NVL($data->forceStatusId, $data->statusId),
            $data->frequencyAlertEmail,
            $data->isInternet,
            $data->isConfirm,
            $data->isSetFree,
            $data->complement,
            $data->subclassId,
            $data->finalExaminationTheme,
            $data->detailEnrollStatusId,
            $data->examiningBoard,
            $data->reasonCancellationId,
            $data->enrollId
        );
        
        $result = $this->execute(SAGU::prepare($sql, $params));

        return $result;
    }

    /**
     * Insert a new record
     *
     * @param $data (object): An object of the type handled by the class
     * @return True if succed, otherwise False
     */
    public function insertEnroll($data)
    {        
        $sql = 'INSERT INTO acdEnroll
                            (contractId,
                             groupId,
                             curriculumId,
                             dateEnroll,
                             hourEnroll,
                             dateCancellation,
                             hourCancellation,
                             reasonCancellationId,
                             note,
                             examNote,
                             finalNote,
                             concept,
                             textEvaluation,
                             frequency,
                             obsExploitation,
                             exploitationInstitutionId,
                             numberHourExploitation,
                             creditsExploitation,
                             isShowDocumentEndCourse,
                             statusId,
                             frequencyAlertEmail,
                             isInternet,
                             ip,
                             isConfirm,
                             isSetFree,
                             complement,
                             subclassId,
                             finalExaminationTheme,
                             detailEnrollStatusId,
                             preEnrollConsumeVacant, 
                             originEnroll)
                     VALUES (?,?,?,
                             TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'), TO_TIMESTAMP(?, \'' . SAGU::getParameter('BASIC', 'MASK_TIME') . '\'),
                             TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'), TO_TIMESTAMP(?, \'' . SAGU::getParameter('BASIC', 'MASK_TIME') . '\'),
                             ?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?, ?, ?, ?, ?, ?)';

        $params = array(
                       $data->contractId,
                       $data->groupId,
                       $data->curriculumId,
                       $data->dateEnroll,
                       $data->hourEnroll,
                       $data->dateCancellation,
                       $data->hourCancellation,
                       $data->reasonCancellationId,
                       $data->note,
                       $data->examNote,
                       $data->finalNote,
                       $data->concept,
                       $data->textEvaluation,
                       $data->frequency,
                       $data->obsExploitation,
                       $data->exploitationInstitutionId,
                       $data->numberHourExploitation,
                       $data->creditsExploitation,
                       $data->isShowDocumentEndCourse,
                       $data->statusId,
                       $data->frequencyAlertEmail,
                       $data->isInternet,
                       $data->ip,
                       $data->isConfirm,
                       $data->isSetFree,
                       $data->complement,
                       $data->subclassId,
                       $data->finalExaminationTheme,
                       $data->detailEnrollStatusId,
                       $data->preEnrollConsumeVacant,
                       $data->originEnroll);

        $result = $this->execute(SAGU::prepare($sql, $params));
        
        return $result;
    }

    /**
     * Delete a record
     *
     * @param $enrollId (string): Primary key for deletion
     * @return (boolean): True if succeed, otherwise False
     */
    public function deleteEnroll($enrollId)
    {
        $busDegreeEnroll = new BusinessAcademicBusDegreeEnroll();
        $busFrequenceEnroll = new BusinessAcademicBusFrequenceEnroll();
        
        $ok = $busDegreeEnroll->deleteFromEnrollId($enrollId);
        if ( $ok )
        {
            $ok = $busFrequenceEnroll->deleteFrequenceEnroll($enrollId);
            if ( $ok )
            {
                $sql = 'DELETE FROM acdEnroll
                              WHERE enrollId = ?';

                $ok = $this->execute(SAGU::prepare($sql, $enrollId));
            }
        }

        return $ok;
    }

    /*****************************************************
     *
     * Functions that generate the data on enroll process
     *
     **************************************************/
    /**
     * Insere uma nova matrícula
     *
     * @param unknown_type $data
     */
    public function insertPersonEnrollNew($data, $isAddition = false, $isWebServices = false)
    {        
        $MIOLO = MIOLO::getInstance();
        $module = 'academic';

        // Keep statistical data
        $this->enrollData = new stdClass();

        $busLearningPeriod = new BusinessAcademicBusLearningPeriod();
        $learningPeriodData = $busLearningPeriod->getLearningPeriod($data->learningPeriodId, $isWebServices);
        
        $acdEnroll = "unit_acdEnroll";
        $acdlearningperiod = "unit_acdlearningperiod";
        $acdGroup = "unit_acdGroup";
        
        // Para webservices.
        if ( $isWebServices )
        {
            $acdEnroll = "acdEnroll";
            $acdlearningperiod = "acdlearningperiod";
            $acdGroup = "acdGroup";

        }

        // Obtém as disciplinas nas quais o aluno já está matriculado
        $sql = "SELECT A.enrollId,
                       A.groupId,
                       A.curriculumId
                  FROM {$acdEnroll} A
                 WHERE A.groupId IN ( SELECT A.groupId
                                      FROM {$acdGroup} A
                                INNER JOIN {$acdlearningperiod} B
                                        ON (B.learningPeriodId = A.learningPeriodId)
                                     WHERE B.periodId = ? )
                   AND A.contractId = ?
                   AND A.enrollId NOT IN (SELECT enrollId FROM acdcomplementaryactivities)
                   AND NOT EXISTS (SELECT 1
                                     FROM acdDegreeEnroll X
                                    WHERE X.enrollId = A.enrollId)";

        $params = array( $learningPeriodData->periodId,
                       $data->contractId );

        $pupilEnrolls = $this->getDatabase()->query(SAGU::prepare($sql, $params));
        
        if ( $isAddition )
        {
            // Somente permite a remoçao das matrículas de disciplinas que estiverem nos dados do parâmetro ($data).
            foreach ( $pupilEnrolls as $enroll )
            {    
                if ( !( ( strlen($data->groupId[$enroll[2]]) > 0 ) && ( $data->groupId[$enroll[2]] == $enroll[1] ) ) )
                {
                    $key = array_search($enroll, $pupilEnrolls);
                    unset($pupilEnrolls[$key]);
                }
            }
        }

        // Limpa os registros referentes a matricula ja existente
        if ( count($pupilEnrolls) > 0 )
        {
            $business2 = new BusinessAcademicBusFrequenceEnroll();
            $business3 = new BusinessAcademicBusEvaluationEnroll();

            foreach ( $pupilEnrolls as $pupilEnroll )
            {
                $enrollId = $pupilEnroll[0];
                $business3->deleteFromEnroll($enrollId);
                $business2->deleteFrequenceEnroll($enrollId);
                $this->deleteEnroll($enrollId);
            }
        }

        return $this->insertNewEnroll($data, true, false, $isWebServices);
    }

    /**
     * Atualiza uma matrícula existente.
     *
     * @param unknown_type $data
     */
    public function updatePersonEnrollNew($data, $isAdaptation=false, $isReprovacao=false, $isWebServices)
    {
        $MIOLO = MIOLO::getInstance();
        $module = 'academic';
        
        // Keep statistical data
        $this->enrollData = new stdClass();

        $busLearningPeriod = new BusinessAcademicBusLearningPeriod();
        $learningPeriodData = $busLearningPeriod->getLearningPeriod($data->learningPeriodId, $isWebServices);
        
        $acdEnroll = "unit_acdEnroll";
        $acdGroup = "unit_acdGroup";
        $acdlearningperiod = "unit_acdlearningperiod";
        
        // Para webservices.
        if ( $isWebServices )
        {
            $acdEnroll = "acdEnroll";
            $acdGroup = "acdGroup";
            $acdlearningperiod = "acdlearningperiod";
        }    
        
        // Obtém as discplinas nas quais o aluno já está matriculado ou pré-matriculado
        $sql = "SELECT enrollId,
                       groupId,
                       subclassId
                  FROM {$acdEnroll}
                 WHERE groupId IN ( SELECT groupId
                                      FROM {$acdGroup} A
                                INNER JOIN {$acdlearningperiod} B
                                        ON (B.learningPeriodId = A.learningPeriodId)
                                     WHERE B.periodId = ? )
                   AND ( statusId = '" . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED') . "' OR statusId = '" . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_PRE_ENROLLED') . "')  
                   AND contractId = ?
                   AND enrollId NOT IN (SELECT enrollId FROM acdcomplementaryactivities)";

        $params = array( $learningPeriodData->periodId,
                       $data->contractId );
        
        $pupilEnrolls = $this->getDatabase()->query(SAGU::prepare($sql, $params)); 
        
        if ( count($pupilEnrolls) > 0 )
        {
            foreach ( $pupilEnrolls as $pupilEnroll )
            {
                // Verifica se o aluno está se matriculando na turma selecionada
                $groupIndex = array_key_exists($pupilEnroll[1], $data->groupId);
                
                if ( !$groupIndex && !$isAdaptation && !$isReprovacao ) // Se não, cancela a matricula já existente caso n?o seja uma adaptaç?o.
                {
                    $data->cancelledGroupId[] = $pupilEnroll[1];

                    $dateCancellation = date(SAGU::getParameter('BASIC', 'MASK_DATE_PHP'));
                    $hourCancellation = date(SAGU::getParameter('BASIC', 'MASK_DATE_PHP'));

                    $busReasonCancellation = new BusinessAcademicBusReasonCancellation();
                    // FIXME: Sistema está utilizando o parâmetro INTERNET_ADJUSTMENT_REASON, mas não necessariamente
                    // a matrícula está sendo feita pela internet. Ver possibilidade de utilizar outro parâmetro.
                    $reasonCancellationId = SAGU::getParameter('ACADEMIC', 'INTERNET_ADJUSTMENT_REASON');
                    $reasonCancellation = $busReasonCancellation->getReasonCancellation($reasonCancellationId);
                    if ( strlen($reasonCancellation->reasonCancellationId) == 0 )
                    {
                        throw new Exception(_M('Valor do parâmetro INTERNET_ADJUSTMENT_REASON é @1, porém este código não corresponde a um dos motivos de cancelamento cadastrados.', $module, $reasonCancellationId));
                    }
                    $sql = 'UPDATE acdenroll SET statusId = ' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_CANCELLED') . ',
                                                 dateCancellation = TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                                                 hourCancellation = TO_TIMESTAMP(?, \'' . SAGU::getParameter('BASIC', 'MASK_TIME') . '\'),
                                                 reasonCancellationId = ' . $reasonCancellationId . '
                                           WHERE enrollId = ? ';

                    $params = array( $dateCancellation,
                                   $hourCancellation,
                                   $pupilEnroll[0] );
                    
                    $this->execute(SAGU::prepare($sql, $params));
                }
                else // Se sim, exclui a turma da lista, pois ela já existe e não precisa ser inserida novamente
                {
                    // Se a subturma foi alterada, atualiza a matrícula
                    if ( ( strlen($data->subclassId[$pupilEnroll[1]]) > 0 ) && ($data->subclassId[$pupilEnroll[1]] != $pupilEnroll[2]) )
                    {
                        $sql = 'UPDATE acdEnroll
                                   SET subclassId = ?
                                 WHERE enrollId = ?';

                        $params = array(
                                $data->subclassId[$pupilEnroll[1]],
                                $pupilEnroll[0]
                        );
                        
                        $this->execute(SAGU::prepare($sql, $params));
                    }
                    
                    $diffArray[$pupilEnroll[1]] = $pupilEnroll[1];
                    $data->groupId = array_diff_key($data->groupId, $diffArray);
                }
            }
        }
                
        return $this->insertNewEnroll($data, true, false, $isWebServices);
    }

    /**
     * Common function for both insert and update enroll methods.
     *
     * @param unknown_type $data
     */
    public function insertNewEnroll($data, $insertMovementContract = true, $migracao = false, $isWebServices = false, $registrarMovContratual = true)
    {  
        $MIOLO = MIOLO::getInstance();
        $module = 'academic';
        $action = MIOLO::getCurrentAction();
        
        $handArray = explode(':', $action);
        $handler   = $handArray[2];
        
        // Obtem confs. de matricula
        $matricula = new Matricula($data->contractId, $this->getTipoDeMatriculaAtual());
        $enrollConfig = $matricula->obterConfiguracoes();

        $busGroup = new BusinessAcademicBusGroup();
        $statusInicialMatricula = SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED');
        
        if ( $enrollConfig instanceof AcdEnrollConfig )
        {
            $enrollStatusId = $enrollConfig->obterCodInicialEstadoMatricula($data->contractId, $data->learningPeriodId);
            
            if ( strlen($enrollStatusId) > 0 )
            {
                $statusInicialMatricula = $enrollStatusId; 
            }
        }
                        
        // Monta os dados referentes a nova matricula
        if ( count($data->groupId) > 0 ) 
        {
            $deveConsumirVaga = $enrollConfig instanceof AcdEnrollConfig ? $enrollConfig->matriculaDeveConsumirVaga() : false;
            
            $enroll = new AcdEnroll();
            $enroll->contractId = $data->contractId;
            $enroll->statusId = SAGU::NVL($data->forceStatusId, $statusInicialMatricula);
            $enroll->ip = $_SERVER['REMOTE_ADDR'];
            //Quando a função insertnewenroll estiver sendo usada pela importação csv a data de matricula vem no objeto $data 
            $enroll->dateEnroll = SAGU::NVL( $data->dateEnroll, date(SAGU::getParameter('BASIC', 'MASK_DATE_PHP')));
            $enroll->hourEnroll = date(SAGU::getParameter('BASIC', 'MASK_TIME_PHP'));
            $enroll->frequency = $data->frequency;
            $enroll->detailEnrollStatusId = $data->detailEnrollStatusId;
            $enroll->preEnrollConsumeVacant = $deveConsumirVaga ? DB_TRUE : DB_FALSE;
            $enroll->originEnroll = $data->originEnroll;
            
            if ( $this->getTipoDeMatriculaAtual() == Matricula::MATRICULA_WEB )
            {
                $enroll->isInternet = DB_TRUE;
            }

            foreach ( $data->groupId as $groupId => $curriculumId )
            {
                $groupData = $busGroup->getGroup($groupId, $isWebServices);

                $enroll->groupId = $groupId;
                $enroll->curriculumId = ( $migracao ) ? $data->curriculumId : $curriculumId;                
                $enroll->curriculumId = strlen($enroll->curriculumId) > 0 ? $enroll->curriculumId : $curriculumId;

                if ( strlen($data->subclassId[$groupId]) > 0 )
                {
                    $enroll->subclassId = $data->subclassId[$groupId];
                }

                // Statistical data to be processed later
                $this->enrollData->enroll[] = $enroll;
                
                $filters = new stdClass();
                $filters->contractId = $enroll->contractId;
                $filters->groupId = $enroll->groupId;
                $filters->curriculumId = $enroll->curriculumId;

                $searchEnroll = $this->searchEnroll($filters, $isWebServices);
                
                // Insere apenas o enroll da disciplina selecionada caso esteje na tela de acrescimo de disciplinas.
                if ( ( !$searchEnroll ) && ( $handler == 'enrolladdition' ) )
                {
                    if ( $this->insertEnroll($enroll) )
                    {
                        $ok = $this->getLastInsertId();
                    }
                }
                else if ( $handler != 'enrolladdition' && ( !$searchEnroll ) ) //Caso não for a tela de acréscimo de disciplina e não está matriculado na disciplina matricula
                {
                    if ( $this->insertEnroll($enroll) )
                    {
                        $ok = $this->getLastInsertId();
                    }
                }
                else if( count($searchEnroll) > 0 ) //Caso já encontrou uma matrícula nesse período
                {
                    //Verifica se o estado atual da matricula encontrada é cancelado, caso contrario nao altera nada
                    //Então muda o status para matriculado e atualiza a matricula
                    if( $searchEnroll[0][20] == SAGU::getParameter($module, 'ENROLL_STATUS_CANCELLED') )
                    {   
                        $existEnroll = new stdClass();
                        $existEnroll = $this->getEnroll($searchEnroll[0][0], $isWebServices);
                        $existEnroll->statusId = SAGU::NVL($data->forceStatusId, $statusInicialMatricula);
                        
                        if( strlen($data->detailEnrollStatusId) > 0 )
                        {
                            $existEnroll->detailEnrollStatusId = $data->detailEnrollStatusId;
                        }
                        
                        $this->updateEnroll($existEnroll);
                        $ok = $existEnroll->enrollId;
                    }
                }
            }
        }

        //Caso precise mexer com a movimentação contratual
        if ( $registrarMovContratual )
        {
            // Verifica se ja possui a movimentação de matricula
            $sql = 'SELECT A.stateContractId,
                           A.contractId,
                           TO_CHAR(A.stateTime,\'' . SAGU::getParameter('BASIC', 'MASK_TIMESTAMP') . '\'),
                           A.disciplinas
                      FROM acdMovementContract A
                     WHERE A.contractId = ?
                       AND A.learningPeriodId = ?
                  ORDER BY A.stateTime DESC LIMIT 1';

            $params = array( $data->contractId,
                        $data->learningPeriodId );

            $actualState = $this->getDatabase()->query(SAGU::prepare($sql, $params));
            $actualStateContractId = $actualState[0][0];
            //Disciplinas matriculado na movientação contratual anterior
            $disciplinasAnterior = $actualState[0][3];
            //Disciplinas atual matriculado
            $disciplinasAtual = BusinessAcademicBusMovementContract::obtemDisciplinasMatriculado($data->contractId, $data->learningPeriodId);

            //Instancia de movimentação contratual
            $busMovementContract = new BusinessAcademicBusMovementContract();

            // Se necessário, insere a movimentação contratual
            if ( $insertMovementContract )
            {    
                if ( $enrollConfig instanceof AcdEnrollConfig && $actualStateContractId != SAGU::getParameter('BASIC', 'STATE_CONTRACT_ID_ENROLLED') )
                {
                    //Verifica se a movimentação vai ser de PRÉ-MATRÍCULA ou MATRÍCULA
                    $stateContractId = $enrollConfig->obterCodInicialEstadoMatricula($data->contractId, $data->learningPeriodId, true);
                }
                else
                {
                    $stateContractId = SAGU::getParameter('BASIC', 'STATE_CONTRACT_ID_ENROLLED');
                }

                /* Se movimentação contratual antiga for igual a matrícula ou ajuste então aluno está fazendo um ajuste
                 * e $stateContractId deve ser AJUSTE DE MATRICULA
                 */
                if ( ($actualStateContractId == SAGU::getParameter('BASIC', 'STATE_CONTRACT_ID_ENROLLED') && $disciplinasAtual != $disciplinasAnterior) ||
                     $actualStateContractId == SAGU::getParameter('ACADEMIC', 'STATE_CONTRACT_ID_ADJUSTMENT') )
                {
                    $stateContractId = SAGU::getParameter('ACADEMIC', 'STATE_CONTRACT_ID_ADJUSTMENT');
                }

                /* Insere nova movimentação contratual
                 * Se movimentação contratual atual for diferente da última cadastrada
                 * Se movimentação contratual atual for de ajuste de matrícula  e disciplinas marcadas forem diferente das disciplinas marcadas anteriormente 
                 * Se movimentação contratual atual for de pré matricula e disciplinas marcadas forem diferente das disciplinas marcadas anteriormente 
                 */
                if ( ($actualStateContractId != $stateContractId) || 
                     ($actualStateContractId == SAGU::getParameter('ACADEMIC', 'STATE_CONTRACT_ID_ADJUSTMENT') && $disciplinasAtual != $disciplinasAnterior) ||
                     ($actualStateContractId == SAGU::getParameter('ACADEMIC', 'STATE_CONTRACT_ID_PRE_ENROLL') && $disciplinasAtual != $disciplinasAnterior)   )
                {                  
                    $movementContract = new AcdMovementContract();
                    $movementContract->contractId = $data->contractId;
                    $movementContract->stateContractId = $stateContractId;
                    $movementContract->reasonId = $data->reasonId;
                    $movementContract->learningPeriodId = $data->learningPeriodId;
                    $movementContract->disciplinas = $disciplinasAtual;

                    if ( $handler != 'importacaoCSV' || $handler != 'matriculaRetroativa' )
                    {
                        $movementContract->disciplinas = null;
                    }

                    //Quando a função insertnewenroll estiver sendo usada pela importação csv a 
                    //data da movimentação de matricula vem no objeto $data e deve ser a mesma da matrícula
                    if ( strlen($data->dateEnroll)>0 && $handler != 'matriculaRetroativa' )
                    {
                        $dateMovementContract = new DateTime(SAGU::dateToDb($data->dateEnroll));
                        $dateMovementContractFormatted = $dateMovementContract->format(SAGU::getParameter('BASIC', 'MASK_TIMESTAMP_WITH_SECONDS_PHP'));
                        $movementContract->stateTime = SAGU::NVL($dateMovementContractFormatted, date(SAGU::getParameter('BASIC', 'MASK_TIMESTAMP_WITH_SECONDS_PHP')));
                    }
                    else
                    {
                        // Se o estado atual é igual ao estado a ser registrado a movimentação contratual, utiliza o statetime do 
                        // estado atual para não registrar duas movimentações identicas
                        if ( $actualStateContractId == $stateContractId )
                        {
                            $data->dateEnroll = $actualState[0][2];
                        }
                        
                        $movementContract->stateTime = SAGU::NVL($data->dateEnroll, date(SAGU::getParameter('BASIC', 'MASK_TIMESTAMP_WITH_SECONDS_PHP')));
                    }
                    
                    $busMovementContract->insertOrUpdateMovementContract($movementContract);
                }
                // Senão, apenas atualiza a data da movimentação de matricula existente
                else
                {
                    $busMovementContractComplement = new BusinessAcademicBusMovementContractComplement();

                    $filters = new stdClass();
                    $filters->contractId = $actualState[0][1];
                    $filters->stateContractId = $actualState[0][0];
                    $filters->stateTime = $actualState[0][2];

                    $movementContractComplement = $busMovementContractComplement->searchMovementContractComplement($filters);

                    // Verifica se existe um complemento da movimentação contratual.
                    if ( count($movementContractComplement) > 0 )
                    {
                        foreach ( $movementContractComplement as $dataComplement )
                        {
                            $filters->stateContractFieldId = $dataComplement[5];
                            $filters->value = 'AJUSTE DE MATRÍCULA';
                        }

                        // Atualiza o campo value do complemento.
                        $busMovementContractComplement->updateMovementContractComplement($filters);
                    }
                    else
                    {                    
                        $filters = new stdClass();
                        $filters->contractId = $actualState[0][1];
                        $filters->stateContractId = $actualState[0][0];
                        $filters->stateContractFieldId = SAGU::getParameter($module, 'MOVEMENT_CONTRACT_ADJUST');
                        $filters->stateTime = $actualState[0][2];
                        $filters->value = 'AJUSTE DE MATRÍCULA';

                        // Insere um novo complemento.
                        $busMovementContractComplement->insertMovementContractComplement($filters);
                    }
                }

                // Statistical data to be processed later
                $this->enrollData->movementContract[] = $movementContract;
            }
        }
                
        return strlen($ok) > 0 ? $ok : (count($this->getErrors()) > 0 );
    }

    /************************************************************
     *
     * Functions to get necessary information for enroll process
     *
     *********************************************************/

    /**
     * Função para obter a matriz curricular de um curso juntamente com seus complementos (ciclos, bifurcações, etc.)
     *
     * @author Leovan Tavares da Silva
     *
     * @param $courseId (string): código do curso
     * @param $courseVersion (int): versão do curso
     * @param $turnId (int): código do turno em que o curso ocorre
     * @param $unitId (int): código da unidade em que o curso ocorre
     * @param $learningPeriodId (int): código do período letivo, necessário para verificar datas de validade das disciplinas
     * @param $groupedPeriod (int): valor para identificar quando disciplinas devem ficar agrupadas em determinado período, independente do período cadastrado na matriz
     * @param $complementar (int): flag para identificar disciplinas que fazem parte de uma matriz complementar (ciclos, bifurcações, etc)
     * @return (array): Matriz contendo dados referentes as disciplinas da matriz curricular (código, período, tipo, categoria, etc.)
     */
    public function getCourseCompleteCurriculum($courseId, $courseVersion, $turnId, $unitId, $learningPeriodId, $groupedPeriod='', $complementar=DB_FALSE)
    {
        if ( strlen($groupedPeriod) == 0)
        {
            $groupedPeriod = 'NULL';
        }

        $sql = 'SELECT A.semester,
                       A.curricularComponentId,
                       A.curricularComponentVersion,
                       B.name AS curricularComponentName,
                       A.curriculumId,
                       A.curricularComponentGroupDocumentEndCourseId,
                       A.curricularComponentGroupElectiveId,
                       A.curricularComponentTypeId,
                       C.description as curricularComponentType,
                       A.curriculumTypeId,
                       D.description as curriculumType,
                       ' . $groupedPeriod . ',
                       \'' . $complementar . '\',
                       B.academicNumberHours
                  FROM unit_acdcurriculum A
            INNER JOIN acdCurricularComponent B
                    ON (B.curricularComponentId = A.curricularComponentId AND
                        B.curricularComponentVersion = A.curricularComponentVersion)
            INNER JOIN acdCurricularComponentType C
                    ON (C.curricularComponentTypeId = A.curricularComponentTypeId)
            INNER JOIN acdCurriculumType D
                    ON (D.curriculumTypeId = A.curriculumTypeId)
                 WHERE A.courseId = ?
                   AND A.courseVersion = ?
                   AND A.turnId = ?
                   AND A.unitId = ?
                   AND (B.endDate IS NULL OR B.endDate > (SELECT beginDate
                                                               FROM unit_acdlearningperiod
                                                              WHERE learningPeriodId = ?))
                   AND A.curriculumTypeId NOT IN (' . SAGU::getParameter('ACADEMIC', 'ACD_CURRICULUM_TYPE_COMPLEMENTARY_ACTIVITY') . ')
              ORDER BY A.semester, B.name';

        $params = array( $courseId,
                       $courseVersion,
                       $turnId,
                       $unitId,
                       $learningPeriodId );

        $return = $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        $sql = 'SELECT parentCourseId,
                       parentCourseVersion,
                       parentTurnId,
                       parentUnitId,
                       parentCurricularComponentsPeriod
                  FROM unit_acdCourseParent
                 WHERE courseId = ?
                   AND courseVersion = ?
                   AND turnId = ?
                   AND unitId = ?';

        $params = array( $courseId,
                       $courseVersion,
                       $turnId,
                       $unitId );

        $resParent = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        if ( count($resParent) > 0 )
        {
            list( $parentCourseId,
                  $parentCourseVersion,
                  $parentTurnId,
                  $parentUnitId,
                  $parentCurricularComponentsPeriod ) = $resParent[0];

            $currParent = $this->getCourseCompleteCurriculum($parentCourseId, $parentCourseVersion, $parentTurnId, $parentUnitId, $learningPeriodId, $parentCurricularComponentsPeriod, DB_TRUE);

            if ( count($currParent) > 0 )
            {
                $return = array_merge($result, $currParent);
            }
        }

        return $return;
    }
    
    /**
     * @return array
     */
    public function obterDisciplinasParaMatriculaEmLote($courseId, $courseVersion, $turnId, $unitId, $learningPeriodId, $classId = null, $semestre = null, $groupId = null, $isCancellation = DB_FALSE)
    {
        $sql = 'SELECT G.groupId || \'_\' || A.curriculumId,
                       G.groupId,
                       A.curricularComponentId,
                       A.curricularComponentVersion,
                       B.name AS curricularComponentName,
                       A.semester,
                       A.curriculumId,
                       B.academicCredits,
                       B.lessonNumberHours,                       
                       null,
                       null, 
                       I.classId,
                       null,
                       ((SELECT count(enrollId) FROM acdenroll WHERE groupId = G.groupId AND statusid NOT IN (getparameter(\'ACADEMIC\', \'ENROLL_STATUS_CANCELLED\')::int))::text || \'/\' || G.vacant) AS vagasUtilizadas
                  FROM unit_acdcurriculum A
            INNER JOIN acdCurricularComponent B
                    ON (B.curricularComponentId = A.curricularComponentId AND
                        B.curricularComponentVersion = A.curricularComponentVersion)
            INNER JOIN acdCurricularComponentType C
                    ON (C.curricularComponentTypeId = A.curricularComponentTypeId)
            INNER JOIN acdCurriculumType D
                    ON (D.curriculumTypeId = A.curriculumTypeId)
            INNER JOIN unit_acdGroup G
                    ON G.curriculumId = A.curriculumId
            LEFT JOIN unit_acdclass I
                    ON (I.classId = G.classId)
                 WHERE A.courseId = ?
                   AND A.courseVersion = ?
                   AND A.turnId = ?
                   AND A.unitId = ?
                   AND G.learningPeriodId = ?
                   AND (B.endDate IS NULL OR B.endDate > (SELECT beginDate
                                                               FROM unit_acdlearningperiod
                                                              WHERE learningPeriodId = ?))
                   AND A.curriculumTypeId NOT IN (GETPARAMETER(\'ACADEMIC\', \'ACD_CURRICULUM_TYPE_COMPLEMENTARY_ACTIVITY\')::int)
                   AND G.classId = COALESCE(?, G.classId)
                   AND A.semester = COALESCE(?, A.semester)
                   AND G.isCancellation = ?
                   AND (G.vacant - (SELECT count(enrollId) FROM acdenroll WHERE groupId = G.groupId AND statusid NOT IN (getparameter(\'ACADEMIC\', \'ENROLL_STATUS_CANCELLED\')::int))) > 0';
        
        $params = array(
                       $courseId,
                       $courseVersion,
                       $turnId,
                       $unitId,
                       $learningPeriodId,
                       $learningPeriodId,
                       $classId,
                       $semestre,
                       $isCancellation);
        
        if($groupId)
        {
            $sql .= 'AND G.groupId = ?';  
            $params[] = $groupId;
        }
        
        $sql .= 'ORDER BY A.semester, B.name';
        
        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));
        
        return $result;
    }
    
    /**
     * Obtém as oferecidas liberadas para uma disciplina
     *
     * @author Leovan Tavares da Silva
     *
     * @param $curriculumData (object): objeto que representa uma disciplina da matriz curricular
     * @param $learningPeriodId (int): código do período letivo
     * @param $classId (int): código da turma
     * @return (array): Matriz com as oferecidas da disciplina
     */
    public function getCurriculumFreeGroups($curriculumData, $learningPeriodId, $classId='')
    {
        $MIOLO = MIOLO::getInstance();
        $module = 'academic';

        $filters = new stdClass();
        $filters->isClosed = DB_FALSE;
        $filters->isCancellation = DB_FALSE;
        $filters->curricularComponentId = $curriculumData->curricularComponentId;
        $filters->curricularComponentVersion = $curriculumData->curricularComponentVersion;
        $filters->periodLearningPeriodId = $learningPeriodId;
        $filters->classId = $classId;
        $filters->orderByGroupId = DB_TRUE;

        $busGroup = new BusinessAcademicBusGroup();
        $groups = $busGroup->searchGroup($filters, true);

        if ( count($groups) > 0 )
        {
            $return = array();
            
            foreach ( $groups as $group )
            {
                $return[$group->groupId] = $group;
            }

            return $return;
        }
        else
        {
            return null;
        }
    }

    /**
     * Filtra as oferecidas de uma disciplina de acordo com as configurações de matrícula
     *
     * @author Leovan Tavares da Silva
     *
     * @param $curriculumData (object): objeto que representa uma disciplina da matriz curricular
     * @param $contractId (int): código de contrato
     * @param $learningPeriodId (int): código do período letivo
     * @param $classId (string): código da turma
     * @param $isElective (boolean): TRUE se é uma disciplina eletiva, senão FALSE
     * @return (array): matriz com os dados das oferecidas que respeitam as configurações de matrícula
     */
    public function getCurriculumGroups($curriculumData, $contractId, $learningPeriodId, $classId, $isElective=false)
    {
        $MIOLO = MIOLO::getInstance();
        $module = 'academic';

        $busContract = new BusinessAcademicBusContract();
        $contractData = $busContract->getContract($contractId);

        $busClassPupil = new BusinessAcademicBusClassPupil();
        $contractClassId = $busClassPupil->getContractCurrentClass($contractId);

        $matricula = new Matricula($contractId, Matricula::MATRICULA_NORMAL);
        $enrollConfig = $matricula->obterConfiguracoes();

        $busSchedule = new BusinessAcademicBusSchedule();
        $busClass = new BusinessAcademicBusClass();        
        $busGroup = new BusinessAcademicBusGroup();

        if ( $isElective )
        {
            $groups = $this->getElectiveFreeGroups($curriculumData, $contractId, $learningPeriodId);
        }
        else
        {
            $groups = $this->getCurriculumFreeGroups($curriculumData, $learningPeriodId);
        }
        
        //Obtem disciplinas vinculadas para matricula
        $disciplinasVinculadas = $this->obterDisciplinasDeVinculos($curriculumData, $learningPeriodId);
        
        if ( count($disciplinasVinculadas) > 0 )
        {
            foreach ( $disciplinasVinculadas as $vinculo )
            {
                $vinculos[] = $vinculo[0];
            }

            if ( count($vinculos) > 0 )
            {
                $filters = new stdClass();
                $filters->groupId = $vinculos;
                $vinculadas = $busGroup->searchGroup($filters, true);
            }

            foreach ( $vinculadas as $v )
            {
                $groups[$v->groupId] = $v;
            }
        }

        $isEnrolled = false;
        $return = array();
        $isUnblock = $this->isSubstitutionUnblock($curriculumData->curriculumId, $contractId, $learningPeriodId);
	
        if ( count($groups) > 0 )
        {
            foreach ( $groups as $groupData )
            {
                if ( ! $isElective )
                {
                    if ( ! $this->isGroupEnrolled($contractId, $groupData->groupId) )
                    {
                        if ( !$isUnblock )
                        {
                            if ( $enrollConfig->showOtherClassesGroups == DB_FALSE )
                            {
                                if ( $groupData->classId != $classId )
                                {
                                    continue;
                                }
                            }

                            if ( ($enrollConfig->showOtherCoursesGroups == DB_FALSE) && ($curriculumData->complementar == DB_FALSE) )
                            {
                                if ( ($curriculumData->curriculumId != $groupData->curriculumId) || ($learningPeriodId != $groupData->learningPeriodId) )
                                {
                                    continue;
                                }
                            }
                        }

                        if ( $enrollConfig->showOtherUnitsGroups == DB_FALSE )
                        {
                            $groupUnits = $busSchedule->getGroupUnits($groupData->groupId);

                            if ( count($groupUnits) > 0 )
                            {
                                if ( ! in_array($contractData->unitId, $groupUnits) )
                                {
                                    continue;
                                }
                            }
                        }

                        if ( $enrollConfig->showOtherTurnsGroups == DB_FALSE )
                        {
                            $groupTurns = $busSchedule->getGroupTurns($groupData->groupId);

                            if ( count($groupTurns) > 0 )
                            {
                                if ( ! in_array($contractData->turnId, $groupTurns) )
                                {
                                    continue;
                                }
                            }
                        }

                        if ( $enrollConfig->showSpecialRegimenGroups == DB_FALSE )
                        {
                            if ( in_array($groupData->regimenId, explode(',', SAGU::getParameter('BASIC', 'SPECIAL_REGIMEN'))) )
                            {
                                continue;
                            }
                        }
                    }
                    else
                    {
                        $isEnrolled = true;
                    }
                }
                
                $return[$groupData->groupId] = $groupData;
            }
        }

        if ( ($enrollConfig->freeOtherPeriodGroups == DB_FALSE) &&
             ($curriculumData->period > $busClass->getSemesterContract($contractId)) &&
             !$isEnrolled &&
             !$isUnblock
           )
        {
            return null;
        }
        
        return $return;
    }





    public function getSubstitutionGroups($curricularComponentId, $learningPeriodId)
    {
        $MIOLO = MIOLO::getInstance();
        $module = 'academic';
        
        $busGroup = new BusinessAcademicBusGroup();
        $busLearningPeriod = new BusinessAcademicBusLearningPeriod();
        
        $learningPeriod = $busLearningPeriod->getLearningPeriod($learningPeriodId);
        
        $filters->curricularComponentId = $curricularComponentId;
        $filters->periodId = $learningPeriod->periodId;
        
        $groups = $busGroup->searchGroup($filters, true);
        
        if ( count($groups) > 0 )
        {
            $data = array();
            foreach ( $groups as $group )
            {
                $data[$group->groupId] = $busGroup->getGroup($group->groupId);
            }

            return $data;
        }
        else
        {
            return null;
        }
    }





    /**
     * Filtra as oferecidas para disciplinas eletivas
     *
     * @author Leovan Tavares da Silva
     *
     * @param $curriculumData (object): objeto que representa uma disciplina da matriz curricular
     * @param $learningPeriodId (int): código do período letivo
     * @param $contractId (int): código do contrato
     * @return (array): matriz com os dados das oferecidas da eletiva
     */
    public function getElectiveFreeGroups($curriculumData, $contractId, $learningPeriodId)
    {
        $sql = 'SELECT CU.curriculumId,
                       CU.curricularComponentId,
                       CU.curricularComponentVersion
                  FROM unit_acdcurriculum CU';
        
        if ( strlen($contractId) > 0 )
        {
            $sql .= ' INNER JOIN unit_acdContract CO
                              ON (CU.courseId = CO.courseId)
                             AND (CU.courseVersion = CO.courseVersion)
                             AND (CU.turnId = CO.turnId)
                             AND (CU.unitId = CO.unitId)
                             AND (CO.contractId = ?) ';
            
            $params[] = $contractId;
        }
           
        $sql .= ' WHERE curricularComponentGroupDocumentEndCourseId = ? ';

        $params[] = $curriculumData->curricularComponentGroupElectiveId;

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        if ( count($result) > 0 )
        {
            $return = array();

            foreach ( $result as $res )
            {
                $data = new stdClass();
                $data->curriculumId = $res[0];
                $data->curricularComponentId = $res[1];
                $data->curricularComponentVersion = $res[2];

                if ( $this->isCoursed($data, $contractId) || $this->isCoursing($data, $contractId, $learningPeriodId) )
                {
                    continue;
                }

                $groups = $this->getCurriculumFreeGroups($data, $learningPeriodId);

                if ( is_array($groups) )
                {
                    $return = array_merge($return, $groups);
                }
            }

            return $return;
        }
        else
        {
            return null;
        }
    }

    /**
     * Obtém dados de substituição de disciplinas
     *
     * @author Leovan Tavares da Silva
     *
     * @param $curriculumData (object): objeto que representa uma disciplina da matriz curricular
     * @param $contractId (int): código do contrato
     * @param $learningPeriodId (int): código do período letivo
     */
    public function getSubstitutionData($curriculumData, $contractId, $learningPeriodId)
    {
        
        if($curriculumData->curriculumId)
        {
            $curriculumId = $curriculumData->curriculumId;
        }
        else
        {
            $curriculumId = $curriculumData[4];
        }
        
        $sql = 'SELECT A.curricularComponentId,
                       A.curricularComponentVersion,
                       B.name as curricularComponentName,
                       A.curriculumId
                  FROM acdCurricularComponentUnblock A
            INNER JOIN acdCurricularComponent B
                    ON (B.curricularComponentId = A.curricularComponentId AND
                        B.curricularComponentVersion = A.curricularComponentVersion)
                 WHERE A.curriculumId = ?
                   AND A.contractId = ?
                   AND A.learningPeriodId = ?
                   AND A.isSubstituted = \'' . DB_TRUE . '\'';

        $params = array( $curriculumId,
                       $contractId,
                       $learningPeriodId );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        $data = new stdClass();
        $data->curricularComponentId = $result[0][0];
        $data->curricularComponentVersion = $result[0][1];
        $data->curricularComponentName = $result[0][2];
        $data->curriculumId = $result[0][3];

        return $data;
    }
    
    /**
     * Retorna se existe desbloqueio por substituicao por curso para os valores passados.
     *
     * @param int $curriculumId
     * @param int $contractId
     * @param int $learningPeriodId
     * 
     * @return boolean
     */
    public function isSubstitutionUnblock($curriculumId, $contractId, $learningPeriodId)
    {
        $sql = 'SELECT TRUE
                  FROM acdCurricularComponentUnblock A
            INNER JOIN acdCurricularComponent B
                    ON (B.curricularComponentId = A.curricularComponentId AND
                        B.curricularComponentVersion = A.curricularComponentVersion)
                 WHERE A.curriculumId = ?
                   AND A.contractId = ?
                   AND A.learningPeriodId = ?
                   AND A.isSubstituted = \'' . DB_TRUE . '\'';

        $params = array( $curriculumId,
                         $contractId,
                         $learningPeriodId );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));
        
        return $result[0][0] == DB_TRUE;
    }

    /**
     * Obtém o código de matrícula (enrollId) de uma disciplina que já foi cursada
     *
     * @author Leovan Tavares da Silva
     *
     * @param $curriculumId (int): código da disciplina na matriz curricular
     * @param $contractId (int): código do contrato
     * @return (int): código da matrícula
     */
    public function getCoursedEnrollId($curriculumId, $contractId)
    {
        $MIOLO = MIOLO::getInstance();
        $module = 'academic';

        $busCurriculum = new BusinessAcademicBusCurriculum();
        $curriculumData = $busCurriculum->getCurriculum($curriculumId);

        $sql = 'SELECT enrollId
                  FROM unit_acdEnroll
                 WHERE (curriculumId = ? OR curriculumId IN (SELECT curriculumId FROM unit_acdcurriculum WHERE curricularComponentId = ? AND curricularComponentVersion = ?))
                   AND contractId IN (' . implode(',', $this->getRelatedContracts($contractId)) . ')
                   AND statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_APPR_OR_EXC') . ')';

        $params = array( $curriculumId,
                       $curriculumData->curricularComponentId,
                       $curriculumData->curricularComponentVersion );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        return $result[0][0];
    }

    /** Obtém o código de matrícula (enrollId) de uma disciplina que já foi cursada
     *
     * @author Leovan Tavares da Silva
     *
     * @param $curriculumId (int): código da disciplina na matriz curricular
     * @param $contractId (int): código do contrato
     * @return (int): código da matrícula
     */
    public function getCoursingEnrollId($curriculumId, $contractId, $learningPeriodId)
    {
        $MIOLO = MIOLO::getInstance();
        $module = 'academic';

        $busCurriculum = new BusinessAcademicBusCurriculum();
        $curriculumData = $busCurriculum->getCurriculum($curriculumId);

        $sql = 'SELECT A.enrollId
                  FROM unit_acdEnroll A
            INNER JOIN unit_acdGroup B
                    ON (B.groupId = A.groupId)
            INNER JOIN unit_acdlearningperiod C
                    ON (C.learningPeriodId = B.learningPeriodId)
                 WHERE (A.curriculumId = ? OR A.curriculumId IN (SELECT curriculumId FROM unit_acdcurriculum WHERE curricularComponentId = ? AND curricularComponentVersion = ?))
                   AND A.contractId IN (' . implode(',', $this->getRelatedContracts($contractId)) . ')
                   AND A.statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED') . ')
                   AND C.periodId NOT IN (SELECT periodId FROM unit_acdlearningperiod WHERE learningPeriodId = ?)';

        $params = array( $curriculumId,
                       $curriculumData->curricularComponentId,
                       $curriculumData->curricularComponentVersion,
                       $learningPeriodId );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        return $result[0][0];
    }

    /**
     * @deprecated: Utilizar a AcdEnroll
     * Obtém o código de matrícula de uma disciplina em que o contrato está matriculado no período letivo
     * informado
     *
     * @author Leovan Tavares da Silva
     *
     * @param $curriculumId (int): código da disciplina na matriz curricular
     * @param $contractId (int): código do contrato
     * @param $learningPeriodId (int): código do período letivo
     */
    public function getEnrolledEnrollId($curriculumId, $contractId, $learningPeriodId)
    {
        $acdEnroll = new AcdEnroll();
        return $acdEnroll->getEnrolledenrollId($curriculumId, $contractId, $learningPeriodId);
    }

    /**
     * Obtém as disciplinas opcionais nas quais um contrato está matriculado no período
     *
     * @author Leovan Tavares da Silva
     *
     * @param $contractId (int): código do contrato
     * @param $learningPeriodId (int): código do período letivo
     * @return (array) Códigos das oferecidas para disciplinas opcionais em que o contrato está matriculado no período
     */
    public function getOptionalGroupsEnrolled($contractId, $learningPeriodId)
    {
        $sql = 'SELECT A.groupId,
                       A.curriculumId
                  FROM unit_acdEnroll A
            INNER JOIN unit_acdcurriculum B
                    ON (B.curriculumId = A.curriculumId)
            INNER JOIN unit_acdGroup C
                    ON (C.groupId = A.groupId)
            INNER JOIN unit_acdlearningperiod D
                    ON (D.learningPeriodId = C.learningPeriodId)
                 WHERE A.contractId IN (' . implode(',', $this->getRelatedContracts($contractId)) . ')
                   AND D.periodId = (SELECT periodId FROM unit_acdlearningperiod WHERE learningPeriodId = ?)
                   AND B.curriculumTypeId IN (' . SAGU::getParameter('ACADEMIC', 'ACD_CURRICULUM_TYPE_OPTATIVE_INTRA') . ', ' . SAGU::getParameter('ACADEMIC', 'ACD_CURRICULUM_TYPE_OPTATIVE_INTER') . ', ' . SAGU::getParameter('ACADEMIC', 'ACD_CURRICULUM_TYPE_EQUALIZATION') . ')
                   AND A.statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED') . ')';

        $params = array( $learningPeriodId );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        if ( count($result) > 0 )
        {
            $return = array();
            foreach ( $result as $res )
            {
                $return[$res[0]] = $res[1];
            }

            return $return;
        }
        else
        {
            return null;
        }
    }

    /**
     * Obtém as disciplinas em que o contrato está reprovado e deve cursar novamente
     *
     * @author Leovan Tavares da Silva
     *
     * @param $contractId (int): código do contrato
     * @param $learningPeriodId (int): código do período letivo
     * @return (array) Códigos das disciplinas (curriculumId) em que o contrato está reprovado
     */
    public function getContractDisapprovements($contractId, $learningPeriodId)
    {
        $sql = 'SELECT curriculumId
                  FROM unit_acdcurriculum
                 WHERE ((curriculumTypeId IN (' . SAGU::getParameter('ACADEMIC', 'CURRICULUM_TYPE_NON_OPTIONAL') . ') AND
                        (semester <> 0)) OR
                        (curricularComponentTypeId IN (' . SAGU::getParameter('ACADEMIC', 'CURRICULAR_COMPONENT_TYPE_SEMINARY') . ')))
                   AND (endDate IS NULL OR endDate > (SELECT beginDate
                                                           FROM unit_acdlearningperiod
                                                          WHERE learningPeriodId = ?))
                   AND curriculumId IN (SELECT curriculumId
                                             FROM unit_acdEnroll
                                            WHERE contractId IN (' . implode(',', $this->getRelatedContracts($contractId)) . ')
                                              AND statusId IN ('. SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_DISAPPROVED') . ',' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_DISAPPROVED_FOR_LACKS') . ',' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_DISAPPROVED_BY_PERIOD') . '))
                   AND curriculumId NOT IN (SELECT curriculumId
                                                 FROM unit_acdEnroll
                                                WHERE contractId IN (' . implode(',', $this->getRelatedContracts($contractId)) . ')
                                                  AND statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_APPR_OR_EXC') . '))';

        $params = array( $learningPeriodId );
        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        if ( count($result) > 0 )
        {
            $return = array();
            foreach ( $result as $res )
            {
                $return[] = $res[0];
            }

            return $return;
        }
        else
        {
            return null;
        }
    }

    /**
     * Obtém as disciplinas em que o contrato está reprovado e deve cursar novamente num determinado periodo letivo
     *
     * @author Jonas Guablerto Diel
     *
     * @param $contractId (int): código do contrato
     * @param $learningPeriodId (int): código do período letivo
     * @return (array) Códigos das disciplinas (curriculumId) em que o contrato está reprovado
     */
    public function getContractDisapprovementsInPeriod($contractId, $learningPeriodId, $previousLearningPeriodId)
    {
        $sql = 'SELECT A.curriculumId
                  FROM unit_acdcurriculum A
                  INNER JOIN unit_acdGroup B
                     ON A.curriculumId=B.curriculumId
                 WHERE ((A.curriculumTypeId IN (' . SAGU::getParameter('ACADEMIC', 'CURRICULUM_TYPE_NON_OPTIONAL') . ') AND
                        (A.semester <> 0)) OR
                        (A.curricularComponentTypeId IN (' . SAGU::getParameter('ACADEMIC', 'CURRICULAR_COMPONENT_TYPE_SEMINARY') . ')))
                   AND (A.endDate IS NULL OR A.endDate > (SELECT beginDate
                                                           FROM unit_acdlearningperiod
                                                          WHERE learningPeriodId = ?))
                   AND A.curriculumId IN (SELECT curriculumId
                                             FROM unit_acdEnroll
                                            WHERE contractId IN (' . implode(',', $this->getRelatedContracts($contractId)) . ')
                                              AND statusId IN ('. SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_DISAPPROVED') . ',' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_DISAPPROVED_FOR_LACKS') . ',' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_DISAPPROVED_BY_PERIOD') . '))
                   AND A.curriculumId NOT IN (SELECT curriculumId
                                                 FROM unit_acdEnroll
                                                WHERE contractId IN (' . implode(',', $this->getRelatedContracts($contractId)) . ')
                                                  AND statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_APPR_OR_EXC') . '))
                                                  AND B.learningPeriodId = ? ';

        $params = array( $learningPeriodId, $previousLearningPeriodId );
        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        if ( count($result) > 0 )
        {
            $return = array();
            foreach ( $result as $res )
            {
                $return[] = $res[0];
            }

            return $return;
        }
        else
        {
            return null;
        }
    }

    /**
     * @deprecated: Utilizar o AcdContract
     * Obtém a lista de contratos relacionados entre si (caso de transferências)
     *
     * @author Leovan Tavares da Silva
     *
     * @param $contractId (int): código do contrato
     * @return (array) Vetor com os códigos dos contratos relacionados entre si
     */
    public function getRelatedContracts($contractId)
    {
        $MIOLO = MIOLO::getInstance();
        $module = 'academic';

        $busContract = new BusinessAcademicBusContract();
        $contractData = $busContract->getContract($contractId);

        $result = array();

        $result[] = $contractId;

        // Se o contrato deve considerar disciplinas de cursos transferidos, obtém o contrato do qual se transferiu
        if ( $contractData->exploitEnrollsInTransfer == DB_TRUE )
        {
            $sql = 'SELECT B.value
                      FROM acdMovementContract A
                INNER JOIN acdMovementContractComplement B
                        ON (B.stateContractId = A.stateContractId AND
                            B.contractId = A.contractId AND
                            B.stateTime = A.stateTime)
                     WHERE A.contractId = ?
                       AND A.stateContractId IN (' . SAGU::getParameter('ACADEMIC', 'STATE_CONTRACT_ID_INTERNAL_TRANSFER_FROM') . ')
                       AND B.stateContractFieldId IN (' . SAGU::getParameter('ACADEMIC', 'STATE_CONTRACT_INTERNAL_TRANSFER_FROM_FIELD') . ')
                  ORDER BY A.stateTime DESC LIMIT 1';

            $res = $this->getDatabase()->query(SAGU::prepare($sql, $contractId));

            if ( strlen($res[0][0]) > 0 )
            {
                $result = array_merge($result, $this->getRelatedContracts($res[0][0]));
            }
        }

        return $result;
    }

    /*
     * Check functions!!!!!
     */
    /**
     * Verifica se uma disciplina já foi cursada por determinado contrato
     *
     * @author Leovan Tavares da Silva
     *
     * @param $curriculumData (object): objeto que representa uma disciplina da matriz curricular
     * @param $contractId (int): código do contrato
     * @return (boolean) TRUE se a disciplina já foi cursada e FALSE caso contrário
     */
    public function isCoursed($curriculumData, $contractId)
    {
        $MIOLO = MIOLO::getInstance();
        $action = $MIOLO->getCurrentAction();
        
        /**
         * Para melhorar o desempenho em telas (principalmente nas telas de matrícula)
         * estamos adicionando retornos que sejam repetidos em um array na sessao,
         * caso precise usar esse método em outra tela, adicionar a acao que leva a ela
         * no if abaixo, nao esquecer tambem de setar NULL ao array sempre que qualquer
         * processo/registro for terminado.
         */
        if ( $action == 'main:process:enrollCurricularComponents' )
        {
            //Busca array
            $arrayIsCoursed = $MIOLO->session->getValue('arrayIsCoursed');
            
            //Cria key
            $string = 'curriculumId=' . $curriculumData->curriculumId;
            $string .= 'curricularComponentId=' . $curriculumData->curricularComponentId;
            $string .= 'curricularComponentVersion=' . $curriculumData->curricularComponentVersion;
            $string .= 'contractId=' . $contractId;
            
            //Se key nao existe ainda, deixa passar, senao retorna
            if ( array_key_exists($string, $arrayIsCoursed) )
            {
                return $arrayIsCoursed[$string];
            }
            
            //Cria variavel para armazenar retorno na sessao depois
            $naSessao = true;
        }

        $sql = 'SELECT A.enrollId
                  FROM unit_acdEnroll A
             LEFT JOIN unit_acdGroup B
                    ON (B.groupId = A.groupId)
             LEFT JOIN unit_acdcurriculum C
                    ON (C.curriculumId = B.curriculumId)
                 WHERE CASE WHEN A.isExploitation = true
                       THEN A.curriculumId = ?
                        ELSE (A.curriculumId = ? OR (C.curricularComponentId = ? AND C.curricularComponentVersion = ?))
                        END
                   AND A.contractId IN (' . implode(',', $this->getRelatedContracts($contractId)) . ')
                   AND A.statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_APPR_OR_EXC') .')';

        $params = array( $curriculumData->curriculumId,
                       $curriculumData->curriculumId,
                       $curriculumData->curricularComponentId,
                       $curriculumData->curricularComponentVersion );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        if ( count($result) > 0 )
        {
            //Salva na sessao
            if ( $naSessao )
            {
                $arrayIsCoursed[$string] = true;
                $MIOLO->session->setValue('arrayIsCoursed', $arrayIsCoursed);
            }
            
            return true;
        }

        $sql = 'SELECT curriculumId
                  FROM acdComplementaryEnroll
                 WHERE curriculumId = ?
                   AND contractId IN (' . implode(',', $this->getRelatedContracts($contractId)) . ')
                   AND enrollStatusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_APPR_OR_EXC') . ')';

        $params = array( $curriculumData->curriculumId );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        if ( count($result) > 0 )
        {
            //Salva na sessao
            if ( $naSessao )
            {
                $arrayIsCoursed[$string] = true;
                $MIOLO->session->setValue('arrayIsCoursed', $arrayIsCoursed);
            }
            
            return true;
        }
        
        //Salva na sessao
        if ( $naSessao )
        {
            $arrayIsCoursed[$string] = false;
            $MIOLO->session->setValue('arrayIsCoursed', $arrayIsCoursed);
        }

        return false;
    }


    /**
     * Verifica se uma disciplina está em curso por determinado contrato
     *
     * @author Leovan Tavares da Silva
     *
     * @param $curriculumData (object): objeto que representa uma disciplina da matriz curricular
     * @param $contractId (int): código do contrato
     * @param $learningPeriodId (int): código do período letivo
     * @return (boolean) TRUE se o contrato está cursando a disciplina e FALSE caso contrário
     */
    public function isCoursing($curriculumData, $contractId, $learningPeriodId)
    {
        $sql = 'SELECT A.enrollId
                  FROM unit_acdEnroll A
            INNER JOIN unit_acdGroup B
                    ON (B.groupId = A.groupId)
            INNER JOIN unit_acdlearningperiod C
                    ON (C.learningPeriodId = B.learningPeriodId)
            INNER JOIN unit_acdcurriculum D
                    ON (D.curriculumId = B.curriculumId)
                 WHERE (A.curriculumId = ? OR (D.curricularComponentId = ? AND D.curricularComponentVersion = ?))
                   AND A.contractId IN (' . implode(',', $this->getRelatedContracts($contractId)) . ')
                   AND A.statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED') . ')
                   AND C.periodId <> (SELECT periodId FROM unit_acdlearningperiod WHERE learningPeriodId = ?)';

        $params = array( $curriculumData->curriculumId,
                       $curriculumData->curricularComponentId,
                       $curriculumData->curricularComponentVersion,
                       $learningPeriodId );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        if ( count($result) > 0 )
        {
            return true;
        }

        return false;
    }

    /**
     * Verifica se um contrato está matriculado em determinada disciplina
     *
     * @author Leovan Tavares da Silva
     *
     * @param $curriculumData (object): objeto que representa uma disciplina da matriz curricular
     * @param $contractId (int): código do contrato
     * @param $learningPeriodId (int): código do período letivo
     * @return (boolean) TRUE se o contrato está matriculado na disciplina e FALSE caso contrário
     */
    public function isEnrolled($curriculumData, $contractId, $learningPeriodId)
    {
        $sql = 'SELECT A.enrollId
                  FROM unit_acdEnroll A
            INNER JOIN unit_acdGroup B
                    ON (B.groupId = A.groupId)
            INNER JOIN unit_acdlearningperiod C
                    ON (C.learningPeriodId = B.learningPeriodId)
            INNER JOIN unit_acdcurriculum D
                    ON (D.curriculumId = B.curriculumId)
                 WHERE (A.curriculumId = ? OR (D.curricularComponentId = ? AND D.curricularComponentVersion = ?))
                   AND A.contractId IN (' . implode(',', $this->getRelatedContracts($contractId)) . ')
                   AND C.periodId = (SELECT periodId FROM unit_acdlearningperiod WHERE learningPeriodId = ?)
                   AND A.statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED') . ')';

        $params = array( $curriculumData->curriculumId,
                       $curriculumData->curricularComponentId,
                       $curriculumData->curricularComponentVersion,
                       $learningPeriodId );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        if ( count($result) > 0 )
        {
            return true;
        }

        return false;
    }


    /**
     * Verifica se um contrato está pré matriculado em determinada disciplina
     *
     * @author Fabiano Tomasini
     *
     * @param $curriculumData (object): objeto que representa uma disciplina da matriz curricular
     * @param $contractId (int): código do contrato
     * @param $learningPeriodId (int): código do período letivo
     * @return (boolean) TRUE se o contrato está matriculado na disciplina e FALSE caso contrário
     */
    public function isPreEnrolled($curriculumData, $contractId, $learningPeriodId)
    {
        $sql = 'SELECT A.enrollId
                  FROM unit_acdEnroll A
            INNER JOIN unit_acdGroup B
                    ON (B.groupId = A.groupId)
            INNER JOIN unit_acdlearningperiod C
                    ON (C.learningPeriodId = B.learningPeriodId)
            INNER JOIN unit_acdcurriculum D
                    ON (D.curriculumId = B.curriculumId)
                 WHERE (A.curriculumId = ? OR (D.curricularComponentId = ? AND D.curricularComponentVersion = ?))
                   AND A.contractId IN (' . implode(',', $this->getRelatedContracts($contractId)) . ')
                   AND C.periodId = (SELECT periodId FROM unit_acdlearningperiod WHERE learningPeriodId = ?)
                   AND A.statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_PRE_ENROLLED') . ')';

        $params = array( $curriculumData->curriculumId,
                       $curriculumData->curricularComponentId,
                       $curriculumData->curricularComponentVersion,
                       $learningPeriodId );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        if ( count($result) > 0 )
        {
            return true;
        }

        return false;
    }

    /**
     * Verifica se um contrato está reprovado em determinada disciplina
     *
     * @author Leovan Tavares da Silva
     *
     * @param $curriculumData (object): objeto que representa uma disciplina da matriz curricular
     * @param $contractId (int): código do contrato
     * @param $learningPeriodId (int): código do período letivo
     * @return (boolean) TRUE se o contrato está reprovado na disciplina e FALSE caso contrário
     */
    public function isDisapproved($curriculumData, $contractId, $learningPeriodId)
    {
        $sql = 'SELECT A.enrollId
                  FROM unit_acdEnroll A
            INNER JOIN unit_acdcurriculum B
                    ON (B.curriculumId = A.curriculumId)
                 WHERE (A.curriculumId = ? OR (B.curricularComponentId = ? AND B.curricularComponentVersion = ?))
                   AND A.contractId IN(' . implode(',', $this->getRelatedContracts($contractId)) . ')
                   AND A.statusId IN ('. SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_DISAPPROVED') . ',' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_DISAPPROVED_FOR_LACKS') . ',' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_DISAPPROVED_BY_PERIOD') . ')
                   AND A.curriculumId NOT IN (SELECT curriculumId
                                                   FROM unit_acdEnroll
                                                  WHERE contractId = A.contractId
                                                    AND statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_APPR_OR_EXC') . '))
                   AND (B.endDate IS NULL OR B.endDate > (SELECT beginDate
                                                               FROM unit_acdlearningperiod
                                                              WHERE learningPeriodId = ?))
                   AND B.curriculumTypeId IN (' . SAGU::getParameter('ACADEMIC', 'CURRICULUM_TYPE_NON_OPTIONAL') . ')
                   AND B.semester <> 0 ';

        $params = array( $curriculumData->curriculumId,
                       $curriculumData->curricularComponentId,
                       $curriculumData->curricularComponentVersion,
                       $learningPeriodId );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        if ( count($result) > 0 )
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    /**
     * Verifica se determinado contrato está matriculado em uma oferecida
     *
     * @author Leovan Tavares da Silva
     *
     * @param $contractId (int): código do contrato
     * @param $groupId (int): código da oferecida
     * @return (boolean) TRUE se o contrato está matriculado na oferecida e FALSE caso contrário
     */
    public function isGroupEnrolled($contractId, $groupId)
    {
        $sql = 'SELECT enrollId
                  FROM unit_acdEnroll
                 WHERE contractId IN (' . implode(',', $this->getRelatedContracts($contractId)) . ')
                   AND groupId = ?
                   AND statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED').','.SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_PRE_ENROLLED') . ')';

        $params = array( $groupId );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        if ( count($result) > 0 )
        {
            return true;
        }

        return false;
    }

    /**
     * Verifica se uma disciplina possui seus pré-requisitos cumpridos
     *
     * @author Leovan Tavares da Silva
     *
     * @param $curriculumData (object): objeto que representa uma disciplina da matriz curricular
     * @param $contractId (int): código do contrato
     * @param $learningPeriodId (int): código do período letivo
     * @param $considerCoursing (boolean): TRUE para que o método leve em consideração disciplinas em curso, FALSE para apenas considerar disciplinas já cursadas
     * @return (boolean) TRUE se os pré-requisitos da disciplina estão cumpridos e FALSE caso contrário
     */
    public function isPreConditionsFree($curriculumData, $contractId, $learningPeriodId, $considerCoursing=false, $aproveitamento=DB_FALSE)
    {
        $busCurriculum = new BusinessAcademicBusCurriculum();
        
        $dadosDisciplina = $busCurriculum->getCurriculum($curriculumData->curriculumId);
        
        $sql = 'SELECT conditionCurriculumId,
                       credits,
                       numberHour,
                       educationAreaId,
                       consideradiscmatriculadas
                  FROM unit_acdCondition
                 WHERE curriculumId = ?
                   AND type = \'P\'';

        $params = array( $curriculumData->curriculumId );

        $conditions = $this->getDatabase()->query(SAGU::prepare($sql, $params));        
        
        //Adicionado mais um parâmetro, pois as matérias que são aproveitamento não tem grupid
        //e o sistema acabava bloqueando as disciplinas, pois não encontrava os pré-requisitos.
        $join = $aproveitamento == DB_TRUE ? 'LEFT JOIN' : 'INNER JOIN'; 
        
        $this->errors[] = "A disciplina " . $dadosDisciplina->curricularComponentId . "/" . $dadosDisciplina->curricularComponentVersion .
                                          ' -  ' . $dadosDisciplina->curricularComponentName . ' não pode ser matriculada, pois: ';
        
        if ( count($conditions) > 0 )
        {
            $return = true;            

            foreach ( $conditions as $condition )
            {
                unset($this->numberHourCondition);
                
                list( $conditionCurriculumId,
                      $credits,
                      $numberHour,
                      $educationAreaId,
                      $consideraDiscMatriculadas ) = $condition;
                
                $sql = "  FROM unit_acdEnroll A
                       {$join} unit_acdGroup B
                            ON (B.groupId = A.groupId)
                    INNER JOIN unit_acdcurriculum C
                            ON (C.curriculumId = A.curriculumId)
                    INNER JOIN acdCurricularComponent D
                            ON (D.curricularComponentId = C.curricularComponentId AND
                                D.curricularComponentVersion = C.curricularComponentVersion)
                         WHERE A.contractId = " . $contractId;
                       
                if ( strlen($conditionCurriculumId) > 0 )
                {
                    $conditionData = $this->getCurriculumData($conditionCurriculumId);

                    if ( ! $this->isCoursed($conditionData, $contractId) )
                    {
                        $return = false;
                        
                        $dadosRequisito = $busCurriculum->getCurriculum($conditionData->curriculumId);
                        
                        $this->errors[] = '*O requisito ' . $dadosRequisito->curricularComponentId .
                                          '/' . $dadosRequisito->curricularComponentVersion . ' - ' . $dadosRequisito->curricularComponentName . ' não foi cursado.';
                    }

                    if ( $considerCoursing && $this->isCoursing($conditionData, $contractId, $learningPeriodId) )
                    {
                        $return = true;
                    }
                    
                    $sql .= ' AND C.curriculumId = ' . $conditionCurriculumId;
                }

                if ( $considerCoursing )
                {
                    $sql .= ' AND A.statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_APPR_OR_EXC') . ')
                               OR ( A.contractId = ' . $contractId . '
                                    AND A.statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED') . ') AND
                                   (SELECT AA.periodId <> (SELECT periodId FROM unit_acdlearningperiod WHERE learningPeriodId = ' . $learningPeriodId . ')
                                      FROM unit_acdlearningperiod AA
                                     WHERE AA.learningPeriodId = B.learningPeriodId)) ';
                }
                else
                {
                    $sql .= ' AND A.statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_APPR_OR_EXC') . ') ';
                }

                if ( strlen($educationAreaId) > 0 && $educationAreaId > 0 )
                {
                    $sql .= ' AND D.educationAreaId = ' . $educationAreaId;
                }
                                
                if ( strlen($credits) > 0 )
                {
                    $sql = 'SELECT sum(academicCredits)' . $sql;

                    $result = $this->getDatabase()->query($sql);

                    if ( ($result[0][0] < $credits) || ( strlen($result[0][0]) == 0) )
                    {      
                        $return = false;
                        
                        $this->errors[] = '*O requisito de  ' . $credits . ' créditos não foi atingido ainda.' .
                                          'Apenas ' . $result[0][0] . ' créditos  foram matriculados/cursados no contrato.';
                    }
                }
                elseif ( strlen($numberHour) > 0 )
                {
                    $sql = 'SELECT sum(academicNumberHours)' . $sql;
                    
                    $result = $this->getDatabase()->query($sql);
                    $sumAcademicnumberHours = $result[0][0];
                    
                    /**
                     * Se o requisito estiver configurado para considerar as disciplinas que poderão ser matrículadas, 
                     * soma as possibilidades de matrícula junto à carga horária total cursada.
                     */
                    if ( $consideraDiscMatriculadas == DB_TRUE && strlen($curriculumData->horasAcademicasTotaisDisponiveis) > 0 )
                    {
                        $sumAcademicnumberHours += $curriculumData->horasAcademicasTotaisDisponiveis;
                        $this->numberHourCondition = $numberHour;
                    }

                    if ( ((double)$sumAcademicnumberHours < (double)$numberHour) || ( strlen($sumAcademicnumberHours) == 0) )
                    {   
                        $return = false;
                        
                        $this->errors[] = '*O requisito de  ' . $numberHour . ' horas não foi atingido ainda.' .
                                          'Apenas ' . $sumAcademicnumberHours . ' horas foram matriculadas/cursadas no contrato.';
                    }
                }
            }
            
            // Verifica se não está desbloqueado
            if ( !$return )
            {
                $sql = " SELECT count(*) 
                           FROM acdcurricularcomponentunblock
                          WHERE contractid = $contractId
                            AND curriculumid = {$curriculumData->curriculumId}
                            AND isconditionbreak ";
                            
                $result = $this->getDatabase()->query($sql);
                
                $return = $result[0][0] > 0;
            }
            else
            {
                // Se o retorno for true, limpa os erros
                unset($this->errors);
            }
                        
            return $return;
        }
        else
        {
            unset($this->errors);
            return true;
        }
    }

    /**
     * Verifica se uma disciplina possui desbloqueio de requisitos
     *
     * @author Leovan Tavares da Silva
     *
     * @param $curriculumData (object): objeto representando uma disciplina na matriz curricular
     * @param $contractId (int): código do contrato
     * @param $learningPeriodId (int): código do período letivo
     * @return (boolean) TRUE se a disciplina possui desbloqueio de requisitos e FALSE caso contrário
     */
    public function isConditionUnblocked($curriculumData, $contractId, $learningPeriodId)
    {
        $sql = 'SELECT count(*)
                  FROM acdCurricularComponentUnblock
                 WHERE curriculumId = ?
                   AND contractId = ?
                   AND learningPeriodId = ?
                   AND isConditionBreak = TRUE';

        $params = array(
                $curriculumData->curriculumId,
                $contractId,
                $learningPeriodId
        );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        if ( $result[0][0] > 0 )
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    /**
     * Verifica se uma disciplina está livre de suas concorrências
     *
     * @author Leovan Tavares da Silva
     *
     * @param $curriculumData (object): objeto que representa uma disciplina da matriz curricular
     * @param $contractId (int): código do contrato
     * @param $learningPeriod (int): código do período letivo
     * @return (boolean) TRUE se nenhuma das concorrências da disciplina foi cursada, FALSE se alguma concorrência foi cursada
     */
    public function isConcurrenceFree($curriculumData, $contractId, $learningPeriodId)
    {
        $sql = 'SELECT curriculumInId
                  FROM unit_acdCurriculumConcurrence
                 WHERE curriculumOutId = ?
                 UNION
                SELECT curriculumOutId
                  FROM unit_acdCurriculumConcurrence
                 WHERE curriculumInId = ?';

        $params = array( $curriculumData->curriculumId,
                       $curriculumData->curriculumId );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        if ( count($result) > 0 )
        {
            $isFree = true;

            foreach ( $result as $res )
            {
                if ( ($this->isCoursed($res[0], $contractId)) || $this->isCoursing($res[0], $contractId, $learningPeriodId) )
                {
                    $isFree = false;
                }
            }

            return $isFree;
        }
        else
        {
            return true;
        }

    }

    /**
     * Check if the two groups have shocking schedules
     *
     * @param $groupId1 (integer): First group id
     * @param $groupId2 (integer): Second group id
     * @return (boolean): True if some shock was found, otherwise False
     */
    public function hasShockingSchedule($groupId1, $groupId2)
    {
        $MIOLO = MIOLO::getInstance();
        $module = 'academic';

        $return = false;
     
        $sql = "select hasShockingSchedule(?, ?)";
        
        $result = $this->getDatabase()->query(SAGU::prepare($sql, array($groupId1, $groupId2)));

        if ( $result[0][0] == DB_TRUE )
        {
            $return = true;
        }

        return $return;
    }
    /**
     * Verifica se um contrato possui desbloqueio de choque para uma disciplina num período letivo
     *
     * @param $contractId (int): código do contrato
     * @param $learningPeriodId (int): código do período letivo
     * @param $curriculumId: código da disciplina na matriz curricular
     * @return TRUE se possui desbloqueio e FALSE caso contrário
     */
    public function isScheduleShock($contractId, $learningPeriodId, $curriculumId)
    {
        $sql = 'SELECT curricularComponentUnblockId
                  FROM acdCurricularComponentUnblock
                 WHERE contractId = ?
                   AND learningPeriodId = ?
                   AND curriculumId = ?
                   AND isScheduleShock = ? ';

        $params = array( $contractId,
                       $learningPeriodId,
                       $curriculumId,
                       DB_TRUE );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        return ( strlen($result[0][0]) > 0 );
    }

    /**
     * Checks the minimum credits
     *
     * @param $data (object): object containing the data to be checked
     * @return (boolean): True if reaches the minimum credits, otherwise false
     */
    public function checkMinimumCreditsCondition($data)
    {
        $MIOLO = MIOLO::getInstance();
        $module = 'academic';

        if ( count($data->groupId) > 0 )
        {
            foreach ( $data->groupId as $groupId => $curriculumId )
            {
                $sql = 'SELECT C.academicCredits
                          FROM unit_acdGroup A
                    INNER JOIN unit_acdcurriculum B
                            ON (B.curriculumId = A.curriculumId)
                    INNER JOIN acdCurricularComponent C
                            ON (C.curricularComponentId = B.curricularComponentId AND
                                C.curricularComponentVersion = B.curricularComponentVersion)
                         WHERE A.groupId = ? ';

                $result = $this->getDatabase()->Query(SAGU::prepare($sql, $groupId));

                $totalAcademicCredits += $result[0][0];                               
            }
        }

        $busLearningPeriod = new BusinessAcademicBusLearningPeriod();
        $learningPeriodData = $busLearningPeriod->getLearningPeriod($data->learningPeriodId);

        $busContract = new BusinessAcademicBusContract();

        // verifica número de créditos
        if ( $busContract->isFreshmanByPeriod($data->contractId, $learningPeriodData->periodId) )
        {
            $minCredits = $learningPeriodData->minimumCreditsFreshman;
        }
        else
        {
            $minCredits = $learningPeriodData->minimumCredits;
        }

        if ( $minCredits > $totalAcademicCredits )
        {
            $busLearning = new BusinessAcademicBusLearningPeriod(); 
            $learningPeriod = $busLearning->getLearningPeriod($data->learningPeriodId);

            if($learningPeriod->matriculasemminimodecreditos == DB_TRUE)
            {
                if($data->maxDiscCredits == $totalAcademicCredits)
                {
                    return true;
                }
            }

            $busMinCreditsUnblock = new BusinessAcademicBusMinimumCreditsUnblock();
            
            $minimumCreditsUnblock = $busMinCreditsUnblock->searchMinimumCreditsUnblock($data);

            if ( count($minimumCreditsUnblock) == 0 )
            {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks whether enroll exceeds the maximum number of credits
     *
     * @param $data (object): object containing the data to be checked
     * @return (boolean): True if maximum number of credits were exceeded. Otherwise, false.
     */
    public function exceedsMaximumNumberOfCredits($data)
    {
        $MIOLO = MIOLO::getInstance();
        $module = 'academic';

        //Nao precisa fazer nenhuma dessas checagens se a pessoa tem desbloqueio por limite de crédito
        $busCredits = new BusinessAcademicBusMinimumCreditsUnblock();
        
        $minimumCreditsUnblock = $busCredits->searchMinimumCreditsUnblock($data);

        if ( strlen($minimumCreditsUnblock[0][0]) > 0 )
        {
                return false;
        }
        
        if ( count($data->groupId) > 0 )
        {
            foreach ( $data->groupId as $groupId => $curriculumId )
            {
                $sql = 'SELECT C.academicCredits
                          FROM unit_acdGroup A
                    INNER JOIN unit_acdcurriculum B
                            ON (B.curriculumId = A.curriculumId)
                    INNER JOIN acdCurricularComponent C
                            ON (C.curricularComponentId = B.curricularComponentId AND
                                C.curricularComponentVersion = B.curricularComponentVersion)
                         WHERE A.groupId = ? ';

                $result = $this->getDatabase()->Query(SAGU::prepare($sql, $groupId));

                $totalAcademicCredits += $result[0][0];
            }
        }

        $busLearningPeriod = new BusinessAcademicBusLearningPeriod();
        $learningPeriodData = $busLearningPeriod->getLearningPeriod($data->learningPeriodId);

        $busContract = new BusinessAcademicBusContract();

        // verifica número de créditos
        if ( $busContract->isFreshmanByPeriod($data->contractId, $learningPeriodData->periodId) )
        {
            $maxCredits = $learningPeriodData->maximumCreditsFreshman;
        }
        else
        {
            $maxCredits = $learningPeriodData->maximumCredits;
        }

        $retVal = false;
        // if maxCredits is zero, ignore check
        if ( $maxCredits != 0 )
        {
            $retVal = $totalAcademicCredits > $maxCredits;
        }

        return $retVal;
    }

    /**
     * Checks the turn minimum credits
     *
     * @param $data (object): object containing the data to be checked
     * @return (boolean): True if reaches the turn minimum credits, otherwise false
     */
    public function checkTurnMinimumCreditsCondition($data)
    {
        $MIOLO = MIOLO::getInstance();
        $module = 'academic'; // MIOLO::getCurrentModule();

        if ( count($data->groupId) > 0 )
        {
            $busContract = new BusinessAcademicBusContract();
            $contractData = $busContract->getContract($data->contractId);

            $totalTurnCredits = 0;

            // Obtem o numero de creditos em que o aluno se matriculou no turno de seu curso
            foreach ( $data->groupId as $groupId => $curriculumId )
            {
                $sql = 'SELECT sum(academicCredits)
                          FROM (SELECT DISTINCT C.academicCredits as academicCredits,
                                                  E.turnId
                                           FROM unit_acdGroup A
                                     INNER JOIN unit_acdcurriculum B
                                             ON (B.curriculumId = A.curriculumId)
                                     INNER JOIN acdCurricularComponent C
                                             ON (C.curricularComponentId = B.curricularComponentId AND
                                                C.curricularComponentVersion = B.curricularComponentVersion)
                                     INNER JOIN acdSchedule D
                                             ON (D.groupId = A.groupId)
                                     INNER JOIN acdTime E
                                             ON (E.timeId = ANY(D.timeIds))
                                          WHERE A.groupId = ?
                                            AND E.turnId = ?) A';

                $result = $this->getDatabase()->Query(SAGU::prepare($sql, array($groupId, $contractData->turnId)));

                $totalTurnCredits += $result[0][0];
            }

            $busLearningPeriod = new BusinessAcademicBusLearningPeriod();
            $learningPeriodData = $busLearningPeriod->getLearningPeriod($data->learningPeriodId);

            // Verifica número de créditos para cursar disciplina em outro turno
            if ( $learningPeriodData->minimumCreditsTurn > 0 && $learningPeriodData->minimumCreditsTurn > $totalTurnCredits )
            {
                $busMinTurnUnblock = new BusinessAcademicBusMinimumTurnUnblock();
                $minimumTurnUnblock = $busMinTurnUnblock->searchMinimumTurnUnblock($data);

                if ( count($minimumTurnUnblock) == 0 )
                {
                    return false;
                }

            }

            return true;
        }
        else
        {
            return true;
        }
    }

    /**
     * Checks the minimum number of hours a pupil must be enrolled, otherwise the enroll
     * will be blocked.
     *
     * @param $data (object): object containing the data to be checked
     * @return (boolean): True if reaches the minimum credits, otherwise false
     */
    public function checkMinimumHoursCondition($data)
    {
        $MIOLO = MIOLO::getInstance();
        $module = 'academic';

        $totalAcademicNumberHours = 0;
        if ( count($data->groupId) > 0 )
        {
            foreach ( $data->groupId as $groupId => $curriculumId )
            {
                $sql = 'SELECT C.academicNumberHours
                          FROM unit_acdGroup A
                    INNER JOIN unit_acdcurriculum B
                            ON (B.curriculumId = A.curriculumId)
                    INNER JOIN acdCurricularComponent C
                            ON (C.curricularComponentId = B.curricularComponentId AND
                                C.curricularComponentVersion = B.curricularComponentVersion)
                         WHERE A.groupId = ? ';

                $result = $this->getDatabase()->Query(SAGU::prepare($sql, $groupId));

                $totalAcademicNumberHours += $result[0][0];
            }
        }

        $busLearningPeriod = new BusinessAcademicBusLearningPeriod();
        $learningPeriodData = $busLearningPeriod->getLearningPeriod($data->learningPeriodId);

        $busContract = new BusinessAcademicBusContract();

        // verifica número de horas para calouros ou veteranos
        if ( $busContract->isFreshmanByPeriod($data->contractId, $learningPeriodData->periodId) )
        {
            // we're reading minimumCreditsFreshman, but the field contains hours (not credits)
            // when isNumberHours == true
            $minNumberHours = $learningPeriodData->minimumCreditsFreshman;
        }
        else
        {
            // we're reading minimumCredits, but the field contains hours (not credits)
            // when isNumberHours == true
            $minNumberHours = $learningPeriodData->minimumCredits;
        }

        // FIXME: there must exist an unblock check for minimum number hours
        return ($minNumberHours == 0 || $totalAcademicNumberHours >= $minNumberHours);
    }

    /**
     * Checks whether enroll exceeds the maximum number of credits
     *
     * @param $data (object): object containing the data to be checked
     * @return (boolean): True if maximum number of credits were exceeded. Otherwise, false.
     */
    public function exceedsMaximumNumberOfHours($data)
    {
        $MIOLO = MIOLO::getInstance();
        $module = 'academic';

        $totalAcademicNumberHours = 0;
        if ( count($data->groupId) > 0 )
        {
            foreach ( $data->groupId as $groupId => $curriculumId )
            {
                $sql = 'SELECT C.academicNumberHours
                          FROM unit_acdGroup A
                    INNER JOIN unit_acdcurriculum B
                            ON (B.curriculumId = A.curriculumId)
                    INNER JOIN acdCurricularComponent C
                            ON (C.curricularComponentId = B.curricularComponentId AND
                                C.curricularComponentVersion = B.curricularComponentVersion)
                         WHERE A.groupId = ? ';

                $result = $this->getDatabase()->Query(SAGU::prepare($sql, $groupId));

                $totalAcademicNumberHours += $result[0][0];
            }
        }

        $busLearningPeriod = new BusinessAcademicBusLearningPeriod();
        $learningPeriodData = $busLearningPeriod->getLearningPeriod($data->learningPeriodId);

        $busContract = new BusinessAcademicBusContract();

        // verifica número de horas
        if ( $busContract->isFreshmanByPeriod($data->contractId, $learningPeriodData->periodId) )
        {
            // we're reading minimumCreditsFreshman, but the field contains hours (not credits)
            // when isNumberHours == true
            $maxNumberHours = $learningPeriodData->maximumCreditsFreshman;
        }
        else
        {
            // we're reading minimumCredits, but the field contains hours (not credits)
            // when isNumberHours == true
            $maxNumberHours = $learningPeriodData->maximumCredits;
        }

        $retVal = false;
        // if maxNumberHours is zero, ignore check
        if ( $maxNumberHours != 0 )
        {
            $retVal = $totalAcademicNumberHours > $maxNumberHours;
        }

        return $retVal;
    }

    /**
     * Checks the turn minimum number hours
     *
     * @param $data (object): object containing the data to be checked
     * @return (boolean): True if reaches the turn minimum number of hours, otherwise false
     */
    public function checkTurnMinimumHoursCondition($data)
    {
        $MIOLO = MIOLO::getInstance();
        $module = 'academic';

        $retVal = false;
        if ( count($data->groupId) > 0 )
        {
            $busContract = new BusinessAcademicBusContract();
            $contractData = $busContract->getContract($data->contractId);

            $totalTurnNumberHours = 0;

            // Obtem o numero de horas em que o aluno se matriculou no turno de seu curso
            foreach ( $data->groupId as $groupId => $curriculumId )
            {
                $sql = 'SELECT sum(academicNumberHours)
                          FROM (SELECT DISTINCT C.academicNumberHours as academicNumberHours,
                                                  E.turnId
                                           FROM unit_acdGroup A
                                     INNER JOIN unit_acdcurriculum B
                                             ON (B.curriculumId = A.curriculumId)
                                     INNER JOIN acdCurricularComponent C
                                             ON (C.curricularComponentId = B.curricularComponentId AND
                                                C.curricularComponentVersion = B.curricularComponentVersion)
                                     INNER JOIN acdSchedule D
                                             ON (D.groupId = A.groupId)
                                     INNER JOIN acdTime E
                                             ON (E.timeId = ANY(D.timeIds))
                                          WHERE A.groupId = ?
                                            AND E.turnId = ?) A';

                $result = $this->getDatabase()->Query(SAGU::prepare($sql, array($groupId, $contractData->turnId)));

                $totalTurnNumberHours += $result[0][0];
            }

            $busLearningPeriod = new BusinessAcademicBusLearningPeriod();
            $learningPeriodData = $busLearningPeriod->getLearningPeriod($data->learningPeriodId);

            // Verifica número de horas para cursar disciplina em outro turno
            if ( $learningPeriodData->minimumCreditsTurn == 0 || $totalTurnNumberHours >= $learningPeriodData->minimumCreditsTurn )
            {
                // FIXME: A minimum hours per turn unblock should be checked here.
                $retVal = true;
            }
        }

        return $retVal;
    }

    /*
     * Métodos antigos
     */

    /**
     * Returns the specified curricular components groups for the specified learning period
     *
     * @param $curricularComponentId
     * @param $curricularComponentVersion
     * @param $learningPeriodId
     */
    public function getGroups($curricularComponentId, $curricularComponentVersion, $learningPeriodId)
    {
        $MIOLO = MIOLO::getInstance();
        $module = 'academic';

        $busLearningPeriod = new BusinessAcademicBusLearningPeriod();
        $learningPeriodData = $busLearningPeriod->getLearningPeriod($learningPeriodId);

        $sql = "SELECT A1.groupId,
                       B1.curricularComponentId,
                       B1.curricularComponentVersion,
                       A1.vacant,
                       A1.totalEnrolled,
                       A1.complement,
                       A1.classId,
                       (SELECT XX.name FROM unit_acdclass XX WHERE XX.classId = A1.classId)
                  FROM unit_acdGroup A1
            INNER JOIN unit_acdcurriculum B1
                    ON (B1.curriculumId = A1.curriculumId)
            INNER JOIN unit_acdlearningperiod C1
                    ON (C1.learningPeriodId = A1.learningPeriodId)
                 WHERE
                        -- Caso parametro esteja habilitado, exibe apenas disciplinas que possuam horarios definidos
                     ( CASE WHEN GETPARAMETER('ACADEMIC', 'ENROLL_SHOW_ONLY_WITH_SCHEDULE') = 't'
                            THEN
                                EXISTS (SELECT 1 FROM acdSchedule X WHERE X.groupId = A1.groupId)
                            ELSE
                                1=1
                            END )
                   AND B1.curricularComponentId = ?
                   AND B1.curricularComponentVersion = ?
                   AND C1.periodId = ?
                   AND A1.isCancellation IS FALSE";

        $params = array( $curricularComponentId,
                       $curricularComponentVersion,
                       $learningPeriodData->periodId );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        return $result;
    }

    /**
     * Obtain the professors data for a specified schedule id
     *
     * @param $scheduleId
     */
    public function getScheduleProfessors($scheduleId)
    {
        $sql = 'SELECT I1.professorId,
                       J1.name AS professorName
                  FROM acdScheduleProfessor I1
            INNER JOIN ONLY basPhysicalPersonProfessor J1
                    ON (J1.personId = I1.professorId)
                 WHERE I1.scheduleId = ?';

        $params = array( $scheduleId );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        return $result;
    }

    /**
     * Returns the status of a specified curricular component for the specified contract.
     *
     * @param $contractId
     * @param $learningPeriodId
     * @param $curriculumId
     */
    public function getCurricularComponentStatus($contractId, $learningPeriodId, $curriculumId)
    {
        global $MIOLO;
        $module = 'academic';

        $busCurriculum = new BusinessAcademicBusCurriculum();
        $dataCurriculum = $busCurriculum->getCurriculum($curriculumId);

        $status = new EnrollCurriculumStatus();
        // this will be the default status
        $status->status = 'FREE';
        $status->text = _M('LIBERADA', $module);
        $status->color = SAGU::getParameter('ACADEMIC', 'CURRICULUM_STATUS_COLOR_FREE');

        if ( $dataCurriculum->curricularComponentTypeId == SAGU::getParameter('ACADEMIC', 'CURRICULAR_COMPONENT_TYPE_SEMINARY') )
        {
            if ( $this->isEnrolledCurricularComponent($contractId, $dataCurriculum->curricularComponentId, $dataCurriculum->curricularComponentVersion) )
            {
                $status->status = 'ENROLLED';
                $status->text = _M('MATRICULADO', $module);
                $status->color = SAGU::getParameter('ACADEMIC', 'CURRICULUM_STATUS_COLOR_ENROLLED');
            }

            return $status;
        }

        $sql = 'SELECT B1.curricularComponentId,
                       B1.curricularComponentVersion,
                       A1.curriculumId
                  FROM unit_acdEnroll A1
            INNER JOIN unit_acdcurriculum B1
                    ON (B1.curriculumId = A1.curriculumId)
                 WHERE A1.contractId = ?
                   AND B1.curricularComponentId = ?
                   AND B1.curricularComponentVersion = ?
                   AND A1.statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_APPR_OR_EXC') . ')';

        $params = array( $contractId,
                       $dataCurriculum->curricularComponentId,
                       $dataCurriculum->curricularComponentVersion );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        if ( count($result) > 0 )
        {
            $status->status = 'COURSED';
            $status->text = _M('CURSADA', $module);
            $status->color = SAGU::getParameter('ACADEMIC', 'CURRICULUM_STATUS_COLOR_COURSED');

            return $status;
        }

        if ( ($this->isCurriculumConcurrence($curriculumId, $contractId, 'COURSED')) || ($this->isCurriculumConcurrence($curriculumId, $contractId, 'COURSING', $learningPeriodId)) )
        {
            $status->status = 'NON COURSED';
            $status->text = _M('INDISPONÍVEL', $module);
            $status->color = SAGU::getParameter('ACADEMIC', 'CURRICULUM_STATUS_COLOR_NON_COURSED');

            return $status;
        }

        if ( !$this->isFreeForEnroll($dataCurriculum->curricularComponentId, $dataCurriculum->curricularComponentVersion, $contractId, $learningPeriodId) )
        {
            $status->status = 'BLOCKED';
            $status->text = _M('BLOQUEADA', $module);
            $status->color = SAGU::getParameter('ACADEMIC', 'CURRICULUM_STATUS_COLOR_BLOCKED');

            if ( $this->isUnblocked($contractId, $learningPeriodId, $curriculumId) )
            {
                $status->status = 'FREE';
                $status->text = _M('DESBLOQUEADA', $module);
                $status->color = SAGU::getParameter('ACADEMIC', 'CURRICULUM_STATUS_COLOR_UNBLOCKED');
            }

            return $status;
        }

        $busLearningPeriod = new BusinessAcademicBusLearningPeriod();
        $learningPeriodData = $busLearningPeriod->getLearningPeriod($learningPeriodId);

        $sql = 'SELECT A.enrollId
                    FROM unit_acdEnroll A
            INNER JOIN unit_acdGroup B
                    ON (B.groupId = A.groupId)
            INNER JOIN unit_acdcurriculum C
                    ON (C.curriculumId = A.curriculumId)
            INNER JOIN unit_acdlearningperiod D
                    ON (D.learningPeriodId = B.learningPeriodId)
                    WHERE A.contractId = ?
                    AND C.curricularComponentId = ?
                    AND C.curricularComponentVersion = ?
                    AND D.periodId <> ?
                    AND A.statusId = ' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED');

        $params = array( $contractId,
                       $dataCurriculum->curricularComponentId,
                       $dataCurriculum->curricularComponentVersion,
                       $learningPeriodData->periodId );

        $res = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        if ( count($res) > 0 )
        {
            $status->status = 'COURSING';
            $status->text = _M('CURSANDO', $module);
            $status->color = SAGU::getParameter('ACADEMIC', 'CURRICULUM_STATUS_COLOR_COURSING');

            return $status;
        }

        if ( $this->isEnrolledCurricularComponent($contractId, $dataCurriculum->curricularComponentId, $dataCurriculum->curricularComponentVersion) )
        {
            $status->status = 'ENROLLED';
            $status->text = _M('MATRICULADO', $module);
            $status->color = SAGU::getParameter('ACADEMIC', 'CURRICULUM_STATUS_COLOR_ENROLLED');

            return $status;
        }

        $hasGroups = null;
        if ( $dataCurriculum->curricularComponentTypeId == SAGU::getParameter('ACADEMIC', 'CURRICULAR_COMPONENT_TYPE_ELECTIVE') )
        {
            $hasGroups = $this->hasElectiveGroups($curriculumId, $learningPeriodId, $contractId);
        }
        else
        {
            $hasGroups = $this->hasGroups($curriculumId, $learningPeriodId);
        }

        if ( !$hasGroups )
        {
            $status->status = 'NON COURSED';
            $status->text = _M('INDISPONÍVEL', $module);
            $status->color = SAGU::getParameter('ACADEMIC', 'CURRICULUM_STATUS_COLOR_NON_COURSED');

            return $status;
        }

        return $status;
    }

    /**
     * Gets the status of a curricular component out of the contract course curriculum.
     *
     * @param $contractId
     * @param $learningPeriodId
     * @param $outCurricularComponentId
     * @param $outCurricularComponentVersion
     */
    public function getOutCurricularComponentStatus($contractId, $learningPeriodId, $outCurricularComponentId, $outCurricularComponentVersion)
    {
        $module = 'academic';

        $status = new stdClass();
        $status->status = 'NON COURSED';
        $status->text = _M('INDISPONÍVEL', $module);
        $status->color = SAGU::getParameter('ACADEMIC', 'CURRICULUM_STATUS_COLOR_NON_COURSED');

        if ( count($this->getGroups($outCurricularComponentId, $outCurricularComponentVersion, $learningPeriodId)) > 0 )
        {
            $status->status = 'FREE';
            $status->text = _M('DESBLOQUEADA', $module);
            $status->color = SAGU::getParameter('ACADEMIC', 'CURRICULUM_STATUS_COLOR_FREE');

            if ( $this->isEnrolledCurricularComponent($contractId, $outCurricularComponentId, $outCurricularComponentVersion) )
            {
                $status->status = 'ENROLLED';
                $status->text = _M('MATRICULADO', $module);
                $status->color = SAGU::getParameter('ACADEMIC', 'CURRICULUM_STATUS_COLOR_ENROLLED');

                return $status;
            }
        }

        return $status;
    }

    /**
     * Lists people enrolled in a group
     *
     * @param $groupId
     */
    public function listGroupEnrolledPeople($groupId, $returnAsObject = false)
    {
        $vars = array(
            'enrollId',
            'courseIdVersion',
            'personId',
            'personName',
            'email',
            'residentialPhone',
            'workPhone',
            'cellPhone',
            'enrollStatusDescription',
        );

        $sql = 'SELECT A.enrollId,
                       B.courseId || \'/\' || B.courseVersion,
                       B.personId,
                       C.name,
                       C.email,
                       C.residentialPhone,
                       C.workPhone,
                       C.cellPhone,
                       D.description
                  FROM unit_acdEnroll A
             LEFT JOIN unit_acdContract B
                    ON (B.contractId = A.contractId)
             LEFT JOIN ONLY basPhysicalPersonStudent C
                    ON (C.personId = B.personId)
             LEFT JOIN acdEnrollStatus D
                    ON (D.statusId = A.statusId)
                 WHERE A.groupId = ?
              ORDER BY C.name';

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $groupId));

        return $returnAsObject ? SAGU::resultToObject($result, $vars) : $result;
    }

    /**
     * Return data when within a enroll period
     *
     * @param $personId
     * @param $isAdjustment
     */
    public function getInEnrollPeriodData($personId, $isAdjustment = false)
    {
        $sql = 'SELECT C.contractId,
                       C.courseId || \'/\' || C.courseVersion || \' - \' || getCourseName(C.courseId),
                       getTurnDescription(C.turnId),
                       getUnitDescription(C.unitId),
                       B.learningPeriodId,
                       B.periodId
                  FROM unit_acdPeriodEnrollDate A
            INNER JOIN unit_acdlearningperiod B
                    ON (B.learningPeriodId = A.learningPeriodId)
            INNER JOIN unit_acdContract C
                    ON (C.courseId = B.courseId AND
                        C.courseVersion = B.courseVersion AND
                        C.turnId = B.turnId AND
                        C.unitId = B.unitId)
                 WHERE C.personId = ?
                   AND (C.conclusionDate IS NULL OR C.conclusionDate > date(now()))
                   AND getContractDisactivationDate(C.contractId) IS NULL
                   AND date(now()) BETWEEN A.beginDate AND A.endDate
                   AND A.isInternet = true
                   AND A.isAdjustment = ?
                   AND (A.isSelectiveProc <> (SELECT count(*) > 0
                                               FROM acdMovementContract AA
                                              WHERE AA.stateContractId = ' . SAGU::getParameter('BASIC', 'STATE_CONTRACT_ID_ENROLLED') . '
                                                AND AA.contractId = C.contractId
                                                AND AA.stateTime < (SELECT AB.beginDate
                                                                      FROM unit_acdlearningperiod AB
                                                                     WHERE AB.learningPeriodId = B.learningPeriodId))
                        OR A.isAdjustment = true)';

        $params[] = $personId;

        if ( $isAdjustment )
        {
            $params[] = DB_TRUE;
        }
        else
        {
            $params[] = DB_FALSE;
        }

        $result = $this->getDatabase()->query(SAGU::Prepare($sql, $params));

        return $result;
    }

    /**
     * Get all enroll for the specified contractId.
     *
     * @param $contractId
     * @param $periodId
     * @param $enrollId
     */
    public function getPersonEnrolls($contractId, $periodId, $enrollId = null)
    {
        $MIOLO = MIOLO::getInstance();
        $module = 'academic';

        $businessSchedule = new BusinessAcademicBusSchedule();
        $businessTurn = new BusinessBasicBusTurn();

        $sql = 'SELECT DISTINCT A.enrollId,
                       A.curriculumId,
                       A.groupId,
                       B.curricularComponentId,
                       B.curricularComponentVersion,
                       CASE WHEN C.name = F.name
                            THEN C.name
                            ELSE C.name || \' (\' || F.name || \')\'
                       END AS curricularComponentName,
                       A.statusId,
                       G.description
                  FROM unit_acdEnroll A
            INNER JOIN unit_acdcurriculum B
                    ON (B.curriculumId = A.curriculumId)
            INNER JOIN acdCurricularComponent C
                    ON (C.curricularComponentId = B.curricularComponentId AND
                        C.curricularComponentVersion = B.curricularComponentVersion)
            INNER JOIN unit_acdGroup D
                    ON (D.groupId = A.groupId)
            INNER JOIN unit_acdcurriculum E
                    ON (E.curriculumId = D.curriculumId)
            INNER JOIN acdCurricularComponent F
                    ON (F.curricularComponentId = E.curricularComponentId AND
                        F.curricularComponentVersion = E.curricularComponentVersion)
            INNER JOIN acdEnrollStatus G
                    ON (G.statusId = A.statusId)
             LEFT JOIN acdSchedule H
                    ON (H.groupId = A.groupId)
                 WHERE A.contractId = ?
                   AND D.learningPeriodId IN (SELECT learningPeriodId FROM unit_acdlearningperiod WHERE periodId = ?)
                   AND A.statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_CANCELLED') . ', ' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED') . ', ' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_PRE_ENROLLED') . ')';

        $params = array( $contractId,
                       $periodId );

        if ( strlen($enrollId) > 0 )
        {
            $sql .= ' AND A.enrollId = ? ';
            $params[] = $enrollId;
        }

        $sql .= ' ORDER BY A.enrollId';        

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        $return = array();
        if ( count($result) > 0 )
        {
            foreach ( $result as $res )
            {
                list( $enrollId, $curriculumId, $groupId, $curricularComponentId, $curricularComponentVersion, $curricularComponentName, $statusId, $statusDescription ) = $res;

                // Search and sorts the day of the week
                $weekDay = $businessSchedule->getGroupWeekDays($groupId);
                if ( count($weekDay) <= 0 )
                {
                    $weekDayDescription = _M('Indef.', $module);
                }
                else
                {
                    ksort($weekDay);

                    $weekDayDescription = str_replace(',', '<br>', implode(',', $weekDay));
                }

                $turn = $businessSchedule->getGroupTurns($groupId);

                if ( count($turn) <= 0 )
                {
                    $turnDescription = _M('Indef.', $module);
                }
                else
                {
                    $turnDescription = str_replace(',', '<br>', implode(',', $turn));
                }
                // Search and sorts the day of the week
                $weekDay = $businessSchedule->getGroupWeekDays($groupId);
                if ( count($weekDay) <= 0 )
                {
                    $weekDayDescription = _M('Indef.', $module);
                }
                else
                {
                    ksort($weekDay);

                    $weekDayDescription = str_replace(',', '<br>', implode(',', $weekDay));
                }

                $row = array(
                        $enrollId,
                        $curricularComponentId,
                        $curricularComponentVersion,
                        $curricularComponentName,
                        $curriculumId,
                        $groupId,
                        $weekDay,
                        $weekDayDescription,
                        $turnDescription,
                        $statusDescription,
                        $statusId
                );

                if ( !in_array($row, $return) )
                {
                    $return[] = $row;
                }
            }
        }

        return $return;
    }

    /************************************************************
     *
     * Testing functions
     *
     *********************************************************/

    /**
     * Check if curriculum has concurrency.
     *
     * @param unknown_type $curriculumId
     * @param unknown_type $contractId
     * @param unknown_type $checkType
     * @param unknown_type $learningPeriodId
     * @return string|string
     */
    public function isCurriculumConcurrence($curriculumId, $contractId, $checkType, $learningPeriodId = null)
    {
        $MIOLO = MIOLO::getInstance();
        $module = 'academic';

        $sql = ' SELECT curriculumInId,
                        curriculumOutId
                   FROM unit_acdCurriculumConcurrence
                  WHERE curriculumInId = ?
                     OR curriculumOutId = ? ';

        $result = $this->getDatabase()->query(SAGU::prepare($sql, array( $curriculumId, $curriculumId )));

        if ( count($result) > 0 )
        {
            if ( $checkType == 'COURSED' )
            {
                $sql = 'SELECT enrollId
                          FROM unit_acdEnroll
                         WHERE contractId = ?
                           AND curriculumId = ?
                           AND statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_APPR_OR_EXC') . ')';
            }
            elseif ( $checkType == 'COURSING' )
            {
                $busLearningPeriod = new BusinessAcademicBusLearningPeriod();
                $dataLearningPeriod = $busLearningPeriod->getLearningPeriod($learningPeriodId);

                $sql = 'SELECT A.enrollId
                          FROM unit_acdEnroll A
                    INNER JOIN unit_acdGroup B
                            ON (B.groupId = A.groupId)
                    INNER JOIN unit_acdcurriculum C
                            ON (C.curriculumId = B.curriculumId)
                    INNER JOIN unit_acdlearningperiod D
                            ON (D.learningPeriodId = B.learningPeriodId)
                         WHERE A.contractId = ?
                           AND A.curriculumId = ?
                           AND D.periodId <> \'' . $dataLearningPeriod->periodId . '\'
                           AND A.statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED') . ')';
            }

            foreach ( $result as $res )
            {
                $resApr1 = $this->getDatabase()->query(SAGU::prepare($sql, array( $contractId, $res[0] )));

                $resApr2 = $this->getDatabase()->query(SAGU::prepare($sql, array( $contractId, $res[1] )));

                if ( (count($resApr1) > 0 ) || (count($resApr2) > 0 ) )
                {
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Check if a curriculum is unblocked.
     *
     * @param $contractId
     * @param $learningPeriodId
     * @param $curriculumId
     */
    public function isUnblocked($contractId, $learningPeriodId, $curriculumId)
    {
        $sql = 'SELECT curricularComponentUnblockId
                  FROM acdCurricularComponentUnblock
                 WHERE contractId = ?
                   AND learningPeriodId = ?
                   AND curriculumId = ?
                   AND isConditionBreak = ? ';

        $params = array( $contractId,
                       $learningPeriodId,
                       $curriculumId,
                       DB_TRUE );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        return ( strlen($result[0][0]) > 0 );
    }

    /**
     * Check if a curricular component is free for a contract to enroll in it.
     *
     * @param $curricularComponentId
     * @param $curricularComponentVersion
     * @param $contractId
     * @param $learningPeriodId
     */
    public function isFreeForEnroll($curricularComponentId, $curricularComponentVersion, $contractId, $learningPeriodId)
    {
        global $MIOLO;
        $module = 'academic';

        $retVal = true;

        $sql = 'SELECT courseId,
                          courseVersion,
                          unitId,
                          turnId
                     FROM unit_acdContract
                    WHERE contractId = ?';

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $contractId));

        list( $courseId,
              $courseVersion,
              $unitId,
              $turnId ) = $result[0];

        $sql = 'SELECT A.curriculumId
                     FROM unit_acdcurriculum A,
                          unit_acdcurriculum B
                    WHERE A.courseId = ?
                      AND A.courseVersion = ?
                      AND A.unitId = ?
                      AND A.turnId = ?
                      AND A.curricularComponentId = ?
                      AND A.curricularComponentVersion = ?
                      AND B.learningPeriodId = ?
                      AND (A.endDate IS NULL
                           OR A.endDate > B.beginDate)';

        $params = array( $courseId,
                       $courseVersion,
                       $unitId,
                       $turnId,
                       $curricularComponentId,
                       $curricularComponentVersion,
                       $learningPeriodId );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));
        $curriculumId = $result[0][0];

        if ( isset($curriculumId) )
        {
            $busCurriculum = new BusinessAcademicBusCurriculum();

            $curriculumData = $busCurriculum->getCurriculum($curriculumId);

            $sql = 'SELECT A.conditionCurriculumId,
                           A.credits,
                           A.numberHour,
                           A.educationAreaId
                      FROM unit_acdCondition A
                     WHERE A.curriculumId = ?
                       AND A.type = \'P\'';

            $result = $this->getDatabase()->query(SAGU::prepare($sql, $curriculumId));

            for($i = 0; $i < count($result); $i++ )
            {
                list( $conditionCurriculumId,
                      $academicCredits,
                      $academicNumberHours,
                      $educationAreaId ) = $result[$i];

                /**
                 * Verifica se a disciplina requisito foi cursada
                 */
                if ( isset($conditionCurriculumId) )
                {
                    $sql = 'SELECT enrollId
                              FROM unit_acdEnroll
                             WHERE contractId = ?
                               AND curriculumId = ?
                               AND statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_APPR_OR_EXC') . ', ' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED') . ', ' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_DEPENDENT') . ')';

                    $params = array( $contractId,
                                   $conditionCurriculumId );

                    $result2 = $this->getDatabase()->query(SAGU::prepare($sql, $params));

                    if ( count($result2) == 0 )
                    {
                        $retVal = false;
                    }
                }

                /**
                 * Se for necessario um numero minimo de horas ou creditos cursados
                 */
                if ( ($academicNumberHours > 0) || ($academicCredits > 0) )
                {
                    $ref = ($academicCredits > 0) ? 'academicCredits' : 'academicNumberHours';

                    $sql = 'SELECT SUM(' . $ref . ')
                              FROM acdCurricularComponent
                             WHERE curricularComponentId IN (
                                   SELECT curricularComponentId
                                     FROM unit_acdcurriculum
                                    WHERE curriculumId IN (
                                          SELECT CASE WHEN ( LENGTH(curriculumId::text) > 0 )
                                                      THEN curriculumid
                                                      ELSE ( SELECT curriculumId
                                                               FROM unit_acdGroup
                                                              WHERE acdEnroll.groupId = groupId )
                                                       END
                                            FROM unit_acdEnroll
                                           WHERE contractId = ?
                                             AND statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_APPR_OR_EXC') . ',' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED') . ') ) )
                               AND educationAreaId = ?';

                    $params = array( $contractId,
                                   $educationAreaId );

                    $result2 = $this->getDatabase()->query(SAGU::prepare($sql, $params));

                    if ( $result2[0][0] < $$ref )
                    {
                        $retVal = false;
                    }

                }

            }
        }

        return $retVal;
    }

    /**
     * Check if a curricular component was coursed
     *
     * @param $contractId   (int): acdContract primary key
     * @param $curriculumId (int): acdCurriculum primary key
     * @return (boolean): Return true or false
     */
    public function checkIfCoursed($contractId, $curriculumId, $checkNumberHours = true)
    {
        $sql = 'SELECT count(A.curriculumId) > 0
                  FROM unit_acdEnroll A
            INNER JOIN unit_acdcurriculum B
                    ON ( A.curriculumId = B.curriculumId )
            INNER JOIN acdCurricularComponent C
                    ON ( B.curricularComponentId = C.curricularComponentId
                         AND B.curricularComponentVersion = C.curricularComponentVersion )
                 WHERE A.contractId = ?
                   AND B.curriculumId = ?
                   AND ((A.statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_APPR_OR_EXC') . ')
                    ';

        $params = array( $contractId,
                       $curriculumId );

        // verificação de horas em aproveitamentos
        if ( $checkNumberHours == true )
        {
            $sql .= ' AND C.academicNumberHours = (SELECT CASE WHEN
                                                              sum(XY.exploitationNumberHours) > 0
                                                          THEN
                                                              sum(XY.exploitationNumberHours)
                                                          ELSE
                                                              C.academicNumberHours
                                                          END
                                                     FROM unit_acdExploitation XY
                                                    WHERE XY.enrollId = A.enrollId)';
        }

        $sql .= ')';

        // Verificação de concorrências
        $sql .= ' OR A.curriculumId IN (SELECT CC.curriculumId
                                         FROM unit_acdcurriculum CC
                                        WHERE CC.courseId = B.courseId
                                          AND (CC.curriculumId IN
                                                          (SELECT CR.curriculumInId
                                                             FROM unit_acdCurriculumConcurrence CR
                                                            WHERE CR.curriculumOutId IN (
                                                                     SELECT CE.curriculumId
                                                                       FROM unit_acdEnroll CE
                                                                      WHERE CE.contractId = \'' . $contractId . '\'
                                                                        AND CE.statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_APPR_OR_EXC') . '))
                                                           ) OR
                                               CC.curriculumId IN (
                                                           SELECT CS.curriculumOutId
                                                             FROM unit_acdCurriculumConcurrence CS
                                                            WHERE CS.curriculumInId IN (
                                                                     SELECT CF.curriculumId
                                                                       FROM unit_acdEnroll CF
                                                                      WHERE CF.contractId = \'' . $contractId . '\'
                                                                        AND CF.statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_APPR_OR_EXC') . ')))
               )) ';

        $sql .= ')';

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        return ($result[0][0] == DB_TRUE);
    }

    /**
     * Check if a curriculum is substituted or not.
     *
     * @param $contractId
     * @param $learningPeriodId
     * @param $curriculumId
     */
    public function checkIfSubstituted($contractId, $learningPeriodId, $curriculumId)
    {
        $sql = 'SELECT curricularComponentId,
                       curricularComponentVersion
                  FROM acdCurricularComponentUnblock
                 WHERE contractId = ?
                   AND learningPeriodId = ?
                   AND curriculumId = ?
                   AND isSubstituted = ? ';

        $params = array( $contractId,
                       $learningPeriodId,
                       $curriculumId,
                       DB_TRUE );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        $data = new stdClass();
        list( $data->curricularComponentId,
              $data->curricularComponentVersion ) = $result[0];

        return $data;
    }

    /**
     * Function that checks leave a particular contract is registered in a given period
     *
     * @param $contractId (integer): Is code of contract
     * @param $periodId (integer): Is code of period
     * @return Return true if you are enroll or false if you are not enroll
     */
    public function isEnrolledInPeriod($contractId, $periodId = null, $learningPeriodId = null)
    {
        $sql = 'SELECT COUNT(*)
                  FROM unit_acdEnroll A,
                       unit_acdGroup B,
                       unit_acdLearningPeriod C
                 WHERE A.groupId = B.groupId
                   AND B.learningPeriodId = C.learningPeriodId
                   AND A.contractId = ?
                   AND A.statusId <> ' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_CANCELLED');
                       
        if ( SAGU::getParameter('ACADEMIC', 'MOSTRAR_PRE_MATRICULADOS_DOCUMENTO_CONFIRMACAO') == DB_FALSE )
        {
            $sql .=  ' AND A.statusId <> ' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_PRE_ENROLLED');
        }

        $params = array();
        $params[] = $contractId;

        if ( strlen($periodId) > 0 )
        {
            $sql .= ' AND C.periodId = ? ';
            $params[] = $periodId;
        }
        elseif ( strlen($learningPeriodId) > 0 )
        {
            $sql .= ' AND C.learningPeriodId = ? ';
            $params[] = $learningPeriodId;
        }

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        return ($result[0][0] > 0);
    }

    /**
     * Checks if a curricular component has groups in learning period
     *
     * @param $curricularComponentId      (int): curricular component id
     * @param $curricularComponentVersion (int): curricular component version
     * @param $larningPeriodId            (int): learning period id
     * @return (boolean): Return true or false
     */
    public function hasGroups($curriculumId, $learningPeriodId)
    {
        $MIOLO = MIOLO::getInstance();
        $module = 'academic';

        $busLearningPeriod = new BusinessAcademicBusLearningPeriod();
        $dataLearningPeriod = $busLearningPeriod->getLearningPeriod($learningPeriodId);

        $busCurriculum = new BusinessAcademicBusCurriculum();
        $dataCurriculum = $busCurriculum->getCurriculum($curriculumId);

        $sql = 'SELECT count(A1.groupId)
                  FROM unit_acdGroup A1
            INNER JOIN unit_acdcurriculum B1
                    ON (B1.curriculumId = A1.curriculumId)
            INNER JOIN unit_acdlearningperiod C1
                    ON (C1.learningPeriodId = A1.learningPeriodId)
                 WHERE EXISTS (SELECT \'X\'
                                 FROM acdSchedule X
                                WHERE X.groupId = A1.groupId)
                   AND B1.curricularComponentId = ?
                   AND B1.curricularComponentVersion = ?
                   AND C1.periodId = ?
                   AND A1.isCancellation = \'' . DB_FALSE . '\'';

        $params = array( $dataCurriculum->curricularComponentId,
                       $dataCurriculum->curricularComponentVersion,
                       $dataLearningPeriod->periodId );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        return ($result[0][0] > 0);
    }

    /**
     * Check if a curriculum has elective groups.
     *
     * @param $curriculumId
     * @param $learningPeriodId
     * @param $contractId
     */
    public function hasElectiveGroups($curriculumId, $learningPeriodId, $contractId)
    {
        $MIOLO = MIOLO::getInstance();
        $module = 'academic';

        $busLearningPeriod = new BusinessAcademicBusLearningPeriod();
        $dataLearningPeriod = $busLearningPeriod->getLearningPeriod($learningPeriodId);

        $busCurriculum = new BusinessAcademicBusCurriculum();
        $dataCurriculum = $busCurriculum->getCurriculum($curriculumId);

        $sql = 'SELECT B.curricularComponentId,
                       B.curricularComponentVersion,
                       A.name as curricularComponentName,
                       B.curriculumId
                  FROM acdCurricularComponent A
            INNER JOIN unit_acdcurriculum B
                    ON (A.curricularComponentId = B.curricularComponentId AND
                        A.curricularComponentVersion = B.curricularComponentVersion)
                 WHERE B.curriculumId NOT IN ( SELECT A1.curriculumId
                                                 FROM unit_acdEnroll A1
                                           INNER JOIN unit_acdcurriculum B1
                                                   ON (B1.curriculumId = A1.curriculumId)
                                                WHERE A1.contractId = ?
                                                  AND B1.curricularComponentId = B.curricularComponentId
                                                 AND B1.curricularComponentVersion = B.curricularComponentVersion
                                                 AND A1.statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_APPR_OR_EXC') . ') )
                   AND A.endDate IS NULL ';

        $params[] = $contractId;

        if ( $dataCurriculum->curricularComponentGroupElectiveId != SAGU::getParameter('ACADEMIC', 'NO_GROUP_ELECTIVE_ID') )
        {
            $sql .= ' AND B.curricularComponentGroupDocumentEndCourseId = ?';

            $params[] = $dataCurriculum->curricularComponentGroupElectiveId;
        }
        else
        {
            return true;
        }

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        if ( count($result) > 0 )
        {
            foreach ( $result as $r )
            {
                if ( $this->isFreeForEnroll($r[0], $r[1], $contractId, $learningPeriodId) || $this->isUnblocked($contractId, $learningPeriodId, $r[3]) )
                {
                    $ccgroups = $this->getGroups($r[0], $r[1], $learningPeriodId);

                    if ( count($ccgroups) > 0 )
                    {
                        foreach ( $ccgroups as $availableGroup )
                        {
                            $groups[] = $availableGroup[0];
                        }
                    }
                }
            }
        }

        return (count($groups) > 0 );
    }

    /**
     * Checks if a contract is enrolled in any group of a curricular component in learning period
     *
     * @param $contractId                 (int): contract id
     * @param $curricularComponentId      (int): curricular component id
     * @param $curricularComponentVersion (int): curricular component version
     * @return (boolean): Return true or false
     */
    public function isEnrolledCurricularComponent($contractId, $curricularComponentId, $curricularComponentVersion)
    {
        $sql = 'SELECT count(A.groupId)
                  FROM unit_acdEnroll A
            INNER JOIN unit_acdGroup B
                    ON (B.groupId = A.groupId)
            INNER JOIN unit_acdcurriculum C
                    ON (C.curriculumId = A.curriculumId)
            INNER JOIN unit_acdcurriculum D
                    ON (D.curriculumId = B.curriculumId)
                 WHERE A.contractId = ?
                   AND ((C.curricularComponentId = ? AND C.curricularComponentVersion = ?) OR
                        (D.curricularComponentId = ? AND D.curricularComponentVersion = ?))
                   AND A.statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED') . ')';

        $params = array( $contractId,
                       $curricularComponentId,
                       $curricularComponentVersion,
                       $curricularComponentId,
                       $curricularComponentVersion );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        return ($result[0][0] > 0);
    }

    /**
     * Return the total credits in which the contract id is enrolled in this learning period.
     *
     * @param (int) $contractId Contract id the total credits will be totalized.
     * @param (int) $learningPeriodId Learning period of the enroll which will be totalized.
     */
    public function getTotalCredits($contractId, $learningPeriodId, $isWebServices = false)
    {
        // FIXME: Criar configuração para definir se utilizará créditos acadêmicos da disciplina ou financeiros da oferecida
        
        $acdEnroll = "unit_acdEnroll";
        $acdGroup = "unit_acdGroup";
        $acdcurriculum = "unit_acdcurriculum";
        $acdlearningperiod = "unit_acdlearningperiod";
        
        // Para webservices.
        if ( $isWebServices )
        {
            $acdEnroll = "acdEnroll";
            $acdGroup = "acdGroup";
            $acdcurriculum = "acdcurriculum";
            $acdlearningperiod = "acdlearningperiod";
        }  
        
        $sql = "SELECT SUM(E.academicCredits)
                  FROM {$acdEnroll} A
            INNER JOIN {$acdGroup} B
                    ON B.groupId = A.groupId
            INNER JOIN {$acdcurriculum} C
                    ON C.curriculumId = B.curriculumId
            INNER JOIN acdCurricularComponent E
                    ON (E.curricularComponentId = C.curricularComponentId AND
                        E.curricularComponentVersion = C.curricularComponentVersion)
            INNER JOIN {$acdlearningperiod} D
                    ON D.learningPeriodId = B.learningPeriodId
                 WHERE A.contractId = ?
                   AND D.periodId = (SELECT periodId
                                       FROM {$acdlearningperiod}
                                      WHERE learningPeriodId = ?)
                   AND A.statusId IN ('" . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED') . "', '" . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_PRE_ENROLLED') . "') ";

        $result = $this->getDatabase()->query(SAGU::prepare($sql, array($contractId, $learningPeriodId)));

        return $result[0][0];
    }
    
    
    /**
     * Obtem o numero de parcelas de um contrato e periodo letivo passados, seguindo as prioridades de configuracao.
     *
     * @param int $contractId
     * @param int $learningPeriodId
     * 
     * @return int
     */
    public function getParcelsNumber($contractId, $learningPeriodId, $isWebServices = false)
    {
        $MIOLO = MIOLO::getInstance();

        $busContract = new BusinessAcademicBusContract();
        $busLearningPeriod = new BusinessAcademicBusLearningPeriod();
        
        $contract = $busContract->getContract($contractId, $isWebServices);
        $learningPeriod = $busLearningPeriod->getLearningPeriod($learningPeriodId, $isWebServices);
        $confParcelsNumber = SAGU::getParameter('basic', 'DEFAULT_PARCELS_NUMBER');
        
        return SAGU::NVL($contract->parcelsNumber, $learningPeriod->parcelsNumber, $confParcelsNumber);
    }
    

    /*******************************************************
     *
     * Functions to verify!
     *
     ****************************************************/

    /**
     * Function that returns the curricular component that the student is enrolled
     *
     * @param $contractId (integer): Is code of contract
     * @param $periodId (string): Is code of period
     * @return $result (array): It contains details of the disciplines in which the student is enrolled
     */
    public function getCurricularComponentsEnrolled($contractId, $periodId)
    {
        $sql = 'SELECT C.courseId,
                       C.courseVersion,
                       D.shortName as courseName,
                       C.curricularComponentId,
                       C.curricularComponentVersion,
                       E.shortName as curricularComponentName,
                       TRIM(TO_CHAR(E.academicCredits, \'' . SAGU::getParameter('BASIC', 'MASK_REAL_2') . '\')),
                       E.academicNumberHours,
                       B.groupId,
                       E.name as curricularComponentFullName
                  FROM unit_acdEnroll A,
                       unit_acdLearningPeriod B1,
                       unit_acdGroup B
             LEFT JOIN acdSchedule F
                    ON ( B.groupId = F.groupId ),
                       unit_acdCurriculum C,
                       acdCourse D,
                       acdCurricularComponent E
                 WHERE A.groupId = B.groupId
                   AND A.curriculumId = C.curriculumId
                   AND D.courseId = C.courseId
                   AND E.curricularComponentId = C.curricularComponentId
                   AND B.learningPeriodId = B1.learningPeriodId
                   AND A.statusId <> ?
                   AND A.contractId = ?
                   AND B1.periodId = ?
              ORDER BY D.shortName';

        $params = array( SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_CANCELLED'),
                       $contractId,
                       $periodId );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        return $result;
    }

    /**
     * Get the history of a contract
     *
     * @param $contractId
     */
    public function getContractHistory($contractId)
    {
        $module = 'academic';

        $sql = 'SELECT C.courseId,
                       C.courseVersion,
                       D.shortName,
                       C.curricularComponentId,
                       C.curricularComponentVersion,
                       E.shortName,
                       TRIM(TO_CHAR(E.academicCredits, \'' . SAGU::getParameter('BASIC', 'MASK_REAL_2') . '\')),
                       E.academicNumberHours,
                       A.statusId,
                       A.statusId,
                       TRIM(TO_CHAR(A.finalNote, \'' . SAGU::getParameter('BASIC', 'MASK_REAL_2') . '\')),
                       B.curriculumId,
                       A.curriculumId,
                       \'\',
                       \'\',
                       \'\',
                       F.periodId
                    FROM unit_acdEnroll A
            INNER JOIN unit_acdGroup B
                    ON (B.groupId = A.groupId)
            INNER JOIN unit_acdcurriculum C
                    ON (C.curriculumId = B.groupId)
            INNER JOIN acdCourse D
                    ON (D.courseId = C.courseId)
            INNER JOIN acdCurricularComponent E
                    ON (E.curricularComponentId = C.curricularComponentId
                        AND E.curricularComponentVersion = C.curricularComponentVersion)
            INNER JOIN unit_acdlearningperiod F
                    ON (F.learningPeriodId = B.learningPeriodId)
                 WHERE A.statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_APPR_OR_EXC') . ')
                   AND A.contractId = ?
              ORDER BY F.beginDate';

        $params[] = $contractId;
        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        for ($x = 0; $x < count($result); $x++)
        {

            $sql = 'SELECT A.curricularComponentId,
                           B.shortName
                      FROM unit_acdcurriculum A,
                           acdCurricularComponent B
                     WHERE A.curricularComponentId = B.curricularComponentId
                       AND A.curricularComponentVersion = B.curricularComponentVersion
                       AND A.curriculumId = ?';

            $result2[$x] = $result[$x];
            if ( $result[$x][11] != $result[$x][12] )
            {
                $res = $this->getDatabase()->query(SAGU::prepare($sql, $result[$x][11]));

                $result2[$x][13] = $res[0][0];
                $result2[$x][14] = $res[0][1];
                $result2[$x][15] = '[ ' . $res[0][0] . ' - ' . $res[0][1] . ' ]';
            }
            else
            {
                $result2[$x][13] = $result[0][3];
                $result2[$x][14] = $result[0][5];
                $result2[$x][15] = '';
            }

            if ( $result2[$x][8] == SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_EXCUSED') )
            {
                $result2[$x][10] = _M('Disp.', $module);
            }
        }

        return $result2;
    }

    /**
     * Enter description here...
     *
     * @param unknown_type $contractId
     * @param unknown_type $filter
     * @return unknown
     */
    public function getContractHistoryFilter($contractId, $filter = null)
    {
        $module = 'academic';

        $sql = 'SELECT A.curriculumId,
                       C.curricularComponentId,
                       C.curricularComponentVersion,
                       case when A.curriculumId != B.curriculumId then
                                 E.shortName || \' [\' || P.shortName || \']\'
                                 else E.shortName END as curricularComponentName,
                       TRIM(TO_CHAR(E.academicCredits, \'' . SAGU::getParameter('BASIC', 'MASK_REAL_2') . '\')),
                       E.academicNumberHours,
                       A.statusId,
                       B1.periodId,
                       CASE WHEN A.statusId = ' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_EXCUSED') . '
                            THEN \'' . _M('Disp.', $module) . '\'
                            ELSE TO_CHAR(A.finalNote, \'999.00\')
                       END,
                       B.curriculumId
                  FROM unit_acdEnroll A,
                       unit_acdLearningPeriod B1,
                       unit_acdGroup B
             LEFT JOIN acdSchedule F
                    ON ( B.groupId = F.groupId ),
                       unit_acdCurriculum C,
                       acdCourse D,
                       acdCurricularComponent E,
                       acdCurricularComponent P,
                       unit_acdCurriculum O
                 WHERE A.groupId = B.groupId
                   AND O.curriculumId = B.curriculumId
                   AND P.curricularComponentId = O.curricularComponentId
                   AND A.curriculumId = C.curriculumId
                   AND D.courseId = C.courseId
                   AND E.curricularComponentId = C.curricularComponentId
                   AND B.learningPeriodId = B1.learningPeriodId
                   AND A.statusId IN(' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_APPR_OR_EXC') . ')
                   AND A.contractId = ?
                   AND O.curriculumTypeId <> ' . SAGU::getParameter('ACADEMIC', 'ACD_CURRICULUM_TYPE_COMPLEMENTARY_ACTIVITY');

        $params[] = $contractId;

        if ( is_array($filter->curriculumId) )
        {
            $curriculumns = implode(',', $filter->curriculumId);
            $sql .= '  AND A.curriculumId IN (' . $curriculumns . ')';
        }
        elseif ( strlen($filter->curriculumId) > 0 )
        {
            $sql .= ' AND A.curriculumId = ?';
            $params[] = $filter->curriculumId;
        }

        $sql .= ' ORDER BY B1.beginDate';

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        return $result;
    }

    // Verificar!!!!!!!!!!!!!!!!!!!
    // FIXME: Add comment
    /**
     * Enter description here...
     *
     * @param unknown_type $contractId
     * @param unknown_type $periodId
     * @param unknown_type $statusId
     * @return unknown
     */
    public function getPeriodCurricularComponentsByStatus($contractId, $periodId, $statusId)
    {
        $sql = 'SELECT C.courseId,
                       C.courseVersion,
                       D.shortName as courseName,
                       C.curricularComponentId,
                       C.curricularComponentVersion,
                       E.shortName as curricularComponentName,
                       TRIM(TO_CHAR(E.academicCredits, \'' . SAGU::getParameter('BASIC', 'MASK_REAL_2') . '\')),
                       E.academicNumberHours,
                       TRIM(TO_CHAR(A.finalNote, \'' . SAGU::getParameter('BASIC', 'MASK_REAL_2') . '\'))
                  FROM unit_acdEnroll A,
                       unit_acdLearningPeriod B1,
                       unit_acdGroup B
             LEFT JOIN acdSchedule F
                    ON ( B.groupId = F.groupId ),
                       unit_acdCurriculum C,
                       acdCourse D,
                       acdCurricularComponent E
                 WHERE A.groupId = B.groupId
                   AND A.curriculumId = C.curriculumId
                   AND D.courseId = C.courseId
                   AND E.curricularComponentId = C.curricularComponentId
                   AND E.curricularComponentVersion = C.curricularComponentVersion
                   AND B.learningPeriodId = B1.learningPeriodId
                   AND A.statusId IN (' . $statusId . ')
                   AND A.contractId = ?
                   AND B1.periodId = ?
              ORDER BY E.shortName';

        $params = array( $contractId,
                       $periodId );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        return $result;
    }

    // Verificar!!!!!!!!!!!!!!11
    // FIXME: Add comment
    /**
     * Enter description here...
     *
     * @param unknown_type $learningPeriodId
     * @param unknown_type $filters
     * @return unknown
     */
    public function getEnrollContractMessages($learningPeriodId, $filters)
    {
        $sql = 'SELECT messagecontractrenewalid,
                       message,
                       font
                  FROM unit_acdMessageContractRenewal
                 WHERE learningPeriodId = ? ';

        $params[] = $learningPeriodId;

        if ( strlen($filters->status) > 0 )
        {
            $sql .= ' AND status = ? ';
            $params[] = $filters->status;
        }

        if ( strlen($filters->isListener) > 0 )
        {
            $sql .= ' AND isListener = ? ';
            $params[] = $filters->isListener;
        }

        $sql .= ' ORDER BY sequence ';

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        return $result;
    }

    // Verificar!!!!!!!!!!!!!!!!!!!
    // FIXME: Add comment
    /**
     * Enter description here...
     *
     * @param unknown_type $contractId
     * @param unknown_type $learningPeriodId
     * @return unknown
     */
    public function getPeriodRestantParcels($contractId, $learningPeriodId)
    {
        $MIOLO = MIOLO::getInstance();
        $module = 'academic';

        $busLearningPeriod = new BusinessAcademicBusLearningPeriod();
        $learningPeriodData = $busLearningPeriod->getLearningPeriod($learningPeriodId);

        $sql = 'SELECT count(months)
                  FROM (SELECT DISTINCT EXTRACT(MONTH FROM maturitydate) as months
                          FROM finincomeforecast
                         WHERE contractid = ?
                           AND isprocessed = \'' . DB_FALSE . '\'
                           AND maturityDate BETWEEN TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\') AND
                                                    TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')) AS sel';

        $params = array( $contractId,
                       $learningPeriodData->beginDate,
                       $learningPeriodData->endDate );

        $restantParcels = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        return $restantParcels[0][0];
    }

    // Verificar!!!!!
    // FIXME: Add comment
    /**
     * Enter description here...
     *
     * @param unknown_type $data
     * @return unknown
     */
    public function updateCurriculumFromEnroll($data)
    {
        $sql = 'UPDATE acdEnroll
                   SET curriculumId = ?
                 WHERE enrollId = ?';

        $params = array( $data->curriculumId,
                       $data->enrollId );

        $result = $this->execute(SAGU::prepare($sql, $params));

        return $result;
    }

    /**
     * Function that return info curriculum
     *
     * @param integer $curriculumId
     * @return object
     */
    public function getCurriculumData($curriculumId)
    {
        $sql = 'SELECT curriculumId,
                       curricularComponentId,
                       curricularComponentVersion
                  FROM unit_acdcurriculum
                 WHERE curriculumId = ?';

        $params = array( $curriculumId );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        $data = new stdClass();
        list( $data->curriculumId,
              $data->curricularComponentId,
              $data->curricularComponentVersion ) = $result[0];

        return $data;
    }


    /**
     * Function to get the total of pupils enrolled by course on a period
     *
     * @param (object) $filter: object with the search filters
     */
    public function searchPupilsEnrolledByCourseSynthetic( $filter )
    {
        $sql = 'SELECT A.courseid,
                       getcoursename(A.courseid),
                       A.courseversion,
                       A.unitId,
                       getunitdescription(A.unitId),
                       A.turnId,
                       getturndescription(A.turnId),
                       count(A.contractId)
                  FROM unit_acdContract A
                 WHERE EXISTS (SELECT AA.contractId
                                 FROM unit_acdEnroll AA
                           INNER JOIN unit_acdGroup BB
                                   ON (BB.groupId = AA.groupId)
                           INNER JOIN unit_acdlearningperiod CC
                                   ON (CC.learningPeriodId = BB.learningPeriodId)
                                WHERE AA.contractId = A.contractId
                                  AND AA.statusid = ' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED') . '';

        if ( strlen($filter->periodId) > 0 )
        {
            $sql .= ' AND CC.periodId = ? ';
            $params[] = $filter->periodId;
        }
        if ( strlen($filter->beginDateEnroll) > 0 && strlen($filter->endDateEnroll) > 0 )
        {
            $sql .= ' GROUP BY 1 HAVING MIN(AA.dateEnroll) BETWEEN TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\') AND
                                                                   TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\') ';
            $params[] = $filter->beginDateEnroll;
            $params[] = $filter->endDateEnroll;
        }
        elseif ( strlen($filter->beginDateEnroll) > 0 )
        {
            $sql .= ' GROUP BY 1 HAVING MIN(AA.dateEnroll) >= TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\') ';
            $params[] = $filter->beginDateEnroll;
        }
        elseif ( strlen($filter->endDateEnroll) > 0 )
        {
            $sql .= ' GROUP BY 1 HAVING MIN(AA.dateEnroll) <= TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\') ';
            $params[] = $filter->endDateEnroll;
        }

        $sql .= ' ) ';

        if ( strlen($filter->courseId) > 0 )
        {
            $sql .= ' AND A.courseid = ? ';
            $params[] = $filter->courseId;
        }
        if ( strlen($filter->courseVersion) > 0 )
        {
            $sql .= ' AND A.courseVersion = ? ';
            $params[] = $filter->courseVersion;
        }
        if ( strlen($filter->turnId) > 0 )
        {
            $sql .= ' AND A.turnId = ? ';
            $params[] = $filter->turnId;
        }
        if ( strlen($filter->unitId) > 0 )
        {
            $sql .= ' AND A.unitId = ? ';
            $params[] = $filter->unitId;
        }
        if ( strlen($filter->classId) > 0 )
        {
            $sql .= ' AND getcontractclassid(A.contractId) = ? ';
            $params[] = $filter->classId;
        }

        $sql .= ' GROUP BY 1, 2, 3, 4, 5, 6, 7
                  ORDER BY 1, 2, 3, 4, 5, 6, 7';

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        return $result;
    }

    /**
     * Function to get the pupils enrolled by course on a period
     *
     * @param (object) $filter: object with the search filters
     */
    public function searchPupilsEnrolledByCourseAnalytical( $filter )
    {
        $sql = 'SELECT TO_CHAR(MIN(C.dateEnroll), \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                       A.courseid,
                       getcoursename(A.courseid),
                       A.courseversion,
                       A.unitId,
                       getunitdescription(A.unitId),
                       A.turnId,
                       getturndescription(A.turnId),
                       A.personId,
                       getpersonname(A.personId),
                       getcontractclassid(A.contractId) as classId
                  FROM unit_acdContract A
            INNER JOIN unit_acdEnroll C
                    ON (C.contractId = A.contractId)
            INNER JOIN unit_acdGroup D
                    ON (D.groupId = C.groupId)
            INNER JOIN unit_acdlearningperiod E
                    ON (E.learningPeriodId = D.learningPeriodId)
                 WHERE C.statusid = ' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED') . '';

        if ( strlen($filter->periodId) > 0 )
        {
            $sql .= ' AND E.periodId = ? ';
            $params[] = $filter->periodId;
        }
        if ( strlen($filter->courseId) > 0 )
        {
            $sql .= ' AND A.courseid = ? ';
            $params[] = $filter->courseId;
        }
        if ( strlen($filter->courseVersion) > 0 )
        {
            $sql .= ' AND A.courseVersion = ? ';
            $params[] = $filter->courseVersion;
        }
        if ( strlen($filter->turnId) > 0 )
        {
            $sql .= ' AND A.turnId = ? ';
            $params[] = $filter->turnId;
        }
        if ( strlen($filter->unitId) > 0 )
        {
            $sql .= ' AND A.unitId = ? ';
            $params[] = $filter->unitId;
        }
        if ( strlen($filter->classId) > 0 )
        {
            $sql .= ' AND getcontractclassid(A.contractId) = ? ';
            $params[] = $filter->classId;
        }

        $sql .= ' GROUP BY 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ';

        if ( strlen($filter->beginDateEnroll) > 0 && strlen($filter->endDateEnroll) > 0 )
        {
            $sql .= ' HAVING MIN(C.dateEnroll) BETWEEN TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\') AND
                                               TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\') ';
            $params[] = $filter->beginDateEnroll;
            $params[] = $filter->endDateEnroll;
        }
        elseif ( strlen($filter->beginDateEnroll) > 0 )
        {
            $sql .= ' HAVING MIN(C.dateEnroll) >= TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\') ';
            $params[] = $filter->beginDateEnroll;
        }
        elseif ( strlen($filter->endDateEnroll) > 0 )
        {
            $sql .= ' HAVING MIN(C.dateEnroll) <= TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\') ';
            $params[] = $filter->endDateEnroll;
        }

        $sql .= ' ORDER BY 2,7,10';

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        return $result;
    }

    /**
     * @deprecated: utilizar o type AcdEnroll
     * Obtem as diciplinas disponiveis para a matricula para uma turma em um semestre
     * 
     * @param type $contractId
     * @param type $classId
     * @param type $learningPeriodId
     * @return Array of stdClass 
     */
    public function getGroupsAvailableForEnroll($contractId, $classId, $learningPeriodId, $classPeriod = null)
    {
        $acdEnroll = new AcdEnroll();
        return $acdEnroll->getGroupsAvailableForEnroll($contractId, $classId, $learningPeriodId, null, null, null, null, null, null, true, null, null, $classPeriod);
    }

    public function getScheduleOccurrenceDatesByBeginAndEndHour($groupId)
    {
        // Get curricular component schedule
        $sql = 'SELECT A.beginHour,
                       A.endHour,
                       ARRAY_TO_STRING(ARRAY_AGG(TO_CHAR(A.occurrenceDate, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')), \', \')
                  FROM (SELECT B.beginHour,
                               B.endHour,
                               A.occurrenceDate
                          FROM (SELECT scheduleId,
                                       UNNEST(occurrenceDates) AS occurrenceDate,
                                       UNNEST(timeIds) AS timeId
                                  FROM acdSchedule
                                 WHERE groupId = ?) A
                    INNER JOIN acdTime B
                            ON B.timeId = A.timeId
                      ORDER BY A.occurrenceDate) A
                      GROUP BY A.beginHour, A.endHour
                      ORDER BY A.beginHour';

        $params = array($groupId);

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        return $result;
    }

    public function getScheduleBeginAndEndHoursByWeekDay($groupId)
    {
        // Get curricular component schedule
        $sql = 'SELECT A.dayOfWeek,
                       ARRAY_TO_STRING(ARRAY_AGG(A.times), \'<br />\')
                  FROM (SELECT A.dayOfWeek,
                               TO_CHAR(B.beginHour, \'HH24:mi\') || \' - \' || TO_CHAR(B.endHour, \'HH24:mi\') AS times
                          FROM (SELECT DISTINCT EXTRACT(DOW FROM UNNEST(occurrenceDates)) AS dayOfWeek,
                                       UNNEST(timeIds) AS timeId
                                  FROM acdSchedule
                                 WHERE groupId = ?) A
                    INNER JOIN acdTime B
                            ON B.timeId = A.timeId
                      ORDER BY A.dayOfWeek, B.beginHour) A
                      GROUP BY A.dayOfWeek';

        $params = array($groupId);

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        $krono = new MKrono();
        for ( $i=0; $i<count($result); $i++ )
        {
            $result[$i][0] = $krono->NToDay($result[$i][0]);
        }

        return $result;
    }
    
    public function getScheduleBeginAndEndHoursByWeekDayForEnrollWeb($groupId)
    {
        $schedules = array();
        if ( strlen($groupId) > 0 )
        {
            $krono = new MKrono();

            // Obter os schedulesids da disciplina
            $sql = " SELECT scheduleid FROM acdschedule WHERE groupid = $groupId ORDER BY 1";
            $schedules = $this->getDatabase()->query($sql);
        }
        
        $result = array();
        foreach ( $schedules as $schedule )
        {
            // Obter os dias para cada scheduleid
            $sql = " SELECT DISTINCT EXTRACT(DOW FROM UNNEST(occurrenceDates)) 
                       FROM acdSchedule
                      WHERE scheduleid = {$schedule[0]}
                   ORDER BY 1 ";
                      
            $days = $this->getDatabase()->query($sql);
            
            // Obter as horas para cada scheduleid
            $sql = " SELECT DISTINCT TO_CHAR(B.beginHour, 'HH24:mi'), TO_CHAR(B.endHour, 'HH24:mi')
                           FROM acdSchedule A
                     INNER JOIN acdTime B
                             ON B.timeId = ANY(A.timeIds)
                          WHERE A.scheduleid = {$schedule[0]}
                       ORDER BY 1 ";

            $hours = $this->getDatabase()->query($sql);
            
            $result[$schedule[0]] = '';
            foreach ( $days as $day )
            {
                $horarios = array();
                foreach ( $hours as $hour )
                {
                    $horarios[] = $hour[0] . ' - ' . $hour[1] . (' - ' .  $krono->NToDay($day[0]));
                }
                
                $result[$schedule[0]] .= implode ('<br>', $horarios) . '<br>';
            }
        }
        
        return $result;        
    }

	public function getScheduleBeginAndEndHours($groupId)
    {
        $sql = 'SELECT A.dayOfWeek,
                               TO_CHAR(B.beginHour, \'hh:mi\') , TO_CHAR(B.endHour, \'hh:mi\') AS times
                          FROM (SELECT DISTINCT EXTRACT(DOW FROM UNNEST(occurrenceDates)) AS dayOfWeek,
                                       UNNEST(timeIds) AS timeId
                                  FROM acdSchedule
                                 WHERE groupId = ?) A
                    INNER JOIN acdTime B
                            ON B.timeId = A.timeId
                      ORDER BY A.dayOfWeek, B.beginHour';

        $params = array($groupId);

        $result = $this->db->query(SAGU::prepare($sql, $params));

        $krono = new MKrono();
        for ( $i=0; $i<count($result); $i++ )
        {
            $result[$i][0] = $krono->NToDay($result[$i][0]);
        }

        return $result;
    }

    
    public function getGroupProfessor($groupId, $somenteEmExercicio = FALSE)
    {
        // Get curricular component schedule
        $sql = 'SELECT DISTINCT C.personId, C.name
                          FROM acdScheduleProfessor A
                    INNER JOIN acdSchedule B
                            ON B.scheduleId = A.scheduleId
                    INNER JOIN basPhysicalPersonProfessor C
                            ON C.personId = A.professorId
                         WHERE B.groupId = ? ';
        
        $params[] = $groupId;
        
        if ( $somenteEmExercicio )
        {
            $sql .= ' AND C.situacao = ? ';
            $params[] = BasPhysicalPersonProfessor::SITUACAO_EM_EXERCICIO;
        }
        
        $sql .= ' ORDER BY C.name ';

        $result = $this->db->query(SAGU::prepare($sql, $params));
        return $result;
    }

    public function getGroupProfessors($groupId)
    {
        // Get curricular component schedule
        $sql = 'SELECT ARRAY_TO_STRING(ARRAY_AGG(A.name), \'<br />\')
                  FROM (SELECT DISTINCT C.name
                          FROM acdScheduleProfessor A
                    INNER JOIN acdSchedule B
                            ON B.scheduleId = A.scheduleId
                    INNER JOIN basPhysicalPersonProfessor C
                            ON C.personId = A.professorId
                         WHERE B.groupId = ?
                      ORDER BY C.name) A';

        $params = array($groupId);

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        return $result;
    }

    /**
     * @deprecated: Utilizar o type AcdEnroll
     * Obtem as disciplinas pendentes, que nao foram cursadas no semestre
     * 
     * @param type $contractId
     * @param type $semester
     * @return Array 
     */
    public function getPendingCurriculumIds($contractId, $semester)
    {
        $acdEnroll = new AcdEnroll();
        return $acdEnroll->getPendingcurriculumIds($contractId, $semester);
    }
    
    /**
     * @deprecated: Utilizar o type AcdEnroll
     * Obtem as disciplinas reprovadas
     * 
     * @param type $contractId
     * @param type $semester
     * @return Array 
     */
    public function getDisaprovedCurriculumIds($contractId)
    {
        $acdEnroll = new AcdEnroll();
        return $acdEnroll->getDisaprovedCurriculumIds($contractId);
    }

    /**
     * Get the last known enroll status of a curriculum id for a specified contract id.
     *
     * @param $contractId
     * @param $curriculumId
     * @return Returns an instance of AcdEnroll when last state found. Otherwise, null.
     */
    public function getLastEnrollByCurriculumId($contractId, $curriculumId)
    {
        $sql = 'SELECT enrollId
                  FROM unit_acdEnroll
                 WHERE contractId = ?
                   AND curriculumId = ?
              ORDER BY dateEnroll DESC,
                       hourEnroll DESC
                 LIMIT 1';

        $params = array($contractId, $curriculumId);
        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        $retVal = null;
        if ( strlen($result[0][0]) > 0 )
        {
            $retVal = $this->getEnroll($result[0][0]);
        }

        return $retVal;
    }
    
    
    public function getLastEnrollByGroupId($contractId, $groupId)
    {
        $sql = 'SELECT enrollId
                  FROM acdEnroll
                 WHERE contractId = ?
                   AND groupid = ?
              ORDER BY dateEnroll DESC,
                       hourEnroll DESC
                 LIMIT 1';

        $params = array($contractId, $groupId);
	
        $result = $this->db->query(SAGU::prepare($sql, $params));

        $retVal = null;
        if ( strlen($result[0][0]) > 0 )
        {
		$retVal->enrollId = $result[0][0];
		$retVal->curriculumId = $result[0][1];
		$retVal->curricularComponentId = $result[0][2];
        }

        return $retVal;
    }

    /**
     * Get all enroll ids of the specified contract in the specified learning period
     *
     * @param $contractId
     * @param $learningPeriodId
     * @param (integer) $minimumSemester Indicates that only enroll for curriculums belonging to the specified
     * semester or a later one will be returned.
     * @return (array) Array with desired data or null, if no data found.
     */
    public function getEnrollByLearningPeriod($contractId, $learningPeriodId, $minimumSemester = null, $groupId=null, $maxSemester=false)
    {
        $sql = 'SELECT A.enrollId,
                       A.curriculumId,
                       A.groupId
                  FROM unit_acdEnroll A
            INNER JOIN unit_acdGroup B
                    ON (B.groupId = A.groupId)
            INNER JOIN unit_acdlearningperiod C
                    ON (C.learningPeriodId = B.learningPeriodId)
            INNER JOIN unit_acdcurriculum D
                    ON D.curriculumId = A.curriculumId
                 WHERE A.contractId = ?
                   AND A.statusId IN (' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED') . ')
                   AND C.periodId IN (SELECT periodId
                                        FROM unit_acdlearningperiod
                                       WHERE learningPeriodId = ?)';

        $params = array( $contractId, $learningPeriodId );
        
        if ( !is_null($groupId) )
        {
            $sql .= ' AND A.groupId = ?';
            $params[] = $groupId;
        }
        
        if ( strlen($minimumSemester) > 0 )
        {
            $sql .= ' AND D.semester >= ?';
            $params[] = $minimumSemester;
        }
        
        if ( $maxSemester )
        {
            $sql .= ' AND D.semester < ( SELECT MAX(B.semester)
                                           FROM unit_acdGroup A 
                                     INNER JOIN unit_acdCurriculum B 
                                             ON A.curriculumid = B.curriculumid 
                                     INNER JOIN unit_acdEnroll D 
                                             ON A.groupid = D.groupid 
                                          WHERE contractid = ?
                                            AND A.learningPeriodid = ? )';
            $params[] = $contractId;
            $params[] = $learningPeriodId;
        }

        return $this->getDatabase()->query(SAGU::prepare($sql, $params));
    }

    /**
     * Analyse all enroll data to ensure that the enroll can be inserted.
     *
     * @param (integer) $contractId
     * @param (integer) $learningPeriodId
     * @param (array) $groups Array where each key is the group id and each value is the curriculum associated to that group id.
     * @return (boolean) True when enroll can be done. False if any problems found.
     */
    public function checkEnrollData($contractId, $learningPeriodId, $groups , $maxCredits = null)
    {
        $MIOLO = MIOLO::getInstance();
        $busContract = new BusinessAcademicBusContract();
        $contract = $busContract->getContract($contractId);
        
        $matricula = new Matricula($contractId, Matricula::MATRICULA_NORMAL);
        $enrollConfig = $matricula->obterConfiguracoes();

        $busGroup = new BusinessAcademicBusGroup();
        $busConcurrence = new BusinessAcademicBusCurriculumConcurrence();
        $busCurriculum = new BusinessAcademicBusCurriculum();
        $busLearningPeriod = new BusinessAcademicBusLearningPeriod();
        $busCondition = new BusinessAcademicBusCondition();

        $groupIds = array_keys($groups);
        // Testar cada groupId com todos os outros groupIds
        for ( $i=0; $i<count($groupIds); $i++ )
        {
            // Verificar requisitos (pré e co)
            $filters = new stdClass();
            $filters->curriculumId = $groups[$groupIds[$i]];
            $condition = $busCondition->searchCondition($filters);

            for ( $j=$i+1; $j<count($groupIds); $j++ )
            {
                // Choque de horário
                if ( $enrollConfig->checkScheduleShock == DB_TRUE )
                {
                    $hasShock = $this->hasShockingSchedule($groupIds[$i], $groupIds[$j]);
                    
                    // Verificar se os horários de uma oferecida conflitam com a outra
                    if ( $hasShock )
                    {
                        $hasShock = $this->naoPossuiDesbloqueioPorChoque($contractId, $learningPeriodId, $groups[$groupIds[$i]], $groups[$groupIds[$j]]);
                            
                        if ( $hasShock )
                        {
                            $group1 = $busGroup->getGroup($groupIds[$i]);
                            $group1Data = $group1->curriculumCurricularComponentId . '/' . $group1->curriculumCurricularComponentVersion . ' - ' . $group1->curriculumCurricularComponentName;

                            $group2 = $busGroup->getGroup($groupIds[$j]);
                            $group2Data = $group2->curriculumCurricularComponentId . '/' . $group2->curriculumCurricularComponentVersion . ' - ' . $group2->curriculumCurricularComponentName;

                            $this->errors[] = _M('Disciplinas @1 e @2 possuem conflito de horário.', $this->module, $group1Data, $group2Data);
                        }
                    }                    
                }

                // Verificar se existe concorrência de currículo
                if ( $busConcurrence->hasCurriculumConcurrence($groups[$i], $groups[$j]) )
                {
                    // Se existe concorrência, verificar algum se tratam de eletivas. Neste caso, ignorar concorrência.
                    $dataCurriculum1 = $busCurriculum->getCurriculum($groups[$i]);
                    $dataCurriculum2 = $busCurriculum->getCurriculum($groups[$j]);

                    if ( ! ($dataCurriculum1->curricularComponentTypeId == SAGU::getParameter('ACADEMIC', 'CURRICULAR_COMPONENT_TYPE_ELECTIVE')) ||
                           ($dataCurriculum2->curricularComponentTypeId == SAGU::getParameter('ACADEMIC', 'CURRICULAR_COMPONENT_TYPE_ELECTIVE')) )
                    {
                        $group1 = $busGroup->getGroup($groupIds[$i]);
                        $group1Data = $group1->curriculumCurricularComponentId . '/' . $group1->curriculumCurricularComponentVersion . ' - ' . $group1->curriculumCurricularComponentName;

                        $group2 = $busGroup->getGroup($groupIds[$j]);
                        $group2Data = $group2->curriculumCurricularComponentId . '/' . $group2->curriculumCurricularComponentVersion . ' - ' . $group2->curriculumCurricularComponentName;

                        $this->errors[] = _M('As disciplinas @1 e @2 são concorrentes, portanto apenas uma delas pode ser cursada.', $this->module, $group1Data, $group2Data);
                    }
                }
            }
        }

        $data = new stdClass();
        $data->contractId = $contractId;
        $data->learningPeriodId = $learningPeriodId;
        $data->groupId = $groups;
        $data->maxDiscCredits = $maxCredits;

        $learningPeriod = $busLearningPeriod->getLearningPeriod($learningPeriodId);

        // Se a checagem de quantidades mínimas e máximas deve ser feita com base em horas
        // ou com base em número de créditos
        if ( $learningPeriod->isNumberHours == DB_TRUE )
        {
            // Número mínimo de horas totais nos quais o aluno deve se matricular
            if ( ! $this->checkMinimumHoursCondition($data) )
            {
                $this->errors[] = _M('Número mínimo de horas não alcançado.', $this->module);
            }

            // Número mínimo de horas totais nos quais o aluno deve se matricular
            if ( $this->exceedsMaximumNumberOfHours($data) )
            {
                $this->errors[] = _M('Número máximo de horas excedido.', $this->module);
            }

            // Número mínimo de horas totais nos quais o aluno deve se matricular no seu turno
            if ( ! $this->checkTurnMinimumHoursCondition($data) )
            {
                $this->errors[] = _M('Número mínimo de horas por turno não alcançado.', $this->module);
            }
        }
        else
        {
            $busLearning = new BusinessAcademicBusLearningPeriod(); 
            $learningPeriod = $busLearning->getLearningPeriod($data->learningPeriodId);

            if($learningPeriod->matriculasemminimodecreditos == DB_TRUE)
            {
                // Número mínimo de créditos totais nos quais o aluno deve se matricular
                if ( ! $this->checkMinimumCreditsCondition($data) )
                {
                    $this->errors[] = _M('Número mínimo de créditos não atingido. Para realizar a matrícula selecione o máximo de disciplinas possíveis.', $this->module);
                }
            }
            else
            {
                // Número mínimo de créditos totais nos quais o aluno deve se matricular
                if ( ! $this->checkMinimumCreditsCondition($data) )
                {
                    $this->errors[] = _M('Número mínimo de créditos não atingido.', $this->module);
                }
            }

            // Número máximo de créditos totais nos quais o aluno pode se matricular
            if ( $this->exceedsMaximumNumberOfCredits($data) )
            {
                $this->errors[] = _M('Número máximo de créditos excedido.', $this->module);
            }

            // Número mínimo de créditos totais nos quais o aluno deve se matricular no seu turno
            if ( ! $this->checkTurnMinimumCreditsCondition($data) )
            {
                $this->errors[] = _M('Número mínimo de créditos no turno não atingido.', $this->module);
            }
        }

        // Número máximo de reprovações para bloquear a matrícula
        if ( $learningPeriod->maximumDisapprovals > 0 )
        {
            $disapprovementsCurriculumIds = $this->getContractDisapprovements($contractId, $learningPeriodId);

            if ( count($disapprovementsCurriculumIds) > $learningPeriod->maximumDisapprovals )
            {
                $this->errors[] = _M('Número máximo de dependências atingido. O aluno deve cursar as dependências antes.', $this->module);
            }
        }
        
        return (count($this->errors) == 0);
    }
    
    /**
     * Retorna true, caso o contrato não possua desbloqueio por choque de horários.
     * 
     * @param int $contractId
     * @param int $learningPeriodId
     * @param int $curriculumId1
     * @param int $curriculumId2
     * @return boolean
     */
    public function naoPossuiDesbloqueioPorChoque($contractId, $learningPeriodId, $curriculumId1, $curriculumId2)
    {
        $businessScheduleShock = new BusinessAcademicBusScheduleShockUnblock();
        
        // Seta que possui choque por padrão.
        $hasShock = true;
        
        // Verifica se o contrato possui desbloqueio de choque para uma das disciplinas (curriculumId) com choque
        if ( $this->isScheduleShock($contractId, $learningPeriodId, $curriculumId1) ||
             $this->isScheduleShock($contractId, $learningPeriodId, $curriculumId2) )
        {
            $hasShock = false;
        }

        if ( $hasShock )
        {   
            $filters1 = new stdClass();
            $filters1->curriculumId = $curriculumId1;
            $substitutionData1 = $this->getSubstitutionData($filters1, $contractId, $learningPeriodId);

            $scheduleShockFilters = new stdClass();
            $scheduleShockFilters->contractId = $contractId;
            $scheduleShockFilters->learningPeriodId = $learningPeriodId;
            $scheduleShockFilters->curricularComponentId = $substitutionData1->curricularComponentId;
            $scheduleShockFilters->curricularComponentVersion = $substitutionData1->curricularComponentVersion;
            $scheduleShockFilters->isScheduleShock = DB_TRUE;

            $scheduleShock1 = $businessScheduleShock->search($scheduleShockFilters);

            $filters2 = new stdClass();
            $filters2->curriculumId = $curriculumId2;
            $substitutionData2 = $this->getSubstitutionData($filters2, $contractId, $learningPeriodId);

            $scheduleShockFilters->curricularComponentId = $substitutionData2->curricularComponentId;
            $scheduleShockFilters->curricularComponentVersion = $substitutionData2->curricularComponentVersion;

            $scheduleShock2 = $businessScheduleShock->search($scheduleShockFilters);   

            // Se ainda possui choque de horários, verifica as substitutas.
            if ( $this->isScheduleShock($contractId, $learningPeriodId, $scheduleShock1[0][3]) ||
                 $this->isScheduleShock($contractId, $learningPeriodId, $scheduleShock2[0][3]) )
            {
                $hasShock = false;
            }
        }
        
        return $hasShock;
    }
    
    /*
     * 
     * 
     */
    public function vagancy($groupId, $isWebSrvices = false)
    {
        $acdCurriculum = "unit_acdCurriculum";
        
        // Para webservices.
        if ( $isWebServices )
        {
            $acdCurriculum = "acdCurriculum";
        }    
        
        $sql = "SELECT G.groupId,
                       B.name AS curricularComponentName,
                       A.semester,
                       G.totalEnrolled,
                       G.vacant,
                       -- Realizado validação devido ao alterar parâmetro de configuração a trigger não recalcular as vagas
                       ((SELECT count(enrollId) 
                           FROM acdenroll 
                          WHERE groupId = G.groupId 
                            AND statusid <> (getparameter('ACADEMIC', 'ENROLL_STATUS_CANCELLED')::int)
                            AND (CASE WHEN statusId = GETPARAMETER('ACADEMIC', 'ENROLL_STATUS_PRE_ENROLLED')::int THEN
                                         preEnrollConsumeVacant IS NOT FALSE
                                     ELSE
                                         1=1
                                 END)
                         )::text) as matriculados
                  FROM {$acdCurriculum} A
            INNER JOIN acdCurricularComponent B
                    ON (B.curricularComponentId = A.curricularComponentId AND
                        B.curricularComponentVersion = A.curricularComponentVersion)
            INNER JOIN acdCurricularComponentType C
                    ON (C.curricularComponentTypeId = A.curricularComponentTypeId)
            INNER JOIN acdCurriculumType D
                    ON (D.curriculumTypeId = A.curriculumTypeId)
            INNER JOIN acdGroup G
                    ON G.curriculumId = A.curriculumId
                 WHERE G.groupId = ?
              ORDER BY A.semester, B.name";

        $params = array($groupId);

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));
        
        return $result;
        
    }

   /**
     * Process all enroll data in order to insert a new enroll or update an existing one.
     *
     * @param (integer) $contractId Id of the contract whose enroll is being done.
     * @param (integer) $learningPeriodId Id of the learning period where the enroll is being done.
     * @param (array) $groups Array where each key is the group id and each value is the curriculum associated to that group id. Ex.: array( array( GROUPID_1 => CURRICULUMID_1 ), array( GROUPID_2 => CURRICULUMID_2 ) )
     * @param (boolean) $disableEnrollCheck Whether enroll checks (schedule shock, minimum credits, etc) are enabled or not.
     * @param (boolean) $isCanceled - Informa que a operação é cancelamento de disciplina.
     * @param (boolean) $isAddition - Informa se é operacao de acrescimo de disciplina.
     * @return (stdClass) An object containing all generated data
     */
    public function enroll($contractId, $learningPeriodId, $groups, $disableEnrollCheck = false, $isCanceled = false, $isAddition = false, $isAdaptation=false, $isReprovacao=false, $isWebServices = false, $originEnroll, $maxCredits = null)
    {
        $enrollData = new stdClass();
        $enrollData->contractId = $contractId;
        $enrollData->learningPeriodId = $learningPeriodId;
        $enrollData->groupId = $groups;
        $enrollData->originEnroll = $originEnroll;
        $action = MIOLO::getCurrentAction();
        
        //Período letivo
        $busLearningPeriod = new BusinessAcademicBusLearningPeriod();
        $learningPeriodData = $busLearningPeriod->getLearningPeriod($learningPeriodId);
        
        $stateContract = BusinessAcademicBusStateContract::getCurrentStateContractId($contractId, $learningPeriodId);
        
        // Para reajuste de pré-matrícula.
        //Não é necessário fazer ajuste de pré-matrícula para acréscimo de disciplinas manual.
        if ( $stateContract == SAGU::getParameter('ACADEMIC', 'STATE_CONTRACT_ID_PRE_ENROLL') && $action != 'main:process:enrolladdition')
        {
            $this->ajustePreMatricula($enrollData);
        }
                
        $busContract = new BusinessAcademicBusContract();
        $eCalouro = ($busContract->isFreshmanByPeriod($contractId, $learningPeriodData->periodId)) ? DB_TRUE : DB_FALSE;
        
        // Leave parcelsNumber blank to force following RN_0001
        $enrollData->parcelsNumber = '';

        $MIOLO = MIOLO::getInstance();
        $module = 'academic';
        $return = null;
                
        if (count($groups) == 0)
        {
            throw new Exception(_M('Nenhuma disciplina informada. Por favor, selecione pelo menos uma disciplina.', $module));
        }

        try
        {            
            // Passa todos os dados de matrícula para uma função que verificará eventuais problemas que impeçam a matrícula
            if ( !$disableEnrollCheck )
            {
                foreach($groups as $groupId => $val)
                {
                    //Busca disciplinas
                    $vagas = $this->vagancy($groupId, $isWebServices);
                    
                    //Verifica se existe vagas para disciplina 
                    foreach ( $vagas as $vaga )
                    {   
                        if(($vaga[4] - $vaga[5]) < 1)
                        {    
                            if ( !$this->isEnrolledByGroup($groupId, $contractId) )
                            {
                                $msg .= '<br />' ._M("Disciplina oferecida {$vaga[0]} - {$vaga[1]} está com vagas lotadas.", $this->module); 

                                throw new Exception($msg);
                            }
                        }
                    }
                }
                
                if ( ! $this->checkEnrollData($contractId, $learningPeriodId, $groups, $maxCredits) )
                {
                    $msg = _M('Não foi possível efetuar a matrícula pelos seguintes motivos:', $this->module);
                    for ( $i=0; $i<count($this->errors); $i++ )
                    {
                        $msg .= '<br />- ' . $this->errors[$i];
                    }
                    $msg .= '<br />' . _M('Resolva os problemas e tente novamente.', $this->module);

                    throw new Exception($msg);
                }
            }

            $contract = $busContract->getContract($contractId, $isWebServices);
           
            $busCourseVersion = new BusinessAcademicBusCourseVersion();
            $courseVersion = $busCourseVersion->getCourseVersion($contract->courseId, $contract->courseVersion);

            $busLearningPeriod = new BusinessAcademicBusLearningPeriod();
            $learningPeriod = $busLearningPeriod->getLearningPeriod($learningPeriodId, $isWebServices);         

            $matricula = new Matricula($contractId, Matricula::MATRICULA_NORMAL);
            $enrollConfig = $matricula->obterConfiguracoes();
            
            // Verifica se é matrícula normal, matrícula para os bixos ou reajuste
            $businessPeriodEnrollDate = new BusinessAcademicBusPeriodEnrollDate();
            $periodEnrollDate = $businessPeriodEnrollDate->getCurrentPeriodEnrollDate($learningPeriodId, $isWebServices);
            $busFunctions = new BusinessBasicBusFunctions();

            /*
             * AJUSTE DE MATRÍCULAS e MATRÍCULA FORA DE PERÍODO (para funcionários)
             * ou
             * Cancelamento de disciplina
             */
            $dateNow = date(SAGU::getParameter('BASIC', 'MASK_DATE_PHP'));
            $isBetweenDates = $busFunctions->isBetweenDates($dateNow, $periodEnrollDate->beginDate, $periodEnrollDate->endDate, SAGU::getParameter('BASIC', 'MASK_DATE'));
            $isAdjustment = strtoupper($periodEnrollDate->isAdjustment) == strtoupper(DB_TRUE);
            if ( !$isAddition && ( $isAdjustment || !$isBetweenDates || $isCanceled ) )
            {   
                $this->updatePersonEnrollNew($enrollData, $isAdaptation, $isReprovacao, $isWebServices);
            }
            // MATRÍCULAS PARA CALOUROS(PROCESSO SELETIVO)
            elseif ( strtoupper($periodEnrollDate->isSelectiveProc) == DB_TRUE )
            {   
                $enrollData->reasonId = SAGU::getParameter('ACADEMIC', 'SELECTIVE_PROCESS_REASON_ID');
                $this->insertPersonEnrollNew($enrollData, $isAddition, $isWebServices);
            }
            // MATRÍCULAS PARA VETERANOS
            else
            {   
                $enrollData->reasonId = SAGU::getParameter('ACADEMIC', 'OLDER_REASON_ID');
                $this->insertPersonEnrollNew($enrollData, $isAddition, $isWebServices);
            }
            
            // Caso esteja definido para o semestre ser equivalente a carga horária cursada.
            $acdSemesterContractPeriod = new AcdSemesterContractPeriod(null, $contractId, $learningPeriod->periodId);
            $acdSemesterContractPeriod->atualizaSemestreDoContrato();
                        
            if ( SAGU::getParameter('BASIC', 'MODULE_FINANCE_INSTALLED') == 'YES' )
            {
                if ( $learningPeriod->isFinanceGenerate == DB_TRUE )
                {                    
                    $busRecInvoice = new BusinessFinanceBusReceivableInvoicePupil();

                    //FIXME: Verifica parâmetro que habilita regra de negócio específica
                    if ( SAGU::getParameter('BASIC', 'ENABLE_BUSINESS_USER') > '0' )
                    {
                        $busRecInvoice = new BusinessFinanceBusReceivableInvoicePupilUser();
                    }
                    
                    $invoices = $busRecInvoice->generateReceivableInvoicesFromEnrollSummaries($contract->contractId, $learningPeriod->learningPeriodId, $eCalouro, $isWebServices);                                               

                    // Retrieve generated invoices
                    $busReceivableInvoice = new BusinessFinanceBusReceivableInvoice();

                    $busEntry = new BusinessFinanceBusEntry();

                    // Create the invoices entry in enrollData
                    for ( $i=0; $i<count($invoices); $i++ )
                    {
                        $this->enrollData->invoices[$invoices[$i]] = $busReceivableInvoice->getReceivableInvoice($invoices[$i]);
                        $this->enrollData->invoices[$invoices[$i]]->balance = $busReceivableInvoice->getInvoiceBalance($invoices[$i]);
                        $this->enrollData->invoices[$invoices[$i]]->entries = $busEntry->getInvoiceEntries($invoices[$i]);
                        $this->enrollData->invoices[$invoices[$i]]->balanceWithPolicies = $busReceivableInvoice->getInvoiceBalanceWithPolicies($invoices[$i]);
                    }                    
                }
            }
            
            /**
             * Se o estado contratual registrado para o aluno for de pré-matricula,
             * verifica se já deve ser transitado para matriculado.
             */
            if ( $busContract->getContractStateId($contractId) == SAGU::getParameter('ACADEMIC', 'STATE_CONTRACT_ID_PRE_ENROLL') )
            {
                sPreMatricula::confirmacaoDePreMatricula($contractId, $learningPeriodId);
            }
            
            $return = $this->enrollData;
        }
        catch ( Exception $e )
        {
            throw $e;
        }
                
        return $return;
    }
    
    /**
     * Deleta as matrículas e títulos gerados na pré-matrícula para reajuste.
     * 
     * @param type $enrollData
     */
    public function ajustePreMatricula($enrollData)
    {
        $filters = new stdClass();
        $filters->contractId = $enrollData->contractId;
        $filters->learningPeriodId = $enrollData->learningPeriodId;
        $filters->curriculumTypeComplementaryActivity = DB_FALSE;
        
        $enrolls = $this->searchEnroll($filters);
        
        // Deleta as enrolls feitas na pré-matrícula.
        if ( count($enrolls) > 0 )
        {
            foreach ( $enrolls as $enroll )
            {   
                $this->deleteEnroll($enroll[0]);
            }
        }

        //Contrato
        $busContract = new BusinessAcademicBusContract();        
        $contract = $busContract->getContract($enrollData->contractId);

        //Configuração de matrículas
        $enrollConfig = new AcdEnrollConfig();
        $configuracaoMatricula = $enrollConfig->obterVigente($enrollConfig->courseId, $enrollConfig->courseVersion, $enrollConfig->turnId, $enrollConfig->unitId);
        
        /* Somente cancela os títulos se financeiro instalado
         * pré matricula ativada e a confirmação da pré-matricula for pelo pagamento da primeira parcela. 
         */
        if ( SAGU::getParameter('BASIC', 'MODULE_FINANCE_INSTALLED') == 'YES' &&
             $configuracaoMatricula->enablePreEnroll == DB_TRUE &&
             $configuracaoMatricula->preEnrollCheckFirstPayment != 'N')
        {
            $busLearningPeriod = new BusinessAcademicBusLearningPeriod();
            $learningPeriod = $busLearningPeriod->getLearningPeriod($enrollData->learningPeriodId);
        
            if ( $learningPeriod->isFinanceGenerate == DB_TRUE )
            {
                // Deleta os títulos gerados na pré-matrícula.
                $busInvoice = new BusinessFinanceBusInvoice();
                $busInvoice->deletaTitulosParaReajusteDePreMatricula($enrollData->contractId, $enrollData->learningPeriodId);
            }
        }
    }

    /**
     * Get all groups in which the contract is enrolled at $learningPeriodId learning period and simulate
     * an enroll edit. This is useful to automatically recalculate the financial data for that enroll.
     *
     * @param (integer) $contractId Contract id whose enrolls will be edited.
     * @param (integer) $learningPeriodId Learning period whose enrolls will be edited.
     * @param (boolean) $disableEnrollCheck When true, no check for debits, shocking schedule, etc are done.
     * @param (boolean) $isCanceled - Informa que a operação é cancelamento de disciplina.
     */
    public function updateLearningPeriodEnroll($contractId, $learningPeriodId, $disableEnrollCheck = false, $isCanceled = false, $enrolls=null)
    {
        // Get pupil's current enroll
        $enroll = ( !is_null($enrolls) ) ? $enrolls : $this->getEnrollByLearningPeriod($contractId, $learningPeriodId);

        // create an array where keys are group ids and values are the curriculum ids
        // associated with each group id.
        $groups = array();
        for ( $i=0; $i<count($enroll); $i++ )
        {
            $enrollData = new stdClass();
            list ( $enrollData->enrollId,
                   $enrollData->curriculumId,
                   $enrollData->groupId ) = $enroll[$i];

            $groups[$enrollData->groupId] = $enrollData->curriculumId;
        }

        // calling this function is equivalent to editing the pupil's current enroll
        return $this->enroll($contractId, $learningPeriodId, $groups, $disableEnrollCheck, $isCanceled);
    }

    /**
     * Obtém uma lista de matrículas no período e ocorrência de curso selecionados cujo pagamento
     * da primeira parcela não tenha sido efetuado ainda. A ocorrência de curso é opcional.
     *
     * @param (string) $periodId Período a ser pesquisado
     * @param (string) $courseId Curso da ocorrência
     * @param (integer) $courseVersion Versão da ocorrência
     * @param (integer) $turnId Turno da ocorrência
     * @param (integer) $unitId Unidade da ocorrência
     * @param (integer) $contractId Contrato a ser pesquisado
     * @return (array) Array containing all matching records.
     */
    public function searchUnpaidEnrolls($periodId, $courseId = null, $courseVersion = null, $turnId = null, $unitId = null, $contractId = null, $limitDate = null)
    {
        $sql = 'SELECT A.enrollId,
                       F.contractId,
                       G.personId,
                       G.name AS personName,
                       F.courseId,
                       F.courseVersion,
                       H.name AS courseName,
                       I.unitId,
                       I.description AS unitDescription,
                       J.turnId,
                       J.description AS turnDescription,
                       E.invoiceId,
                       TO_CHAR(E.maturityDate, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                       balanceWithPoliciesDated(E.invoiceId, now()::date),
                       G.residentialPhone,
                       G.cellPhone 
                  FROM unit_acdEnroll A
            INNER JOIN unit_acdGroup B
                    ON B.groupId = A.groupId
            INNER JOIN unit_acdLearningPeriod C
                    ON C.learningPeriodId = B.learningPeriodId
            INNER JOIN finEntry D
                    ON D.contractId = A.contractId
            INNER JOIN finReceivableInvoice E
                    ON E.invoiceId = D.invoiceId
            INNER JOIN unit_acdContract F
                    ON F.contractId = A.contractId
            INNER JOIN ONLY basPhysicalPerson G
                    ON G.personId = F.personId
            INNER JOIN acdCourse H
                    ON H.courseId = F.courseId
            INNER JOIN basUnit I
                    ON I.unitId = F.unitId
            INNER JOIN basTurn J
                    ON J.turnId = F.turnId
                 WHERE C.periodId = ?
                   AND E.isCanceled IS FALSE
                   AND balance(E.invoiceId) > 0
                   AND E.maturityDate < now()
                   AND E.parcelNumber = 1
                   AND D.learningPeriodId IN (SELECT learningPeriodId FROM acdLearningPeriod WHERE periodId = C.periodId)';

        // se outra parcela desta matrícula (que não a primeira) já tiver sido
        // paga, não retornar o registro
        $sql .= '  AND NOT EXISTS (SELECT 1
                                     FROM finReceivableInvoice X
                               INNER JOIN finEntry Y
                                       ON Y.invoiceId = X.invoiceId
                                    WHERE X.personId = E.personId
                                      AND Y.learningPeriodId = C.learningPeriodId
                                      AND Y.contractId = F.contractId
                                      AND X.parcelNumber > 1
                                      AND balance(X.invoiceId) = 0)';

        $params = array($periodId);
        if ( strlen($courseId) > 0 && strlen($courseVersion) > 0 && strlen($turnId) > 0 && strlen($unitId) > 0 )
        {
            $sql .= ' AND F.courseId = ?
                       AND F.courseVersion = ?
                       AND F.turnId = ?
                       AND F.unitId = ?';
            $params = array_merge($params, array($courseId, $courseVersion, $turnId, $unitId));
        }

        if ( strlen($contractId) > 0 )
        {
            $sql .= ' AND A.contractId = ?';
            $params[] = $contractId;
        }

        if ( strlen($limitDate) > 0 )
        {
            $sql .= ' AND E.maturityDate <= TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') .  '\')';
            $params[] = $limitDate;
        }

        $sql .= ' ORDER BY G.name, A.contractId, E.maturityDate';

        $retVal = array();

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));
        if ( count($result) > 0 )
        {
            $retVal = $result;
        }

        return $retVal;
    }

    /**
     * Utiliza o método searchUnpaidEnrolls() para localizar todas as matrículas cuja
     * primeira parcela não tenha sido paga e exclui todas as informações relativas a
     * tais matrículas (matrícula, resumos de matrícula, previsões de lançamento e títulos).
     *
     * @param (string) $periodId Período a ser pesquisado
     * @param (string) $courseId Curso da ocorrência
     * @param (integer) $courseVersion Versão da ocorrência
     * @param (integer) $turnId Turno da ocorrência
     * @param (integer) $unitId Unidade da ocorrência
     * @param (integer) $contractId Contrato a ser pesquisado
     * @return (boolean) TRUE se tudo funcionou. Caso contrário, FALSE.
     */
    public function deleteUnpaidEnrolls($periodId, $courseId = null, $courseVersion = null, $turnId = null, $unitId = null, $contractId = null)
    {
        $MIOLO = MIOLO::getInstance();

        $busGroup = new BusinessAcademicBusGroup();
        $busEntry = new BusinessFinanceBusEntry();
        $busReceivableInvoice = new BusinessFinanceBusReceivableInvoice();
        $busIncomeForecast = new BusinessFinanceBusIncomeForecast();
        $busBankAccount = new BusinessFinanceBusBankAccount();
        $busRelease = new BusinessFinanceBusRelease();
        $busDegreeEnroll = new BusinessAcademicBusDegreeEnroll();
        $busFrequenceEnroll = new BusinessAcademicBusFrequenceEnroll();

        $invoices = array();
        $enrollsToDelete = array();
        $learningPeriods = array();

        $enrolls = $this->searchUnpaidEnrolls($periodId, $courseId, $courseVersion, $turnId, $unitId, $contractId);

        // para cada matrícula a ser excluída
        $invoices = array();
        $learningPeriods = array();
        for ( $i=0; $i<count($enrolls); $i++ )
        {
            $enrollId = $enrolls[$i][0];

            $enroll = $this->getEnroll($enrollId);

            $group = $busGroup->getGroup($enroll->groupId);

            $learningPeriodId = $group->learningPeriodId;

            $learningPeriods[$group->learningPeriodId] = $group->learningPeriodId;

            // Gerar lista de títulos a excluir
            $filters = new stdClass();
            $filters->contractId = $contractId;
            $filters->learningPeriodId = $learningPeriodId;
            $entries = $busEntry->searchEntry($filters);

            for ( $j=0; $j<count($entries); $j++ )
            {
                $invoices[$entries[$j][1]] = $entries[$j][1];
            }

            // Excluir somente matrículas com estado MATRICULADO
            if ( in_array($enroll->statusId, array(SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED'), SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_PRE_ENROLLED'))) )
            {
                $enrollsToDelete[$enrollId] = $enrollId;
            }
        }

        // filtrar títulos iguais
        $invoices = array_keys($invoices);

        // filtrar matrículas iguais
        $enrollsToDelete = array_keys($enrollsToDelete);

        // filtrar períodos letivos iguais
        $learningPeriods = array_keys($learningPeriods);

        // zerar contadores para uso de fora da classe
        $this->enrollsDeleted = 0;
        $this->invoicesDeleted = 0;

        // excluir matrículas
        $this->enrollsDeleted = 0;
        for ( $i=0; $i<count($enrollsToDelete); $i++ )
        {
		    $filters = new StdClass();
            $filters->enrollId = $enrollsToDelete[$i];
            
            $degreeEnrolls = $busDegreeEnroll->searchDegreeEnroll($filters);
            
            if ( count($degreeEnrolls) > 0 )
            {
                foreach ($degreeEnrolls as $degreeEnroll)
                {
                    $busDegreeEnroll->deleteDegreeEnroll($degreeEnroll[0]);
                }
            }
            
            $busFrequenceEnroll->deleteFrequenceEnroll($enrollsToDelete[$i]);            

            if ( ! $this->deleteEnroll($enrollsToDelete[$i]) )
            {
                throw new Exception('Não foi possível excluir matrículas do contrato @1.', $module, $contractId);
            }
            $this->enrollsDeleted++;
        }

        // verificar se todos os títulos podem ser excluídos e excluí-los no caso
        // de não haver impedimentos
        for ( $j=0; $j<count($invoices); $j++ )
        {
            // excluir registros da finBankAccountInfo
            if ( ! $busBankAccount->deleteBankInvoiceInfoInvoice($invoices[$j]) )
            {
                throw new Exception(_M('Não foi possível excluir as informações bancárias do título @1.', $module, $invoices[$j]));
            }
            // excluir registros da finRelease
            if ( ! $busRelease->deleteReleasesByInvoice($invoices[$j]) )
            {
                throw new Exception(_M('Não foi possível excluir as liberações de juros e multas do título @1.', $module, $invoices[$j]));
            }

            $entries = $busEntry->getInvoiceEntries($invoices[$j]);
            for ( $k=0; $k<count($entries); $k++ )
            {
                if ( ($entries[$k]->contractId != $contractId ||
                      $entries[$k]->learningPeriodId != $learningPeriodId) &&
                     ( strlen($entries[$k]->contractId) > 0 &&
                      strlen($entries[$k]->learningPeriodId) > 0 ) )
                {
                    throw new Exception(_M('Título @1, vinculado ao contrato @2 não pode ser excluído por este processo, pois contém lançamentos de outros contratos ou períodos letivos.', $module, $entries[$k]->invoiceId, $contractId));
                }
            }

            // se chegar aqui, pode excluir o título, pois não há impedimentos
            if ( ! $busReceivableInvoice->deleteReceivableInvoice($invoices[$j]) )
            {
                throw new Exception(_M('Não foi possível excluir título @1. Verifique se não está contabilizado.', $module, $invoices[$j]));
            }

            $this->invoicesDeleted++;
        }

        // excluir previsões de lançamento e resumos de matrícula que tenham sido
        // gerados para este contrato em algum dos períodos letivos vinculados a
        // esta matrícula
        for ( $i=0; $i<count($learningPeriods); $i++ )
        {
            $filters = new stdClass();
            $filters->contractId = $contractId;
            $filters->learningPeriodId = $learningPeriods[$i];

            // exclusão das previsões de lançamento
            $incomeForecasts = $busIncomeForecast->searchIncomeForecast($filters);

            for ( $j=0; $j<count($incomeForecasts); $j++ )
            {
                if ( ! $busIncomeForecast->deleteIncomeForecast($incomeForecasts[$j][4]) )
                {
                    throw new Exception(_M('Não foi possível excluir a previsão de lançamento @1, vinculada ao contrato @2 e período letivo @3.', $module, $incomeForecasts[$j][4], $contractId, $learningPeriods[$i]));
                }
            }
        }

        return true;
    }

    public function getCreditsAvailableForEnroll($contractId, $semester, $classId, $learningPeriodId)
    {
        // FIXME: Criar configuração para definir se utiliza os créditos acadêmicos da disciplina ou os financeiros da oferecida

        $sql = '    SELECT sum(C.academicCredits)
                      FROM unit_acdcurriculum A
                INNER JOIN unit_acdContract B
                        ON (B.courseId = A.courseId
                            AND B.courseVersion = A.courseVersion)
                INNER JOIN acdCurricularComponent C
                        ON (C.curricularComponentId = A.curricularComponentId
                            AND C.curricularComponentVersion = A.curricularComponentVersion)
                INNER JOIN unit_acdGroup D
                        ON (D.curriculumId = A.curriculumId)
                INNER JOIN unit_acdlearningperiod E
                        ON E.learningPeriodId = D.learningPeriodId
                INNER JOIN basTurn F
                        ON F.turnId = B.turnId
                INNER JOIN basUnit G
                        ON G.unitId = B.unitId
                INNER JOIN acdRegimen H
                        ON H.regimenId = D.regimenId
                INNER JOIN unit_acdclass K
                        ON K.classId = D.classId
                     WHERE B.contractId = ?
                       AND D.classId = ?
                       AND NOT E.isClosed
                       AND E.periodId IN (SELECT periodId FROM unit_acdlearningperiod WHERE learningPeriodId = ?)
                       AND A.curriculumTypeId != ?::integer';

        $params = array($contractId, $classId, $learningPeriodId, SAGU::getParameter('ACADEMIC', 'ACD_CURRICULUM_TYPE_COMPLEMENTARY_ACTIVITY'));
        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        return $result[0][0];
    }

    public function getHoursAvailableForEnroll($contractId, $semester, $classId, $learningPeriodId)
    {
        $sql = '    SELECT sum(C.academicNumberHours)
                      FROM unit_acdcurriculum A
                INNER JOIN unit_acdContract B
                        ON (B.courseId = A.courseId
                            AND B.courseVersion = A.courseVersion)
                INNER JOIN acdCurricularComponent C
                        ON (C.curricularComponentId = A.curricularComponentId
                            AND C.curricularComponentVersion = A.curricularComponentVersion)
                INNER JOIN unit_acdGroup D
                        ON (D.curriculumId = A.curriculumId)
                INNER JOIN unit_acdlearningperiod E
                        ON E.learningPeriodId = D.learningPeriodId
                INNER JOIN basTurn F
                        ON F.turnId = B.turnId
                INNER JOIN basUnit G
                        ON G.unitId = B.unitId
                INNER JOIN acdRegimen H
                        ON H.regimenId = D.regimenId
                INNER JOIN unit_acdclass K
                        ON K.classId = D.classId
                     WHERE B.contractId = ?
                       AND D.classId = ?
                       AND NOT E.isClosed
                       AND E.periodId IN (SELECT periodId FROM unit_acdlearningperiod WHERE learningPeriodId = ?)
                       AND A.curriculumTypeId != ?::integer';

        $params = array($contractId, $classId, $learningPeriodId, SAGU::getParameter('ACADEMIC', 'ACD_CURRICULUM_TYPE_COMPLEMENTARY_ACTIVITY'));
        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        return $result[0][0];
    }

    public function searchFinalExamination($filters)
    {
        $module = SAGU::getFileModule(__FILE__);

        $sql = 'SELECT * FROM ( SELECT A.enrollId,
                        A.contractId,
                        A.groupId,
                        F.periodId,
                        C.curricularComponentId || \'/\' || C.curricularComponentVersion,
                        CASE WHEN D.name <> I.name
                            THEN D.name || \' (\' || I.name || \')\'
                            ELSE D.name
                        END,
                        NULL,
                        D.academicNumberHours || \'h - \' || D.academicCredits || \' ' . _M('créd', $module) . '\',
                        CASE WHEN B.useConcept
                             THEN ( SELECT COALESCE( O.concept, \'\')::TEXT FROM acdDegreeEnroll O INNER JOIN acdDegree P ON( O.degreeId = P.degreeId AND P.parentDegreeId IS NULL AND O.enrollId = A.enrollId) ORDER BY O.degreeEnrollId DESC LIMIT 1 )
                             ELSE ( SELECT ROUND( O.note::NUMERIC, \'' . SAGU::getParameter('BASIC', 'GRADE_ROUND_VALUE') . '\')::TEXT FROM acdDegreeEnroll O INNER JOIN acdDegree P ON( O.degreeId = P.degreeId AND P.parentDegreeId IS NULL AND O.enrollId = A.enrollId) ORDER BY O.degreeEnrollId DESC LIMIT 1 )
                             END,
                        ROUND( ((A.frequency * 100) / D.academicNumberHours)::NUMERIC, \'' . SAGU::getParameter('BASIC', 'GRADE_ROUND_VALUE') . '\')::TEXT || \' % \',
                        A.statusId,
                        E.description,
                        B.classId || \' - \' || G.name
                   FROM unit_acdEnroll A
              INNER JOIN unit_acdGroup B
                        ON (B.groupId = A.groupId)
              INNER JOIN unit_acdcurriculum C
                       ON (C.curriculumId = A.curriculumId)
              INNER JOIN acdCurricularComponent D
                       ON (D.curricularComponentId = C.curricularComponentId AND
                            D.curricularComponentVersion = C.curricularComponentVersion)
              INNER JOIN acdEnrollStatus E
                       ON (E.statusId = A.statusId)
              INNER JOIN unit_acdlearningperiod F
                       ON (F.learningPeriodId = B.learningPeriodId)
              INNER JOIN unit_acdcurriculum H
                       ON (H.curriculumId = B.curriculumId)
              INNER JOIN acdCurricularComponent I
                       ON (I.curricularComponentId = H.curricularComponentId AND
                            I.curricularComponentVersion = H.curricularComponentVersion)
               LEFT JOIN unit_acdclass G
                        ON (G.classId = B.classId)';

        if ( strlen($filters->contractId) > 0 )
        {
            $where .= ' AND A.contractId = ? ';
            $params[] = $filters->contractId;
        }

        if ( strlen($filters->periodId) > 0 )
        {
            $where .= ' AND F.periodId = ? ';
            $params[] = $filters->periodId;
        }

        $finalExaminationType = SAGU::getParameter('academic', 'ACD_CURRICULUM_TYPE_FINAL_EXAMINATION');
        if ( strlen($finalExaminationType) > 0 )
        {
            $where .= ' AND C.curricularComponentTypeId = ? ';
            $params[] = SAGU::getParameter('academic', 'ACD_CURRICULUM_TYPE_FINAL_EXAMINATION');

            unset($result);

            $sql .= ' WHERE ' . substr($where, 4) . '
                   ORDER BY F.periodId DESC,
                            A.statusId,
                            D.name ) ';

            $sql.= '   AS sel ORDER BY 3, 10, 5';

            $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

            // obter dias e turnos, professores e salas
            $sql = "SELECT array_agg(DISTINCT (SELECT shortDescription
                                                 FROM basWeekDay
                                                WHERE weekDayId = EXTRACT(DOW FROM A.occurrenceDate)) || '-' || D.shortDescription) AS daysAndTurns,
                           array_agg(DISTINCT G.name) AS professors,
                           array_agg(DISTINCT H.room || '-' || H.building) AS roomBuilding
                      FROM (SELECT A.groupId, UNNEST(A.occurrenceDates) AS occurrenceDate
                              FROM acdSchedule A
                             WHERE A.groupId = ?) A
                INNER JOIN (SELECT A.groupId, UNNEST(A.timeIds) AS timeId
                              FROM acdSchedule A
                             WHERE A.groupId = ?) B
                        ON (B.groupId = A.groupId)
                INNER JOIN acdTime C
                        ON C.timeId = B.timeId
                INNER JOIN basTurn D
                        ON D.turnId = C.turnId,
                           acdSchedule E
                INNER JOIN acdScheduleProfessor F
                        ON F.scheduleId = E.scheduleId
                INNER JOIN ONLY basPerson G
                        ON G.personId = F.professorId
                 LEFT JOIN insPhysicalResource H
                        ON H.physicalResourceId = E.physicalResourceId
                           AND H.physicalResourceVersion = E.physicalResourceVersion
                     WHERE E.groupId = ?";

            for ( $i=0; $i<count($result); $i++ )
            {
                if ( strlen($result[$i][2]) > 0 )
                {
                    $params = array($result[$i][2], $result[$i][2], $result[$i][2]);
                    $extraData = $this->getDatabase()->query(SAGU::prepare($sql, $params));

                    if ( count($extraData) > 0 )
                    {
                        $result[$i] = array_merge($result[$i], $extraData[0]);
                    }
                }
            }
        }

        return $result;
    }
    
    
/**
     * Método para obter a carga horária total na qual um
     * contrato se matriculou no período
     *
     * @author Leovan Tavares da Silva
     *
     * @param $contractId (integer): Código do contrato
     * @param $learningPeriodId (integer): Período letivo
     *
     * @return (numeric): Carga horária contratada.
     */
    public function getContractEnrolledHours($contractId, $learningPeriodId)
    {
        $status = array( SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_CANCELLED'),
                         SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_EXCUSED') );

        $sql = ' SELECT SUM(E.academicNumberHours)
                   FROM unit_acdEnroll A
                  INNER JOIN unit_acdGroup B
                     ON (B.groupId = A.groupId)
                  INNER JOIN unit_acdcurriculum D
                     ON (D.curriculumId = B.curriculumId)
                  INNER JOIN acdCurricularComponent E
                     ON (E.curricularComponentId = D.curricularComponentId AND
                         E.curricularComponentVersion = D.curricularComponentVersion)
                  INNER JOIN unit_acdlearningperiod F
                     ON (F.learningPeriodId = B.learningPeriodId)
                  WHERE A.contractId = ?
                    AND F.periodId = (SELECT periodId FROM unit_acdlearningperiod WHERE learningPeriodId = ?)
                    AND A.statusId NOT IN (' . implode(',', $status) . ')';

        $args = array( $contractId, $learningPeriodId );

        $result = $this->getDatabase()->query( SAGU::prepare($sql, $args) );

        if ( is_null($result[0][0]) )
        {
            return '0';
        }

        return $result[0][0];
    }
    
    public function getLastInsertId()
    {
        return SDatabase::getLastInsertId('acdEnroll');
    }
    
    /**
     * Executa metodo de calculo de notas
     */
    public function calculaNota($enrollId)
    {
        return SDatabase::query('SELECT calculaNota(?)', array($enrollId));
    }
    
    /**
     * @return string
     */
    public function getFutureStatus($enrollId)
    {
        $busEnrollStatus = new BusinessAcademicBusEnrollStatus();

        $statusId = $this->getFutureStatusId($enrollId);        
        $list = $busEnrollStatus->listEnrollStatus(1);
            
        return $list[$statusId];
    }
    
    /**
     * @return int
     */
    public function getFutureStatusIdCache($enrollId)
    {
        static $cache = array();
        
        if ( !isset($cache[$enrollId]) )
        {
            $cache[$enrollId] = $this->getFutureStatusId($enrollId);
        }
        
        return $cache[$enrollId];
    }
        
    /**
     * Obtem o estado futuro da matricula (aprovado, reprovado, reprovado por faltas...)
     * 
     * @return int
     */
    public function getFutureStatusId($enrollId, $isWebServices = false)
    {
        $busCurrComponent = new BusinessAcademicBusCurricularComponent();
        $busDegree = new BusinessAcademicBusDegree();
        $busDegreeEnroll = new BusinessAcademicBusDegreeEnroll();
        $busEnroll = new BusinessAcademicBusEnroll();
        $busGroup = new BusinessAcademicBusGroup();
        $busLearningPeriod = new BusinessAcademicBusLearningPeriod();

        $enrollData = $busEnroll->getEnroll($enrollId, $isWebServices);
        $groupData = $busGroup->getGroup($enrollData->groupId, $isWebServices);
        $finalDegree = $busDegree->getLearningPeriodFinalDegree($groupData->learningPeriodId);
        $learningPeriodData = $busLearningPeriod->getLearningPeriod($groupData->learningPeriodId, $isWebServices);
        $currComponentData = $busCurrComponent->getCurricularComponent($groupData->curriculumCurricularComponentId, $groupData->curriculumCurricularComponentVersion);
        $newStatusId = $enrollData->statusId;
        
        // considera inicialmente que o aluno está aprovado
        if ( in_array($newStatusId, array(SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_CANCELLED'), SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_DESISTING'), SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_EXCUSED'))) )
        {
            return $newStatusId;
        }

        //Caso o webservices definir a situação do aluno, esta será a situação gravada na matrícula dele
        if( $isWebServices && strlen($newStatusId) > 0 && $newStatusId != SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED') )
        {
            return $newStatusId;
        }

        $newStatusId = SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_APPROVED');

        // verificar notas se a disciplina não usa conceito
        if ( $groupData->useConcept == DB_FALSE )
        {
            // se a oferecida utiliza avaliação por nota
            if ( in_array($groupData->evaluationTypeId, array(AcdEvaluationType::BY_NOTE, AcdEvaluationType::BY_NOTE_AND_FREQUENCY)) )
            {
                $pupilFinalGrade = $busDegreeEnroll->getDegreeEnrollCurrentGrade($finalDegree->degreeId, $enrollData->enrollId, false);

                // verificar se a nota obtida é maior ou igual à média mínima para aprovação
                if ($pupilFinalGrade >= $learningPeriodData->finalAverage)
                {
                    $newStatusId = SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_APPROVED');
                }
                else
                {
                    $newStatusId = SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_DISAPPROVED');
                }
            }
        }
        // verificar notas se a disciplina usa conceito
        elseif ( $groupData->useConcept == DB_TRUE )
        {
            // se a oferecida utiliza avaliação por nota
            if ( in_array($groupData->evaluationTypeId, array(AcdEvaluationType::BY_NOTE, AcdEvaluationType::BY_NOTE_AND_FREQUENCY)) )
            {
                $pupilFinalGrade = $busDegreeEnroll->getDegreeEnrollCurrentGrade($finalDegree->degreeId, $enrollData->enrollId, true);

                // business conceito
                $businessConcept = new BusinessAcademicBusConcept();

                // obtem o conceito
                $filters = new stdClass();
                $filters->conceptGroupId = $groupData->conceptGroupId;
                $filters->description = $pupilFinalGrade;
                $conceptData = $businessConcept->searchConceptAsObject($filters);
                $concept = $conceptData[0];
                $concept instanceof AcdConcept;

                // verifica se acho o conceito
                if ( strlen($concept->enrollStatusId) )
                {
                    $newStatusId = $concept->enrollStatusId;
                }
            }
        }

        // se a oferecida utiliza avaliação por frequência
        if ( in_array($groupData->evaluationTypeId, array(AcdEvaluationType::BY_FREQUENCY, AcdEvaluationType::BY_NOTE_AND_FREQUENCY)) )
        {
            //busca a frequencia em cima das aulas que já ocorreram, e não do total das aulas $enrollData->frequency
            $frequencia = $busEnroll->obterPercentualDeFrequencia($enrollId); 
                        
            // se não foi atingida a frequência mínima e o aluno não possui dispensa, reprovar por faltas
            if ( $frequencia < $learningPeriodData->minimumFrequency )
            {
                $newStatusId = SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_DISAPPROVED_FOR_LACKS');
            }
        }
        
        return $newStatusId;
    }
    
    /**
     *
     * @return int
     */
    public function getTipoDeMatriculaAtual()
    {
        return SAGU::NVL($this->tipoDeMatriculaAtual, Matricula::MATRICULA_NORMAL);
    }

    public function setTipoDeMatriculaAtual($tipoDeMatriculaAtual)
    {
        $this->tipoDeMatriculaAtual = $tipoDeMatriculaAtual;
    }
    
    /**
     * Edita somente o groupId da matrícula para aproveitar as notas e frequ?ncias
     * digitadas.
     * 
     * @param type $enrollId
     * @param type $groupId
     * @return type
     */
    public function updateEnrollClassTransfer($enrollId, $groupId)
    {
        $sql = "UPDATE acdEnroll
                   SET groupId = ?
                 WHERE enrollId = ?";
        
        $params = array(
            $groupId,
            $enrollId,
        );
        
        $result = $this->execute(SAGU::prepare($sql, $params));

        return $result;
    }
    
    /**
     * Retorna a frequência de um aluno em uma disciplina, em %.
     * 
     * @author Bruno Fuhr [bruno@solis.com.br]
     * @param int $enrollId
     * @return double precision
     */
    public function obterPercentualDeFrequencia($enrollId)
    {
        $sql = ' SELECT obterPercentualDeFrequencia(?) ';
        
        $params = array(
            $enrollId
        );
        
        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        return $result[0][0];
    }
    
    public function obterDisciplinasDoContrato($contractId)
    {
        if ( $contractId )
        {
            $sql = ' SELECT DISTINCT(groupid) FROM acdenroll WHERE contractid = ? ';

            $params = array(
                $contractId
            );

            $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));
            $data = array();
            foreach ( $result as $line )
            {
                $data[] = $line[0];
            }
        }

        return $data;
    }
    
    public function isEnrolledByGroup($groupId, $contractId)
    {
        $sql = " SELECT enrollid 
                   FROM acdenroll 
                  WHERE groupid = ? 
                    AND contractid = ? 
                    AND statusid IN (getparameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED')::int ) ";
        
        $params = array(
            $groupId,
            $contractId
        );
        
        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));
        
        return $result[0][0] ? TRUE : FALSE;
    }
    
    /**
     * Cancela matrícula. Pode-se passar uma razão.
     * 
     * @param int $enrollId - Código da matrícula.
     * @param int $reasonCancellationId - Código da razão de cancelamento.
     * @return boolean
     */
    public function cancelEnroll($enrollId, $reasonCancellationId)
    {
        $sql = "UPDATE acdEnroll
                   SET statusId = ? ";
        
        $params[] = SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_CANCELLED');
        
        if ( strlen($reasonCancellationId) > 0 )
        {
            $sql .= ", reasonCancellationId = ? ";
            $params[] = $reasonCancellationId;
        }
        
        $sql .= " WHERE enrollId = ? ";
        
        $params[] = $enrollId;
        
        $result = $this->execute(SAGU::prepare($sql, $params));

        return $result;
    }
    
    /**
     * Verifica se o aluno está matriculado no periodo
     * 
     * @param type $contractId
     * @param type $learningPeriodId
     * @return type boolean
     */
    public function verificaMatriculaNoPeriodo($contractId, $learningPeriodId)
    {
        $sql = ' SELECT count(*) >= 1 
                   FROM acdenroll A 
             INNER JOIN acdgroup B 
                     ON A.groupid = B.groupid
             INNER JOIN acdlearningperiod C
                     ON B.learningperiodid = C.learningperiodid
                  WHERE A.contractid = ?
                    AND C.periodid IN ( SELECT periodid 
                                          FROM acdlearningperiod 
                                         WHERE learningperiodid = ? )
                   AND (A.statusid = (\'' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED') . '\' )::INTEGER)';
       
        $params[] = $contractId;
        $params[] = $learningPeriodId;
                
        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));
        
        return $result[0][0];
    }
    
    /**
     * Verifica se curriculumId passado por parametro possui um co-requisito
     * 
     * @param int $contractId
     * @param int $curriculumId CurriculumId que deve ser verificado
     * @param array $ignoreCurriculumIds CurriculumId's que devem ser ignorados
     * @param boolean $isFromWeb
     * @param array $desmarcados Disciplinas desmarcadas na interface
     * 
     * @return string Mensagem de erro que deve aparecer na tela
     */
    public function obterBloqueioPorCoRequisito($contractId, $curriculumId, $ignoreCurriculumIds = array(), $isFromWeb = false, $desmarcados = array())
    {
        // utilizamos -1 para evitar erros SQL
        $ignoreCurriculumList = count($ignoreCurriculumIds) > 0 ? implode(',', $ignoreCurriculumIds) : '-1';
        $desmarcadosLista = count($desmarcados) > 0 ? implode(',', $desmarcados) : '-1';

        // mensagem de erro que aparecera na tela
        $message = $isFromWeb ?
            "'A disciplina ' || CC.name || ' possui como co-requisito ' || _CC.name || ', assim é necessário que você curse as duas disciplinas SIMULTANEAMENTE, ou que você já tenha cursado ' || _CC.name" :
            "'A disciplina ' || CC.name || ' possui como co-requisito ' || _CC.name || ', devendo assim ser cursadas simultaneamente'";

        // SQL que verifica se a disciplina Y (Disciplina do requisito) foi cursada
        // Caso a disciplina Y esteja na lista dos $ignoreCurriculumIds, ignora
        $sql = "SELECT {$message}
                  FROM acdcondition C
            INNER JOIN acdCurriculum CU
                    ON CU.curriculumId = C.curriculumId
            INNER JOIN acdCurricularComponent CC
                    ON (CC.curricularComponentId, CC.curricularComponentVersion) = (CU.curricularComponentId, CU.curricularComponentVersion)
            INNER JOIN acdCurriculum _CU
                    ON _CU.curriculumId = C.conditioncurriculumid
            INNER JOIN acdCurricularComponent _CC
                    ON (_CC.curricularComponentId, _CC.curricularComponentVersion) = (_CU.curricularComponentId, _CU.curricularComponentVersion)
                 WHERE C.curriculumId = ?
                   AND C.type = 'C'
                   AND C.conditioncurriculumid NOT IN ({$ignoreCurriculumList})
                   AND NOT EXISTS(SELECT 1
                                    FROM acdEnroll E
                               LEFT JOIN acdGroup G
                                      ON G.groupId = E.groupId
                                   WHERE E.contractId = ?
                                     AND E.statusId <> GETPARAMETER('ACADEMIC', 'ENROLL_STATUS_CANCELLED')::int
                                     AND C.conditioncurriculumid IN (E.curriculumId, G.curriculumId) 
                                     AND C.conditioncurriculumid NOT IN ({$desmarcadosLista}) )";

        $args[] = $curriculumId;
        $args[] = $contractId;
        
        $rows = SDatabase::query($sql, $args);
        
        return $rows[0][0];
    }
    
    /**
     * Verfica se nenhuma disciplina do período está com status de pré-matriculado
     * 
     * @param type $contractId
     * @param type $learningPeriodId
     * @return boolean caso não exista disciplinas pré-matriculadas 't' e 'f' caso contrário
     */
    public function verificaDisciplinasPreMatriculadasNoPeriodo($contractId, $learningPeriodId)
    {
        $sql = 'SELECT COUNT(*) = 0
                  FROM acdEnroll A
            INNER JOIN acdGroup B
                    ON (A.groupId = B.groupId)
            INNER JOIN acdLearningPeriod C
                    ON (B.learningPeriodId = C.learningPeriodId)
                 WHERE A.contractId = ?
                   AND A.statusId = \'' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_PRE_ENROLLED') . '\'
                   AND C.periodId IN ( SELECT periodId 
                                         FROM acdLearningPeriod
                                        WHERE learningPeriodId = ? )';
        
        $args[] = $contractId;
        $args[] = $learningPeriodId;
        
        $result = SDatabase::query($sql, $args);
        
        return $result[0][0];
    }
    
    /**
     * Verfica se existem disciplinas vinculadas.
     * 
     * @param array $curriculumData
     * @param int $learningPeriodId
     * @return boolean caso não exista disciplinas pré-matriculadas 't' e 'f' caso contrário
     */
    public function obterDisciplinasDeVinculos($curriculumData, $learningPeriodId)
    {
        $sql = "SELECT G.groupId
                  FROM acdCurriculumLink CL
            INNER JOIN acdGroup G
                    ON G.curriculumId = CL.curriculumLinkId
            INNER JOIN acdLearningPeriod LP
                    ON LP.learningPeriodId = G.learningPeriodId
                 WHERE CL.curriculumId = ?
                   AND CL.utilizaVinculoParaMatricula
                   AND LP.periodId = ( SELECT periodId
                                        FROM acdLearningPeriod
                                       WHERE learningPeriodId = ? )";
        $args[] = $curriculumData->curriculumId;
        $args[] = $learningPeriodId;
        
        $result = SDatabase::query($sql, $args);
        
        return $result;
    }
    
    
    public function checkEnroll($enrollId, $isWebServices = false)
    {
        $acdEnroll = "unit_acdEnroll";
        // Para webservices.
        if ( $isWebServices )
        {
            $acdEnroll = "acdEnroll";
        }          
        $sql = "SELECT A.enrollId,
                       A.groupId
                  FROM {$acdEnroll} A
                 WHERE A.enrollId = ?";
        $result = $this->getDatabase()->query(SAGU::prepare($sql, $enrollId));

        if ( strlen($result[0][0]) > 0 )
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    
    public function checkGroupId($groupId, $isWebServices = false)
    {
        $acdEnroll = "unit_acdEnroll";
        // Para webservices.
        if ( $isWebServices )
        {
            $acdEnroll = "acdEnroll";
        }          
        $sql = "SELECT A.enrollId,
                       A.groupId
                  FROM {$acdEnroll} A
                 WHERE A.groupId = ?";

                  $result = $this->getDatabase()->query(SAGU::prepare($sql, $groupId));

        if ( strlen($result[0][0]) > 0 )
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
}
?>
