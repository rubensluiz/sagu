<?php
/**
 * <--- Copyright 2005-2010 de Solis - Cooperativa de Soluções Livres Ltda.
 * 
 * Este arquivo é parte do programa Sagu.
 * 
 * O Sagu é um software livre; você pode redistribuí-lo e/ou modificá-lo
 * dentro dos termos da Licença Pública Geral GNU como publicada pela Fundação
 * do Software Livre (FSF); na versão 2 da Licença.
 * 
 * Este programa é distribuído na esperança que possa ser útil, mas SEM
 * NENHUMA GARANTIA; sem uma garantia implícita de ADEQUAÇÃO a qualquer MERCADO
 * ou APLICAÇÃO EM PARTICULAR. Veja a Licença Pública Geral GNU/GPL em
 * português para maiores detalhes.
 * 
 * Você deve ter recebido uma cópia da Licença Pública Geral GNU, sob o título
 * "LICENCA.txt", junto com este programa, se não, acesse o Portal do Software
 * Público Brasileiro no endereço www.softwarepublico.gov.br ou escreva para a
 * Fundação do Software Livre (FSF) Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA --->
 * 
 * Class to manipulate the acdLearningPeriod table data.
 *
 * @author Jamiel Spezia [jamiel@solis.coop.br]
 *
 * @version $Id$
 *
 * \b Maintainers: \n
 * Alexandre Heitor Schmidt [alexsmith@solis.coop.br]
 * Arthur Lehdermann [arthur@solis.coop.br]
 * Daniel Afonso Heisler [daniel@solis.coop.br]
 * Jonas Gualberto Diel [jonas_diel@solis.coop.br]
 * Samuel Koch [samuel@solis.coop.br]
 * William Prigol Lopes [william@solis.coop.br]
 * Fabiano Tomasini [fabiano@solis.coop.br]
 *
 * @since
 * Creation date 2005/03/10
 */

class BusinessAcademicBusLearningPeriod extends sBusiness
{
   /**
    * Insert a new learning period
    * 
    * @param $data (object): acdLearningPeriod object
    *
    * @return (integer): If all goes well, return the id of the inserted learning period. Otherwise, return null.
    */
    public function insertLearningPeriod($data, $checkPeriodConflict = true)
    {
    	$module = 'academic';
    	$retVal = null;

    	try
    	{
            if ( $checkPeriodConflict )
            {
                $periods = $this->checkLearningPeriodDates($data->courseId, $data->courseVersion, $data->turnId, $data->unitId, $data->beginDate, $data->endDate);

                if ( count($periods) > 0 )
                {
                    throw new Exception(_M('Data inicial e final sobrepõem o período letivo @1', $module, implode(', ', $periods)));
                }
            }

            $sql = 'SELECT nextval(\'seq_learningperiodid\')';

            $learningPeriodId = $this->getDatabase()->query($sql);

            $sql = 'INSERT INTO acdLearningPeriod
                                ( learningPeriodId,
                                    periodId,
                                    courseId,
                                    courseVersion,
                                    turnId,	                              
                                    parcelsNumber,
                                    unitId,
                                    description,
                                    formationLevelId,
                                    previousLearningPeriodId,
                                    beginDate,
                                    endDate,
                                    beginDateLessons,
                                    weekEndExamsBegin,
                                    finalAverage,
                                    minimumFrequency,
                                    minimumCredits,
                                    minimumCreditsFreshman,
                                    minimumCreditsTurn,
                                    isFinanceGenerate,
                                    disapprovementsToDisapprovePeriod,
                                    isClosed,
                                    maximumperiods,
                                    maximumdisapprovals,
                                isnumberhours,
                                maximumCredits,
                                maximumCreditsFreshman,
                                gradesByConcept,
                                evaluationControlMethodId,
                                justifyDisapprovals,
                                enrollAcceptedTerm,
                                maximumFinalAverage,
                                limitRegisterDate,
                                blockFinalExaminationGradesTyping,
                                matriculasemminimodecreditos)
                            VALUES (?,?,?,?,?,?,?,?,?,?,
                                    TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                                    TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                                    TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                                    TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                                    ?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,
                                    datetodb(?),?,?)';

            $args = array( $learningPeriodId[0][0],
                            $data->periodId,
                            $data->courseId,
                            $data->courseVersion,
                            $data->turnId,
                            $data->parcelsNumber,
                            $data->unitId,
                            strtoupper($data->description),
                            $data->formationLevelId,
                            $data->previousLearningPeriodId,
                            $data->beginDate,
                            $data->endDate,
                            $data->beginDateLessons,
                            $data->weekEndExamsBegin,
                            $data->finalAverage,
                            $data->minimumFrequency,
                            $data->minimumCredits,
                            $data->minimumCreditsFreshman,
                            $data->minimumCreditsTurn,
                            SAGU::NVL($data->isFinanceGenerate, DB_FALSE),
                            SAGU::NVL($data->disapprovementsToDisapprovePeriod, 0),
                            SAGU::NVL($data->isClosed, DB_FALSE),
                            SAGU::NVL($data->maximumPeriods, 0),
                            SAGU::NVL($data->maximumDisapprovals, 0),
                        SAGU::NVL($data->isNumberHours, DB_FALSE),
                        SAGU::NVL($data->maximumCredits, 0),
                        SAGU::NVL($data->maximumCreditsFreshman, 0),
                        $data->gradesByConcept,
                        SAGU::NVL($data->evaluationControlMethodId, 1),
                        SAGU::NVL($data->justifyDisapprovals, DB_FALSE),
                        $data->enrollAcceptedTerm,
                        $data->maximumFinalAverage,
                        $data->limitRegisterDate,
                        SAGU::NVL($data->blockFinalExaminationGradesTyping, DB_TRUE),
                        $data->matriculasemminimodecreditos);                              

            $result = $this->getDatabase()->execute(SAGU::prepare($sql, $args, false));

            if ( $result )
            {
                $retVal = $learningPeriodId[0][0];
            }
    	}
    	catch ( Exception $e )
    	{
            $this->addError($e->getMessage());
    	}
    	
    	return $retVal;
    }

   /**
    * Obtain the specified learning period id data.
    * 
    * @param $data (object): acdPeriod object
    *
    * @return AcdLearningPeriod
    */
    public function getLearningPeriod($learningPeriodId, $isWebServices = false)
    {
        $acdlearningperiod = "unit_acdlearningperiod";
        
        // Para webservices.
        if ( $isWebServices )
        {
            $acdlearningperiod = "acdlearningperiod";
        }  
        
        $sql = "SELECT A.learningPeriodId,
                       A.periodId,
                       B.description,
                       A.courseId,
                       C.name,
                       A.courseVersion,
                       A.turnId,
                       A.unitId,
                       A.description,
                       A.formationLevelId,
                       A.previousLearningPeriodId,
                       TO_CHAR(A.beginDate, '" . SAGU::getParameter('BASIC', 'MASK_DATE') . "'),
                       TO_CHAR(A.endDate, '" . SAGU::getParameter('BASIC', 'MASK_DATE') . "'),
                       TO_CHAR(A.beginDateLessons, '" . SAGU::getParameter('BASIC', 'MASK_DATE') . "'),
                       TO_CHAR(A.weekEndExamsBegin, '" . SAGU::getParameter('BASIC', 'MASK_DATE') . "'),
                       A.finalAverage,
                       A.minimumFrequency,
                       A.userName,
                       TO_CHAR(A.dateTime,'" . SAGU::getParameter('BASIC', 'MASK_TIMESTAMP') . "'),
                       A.ipAddress,
                       A.parcelsNumber,
                       A.minimumCredits,
                       A.minimumCreditsFreshman,
                       A.minimumCreditsTurn,
                       A.isFinanceGenerate,
                       A.disapprovementsToDisapprovePeriod,
                       A.isClosed,
                       A.maximumperiods,
                       A.maximumdisapprovals,
                       isnumberhours,
                       maximumCredits,
                       maximumCreditsFreshman,
                       getTurnDescription(A.turnId) as turnDescription,
                       getUnitDescription(A.unitId) as unitDescription,
                       A.gradesByConcept,
                       A.evaluationControlMethodId,
                       A.justifyDisapprovals,
                       A.enrollAcceptedTerm,
                       A.maximumFinalAverage,
                       gettotallearningperioddays(A.learningPeriodId) AS learningDays,
                       TO_CHAR(A.limitRegisterDate,'" . SAGU::getParameter('BASIC', 'MASK_DATE') . "') AS limitRegisterDate,
                       blockFinalExaminationGradesTyping,
                       matriculasemminimodecreditos
                  FROM {$acdlearningperiod} A
             LEFT JOIN acdPeriod B ON (A.periodId = B.periodId)
             LEFT JOIN acdCourse C ON (A.courseId = C.courseId)
                 WHERE A.learningPeriodId = ?";

        $result = $this->getDatabase()->query(SAGU::prepare($sql,$learningPeriodId));
        $period = new AcdLearningPeriod();

        list ( $period->learningPeriodId,
               $period->periodId,
               $period->periodDescription,
               $period->courseId,
               $period->courseName,
               $period->courseVersion,
               $period->turnId,
               $period->unitId,
               $period->description,
               $period->formationLevelId,
               $period->previousLearningPeriodId,
               $period->beginDate,
               $period->endDate,
               $period->beginDateLessons,
               $period->weekEndExamsBegin,
               $period->finalAverage,
               $period->minimumFrequency,
               $period->userName,
               $period->dateTime,
               $period->ipAddress,
               $period->parcelsNumber,
               $period->minimumCredits,
               $period->minimumCreditsFreshman,
               $period->minimumCreditsTurn,
               $period->isFinanceGenerate,
               $period->disapprovementsToDisapprovePeriod,
               $period->isClosed,
               $period->maximumPeriods,
               $period->maximumDisapprovals,
               $period->isNumberHours,
               $period->maximumCredits,
               $period->maximumCreditsFreshman,
               $period->turnDescription,
               $period->unitDescription,
               $period->gradesByConcept,
               $period->evaluationControlMethodId,
               $period->justifyDisapprovals,
               $period->enrollAcceptedTerm,
               $period->maximumFinalAverage,
               $period->learningDays,
               $period->limitRegisterDate,
               $period->blockFinalExaminationGradesTyping,
               $period->matriculasemminimodecreditos) = $result[0];

        // FIXME: this is to keep compatibility with other functions
        // that may be acessing description as learningPeriodDescription,
        // which is wrong.
        $period->learningPeriodDescription = $period->description;

        return $period;
    }

    /**
     * Search for learning period.
     *
     * @author Jamiel Spezia [jamiel@solis.coop.br]
     *
     * @param $data Object containing data to filter the listing.
     *
     * @return An array containing the search results.
     */
    public function searchLearningPeriod($data, $returnAsObject = false, $isWebServices = false)
    {
        $acdlearningperiod = "unit_acdlearningperiod";
        
        // Para webservices.
        if ( $isWebServices )
        {
            $acdlearningperiod = "acdlearningperiod";
        } 
        
        $select = "SELECT A.learningPeriodId,
                          A.description,
                          A.previouslearningperiodid,
                          TO_CHAR(A.beginDate,'" . SAGU::getParameter('BASIC', 'MASK_DATE') . "'),
                          TO_CHAR(A.endDate,'" . SAGU::getParameter('BASIC', 'MASK_DATE') . "'),
                          A.formationLevelId,
                          B.description,
                          A.courseId,
                          C.name,
                          A.courseVersion,
                          A.turnId,
                          A.unitId,
                          A.evaluationControlMethodId,
                          A.periodId
                     FROM {$acdlearningperiod} A
                LEFT JOIN acdFormationLevel B
                       ON (A.formationLevelId = B.formationLevelId)
               INNER JOIN acdCourse C
                       ON (C.courseId = A.courseId)";

        if ( strlen($data->learningPeriodId) > 0 )
        {
            $where .= '     AND A.learningPeriodId = ?';
            $args[] = $data->learningPeriodId;
        }

        if ( strlen($data->periodId) > 0 )
        {
            $where .= '     AND A.periodId LIKE ?';
            $args[] = $data->periodId;
        }

        if ( strlen($data->formationLevelId) > 0 )
        {
            $where .= '     AND A.formationLevelId = ?';
            $args[] = $data->formationLevelId;
        }

        if ( strlen($data->courseId) > 0 )
        {
            $where .= '     AND A.courseId = ?';
            $args[] = $data->courseId;
        }

        if ( strlen($data->courseVersion) > 0 )
        {
            $where .= '     AND A.courseVersion = ?';
            $args[] = $data->courseVersion;
        }

        if ( strlen($data->turnId) > 0 )
        {
            $where .= '     AND A.turnId = ?';
            $args[] = $data->turnId;
        }

        if ( strlen($data->unitId) > 0 )
        {
            $where .= '     AND A.unitId = ?';
            $args[] = $data->unitId;
        }
        if ( strlen($data->maximumPeriods) > 0 )
        {
            $where .= '     AND A.maximumperiods = ?';
            $args[] = $data->maximumPeriods;
        }

        if ( strlen($data->maximumDisapprovals) > 0 )
        {
            $where .= '     AND A.maximumdisapprovals = ?';
            $args[] = $data->maximumDisapprovals;
        }

        if ( strlen($data->referenceDate) > 0 )
        {
            $where .= ' AND TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\') BETWEEN A.beginDate AND A.endDate ';
            $args[] = $data->referenceDate;
        }

        if ( strlen($data->evaluationControlMethodId) > 0 )
        {
            $where .= ' AND A.evaluationControlMethodId = ?';
            $args[] = $data->evaluationControlMethodId;
        }

        if ( $where != '' )
        {
            $select .= '    WHERE ' . substr($where,8);
            $orderBy = ' ORDER BY A.courseId, A.description';
            
            if ( $data->orderByDesc == DB_TRUE )
            {
                $orderBy = ' ORDER BY A.learningPeriodId DESC, A.courseId, A.description ';    
            }
            
            $select .= $orderBy;
            
            $result = $this->getDatabase()->query(SAGU::prepare($select,$args));
            
        }

        if ($returnAsObject && (count($result) > 0))
        {
            $objresult = array();
            foreach ($result as $i => $r)
            {
                list( $objresult[$i]->learningPeriodId,
                      $objresult[$i]->description,
                      $objresult[$i]->previouslearningperiodid,
                      $objresult[$i]->beginDate,
                      $objresult[$i]->endDate,
                      $objresult[$i]->formationLevelId,
                      $objresult[$i]->description,
                      $objresult[$i]->courseId,
                      $objresult[$i]->name,
                      $objresult[$i]->courseVersion,
                      $objresult[$i]->turnId,
                      $objresult[$i]->unitId,
                      $objresult[$i]->evaluationControlMethodId,
                      $objresult[$i]->periodId) = $r;
            }
            
            return $objresult;
        }

        return $result;
    }
    
    public function listLearningPeriod()
    {
        $sql = 'SELECT learningPeriodId,
                       description
                  FROM unit_acdlearningperiod
              ORDER BY 1';
              
        $result = $this->getDatabase()->query($sql);
        
        return $result;
    }    
    
    //lista periodos quando matricula simplificada for um novo cadastro
    public function listLearningPeriodSimple($courseId)
    {
        $sql = 'SELECT A.learningPeriodId,
                       A.description,
                       A.courseVersion,
                       A.turnId,
                       A.unitId
                  FROM unit_acdlearningperiod A 
            INNER JOIN unit_acdcourseoccurrence B
                    ON A.courseid = B.courseid
                 WHERE B.courseid = ?
              ORDER BY 1';
        
        $args = array ($courseId);
        
        $result = $this->getDatabase()->query(SAGU::prepare($sql, $args));
        
        return $result;
    }

    /**
     * Check Learning Period Dates
     * 
     * @param $courseId
     * @param $courseVersion
     * @param $turnId
     * @param $unitId
     * @param $beginDate
     * @param $endDate
     * @param $learningPeriodId
     * 
     * @return (array) Empty array if no conflicting learning periods exists. Otherwise, an array containing the conflicting learning periods.
     */
    private function checkLearningPeriodDates($courseId, $courseVersion, $turnId, $unitId, $beginDate, $endDate, $learningPeriodId = null)
    {
        $sql = 'SELECT learningPeriodId
                  FROM unit_acdlearningperiod
                 WHERE courseId = ?
                   AND courseVersion = ?
                   AND turnId = ?
                   AND unitId = ? 
                   AND (TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\') BETWEEN beginDate AND endDate
                        OR TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\') BETWEEN beginDate AND endDate)';
        
        $args = array ($courseId,
                       $courseVersion,
                       $turnId,
                       $unitId,
                       $beginDate,
                       $endDate);
        
        if ( strlen($learningPeriodId) > 0 )
        {
        	$sql .= ' AND learningPeriodId != ?';
        	$args[] = $learningPeriodId;
        }
                           
        $result = $this->getDatabase()->query(SAGU::prepare($sql, $args));

        $periods = array();
        if ( count($result) > 0 )
        {
            foreach ( $result as $r )
            {
                $periods[] = $r[0]; 
            }
        }
        
        return $periods;
    }
    
    public function checkLearningPeriodSimple($courseId, $courseVersion, $turnId, $unitId,  $learningPeriodId = null, $description = null)
    {
        $sql = 'SELECT learningPeriodId,
                       description
                  FROM unit_acdlearningperiod
                 WHERE courseId = ?
                   AND courseVersion = ?
                   AND turnId = ?
                   AND unitId = ?';
        
        $args = array ($courseId,
                       $courseVersion,
                       $turnId,
                       $unitId);
        
        if ( strlen($learningPeriodId) > 0 )
        {
        	$sql .= ' AND learningPeriodId != ?';
        	$args[] = $learningPeriodId;
        }
                           
        $result = $this->getDatabase()->query(SAGU::prepare($sql, $args));
        
        return $result;
    }
    
    /**
     * Update the specified learning period data.
     *
     * @author Jamiel Spezia [jamiel@solis.coop.br]
     *
     * @param $data (object): Data identifying the learning period and its new data.
     *
     * @return On succeed, returns true. Otherwise, false.
     */
    public function updateLearningPeriod($data)
    {
    	$module = 'academic';
    	$retVal = false;
    	
    	try
    	{
            $periods = $this->checkLearningPeriodDates($data->courseId, $data->courseVersion, $data->turnId, $data->unitId, $data->beginDate, $data->endDate, $data->learningPeriodId);
            if ( count($periods) > 0 )
            {
                throw new Exception(_M('Datas de início e fim sobrepõem as datas do seguinte período letivo: @1', $module, implode(', ', $periods)));
            }

            $sql = 'UPDATE acdLearningPeriod
	                   SET periodId = ?,
	                       courseId = ?,
	                       courseVersion = ?,
	                       turnId = ?,
	                       parcelsNumber = ?,
	                       unitId = ?,
	                       description = ?,
	                       formationLevelId = ?,
	                       previousLearningPeriodId = ?,
	                       beginDate = TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
	                       endDate = TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
	                       beginDateLessons = TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
	                       weekEndExamsBegin = TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
	                       finalAverage = ?,
	                       minimumFrequency = ?,
	                       minimumCredits = ?,
	                       minimumCreditsFreshman = ?,
	                       minimumCreditsTurn = ?,
	                       isFinanceGenerate = ?,
	                       disapprovementsToDisapprovePeriod = ?,
	                       isClosed = ?,
	                       maximumperiods = ?,
	                       maximumdisapprovals = ?,
                               isnumberhours = ?,
                               maximumCredits = ?,
                               maximumCreditsFreshman = ?,
                               gradesByConcept = ?,
                               evaluationControlMethodId = ?,
                               justifyDisapprovals = ?,
                               enrollAcceptedTerm = ?,
                               maximumFinalAverage = ?,
                               limitRegisterDate = ?,
                               blockFinalExaminationGradesTyping = ?,
                               matriculasemminimodecreditos = ?
	                 WHERE learningPeriodId = ?';
	
	        $args = array( $data->periodId,
	                       $data->courseId,
	                       $data->courseVersion,
	                       $data->turnId,
	                       $data->parcelsNumber,
	                       $data->unitId,
	                       strtoupper($data->description),
	                       $data->formationLevelId,
	                       $data->previousLearningPeriodId,
	                       $data->beginDate,
	                       $data->endDate,
	                       $data->beginDateLessons,
	                       $data->weekEndExamsBegin,
	                       $data->finalAverage,
	                       $data->minimumFrequency,
	                       $data->minimumCredits,
	                       $data->minimumCreditsFreshman,
	                       $data->minimumCreditsTurn,
	                       $data->isFinanceGenerate,
	                       $data->disapprovementsToDisapprovePeriod,
	                       $data->isClosed,
	                       $data->maximumPeriods,
	                       $data->maximumDisapprovals,
                               $data->isNumberHours,
                               $data->maximumCredits,
                               $data->maximumCreditsFreshman,
                               $data->gradesByConcept,
                               $data->evaluationControlMethodId,
                               $data->justifyDisapprovals,
                               $data->enrollAcceptedTerm,
                               $data->maximumFinalAverage,
                               $data->limitRegisterDate,
                               $data->blockFinalExaminationGradesTyping,
                               $data->matriculasemminimodecreditos,
	                       $data->learningPeriodId );
                
	        $sqls = SAGU::prepare($sql, $args, false);
	
	        $retVal = true;
	        for ( $i=0; $i<count($sqls) && $retVal; $i++ )
	        {
	            $retVal = $this->getDatabase()->execute($sqls[$i]);
	        }
    	}
    	catch ( Exception $e )
    	{
            $retVal = false;
            $this->addError($e->getMessage());
    	}

        return $retVal;
    }
    
    public function getLearningPeriodByDatesPeriod($beginDate, $endDate, $courseId = null, $courseVersion = null, $turnId = null, $unitId = null)
    {
        $sql = "SELECT learningPeriodId
                  FROM acdLearningPeriod
                 WHERE (begindate, enddate) OVERLAPS (TO_DATE(?,'dd/mm/yyyy'), TO_DATE(?,'dd/mm/yyyy'))
                   AND courseid = ?
                   AND courseversion = ?
                   AND turnid = ?
                   AND unitid = ?
                   ORDER BY enddate DESC LIMIT 1;";
        
        $args = array($beginDate, $endDate, $courseId, $courseVersion, $turnId, $unitId);
        $result = $this->getDatabase()->query(SAGU::prepare($sql, $args));
        
        return $result[0][0];
    }

    /**
     * Delete the specified learning period.
     *
     * @author Jamiel Spezia [jamiel@solis.coop.br]
     *
     * @param $courseId (int): Identifier of the learning period to be retrieved.
     *
     * @return On succeed, returns true. Otherwise, false.
     */
    public function deleteLearningPeriod($learningPeriodId)
    {
        $delete = 'DELETE FROM acdLearningPeriod
                         WHERE learningPeriodId = ?';


        $result = $this->getDatabase()->Execute(SAGU::prepare($delete,$learningPeriodId));

        return $result;
    }
    
    /**
     * Valida o período para ser deletado. Se o periodo existir em qualquer
     * umas das 5 tabelas chamadas na função, o período não pode ser excluido,
     * informando um erro destinto para cada tabela.
     *
     * @author Augusto A. Silva [augusto@solis.coop.br]
     * 
     * @param type $learningPeriodId : id do período
     */
    public function validateDelOfLearningPeriod($learningPeriodId)
    {
        $errorMsg = "";
        
        $sql = 'SELECT learningPeriodId
                  FROM unit_acdPeriodEnrollDate 
                 WHERE learningPeriodId = ?';
        
        $result = $this->getDatabase()->query(SAGU::prepare($sql, $learningPeriodId));                
        if ( isset($result[0][0]) )
        {
            $errorMsg .= _M('Já existe um período de matrícula.<br>');
        }
        
        $sql = 'SELECT learningPeriodId 
                  FROM unit_acdGroup 
                 WHERE learningPeriodId = ?;';
        
        $result = $this->getDatabase()->query(SAGU::prepare($sql, $learningPeriodId));
        if ( isset($result[0][0]) )
        {
            $errorMsg .= _M('Já existe uma oferta de disciplinas.<br>');
        }
        
        $sql = 'SELECT learningPeriodId 
                  FROM acdExamDate 
                 WHERE learningPeriodId = ?;';
        
        $result = $this->getDatabase()->query(SAGU::prepare($sql, $learningPeriodId));
        if ( isset($result[0][0]) )
        {
            $errorMsg .= _M('Já existe datas de exame.<br>');
        }
        
        $sql = 'SELECT learningPeriodId 
                  FROM acdCurricularComponentUnblock 
                 WHERE learningPeriodId = ?;';
        
        $result = $this->getDatabase()->query(SAGU::prepare($sql, $learningPeriodId));
        if ( isset($result[0][0]) )
        {
            $errorMsg .= _M('Já existe contratos trancados ou reativados.<br>');
        }
        
        $sql = 'SELECT initialLearningPeriodId 
                  FROM unit_acdclass 
                 WHERE initialLearningPeriodId = ?;';
        
        $result = $this->getDatabase()->query(SAGU::prepare($sql, $learningPeriodId));
        if ( isset($result[0][0]) )
        {
            $errorMsg .= _M('Já existe uma turma.<br>');
        }
        
        return $errorMsg;
    }

    /**
     * Find a learning period with a contract id and a period id.
     *
     * @author Alexandre Heitor Schmidt [alexsmith@solis.coop.br]
     * 
     * @param $contractId (integer): Contract id to get course occurrence
     * @param $periodId (string): Period id.
     *
     * @return (object) A AcdLearningPeriod object or null if no learning period found.
     */
    public function getLearningPeriodByContractAndPeriod($contractId, $periodId)
    {
        $sql = 'SELECT A.learningPeriodId
                  FROM unit_acdlearningperiod A
            INNER JOIN unit_acdContract B
                    ON B.courseId = A.courseId AND
                       B.courseVersion = A.courseVersion AND
                       B.turnId = A.turnId AND
                       B.unitId = A.unitId
                 WHERE B.contractId = ?
                   AND A.periodId = ?';

        $args = array( $contractId,
                       $periodId );

        $return = $this->getDatabase()->query(SAGU::prepare($sql, $args));

        $retVal = null;
        if ( strlen($return[0][0]) > 0 )
        {
            $retVal = $this->getLearningPeriod($return[0][0]);
        }

        return $retVal;
    }

    /**
     *  Function to get the Previous Learning period
     *
     * @author Jonas Gualberto Diel [jonas_diel@solis.coop.br]
     *
     * @param Date $beginDate - Begin date of new learning period
     * @param int $courseId - Course id
     * @param int $courseVersion - Course version id
     * @param int $unitId - Unit id
     * @param int $turnId - Turn id
     *
     * @return int Previous - Learning period id
     */
    public function getPreviousLearningPeriod($beginDate, $courseId, $courseVersion, $unitId, $turnId)
    {
        $sql = "SELECT * FROM findpreviouslearningperiodid(to_date(?,'".SAGU::getParameter('basic', 'MASK_DATE')."'),?,?,?,?);";

        $args[] = $beginDate;
        $args[] = $courseId;
        $args[] = $courseVersion;
        $args[] = $unitId;
        $args[] = $turnId;
        
        $result = $this->getDatabase()->query(SAGU::prepare($sql, $args));

        return $result;
    }

    public function disapprovePeriod($learningPeriodId, $contractsToDisapprovePeriod)
    {
        $MIOLO = MIOLO::getInstance();
        $module = MIOLO::getCurrentModule();

        if ( strlen($contractsToDisapprovePeriod) > 0 )
        {
            $enrollsToDisapproveSQL = 'SELECT trim(substr(CONCAT(enrollId || \',\'), 0,                                                                      length(CONCAT(enrollId || \',\'))))
                                         FROM unit_acdEnroll
                                   INNER JOIN unit_acdGroup
                                           ON( unit_acdEnroll.groupId = unit_acdGroup.groupId AND
                                               unit_acdGroup.learningPeriodId = ? AND
                                               unit_acdEnroll.statusId IN (?,?) )
                                        WHERE contractId IN(' . $contractsToDisapprovePeriod . ')';

            $args = array(  $learningPeriodId,
                            SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_APPROVED'),
                            SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED')  );

            $enrollsToDisaprove = $this->getDatabase()->query(SAGU::prepare($enrollsToDisapproveSQL, $args));

            if ( strlen($enrollsToDisaprove[0][0] > 0) )
            {
                $sql = ' UPDATE acdEnroll
                            SET statusId = ?
                          WHERE enrollId IN( '.$enrollsToDisaprove[0][0].' )';

                $args = array(  SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_DISAPPROVED_BY_PERIOD') );

                $sqls = SAGU::prepare($sql, $args);

                for ( $i=0; $i<count($sqls); $i++ )
                {
                    $result = $this->getDatabase()->execute($sqls[$i]);
                }

                $arrayContracts = array_unique(explode(',',$contractsToDisapprovePeriod));

                $busClass = new BusinessAcademicBusClass();
                $busClassPupil = new BusinessAcademicBusClassPupil();

                foreach ( $arrayContracts as $contractId ) // Inserting the drives contract for disapprove period
                {
                    $sql = 'INSERT INTO acdMovementContract
                                        ( contractId,
                                          stateContractId,
                                          stateTime,
                                          learningPeriodId
                                         )
                                  VALUES ( ?,
                                           ?,
                                           TO_TIMESTAMP(?,\'' . SAGU::getParameter('BASIC', 'MASK_TIMESTAMP') . '\'),
                                           ?
                                         )';

                    $args = array( $contractId,
                                   SAGU::getParameter('ACADEMIC', 'STATE_CONTRACT_ID_PERIOD_DISAPPROVEMENT'),
                                   date(SAGU::getParameter('BASIC', 'MASK_TIMESTAMP_PHP')),
                                   $learningPeriodId );

                    $result = $this->getDatabase()->Execute(SAGU::prepare($sql, $args));

                    $sql = 'INSERT INTO acdMovementContractComplement
                                        ( contractId,
                                          stateContractId,
                                          stateTime,
                                          stateContractFieldId,
                                          value
                                         )
                                  VALUES ( ?,
                                           ?,
                                           TO_TIMESTAMP(?,\'' . SAGU::getParameter('BASIC', 'MASK_TIMESTAMP') . '\'),
                                           ?,
                                           ?
                                         )';

                    $currenClassContract = $busClassPupil->getContractCurrentClass($contractId);

                    array_pop($args);
                    $args[] = SAGU::getParameter('ACADEMIC', 'STATE_CONTRACT_PERIOD_DISAPPROVEMENT_FIELD');
                    $args[] = $busClass->getSemesterContract($contractId);

                    $result = $this->getDatabase()->Execute(SAGU::prepare($sql, $args));
                }
            }
        }
        else
        {
            $result = false;
        }

        return $result;
    }

    /**
     * Check wether all groups belonging to the specified learning period id are closed or not.
     * 
     * @param $learningPeriodId (integer) Id of the learning period being queried for open groups.
     *
     * @return (boolean) True when all groups are closed. False when one or more open groups are found.
     */
    public function allGroupsClosed($learningPeriodId)
    {
        /* Verifica se há disciplinas abertas no período. Garantir que, caso alguma disciplina
         * em aberto seja encontrada, não se trate de uma disciplina que só tenha alunos cancelados,
         * desistentes ou dispensados. Caso existam oferecidas sem alunos matriculados, estas podem
         * ser fechadas sem verificações. Por este motivo, não são computadas neste SQL.
         */
        $sql = 'SELECT COUNT(DISTINCT A.groupId)
                  FROM unit_acdEnroll A
            INNER JOIN unit_acdGroup B
                    ON B.groupId = A.groupId
                 WHERE B.isClosed = FALSE
                   AND A.statusId NOT IN (\'' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_CANCELLED') . '\',\'' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_DESISTING') . '\',\'' . SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_EXCUSED') . '\')
                   AND B.learningPeriodId = ?';

        $result = $this->getDatabase()->query(SAGU::prepare($sql, array($learningPeriodId)));

        return ($result[0][0] == 0);
    }

    public function getContractsToDisapprovePeriod($learningPeriodId, $disapprovementsToDisapprovePeriod)
    {
        $sql = 'SELECT trim(substr(CONCAT(contractId || \',\'), 0,                                                                    length(CONCAT(contractId || \',\')))) 
                  FROM ( SELECT count(*) as disapprovements,
                                contractId
                           FROM unit_acdEnroll A
                     INNER JOIN unit_acdGroup B ON ( A.groupId = B.groupId )
                          WHERE A.statusId IN (?, ?)
                            AND B.learningPeriodId = ?
                       GROUP BY contractId)a
                          WHERE disapprovements >= ?';

        $args = array( SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_DISAPPROVED'),
                       SAGU::getParameter('ACADEMIC', 'ENROLL_STATUS_DISAPPROVED_FOR_LACKS'),
                       $learningPeriodId,
                       $disapprovementsToDisapprovePeriod );

        $contractsToDisapprovePeriod = $this->getDatabase()->query(SAGU::prepare($sql, $args));

        $returnData = new stdClass();
        list( $returnData->contractIds ) = str_replace(' ','',$contractsToDisapprovePeriod[0]);

        return $returnData;
    }

	/**
	 * Try to find a learning period based on a date.
	 * 
	 * @param (string) $courseId The course id of the learning period.
	 * @param (int) $courseVersion The course version of the learning period.
	 * @param (int) $turnId The turn id of the learning period.
	 * @param (int) $unitId The unit id of the learning period.
	 * @param (date) $date The date which must lie between the learning period's begin and end dates.
	 * 
	 * @return If a period is found, return it as an object, identical to the $this->getLearningPeriod() method. Otherwise, return null;
	 */
    public function getLearningPeriodByDate($courseId, $courseVersion, $turnId, $unitId, $date, $all = false)
    {
        $MIOLO = MIOLO::getInstance();
        $module = MIOLO::getCurrentModule();
        
        // Caso parâmetro '$all' seja true, traz todos os períodos letivos, independente a unidade.
        $acdLearningPeriod = ( $all ) ? 'acdLearningPeriod' : 'unit_acdlearningperiod';
        
    	$sql = 'SELECT learningPeriodId,
    	               description
    	          FROM ' . $acdLearningPeriod . '
    	         WHERE courseId = ?
    	           AND courseVersion = ?
    	           AND turnId = ?
                   AND unitId = ?
    	           AND TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\') BETWEEN beginDate AND endDate
    	      ORDER BY beginDate';

    	$result = $this->getDatabase()->query(SAGU::prepare($sql, array($courseId, $courseVersion, $turnId, $unitId, $date)));
    	
    	$retVal = null;
    	if ( count($result) > 1 )
    	{
    		$msg = _M('Os seguintes períodos letivos possuem datas que se sobrepõem:', $module) . '<br />';
    		for ( $i=0; $i<count($result); $i++ )
    		{
    			$msg .= $result[$i][0] . ' - ' . $result[$i][1] . '<br />';
    		}
    		$MIOLO->error($msg);
    	}
    	elseif ( count($result) == 1 )
    	{
    		$retVal = $this->getLearningPeriod($result[0][0], $all);
    	}
    	
    	return $retVal;
    }

    /**
     * Função que fecha um determinado período letivo
     *
     * @param (integer) $learningPeriodId
     * @return (boolean)
     */
    public function closeLearningPeriod($learningPeriodId)
    {
        $MIOLO = MIOLO::getInstance();
        $module = SAGU::getFileModule(__FILE__);
        
        // Dá erro se período já fechado
        $learningPeriod = $this->getLearningPeriod($learningPeriodId);

        if ( strlen($learningPeriod->learningPeriodId) <= 0 )
        {
            $this->addError(_M('Período letivo @1 não encontrado.', $module, $learningPeriod));
            throw new Exception();
        }

        if ( $learningPeriod->isClosed == DB_TRUE )
        {
            $this->addError(_M('Período letivo @1 já está fechado.', $module, $learningPeriodId));
            throw new Exception();
        }

        $busGroup = new BusinessAcademicBusGroup();
        $busCourseVersion = new BusinessAcademicBusCourseVersion();

        $filters = new stdClass();
        $filters->isClosed = DB_FALSE;
        $filters->learningPeriodId = $learningPeriodId;
        $groups = $busGroup->searchGroup($filters);

        $busDegreeCurricularComponentGroup = new BusinessAcademicBusDegreeCurricularComponentGroup();
        $busDegree = new BusinessAcademicBusDegree();

        $busDegreeEnroll = new BusinessAcademicBusDegreeEnroll();

        // Para cada oferecida
        for ( $i = 0; $i<count($groups); $i++ )
        {
            /*
             * Se algum erro ocorrer, replica-lo neste business para
             * poder ser capturado por quem chamou este método
             */
            try
            {
                /*
                 * Verifica se o método de avalição no período letivo é
                 * por grupo de disciplinas
                 */
                if ( $learningPeriod->evaluationControlMethodId == 2 )
                {
                    // Obtem os alunos da oferecida
                    $busGradeTyping = new BusinessAcademicBusGradeTyping();
                    $dataPupils = $busGradeTyping->listGroupEnrolledPupils($groups[$i][0]);

                    foreach( (array)$dataPupils as $pupil )
                    {
                        // Obtem a degreeId da nota final do período letivo
                        $filtersDegree = new stdClass();
                        $filtersDegree->learningPeriodId = $learningPeriod->learningPeriodId;
                        $filtersDegree->parentDegreeIdIsNull = DB_TRUE;
                        $degree = $busDegree->searchDegree($filtersDegree);
                        $degreeId = $degree[0][0];

                        // Obtem a nota obtida no eixo temático
                        $enrollId = $pupil[0];
                        $contractId = $pupil[7];
                        $concept = $groups[$i][11];
                        $curricularComponentGroupId = $groups[$i][12];
                        $note = $busDegreeCurricularComponentGroup->getDegreeEnrollCurrentGrade($learningPeriod->learningPeriodId, $contractId, $curricularComponentGroupId, ($concept == DB_TRUE) ? true : false );
                        $noteValue = $note->evaluation;
                        $statusId = $note->enrollStatusId;
                        
                        /* Insere uma nova nota final para o aluno na disciplina oferecida
                         * a nota e o status serão os digitados no eixo temático
                         */
                        $dataDegreeEnroll = new stdClass();
                        $dataDegreeEnroll->degreeId = $degreeId;
                        $dataDegreeEnroll->enrollId = $enrollId;

                        if ( $concept == DB_TRUE )
                        {
                            $dataDegreeEnroll->concept = $noteValue;
                        }
                        else
                        {
                            $dataDegreeEnroll->note = $noteValue;
                        }
                        
                        $dataDegreeEnroll->description = _M('NOTA INSERIDA PELO EIXO TEMÁTICO', $module);
                        $dataDegreeEnroll->recordDate = date(SAGU::getParameter('BASIC', 'MASK_TIMESTAMP_PHP'));

                        // Insere a nova nota para o aluno
                        $busDegreeEnroll->insertDegreeEnroll($dataDegreeEnroll);

                    }
                }

                /* Chamar rotina de fechamento de oferecida para cada
                 * oferecida do período
                 */
                $busGroup->closeGroup($groups[$i][0]);
            }
            catch ( Exception $e )
            {
                /* Se ocorrerem erros no processo de fechamento, repassar os erros
                 * para o busLearningPeriod.
                 */
                $errors = $busGroup->getErrors();
                for ( $j=0; $j<count($errors); $j++ )
                {
                    $this->addError($errors[$j]);
                }
            }
        }

        // Abortar operação se houve algum erro
        if ( count($this->getErrors()) > 0 )
        {
            throw new Exception();
        }

        // Verifica se conseguiu fechar todas as disciplinas que tinham de ser fechadas
        if ( !$this->allGroupsClosed($learningPeriodData->learningPeriodId) )
        {
            $this->addError(_M('Este período letivo só poderá ser fechado quando todas as disciplinas oferecidas relacionadas estiverem fechadas.', $module));
            throw new Exception();
        }

        /* Para cursos seriados, verificar se existem contratos que devem ser
         * marcados como reprovados no período
         */
        $courseVersion = $busCourseVersion->getCourseVersion($learningPeriod->courseId, $learningPeriod->courseVersion);

        // Se existirem, reprovar contratos no período
        if ( in_array($courseVersion->courseVersionTypeId, explode(',', SAGU::getParameter('ACADEMIC', 'ACD_COURSE_TYPE_ID_SERIAL'))) )
        {
            $contractsToDisapprovePeriod = $this->getContractsToDisapprovePeriod($learningPeriod->learningPeriodId, $learningPeriod->disapprovementsToDisapprovePeriod);
            if ( count($contractsToDisapprovePeriod->contractIds) > 0 )
            {
                $this->disapprovePeriod($learningPeriodData->learningPeriodId, $contractsToDisapprovePeriod->contractIds);
            }
        }

        // Se chegar até aqui, o período letivo pode ser marcado como fechado
        $learningPeriod->isClosed = DB_TRUE;
        if ( !$this->updateLearningPeriod($learningPeriod) )
        {
            $this->addError(_M('Erro fechando período letivo @1.', $module, $learningPeriodId));
            throw new Exception();
        }

        return true;
    }
    
    /**
     * Obtem a data limite definida para registro de nota/frequencia.
     * 
     * A data pode ser obtida tanto do desbloqueio por disciplina oferecida
     *  quanto do período letivo, prevalecerá a MAIOR.
     * 
     * @return string
     */
    public function obterDataLimiteParaRegistro($groupId)
    {
        $sql = 'SELECT dateToUser((SELECT MAX(x) FROM UNNEST(ARRAY[gu.limitdate, lp.limitregisterdate]) x))
                  FROM acdgroup g
            INNER JOIN acdlearningperiod lp ON lp.learningperiodid = g.learningperiodid
             LEFT JOIN acdgroupunblock gu ON gu.groupid = g.groupid
                   AND gu.groupunblockid = (SELECT groupunblockid FROM acdgroupunblock WHERE groupid = g.groupid ORDER BY registerdate DESC LIMIT 1)
                 WHERE g.groupId = ?';
        
        $rows = SDatabase::query($sql, array($groupId));
        
        return $rows[0][0];
    }
    
    /**
     * Verifica se o PORTAL tem permissao de digitar nota ou frequencia de acordo com data limite estabelecida.
     * 
     * CUIDADO: Funcao utilizada no SAGU e PORTAL NOVO
     * 
     * @return boolean
     */
    public function permiteRegistrarNotaOuFrequencia($groupId)
    {
        $date = $this->obterDataLimiteParaRegistro($groupId);
        
        $sql = 'SELECT ? IS NULL OR NOW()::date <= dateToDb(?)';
        $rows = SDatabase::query($sql, array($date, $date));
        
        return $rows[0][0] == DB_TRUE;
    }
    
    /**
     * CUIDADO: Funcao utilizada no SAGU e PORTAL NOVO
     * 
     * @return string
     */
    public function obterMensagemDigitacaoBloqueada($groupId)
    {
        $module = SAGU::getFileModule(__FILE__);
        $date = $this->obterDataLimiteParaRegistro($groupId);

        $msg = _M('N&atilde;o &eacute; permitido mais alterar os dados desta disciplina, pois foi estabelecida uma data limite que vai at&eacute; @1.', $module, $date);
        
        return $msg;
    }
    
    public function obterPeriodoAtual()
    {
        $sql = " SELECT getParameter('BASIC', 'CURRENT_PERIOD_ID') ";
        
        $result = $this->getDatabase()->query($sql);
        
        return $result[0][0];
    }
    
     
    /**
     * Obtém o código do período letivo através do código da disciplina oferecida
     * groupid
     * 
     * @param int $groupId
     * @return int learningPeriodId
     */
    public function getLearningPeriodByGroup($groupId)
    {
        $sql = 'SELECT learningPeriodId
                  FROM unit_acdGroup A
                 WHERE groupId = ?';

        $args = array( $groupId );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $args));

        return ($result[0][0]);
    }
    
    public function getLastLearningPeriodByCourse($courseId, $courseVersion, $turnId, $unitId)
    {
        $sql = 'SELECT learningperiodid
                  FROM acdlearningperiod 
                 WHERE courseid = ? 
                   AND courseversion = ? 
                   AND turnid = ? 
                   AND unitid = ? 
              ORDER BY begindate DESC LIMIT 1';

        $args = array( $courseId, $courseVersion, $turnId, $unitId );

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $args));

        return ($result[0][0]);
    }
     
    public function obterNotaMaximaDaDisciplina($groupId)
    {
        $sql = new MSQL();
        $sql->setTables('acdgroup A LEFT JOIN acdlearningperiod B ON (A.learningperiodid = B.learningperiodid)');
        $sql->setColumns('maximumfinalaverage');
        $sql->setWhere('A.groupid = ?');
        $sql->addParameter($groupId);

        $result = $this->getDatabase()->query($sql->select());
        return $result[0][0];
    }
    
    
}
?>
