<?php
/**
 * <--- Copyright 2005-2010 de Solis - Cooperativa de Soluções Livres Ltda.
 *
 * Este arquivo é parte do programa Sagu.
 *
 * O Sagu é um software livre; você pode redistribuí-lo e/ou modificá-lo
 * dentro dos termos da Licença Pública Geral GNU como publicada pela Fundação
 * do Software Livre (FSF); na versão 2 da Licença.
 *
 * Este programa é distribuído na esperança que possa ser útil, mas SEM
 * NENHUMA GARANTIA; sem uma garantia implícita de ADEQUAÇÃO a qualquer MERCADO
 * ou APLICAÇÃO EM PARTICULAR. Veja a Licença Pública Geral GNU/GPL em
 * português para maiores detalhes.
 *
 * Você deve ter recebido uma cópia da Licença Pública Geral GNU, sob o título
 * "LICENCA.txt", junto com este programa, se não, acesse o Portal do Software
 * Público Brasileiro no endereço www.softwarepublico.gov.br ou escreva para a
 * Fundação do Software Livre (FSF) Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA --->
 *
 * Class responsible for storing the functions of login.
 *
 * @author Samuel Koch [samuel@solis.coop.br]
 *
 * @version $Id$
 *
 * \b Maintainers: \n
 * Arthur Lehdermann [arthur@solis.coop.br]
 * Samuel Koch [samuel@solis.coop.br]
 * Jonas Gualberto Diel [jonas_diel@solis.coop.br]
 *
 * @since
 * Class created on 09/07/2009
 *
 * */

/**
 * Form to manipulate a login
 * */
class webServicesAcademic
{
    private $auth;
    private $MIOLO;

    const TYPE_CREDIT = 'c';
    const TYPE_SERIAL = 's';

    public function __construct()
    {
        global $MIOLO;

        chdir( '../' );

        $_SERVER['REQUEST_URI'] = 'module=academic';

        require_once 'classes/miolo.class';
        require_once 'classes/support.inc';

        $this->MIOLO = MIOLO::getInstance();

        $this->MIOLO->conf = new MConfigLoader();
        $this->MIOLO->conf->LoadConf();

        $this->MIOLO->Init();
        $this->MIOLO->Uses( 'classes/sagu.class', 'basic' );
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return the contracts of the student
     *
     * @param: $personId (integer): Is code of student
     *
     * @return (array): Return a array of objects with the informations of contract
     */
    public function wsSearchContract( $personId )
    {
        $busContract = new BusinessAcademicBusContract();

        $filters = new stdClass();
        $filters->personId = $personId;
        $wsContracts = $busContract->searchContract( $filters );

        if ( count( $wsContracts ) > 0 )
        {
            foreach ( $wsContracts as $value )
            {
                list ( $contractId,
                    $personId,
                    $personName,
                    $courseIdVersion,
                    $courseName,
                    $courseVersion,
                    $turnDescription,
                    $unitDescription,
                    $null,
                    $employeeId,
                    $isPayrollDiscount ) = $value;

                $contract = new stdClass();
                $contract->contractId = $contractId;
                $contract->personId = $personId;
                $contract->personName = $personName;
                $contract->courseIdVersion = $courseIdVersion;
                $contract->courseName = $courseName;
                $contract->turnDescription = $turnDescription;
                $contract->unitDescription = $unitDescription;
                $contract->employeeId = $employeeId;
                $contract->isPayrollDiscount = $isPayrollDiscount;
                $contracts[] = $contract;
            }
        }

        return $contracts;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return the contracts of the student
     *
     * @param: $personId (integer): Is code of student
     *
     * @return (array): Return a array of objects with the informations of contract
     */
    public function wsSearchDateForEnroll( $personId )
    {
        $busContract = new BusinessAcademicBusContract();
        $busPeriodEnrollDate = new BusinessAcademicBusPeriodEnrollDate();
        $wsContracts = $busContract->listAvailableContractsForEnroll( $personId );

        if ( count( $wsContracts ) > 0 )
        {
            foreach ( $wsContracts as $value )
            {
                $contract = new stdClass();
                list ( $contract->contractId,
                    $contract->courseId,
                    $contract->courseVersion,
                    $contract->courseName,
                    $contract->turnDescription,
                    $contract->unitDescription ) = $value;

                $contract->courseName = $contract->courseName;
                $wsLearningPeriodEnrollDate = $busPeriodEnrollDate->searchPeriodEnrollDate( $contract );

                if ( count( $wsLearningPeriodEnrollDate ) > 0 )
                {
                    foreach ( $wsLearningPeriodEnrollDate as $value1 )
                    {
                        list ( $periodEnrollDateId,
                            $learningPeriodId,
                            $description,
                            $beginDate,
                            $endDate,
                            $isInternet,
                            $isAdjustment,
                            $isSelectiveProc ) = $value1;

                        $learningPeriod = new stdClass();
                        $learningPeriod->periodEnrollDateId = $periodEnrollDateId;
                        $learningPeriod->description = $description;
                        $learningPeriod->beginDate = $beginDate;
                        $learningPeriod->endDate = $endDate;
                        $learningPeriod->isInternet = $isInternet;
                        $learningPeriod->isAjustment = $isAdjustment;
                        $learningPeriod->isSelectiveProc = $isSelectiveProc;

                        $learningPeriods[] = $learningPeriod;
                    }
                }
            }
        }

        return $learningPeriods;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return the contracts of the student
     *
     * @param: $personId (integer): Is code of student
     *
     * @return (array): Return a array of objects with the informations of contract
     */
    public function wsSearchContractForEnroll( $personId )
    {
        $busContract = new BusinessAcademicBusContract();
        $wsContracts = $busContract->listAvailableContractsForEnroll( $personId );

        if ( count( $wsContracts ) > 0 )
        {
            foreach ( $wsContracts as $value )
            {
                $contract = new stdClass();
                list ( $contract->contractId,
                    $contract->courseId,
                    $contract->courseVersion,
                    $contract->courseName,
                    $contract->turnDescription,
                    $contract->unitDescription ) = $value;

                $contracts[] = $contract;
            }
        }

        return $contracts;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * FIXME: Add a comment.
     */
    public function wsListAvailableCurricularComponentForEnroll( $data2 )
    {
        $busContract = new BusinessAcademicBusContract();
        $busPeriodEnrollDate = new BusinessAcademicBusPeriodEnrollDate();
        $busEnroll = new BusinessAcademicBusEnroll();
        $busGroup = new BusinessAcademicBusGroup();
        $busEnrollConfig = new BusinessAcademicBusEnrollConfig();
        $busClassPupil = new BusinessAcademicBusClassPupil();
        $busCouse = new BusinessAcademicBusCourse();
        $busCouseVersion = new BusinessAcademicBusCourseVersion();
        $busLearningPeriod = new BusinessAcademicBusLearningPeriod();

        $wsContract = $busContract->getContract( $data2->contractId );
        $dataCourseVersion = $busCouseVersion->getCourseVersion( $wsContract->courseId, $wsContract->courseVersion );
        $versionType = $dataCourseVersion->courseVersionTypeId;
        $serial = SAGU::getParameter( 'academic', 'ACD_COURSE_TYPE_ID_SERIAL' );
        $serialArray = explode( ',', $serial );

        if ( in_array( $versionType, $serialArray ) ) //Verifica o se o curso é seriado ou de crédito
        {
            $courseVersionType = self::TYPE_SERIAL;
        }
        else
        {
            $courseVersionType = self::TYPE_CREDIT;
        }

        if ( count( $wsContract ) > 0 )
        {
            $data = $wsContract;
            $data->periodId = $data2->periodId;
            $data->isInternet = true;
            $wsLearningPeriodEnrollDate = $busPeriodEnrollDate->searchPeriodEnrollDate( $data );

            if ( count( $wsLearningPeriodEnrollDate ) > 0 )
            {
                foreach ( $wsLearningPeriodEnrollDate as $value1 )
                {
                    list ( $data->periodEnrollDateId,
                        $data->learningPeriodId,
                        $data->description,
                        $data->beginDate,
                        $data->endDate,
                        $data->isInternet,
                        $data->isAdjustment,
                        $data->isSelectiveProc ) = $value1;
                }
            }

            $enrollConfig = $busEnrollConfig->getCourseEnrollConfig( $data->courseId, $data->courseVersion, $data->turnId, $data->unitId );
            $courseComplementCurriculum = $busEnroll->getCourseCompleteCurriculum( $data->courseId, $data->courseVersion, $data->turnId, $data->unitId, $data->learningPeriodId );
            if ( count( $courseComplementCurriculum ) > 0 )
            {
                foreach ( $courseComplementCurriculum as $curriculuns )
                {
                    $curriculumData = new stdClass();
                    list ( $curriculumData->semester,
                        $curriculumData->curricularComponentId,
                        $curriculumData->curricularComponentVersion,
                        $curriculumData->curricularComponentName,
                        $curriculumData->curriculumId,
                        $curriculumData->curricularComponentGroupDocumentEndCourseId,
                        $curriculumData->curricularComponentGroupElectiveId,
                        $curriculumData->curricularComponentTypeId,
                        $curriculumData->curricularComponentType,
                        $curriculumData->curriculumTypeId,
                        $curriculumData->curriculumType,
                        $curriculumData->groupedPeriod,
                        $curriculumData->complementar ) = $curriculuns;

                    $isEnrolled = $busEnroll->isCoursed( $curriculumData, $data->contractId );
                    if ( !$isEnrolled )
                    {
                        unset( $filters );
                        $filters->curricularComponentId = $curriculumData->curricularComponentId;
                        $filters->curricularComponentVersion = $curriculumData->curricularComponentVersion;
                        $filters->isClosed = DB_FALSE;
                        $filters->isCancelation = DB_FALSE;

                        if ( $enrollConfig->showOtherCoursesGroups )
                        {
                            $filters->courseId = $data->courseId;
                        }

                        if ( $enrollConfig->showOtherUnitsGroups )
                        {
                            $filters->unitId = $data->unitId;
                        }

                        if ( $enrollConfig->showOtherTurnsGroups )
                        {
                            $filters->turnId = $data->turnId;
                        }

                        if ( $enrollConfig->showOtherClassesGroups )
                        {
                            unset( $filters1 );
                            $filters1->contractId = $data->contractId;
                            $class = $busClassPupil->searchClassPupil( $filters1 );
                            $filters->classId = $class[0][0];
                        }

                        if ( !$enrollConfig->freeotherperiodgroups )
                        {
                            $filters->learningPeriodId = $data->learningPeriodId;
                        }

                        $curriculumFreeGroups = $busGroup->searchGroup( $filters );

                        if ( count( $curriculumFreeGroups ) > 0 )
                        {
                            if ( ($busEnroll->isPreConditionsFree( $curriculumData, $data->contractId, $data->learningPeriodId, $enrollConfig->freeincourseconditions )) || $busEnroll->isConditionUnblocked( $curriculumData, $data->contractId, $data->learningPeriodId ) || $busEnroll->isConcurrenceFree( $curriculumData, $data->contractId, $data->learningPeriodId ) )
                            {
                                if ( $courseVersionType == self::TYPE_SERIAL )
                                {
                                    //verifica se existe dependencias atribuindo-as no array $dependencies
                                    $dependencies = $busEnroll->getContractDisapprovements( $data->contractId, $data->learningPeriodId );
                                    if ( count( $dependencies ) > 0 )
                                    {
                                        $dependenciesNumber = count( $dependencies ); //numero de dependencias
                                        $dataLearningPeriod = $busLearningPeriod->getLearningPeriod( $data->learningPeriodId );
                                        $maximumPeriods = $dataLearningPeriod->maximumPeriods; //máximo de periodos para cursar as dependencias
                                        $maximumDisapprovals = $dataLearningPeriod->maximumDisapprovals; //numero máximo de reprovações
                                        $disprovementPeriod = $dataLearningPeriod->disapprovementsToDisapprovePeriod; //numero de reprovações para cursar novamente todo o semestre
                                        //O aluno deve refazer todas as disciplinas do semestre. mesmo as que aprovou
                                        if ( $dependenciesNumber > $disprovementPeriod || $dependenciesNumber > $maximumDisapprovals )
                                        {
                                            if ( in_array( $curriculumData->curriculumId, $dependencies ) )
                                            {
                                                $arrayData['groupId'] = $curriculumFreeGroups[0][0];
                                                $arrayData['contractId'] = $data->contractId;
                                                $arrayData['curriculumId'] = $curriculumData->curriculumId;
                                                $arrayData['curricularComponentDescription'] = $curriculumFreeGroups[0][1];
                                                $arrayData['isCancelation'] = $curriculumFreeGroups[0][2];
                                                $arrayData['totalEnroled'] = $curriculumFreeGroups[0][3];
                                                $arrayData['learningPeriodId'] = $curriculumFreeGroups[0][7];
                                                $arrayData['curricularComponentId'] = $filters->curricularComponentId;
                                                $arrayData['curricularComponentVersion'] = $filters->curricularComponentVersion;
                                                $arrayData['isUnlock'] = DB_FALSE;
                                                $arrayData['isEnrolled'] = $this->wsIsEnrolledCurricularComponent( $data->contractId, $filters->curricularComponentId, $filters->curricularComponentVersion );
                                                $courseEnrollArray[] = $arrayData;
                                            }
                                        }
                                        elseif ( $dependenciesNumber <= $maximumDisapprovals )
                                        {
                                            $previousLearningPeriodId = $dataLearningPeriod->previousLearningPeriodId;

                                            for ( $cont = 1; $cont < $maximumPeriods && $previousLearningPeriodId; $cont++ )
                                            {
                                                $dataPeriod = $busLearningPeriod->getLearningPeriod( $previousLearningPeriodId );
                                                $previousLearningPeriodId = $dataPeriod->previousLearningPeriodId;
                                            }

                                            $cont = 0;
                                            while ( ($cont < $maximumPeriods) && $previousLearningPeriodId )
                                            {
                                                $oldDependencies = $busEnroll->getContractDisapprovementsInPeriod( $data->contractId, $data->learningPeriodId, $previousLearningPeriodId );
                                                if ( count( $oldDependencies ) > 0 )
                                                {
                                                    if ( count( $arrayOldDependencies ) > 0 )
                                                    {
                                                        foreach ( $oldDependencies as $cod => $line )
                                                        {
                                                            if ( !in_array( $line, $arrayOldDependencies ) )
                                                            {
                                                                $arrayOldDependencies[] = $line;
                                                            }
                                                        }
                                                    }
                                                    else
                                                    {
                                                        $arrayOldDependencies = $oldDependencies;
                                                    }
                                                }
                                                $dataPeriod = $busLearningPeriod->getLearningPeriod( $previousLearningPeriodId );
                                                $previousLearningPeriodId = $dataPeriod->previousLearningPeriodId;
                                                $cont++;
                                            }
                                            if ( in_array( $curriculumData->curriculumId, $dependencies ) )
                                            {
                                                if ( !(in_array( $curriculumData->curriculumId, $arrayOldDependencies )) )
                                                {
                                                    //disciplinas com menos de 2 semestres opcionais
                                                    $arrayData['isUnlock'] = DB_TRUE;
                                                }
                                                else
                                                {
                                                    //disciplinas com mais de 2 semestres obrigado a cursar
                                                    $arrayData['isUnlock'] = DB_FALSE;
                                                }
                                            }
                                            else
                                            {
                                                //disciplinas autuais obridadas a cursar
                                                $arrayData['isUnlock'] = DB_FALSE;
                                            }
                                            $arrayData['groupId'] = $curriculumFreeGroups[0][0];
                                            $arrayData['contractId'] = $data->contractId;
                                            $arrayData['curriculumId'] = $curriculumData->curriculumId;
                                            $arrayData['curricularComponentDescription'] = $curriculumFreeGroups[0][1];
                                            $arrayData['isCancelation'] = $curriculumFreeGroups[0][2];
                                            $arrayData['totalEnroled'] = $curriculumFreeGroups[0][3];
                                            $arrayData['learningPeriodId'] = $curriculumFreeGroups[0][7];
                                            $arrayData['curricularComponentId'] = $filters->curricularComponentId;
                                            $arrayData['curricularComponentVersion'] = $filters->curricularComponentVersion;
                                            $courseEnrollArray[] = $arrayData;
                                        }
                                    }
                                    else
                                    {
                                        $arrayData['groupId'] = $curriculumFreeGroups[0][0];
                                        $arrayData['contractId'] = $data->contractId;
                                        $arrayData['curriculumId'] = $curriculumData->curriculumId;
                                        $arrayData['curricularComponentDescription'] = $curriculumFreeGroups[0][1];
                                        $arrayData['isCancelation'] = $curriculumFreeGroups[0][2];
                                        $arrayData['totalEnroled'] = $curriculumFreeGroups[0][3];
                                        $arrayData['learningPeriodId'] = $curriculumFreeGroups[0][7];
                                        $arrayData['curricularComponentId'] = $filters->curricularComponentId;
                                        $arrayData['curricularComponentVersion'] = $filters->curricularComponentVersion;
                                        $arrayData['isUnlock'] = DB_FALSE;
                                        $courseEnrollArray[] = $arrayData;
                                    }
                                }
                                else
                                {
                                    $arrayData['groupId'] = $curriculumFreeGroups[0][0];
                                    $arrayData['contractId'] = $data->contractId;
                                    $arrayData['curriculumId'] = $curriculumData->curriculumId;
                                    $arrayData['curricularComponentDescription'] = $curriculumFreeGroups[0][1];
                                    $arrayData['isCancelation'] = $curriculumFreeGroups[0][2];
                                    $arrayData['totalEnroled'] = $curriculumFreeGroups[0][3];
                                    $arrayData['learningPeriodId'] = $curriculumFreeGroups[0][7];
                                    $arrayData['curricularComponentId'] = $filters->curricularComponentId;
                                    $arrayData['curricularComponentVersion'] = $filters->curricularComponentVersion;
                                    $arrayData['isUnlock'] = DB_TRUE;
                                    $courseEnrollArray[] = $arrayData;
                                }
                            }
                        }
                    }
                }
                if ( count( $courseEnrollArray ) > 0 )
                {
                    foreach ( $courseEnrollArray as $item )
                    {
                        $curricularComponent = new stdClass();

                        foreach ( $item as $id => $value )
                        {
                            $curricularComponent->$id = $value;
                        }

                        $curricularComponents[] = $curricularComponent;
                    }
                }
            }
        }

        return $curricularComponents;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * This function return if is enrolled the curricular component
     *
     * @param $contractId
     * @param $curricularComponentId
     * @param $curricularComponentVersion
     *
     * @return (boolean) Return if is enrolled
     */
    public function wsIsEnrolledCurricularComponent( $contractId, $curricularComponentId, $curricularComponentVersion )
    {
        $busEnroll = new BusinessAcademicBusEnroll();
        $wsIsEnrolled = $busEnroll->isEnrolledCurricularComponent( $contractId, $curricularComponentId, $curricularComponentVersion );

        return $wsIsEnrolled;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return the contracts of the student
     *
     * @param: $personId (integer): Is code of student
     *
     * @return (array): Return a array of objects with the informations of contract
     */
    public function wsGetContract( $contractId )
    {
        $busContract = new BusinessAcademicBusContract();
        $wsContracts = $busContract->getContract( $contractId );

        if ( count( $wsContracts ) > 0 )
        {
            $contract = new stdClass();
            $contract->contractId = $wsContracts->contractId;
            $contract->personId = $wsContracts->personId;
            $contract->personName = $wsContracts->personName;
            $contract->courseId = $wsContracts->courseId;
            $contract->courseVersion = $wsContracts->courseVersion;
            $contract->courseName = $wsContracts->courseName;
            $contract->turnDescription = $wsContracts->turnDescription;
            $contract->unitDescription = $wsContracts->unitDescription;
            $contract->formationDate = $wsContracts->formationDate;
            $contract->formationPeriodId = $wsContracts->formationPeriodId;
            $contract->conclusionDate = $wsContracts->conclusionDate;
            $contract->maturityDate = $wsContracts->maturityDay;
            $contract->isListener = $wsContracts->isListener;
            $contract->parcelsNumber = $wsContracts->parcelsNumber;
            $contract->isPayrollDiscount = $wsContracts->isPayrollDiscount;
        }

        return $contract;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return the frequency and notes
     *
     * @param: $contractId (integer): Is contract code of student
     * @param: $periodId (integer): Is period code
     *
     * @return (array): Return a array of objects with the curricilar component
     */
    public function wsGetFrequencyAndNotes( $contractId, $periodId )
    {
        $busDiverseConsultation = new BusinessAcademicBusDiverseConsultation();
        $busSchedule = new BusinessAcademicBusSchedule();
        $busTimeSheet = new BusinessAcademicBusTimeSheet();
        $busDegree = new BusinessAcademicBusDegree();
        $busFrequency = new BusinessAcademicBusFrequenceEnroll();

        $filters = new stdClass();
        $filters->contractId = $contractId;
        $filters->periodId = $periodId;
        $wsCurricularComponent = $busDiverseConsultation->getCurricularComponentCoursed( $filters );

        if ( count( $wsCurricularComponent ) > 0 )
        {
            foreach ( $wsCurricularComponent as $value )
            {
                list ( $enrollId,
                    $groupId,
                    $periodId,
                    $curricularComponentId,
                    $curricularComponentName,
                    $null,
                    $academicNumberHours,
                    $note,
                    $frequence,
                    $statusId,
                    $statusDescription,
                    $className) = $value;

                // Group Schedule Data With Rooms
                $wsGroupScheduleDataWithRooms = $busSchedule->getGroupScheduleDataWithRooms( $groupId );
                $wsDegree = $busDegree->getEnrollDegree( $groupId );

                if ( count( $wsGroupScheduleDataWithRooms ) > 0 )
                {
                    unset( $scheduleArray );
                    unset( $roomArray );

                    foreach ( $wsGroupScheduleDataWithRooms as $scheduleInfo )
                    {
                        unset( $scheduleStr );

                        if ( strlen( $scheduleInfo[0] ) > 0 )
                        {
                            $scheduleStr = $scheduleInfo[0];
                        }

                        if ( strlen( $scheduleStr ) > 0 )
                        {
                            $scheduleStr .= strlen( $scheduleInfo[1] ) ? '-' . $scheduleInfo[1] : '';
                        }
                        else
                        {
                            $scheduleStr = $scheduleInfo[1];
                        }

                        if ( strlen( $scheduleStr ) > 0 )
                        {
                            $scheduleArray[] = $scheduleStr;
                        }

                        unset( $roomStr );

                        if ( strlen( $scheduleInfo[2] ) > 0 )
                        {
                            $roomStr = $scheduleInfo[2];
                        }

                        if ( strlen( $roomStr ) > 0 )
                        {
                            $roomStr .= strlen( $scheduleInfo[3] ) ? '-' . $scheduleInfo[3] : '';
                        }
                        else
                        {
                            $roomStr = $scheduleInfo[3];
                        }

                        if ( strlen( $roomStr ) > 0 )
                        {
                            $roomArray[] = $roomStr;
                        }
                    }

                    unset( $str );

                    if ( count( $scheduleArray ) > 0 )
                    {
                        $str = implode( '/', $scheduleArray );
                    }

                    if ( count( $roomArray ) > 0 )
                    {
                        if ( strlen( $str ) > 0 )
                        {
                            $str .= "(" . implode( '/', $roomArray ) . ')';
                        }
                        else
                        {
                            $str = implode( '/', $roomArray );
                        }
                    }
                }
                // End Group Schedule Data With Rooms

                $curricularComponent = new stdClass();
                $curricularComponent->enrollId = $enrollId;
                $curricularComponent->groupId = $groupId;
                $curricularComponent->periodId = $periodId;
                $curricularComponent->curricularComponentId = $curricularComponentId;
                $curricularComponent->curricularComponentName = $curricularComponentName;
                $curricularComponent->academicNumberHours = $academicNumberHours;
                $curricularComponent->note = $note;
                $curricularComponent->frequence = $frequence;
                $curricularComponent->statusId = $statusId;
                $curricularComponent->statusDescription = $statusDescription;
                $curricularComponent->className = $className;
                $curricularComponent->timeAndRoom = $str;

                if ( count( $wsDegree ) > 0 )
                {
                    foreach ( $wsDegree as $value )
                    {
                        $wsDegreeEnroll = $busDegree->searchEnrollDegree( $enrollId, null, $value[0] );

                        list ( $degreeId,
                            $enrollId2,
                            $periodId,
                            $description,
                            $degreenumber,
                            $weight,
                            $note,
                            $concept,
                            $parentDegreeId ) = $wsDegreeEnroll[0];

                        $degree = new stdClass();
                        $degree->degreeId = $degreeId;
                        $degree->enrollId = $enrollId2;
                        $degree->periodId = $periodId;
                        $degree->description = $description;
                        $degree->degreeNumber = $degreenumber;
                        $degree->weight = $weight;
                        $degree->note = $note;
                        $degree->concept = $concept;
                        $degree->parentDegreeId = $parentDegreeId;

                        $curricularComponent->degrees[] = $degree;
                    }
                }

                // <schedules>
                $filters->groupId = $groupId;
                $schedules = $busSchedule->searchSchedule( $filters );

                unset( $scheduleArray );

                if ( count($schedules) > 0 )
                {
                    foreach ( $schedules as $dataSchedule )
                    {
                        list ( $scheduleId,
                            $groupId,
                            $unitId,
                            $unitDescription,
                            $periodId,
                            $beginDate,
                            $endDate ) = $dataSchedule;

                        $wsGroupSchedule = $busSchedule->getScheduleByGroup( $scheduleId );

                        if ( count( $wsGroupSchedule->occurrenceDates ) > 0 )
                        {
                            foreach ( $wsGroupSchedule->occurrenceDates as $value )
                            {
                                if ( count( $wsGroupSchedule->timeIds ) > 0 )
                                {
                                    foreach ( $wsGroupSchedule->timeIds as $value1 )
                                    {
                                        $filters->timeId = $value1;
                                        $timeSheet = $busTimeSheet->searchTime( $filters );

                                        list ( $timeId,
                                            $turnId,
                                            $beginHour,
                                            $endHour,
                                            $numberMinutes ) = $timeSheet[0];

                                        $valor = substr( $value, -4 ) . "-" . substr( $value, 3, 2 ) . "-" . substr( $value, 0, 2 );
                                        $count = 0;

                                        while ( array_key_exists( $valor . $count, $scheduleArray ) )
                                        {
                                            $count++;
                                        }

                                        $wsProfessorName = $busDiverseConsultation->getGroupProfessorNames( $groupId, $scheduleId );
                                        $scheduleArray[$valor . $count] = array ( $value, $beginHour . ' - ' . $endHour, $unitDescription, $wsProfessorName[0], $numberMinutes, $scheduleId, $timeId );
                                    }
                                }
                            }
                        }
                    }
                }

                if ( count( $scheduleArray ) > 0 )
                {
                    ksort( $scheduleArray );

                    foreach ( $scheduleArray as $value )
                    {
                        $schedule = new stdClass();
                        $schedule->occurrenceDate = $value[0];
                        $schedule->time = $value[1];
                        $schedule->unitDescription = $value[2];
                        $schedule->professorName = $value[3];
                        $schedule->numberMinutes = $value[4];
                        $schedule->scheduleId = $value[5];
                        $schedule->timeId = $value[6];

                        // Frequency
                        $wsFrequency = $busFrequency->getEnrollFrequencyOnDate( $enrollId, $value[5], $value[0], $value[6] );

                        $schedule->frequency = $wsFrequency;

                        $curricularComponent->schedules[] = $schedule;
                    }

                    unset( $scheduleArray );
                }// End Schedules

                $curricularComponents[] = $curricularComponent;
            }
        }

        return $curricularComponents;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return the schedules and curricular component
     *
     * @param: $contractId (integer): Is contract code of student
     * @param: $periodId (integer): Is period code
     *
     * @return (array): Return a array of objects with the curricilar component
     */
    public function wsGetScheduleCurricularComponent( $contractId, $periodId )
    {
        $busDiverseConsultation = new BusinessAcademicBusDiverseConsultation();
        $busSchedule = new BusinessAcademicBusSchedule();
        $busTimeSheet = new BusinessAcademicBusTimeSheet();

        $filters = new stdClass();
        $filters->contractId = $contractId;
        $filters->periodId = $periodId;

        $wsCurricularComponents = $busDiverseConsultation->getCurricularComponentCoursed( $filters );

        if ( count( $wsCurricularComponents ) > 0 )
        {
            foreach ( $wsCurricularComponents as $curricularComponent )
            {
                list ( $enrollId,
                    $groupId,
                    $periodId,
                    $curricularComponentId,
                    $curricularComponentName,
                    $null,
                    $academicNumberHours,
                    $note,
                    $frequence,
                    $statusId,
                    $statusDescription,
                    $className ) = $curricularComponent;

                $curricularComponent = new stdClass();
                $curricularComponent->enrollId = $enrollId;
                $curricularComponent->groupId = $groupId;
                $curricularComponent->periodId = $periodId;
                $curricularComponent->curricularComponentId = $curricularComponentId;
                $curricularComponent->curricularComponentName = $curricularComponentName;
                $curricularComponent->academicNumberHours = $academicNumberHours;
                $curricularComponent->note = $note;
                $curricularComponent->frequence = $frequence;
                $curricularComponent->statusId = $statusId;
                $curricularComponent->statusDescription = $statusDescription;
                $curricularComponent->className = $className;

                $filters->groupId = $groupId;
                $schedulesData = $busSchedule->searchSchedule( $filters );

                if ( count( $schedulesData ) > 0 )
                {
                    foreach ( $schedulesData as $scheduleData )
                    {
                        list ( $scheduleId,
                            $groupId,
                            $unitId,
                            $unitDescription,
                            $periodId,
                            $beginDate,
                            $endDate ) = $scheduleData;

                        $wsGroupSchedule = $busSchedule->getScheduleByGroup( $scheduleId );
                        $wsProfessorName = $busDiverseConsultation->getGroupProfessorNames( $groupId, $scheduleId );

                        if ( count( $wsGroupSchedule->occurrenceDates ) > 0 )
                        {
                            foreach ( $wsGroupSchedule->occurrenceDates as $occurrenceDate )
                            {
                                if ( count( $wsGroupSchedule->timeIds ) > 0 )
                                {
                                    foreach ( $wsGroupSchedule->timeIds as $timeId )
                                    {
                                        $filters->timeId = $timeId;
                                        $timeSheet = $busTimeSheet->searchTime( $filters );

                                        list ( $timeId,
                                            $turnId,
                                            $beginHour,
                                            $endHour,
                                            $numberMinutes ) = $timeSheet[0];

                                        $valor = substr( $occurrenceDate, -4 ) . "-" . substr( $occurrenceDate, 3, 2 ) . "-" . substr( $occurrenceDate, 0, 2 );
                                        $count = 0;

                                        while ( array_key_exists( $valor . $count, $scheduleArray ) )
                                        {
                                            $count++;
                                        }

                                        $scheduleArray[$valor . $count] = array ( $occurrenceDate, $beginHour . ' - ' . $endHour, $unitDescription, $wsProfessorName[0] );
                                    }
                                }
                            }
                        }
                    }
                }

                if ( is_array( $scheduleArray ) )
                {
                    ksort( $scheduleArray );

                    foreach ( $scheduleArray as $scheduleArrayData )
                    {
                        $schedule = new stdClass();
                        $schedule->occurrenceDate = $scheduleArrayData[0];
                        $schedule->time = $scheduleArrayData[1];
                        $schedule->unitDescription = $scheduleArrayData[2];
                        $schedule->professorName = $scheduleArrayData[3];

                        $curricularComponent->schedules[] = $schedule;
                    }

                    unset( $scheduleArray );
                }

                $curricularComponents[] = $curricularComponent;
            }
        }

        return $curricularComponents;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return the curricular component
     *
     * @param: $contractId (integer): Is contract code of student
     * @param: $periodId (integer): Is period code
     *
     * @return (array): Return a array of objects with the curricilar component
     */
    public function wsGetCurricularComponent( $contractId, $periodId )
    {
        $busDiverseConsultation = new BusinessAcademicBusDiverseConsultation();

        $filters->contractId = $contractId;
        $filters->periodId = $periodId;
        $wsCurricularComponent = $busDiverseConsultation->getCurricularComponentCoursed( $filters );

        if ( count( $wsCurricularComponent ) > 0 )
        {
            foreach ( $wsCurricularComponent as $value )
            {
                list ( $enrollId,
                    $groupId,
                    $periodId,
                    $curricularComponentId,
                    $curricularComponentName,
                    $null,
                    $academicNumberHours,
                    $note,
                    $frequence,
                    $statusId,
                    $statusDescription,
                    $className ) = $value;

                $curricularComponent = new stdClass();
                $curricularComponent->enrollId = $enrollId;
                $curricularComponent->groupId = $groupId;
                $curricularComponent->periodId = $periodId;
                $curricularComponent->curricularComponentId = $curricularComponentId;
                $curricularComponent->curricularComponentName = $curricularComponentName;
                $curricularComponent->academicNumberHours = $academicNumberHours;
                $curricularComponent->note = $note;
                $curricularComponent->frequence = $frequence;
                $curricularComponent->statusId = $statusId;
                $curricularComponent->statusDescription = $statusDescription;
                $curricularComponent->className = $className;

                $curricularComponents[] = $curricularComponent;
            }
        }

        return $curricularComponents;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return the scholarship description, complementary activities and proficiencies
     *
     * @param: $contractId (integer): Is contract code of student
     *
     * @return (array): Return a array of objects with the scholarship description
     */
    public function wsGetCurricularComponents( $contractId )
    {
        $busDiverseConsultation = new BusinessAcademicBusDiverseConsultation();
        $busComplementaryActivities = new BusinessAcademicBusComplementaryActivities();
        $busSchedule = new BusinessAcademicBusSchedule();

        $filters->contractId = $contractId;
        $filters->proficiency = false;
        $wsScholarschip = $busDiverseConsultation->getCurricularComponentCoursed( $filters );

        if ( count( $wsScholarschip ) > 0 )
        {
            $data = new stdClass();

            foreach ( $wsScholarschip as $value )
            {
                list ( $enrollId,
                    $groupId,
                    $periodId,
                    $curricularComponentId,
                    $curricularComponentName,
                    $null,
                    $academicNumberHours,
                    $note,
                    $frequency,
                    $statusId,
                    $statusDescription,
                    $className ) = $value;

                $wsProfessorName = $busDiverseConsultation->getGroupProfessorNames( $groupId );
                $wsSchedule = $busSchedule->getGroupScheduleDataWithRooms( $groupId );

                // Schedule
                if ( count( $wsSchedule ) > 0 )
                {
                    unset( $scheduleArray );
                    unset( $roomArray );

                    foreach ( $wsSchedule as $scheduleInfo )
                    {
                        unset( $scheduleStr );

                        if ( strlen( $scheduleInfo[0] ) > 0 )
                        {
                            $scheduleStr = $scheduleInfo[0];
                        }

                        if ( strlen( $scheduleStr ) > 0 )
                        {
                            $scheduleStr .= strlen( $scheduleInfo[1] ) ? '-' . $scheduleInfo[1] : '';
                        }
                        else
                        {
                            $scheduleStr = $scheduleInfo[1];
                        }

                        if ( strlen( $scheduleStr ) > 0 )
                        {
                            $scheduleArray[] = $scheduleStr;
                        }

                        unset( $roomStr );

                        if ( strlen( $scheduleInfo[2] ) > 0 )
                        {
                            $roomStr = $scheduleInfo[2];
                        }

                        if ( strlen( $roomStr ) > 0 )
                        {
                            $roomStr .= strlen( $scheduleInfo[3] ) ? '-' . $scheduleInfo[3] : '';
                        }
                        else
                        {
                            $roomStr = $scheduleInfo[3];
                        }

                        if ( strlen( $roomStr ) > 0 )
                        {
                            $roomArray[] = $roomStr;
                        }
                    }

                    unset( $str );

                    if ( count( $scheduleArray ) > 0 )
                    {
                        $str = implode( '/', $scheduleArray );
                    }

                    if ( count( $roomArray ) > 0 )
                    {
                        if ( strlen( $str ) > 0 )
                        {
                            $str .= "\n(" . implode( '/', $roomArray ) . ')';
                        }
                        else
                        {
                            $str = implode( '/', $roomArray );
                        }
                    }
                }
                //end shedule

                $scholarshipDescription = new stdClass();
                $scholarshipDescription->enrollId = $enrollId;
                $scholarshipDescription->groupId = $groupId;
                $scholarshipDescription->periodId = $periodId;
                $scholarshipDescription->curricularComponentId = $curricularComponentId;
                $scholarshipDescription->curricularComponentName = $curricularComponentName;
                $scholarshipDescription->academicNumberHours = $academicNumberHours;
                $scholarshipDescription->note = $note;
                $scholarshipDescription->frequency = $frequency;
                $scholarshipDescription->statusId = $statusId;
                $scholarshipDescription->statusDescription = $statusDescription;
                $scholarshipDescription->className = $className;
                $scholarshipDescription->professorName = $wsProfessorName[0];
                $scholarshipDescription->schedule = $str;

                $data->scholarshipDescriptions[] = $scholarshipDescription;
            }
        }

        $wsComplementaryActivities = $busComplementaryActivities->searchComplementaryActivities( $filters );

        if ( count( $wsComplementaryActivities ) > 0 )
        {
            foreach ( $wsComplementaryActivities as $value )
            {
                list ( $complementaryActivitiesId,
                    $enrollId,
                    $complementaryActivitiesDescription,
                    $totalHours,
                    $totalCredits,
                    $degree,
                    $concept,
                    $periodId,
                    $complementaryActivitiesCategoryId,
                    $complementaryActivitiesCategoryDescription ) = $value;

                $complementaryActivitie = new stdClass();
                $complementaryActivitie->enrollId = $enrollId;
                $complementaryActivitie->complementaryActivitiesDescription = $complementaryActivitiesDescription;
                $complementaryActivitie->totalHours = $totalHours;
                $complementaryActivitie->totalCredits = $totalCredits;
                $complementaryActivitie->degree = $degree;
                $complementaryActivitie->concept = $concept;
                $complementaryActivitie->periodId = $periodId;
                $complementaryActivitie->complementaryActivitiesCategoryId = $complementaryActivitiesCategoryId;
                $complementaryActivitie->complementaryActivitiesCategoryDescription = $complementaryActivitiesCategoryDescription;

                $data->complementaryActivities[] = $complementaryActivitie;
            }
        }

        $filters->proficiency = true;
        $wsProficiency = $busDiverseConsultation->getCurricularComponentCoursed( $filters );

        if ( count( $wsProficiency ) > 0 )
        {
            foreach ( $wsProficiency as $value )
            {
                list ( $enrollId,
                    $groupId,
                    $periodId,
                    $curricularComponentId,
                    $curricularComponentName,
                    $null, $academicNumberHours,
                    $note,
                    $statusId,
                    $statusDescription,
                    $className ) = $value;

                $proficiency = new stdClass();
                $proficiency->enrollId = $enrollId;
                $proficiency->groupId = $groupId;
                $proficiency->periodId = $periodId;
                $proficiency->curricularComponentId = $curricularComponentId;
                $proficiency->curricularComponentName = $curricularComponentName;
                $proficiency->statusId = $statusId;
                $proficiency->statusDescription = $statusDescription;

                $proficiencies[] = $proficiency;
            }

            $data->proficiencies = $proficiencies;
        }

        return $data;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return the scholarship description
     *
     * @param: $contractId (integer): Is contract code of student
     *
     * @return (array): Return a array of objects with the scholarship description
     */
    public function wsScholarshipDescription( $contractId )
    {
        $filters->contractId = $contractId;
        $filters->proficiency = false;

        $busDiverseConsultation = new BusinessAcademicBusDiverseConsultation();
        $wsScholarschip = $busDiverseConsultation->getCurricularComponentCoursed( $filters );

        if ( count( $wsScholarschip ) > 0 )
        {
            foreach ( $wsScholarschip as $value )
            {
                list ( $enrollId,
                    $groupId,
                    $periodId,
                    $curricularComponentId,
                    $curricularComponentName,
                    $null,
                    $academicNumberHours,
                    $note,
                    $frequency,
                    $statusId,
                    $statusDescription,
                    $className ) = $value;

                $scholarship = new stdClass();
                $scholarship->enrollId = $enrollId;
                $scholarship->groupId = $groupId;
                $scholarship->periodId = $periodId;
                $scholarship->curricularComponentId = $curricularComponentId;
                $scholarship->curricularComponentName = $curricularComponentName;
                $scholarship->academicNumberHours = $academicNumberHours;
                $scholarship->note = $note;
                $scholarship->frequency = $frequency;
                $scholarship->statusId = $statusId;
                $scholarship->statusDescription = $statusDescription;
                $scholarship->className = $className;

                $scholarships[] = $scholarship;
            }
        }

        return $scholarships;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return the complementary activities
     *
     * @param: $contractId (integer): Is contract code of student
     *
     * @return (array): Return a array of objects with the complementary activities
     */
    public function wsComplementaryActivities( $contractId )
    {
        $filters->contractId = $contractId;

        $busComplementaryActivities = new BusinessAcademicBusComplementaryActivities();
        $wsComplementaryActivities = $busComplementaryActivities->searchComplementaryActivities( $filters );

        if ( count( $wsComplementaryActivities ) > 0 )
        {
            foreach ( $wsComplementaryActivities as $value )
            {
                list ( $complementaryActivitiesId,
                    $enrollId,
                    $complementaryActivitiesDescription,
                    $totalHours,
                    $totalCredits,
                    $degree,
                    $concept,
                    $periodId,
                    $complementaryActivitiesCategoryId,
                    $complementaryActivitiesCategoryDescription ) = $value;

                $complementaryActivity = new stdClass();
                $complementaryActivity->enrollId = $enrollId;
                $complementaryActivity->complementaryActivitiesDescription = $complementaryActivityDescription;
                $complementaryActivity->totalHours = $totalHours;
                $complementaryActivity->totalCredits = $totalCredits;
                $complementaryActivity->degree = $degree;
                $complementaryActivity->concept = $concept;
                $complementaryActivity->periodId = $periodId;
                $complementaryActivity->complementaryActivitiesCategoryId = $complementaryActivityCategoryId;
                $complementaryActivity->complementaryActivitiesCategoryDescription = $complementaryActivitiesCategoryDescription;

                $complementaryActivities[] = $complementaryActivity;
            }
        }

        return $complementaryActivities;
    }

    /* Este método não é suportado pelo wsdl
     * Function to webservices that return the complementary activities
     *
     * @param: $contractId (integer): Is contract code of student
     *
     * @return (array): Return a array of objects with the proficiency
     */
    public function wsProficiency( $contractId )
    {
        $filters->contractId = $contractId;
        $filters->proficiency = true;

        $busDiverseConsultation = new BusinessAcademicBusDiverseConsultation();
        $wsProficiency = $busDiverseConsultation->getCurricularComponentCoursed( $filters );

        if ( count( $wsProficiency ) > 0 )
        {
            foreach ( $wsProficiency as $value )
            {
                list ( $enrollId,
                    $groupId,
                    $periodId,
                    $curricularComponentId,
                    $curricularComponentName,
                    $null, $academicNumberHours,
                    $note,
                    $statusId,
                    $statusDescription,
                    $className ) = $value;

                $proficiency = new stdClass();
                $proficiency->enrollId = $enrollId;
                $proficiency->groupId = $groupId;
                $proficiency->periodId = $periodId;
                $proficiency->curricularComponentId = $curricularComponentId;
                $proficiency->curricularComponentName = $curricularComponentName;
                $proficiency->statusId = $statusId;
                $proficiency->statusDescription = $statusDescription;

                $proficiencies[] = $proficiency;
            }
        }

        return $proficiencies;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return the list of the pupils periods
     *
     * @param: $personId (integer): Is code of student
     *
     * @return (array): Return a array of objects with the list periods
     */
    public function wsListPeriodsPupils( $personId )
    {
        $busPeriod = new BusinessAcademicBusPeriod();
        $wsListPeriod = $busPeriod->listPupilsPeriods( $personId );

        if ( count( $wsListPeriod ) > 0 )
        {
            foreach ( $wsListPeriod as $value )
            {
                list ( $periodId,
                    $periodDescription ) = $value;

                $period = new stdClass();
                $period->periodId = $periodId;
                $period->periodDescription = $periodDescription;
                $period->currentPeriodId = SAGU::getParameter('basic', 'CURRENT_PERIOD_ID');

                $periods[] = $period;
            }
        }

        return $periods;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return the list of the periods
     *
     * @return (array): Return a array of objects with the list periods
     */
    public function wsListPeriods()
    {
        $busPeriod = new BusinessAcademicBusPeriod();
        $wsListPeriod = $busPeriod->listPeriod();

        if ( count( $wsListPeriod ) > 0 )
        {
            foreach ( $wsListPeriod as $value )
            {
                list ( $periodId,
                    $periodDescription ) = $value;

                $period = new stdClass();
                $period->periodId = $periodId;
                $period->periodDescription = $periodDescription;

                $periods[] = $period;
            }
        }

        return $periods;
    }

    public function wsListPeriodsByContract($contractId)
    {
        $busPeriod = new BusinessAcademicBusPeriod();
        $wsListPeriod = $busPeriod->listPeriod();

        if ( count( $wsListPeriod ) > 0 )
        {
            foreach ( $wsListPeriod as $value )
            {
                list ( $periodId,
                       $periodDescription ) = $value;

                $period = new stdClass();
                $period->periodId = $periodId;
                $period->periodDescription = $periodDescription;
                $period->currentPeriodId = SAGU::getParameter('basic', 'CURRENT_PERIOD_ID');

                $periods[] = $period;
            }
        }

        return $periods;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return degree
     *
     * @param: $enrollId (integer): Is enroll code
     *
     * @return (array): Return a array of objects with the degree
     */
    public function wsGetDegree( $enrollId, $parentDegreeId = null )
    {
        $busDegree = new BusinessAcademicBusDegree();
        $wsDegree = $busDegree->searchEnrollDegree( $enrollId, $parentDegreeId );

        if ( count( $wsDegree ) > 0 )
        {
            foreach ( $wsDegree as $value )
            {
                list ( $degreeId,
                    $enrollId,
                    $periodId,
                    $description,
                    $degreenumber,
                    $weight,
                    $note,
                    $concept,
                    $parentDegreeId ) = $value;

                $degree = new stdClass();
                $degree->degreeId = $degreeId;
                $degree->enrollId = $enrollId;
                $degree->periodId = $periodId;
                $degree->description = $description;
                $degree->degreeNumber = $degreenumber;
                $degree->weight = $weight;
                $degree->note = $note;
                $degree->concept = $concept;
                $degree->parentDegreeId = $parentDegreeId;

                $degrees[] = $degree;
            }
        }

        return $degrees;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return groupId
     *
     * @param: $enrollId (integer): Is enroll code
     *
     * @return (integer): Return the groupId
     */
    public function wsGetGroupId( $enrollId )
    {
        $busEnroll = new BusinessAcademicBusEnroll();

        $wsGetEnroll = $busEnroll->getEnroll( $enrollId );

        return $wsGetEnroll->groupId;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return degree description and evaluation
     *
     * @param: $enrollId (integer): Is enroll code
     * @param: $professorId (integer): Is person id of the professor
     *
     * @return (array): Return a array of objects with the degree
     */
    public function wsSearchDegreeDescriptionAndPupilsDegrees( $groupId, $professorId )
    {
        $busDegree = new BusinessAcademicBusDegree();
        $busDegreeEnroll = new BusinessAcademicBusDegreeEnroll();
        $busEvaluation = new BusinessAcademicBusEvaluation();
        $busEvaluationEnroll = new BusinessAcademicBusEvaluationEnroll();
        $busGradeTyping = new BusinessAcademicBusGradeTyping();

        $return = new StdClass();
        $wsDegreeDescription = $busDegree->searchDegreeDescription( $groupId );

        // Degree Description
        if ( count( $wsDegreeDescription ) > 0 )
        {
            foreach ( $wsDegreeDescription as $value )
            {
                list ( $degreeId,
                    $description,
                    $degreeNumber ) = $value;

                $degree = new stdClass();
                $degree->degreeId = $degreeId;
                $degree->description = $description;
                $degree->degreeNumber = $degreeNumber;

                // Evaluation Description
                $wsEvaluationDescription = $busEvaluation->searchEvaluationDescription( $professorId, $degreeId, $groupId);

                if ( count( $wsEvaluationDescription ) > 0 )
                {
                    unset( $evaluations );

                    foreach ( $wsEvaluationDescription as $value )
                    {
                        list ( $evaluationId,
                            $description ) = $value;

                        $evaluation = new stdClass();
                        $evaluation->evaluationId = $evaluationId;
                        $evaluation->description = $description;

                        $evaluations[] = $evaluation;
                    }

                    $degree->evaluations = $evaluations;
                }

                $degrees[] = $degree;
            }

            $return->degrees = $degrees;
        }

        // Pupils
        $wsListGroupEnrolledPeople = $busGradeTyping->listGroupEnrolledPupils( $groupId );

        if ( count( $wsListGroupEnrolledPeople ) > 0 )
        {
            foreach ( $wsListGroupEnrolledPeople as $value )
            {
                list ( $enrollId,
                    $personId,
                    $name,
                    $courseId,
                    $statusId,
                    $statusDescription,
                    $isClosed ) = $value;

                $group = new stdClass();
                $group->enrollId = $enrollId;
                $group->personId = $personId;
                $group->personName = $name;
                $group->statusDescription = $statusDescription;
                $group->isClosed = ($isClosed == DB_TRUE);

                $wsDegreesPupil = $busDegree->getEnrollDegree( $groupId );

                if ( count( $wsDegreesPupil ) > 0 )
                {
                    unset( $degrees );

                    foreach ( $wsDegreesPupil as $value1 )
                    {
                        list ( $degreeId,
                               $degreeNumber,
                               $enableGradeTyping,
                               $weight,
                               $parentDegreeId,
                               $mayBeNull,
                               $finalAverage ) = $value1;

                        $degree = new stdClass();
                        $degree->degreeId = $degreeId;
                        $degree->degreeNumber = $degreeNumber;
                        $degree->enableGradeTyping = ($enableGradeTyping == DB_TRUE);
                        $degree->weight = $weight;
                        $degree->parentDegreeId = $parentDegreeId;
                        $degree->mayBeNull = $mayBeNull;
                        $degree->finalAverage = $finalAverage;

                        $dataNote = $busDegreeEnroll->getDegreeEnrollHistory( $degreeId, $enrollId, $concept = false );

                        list ( $note,
                            $description,
                            $recordDate,
                            $username ) = $dataNote[0];

                        $degree->note = $note;

                        $wsEvaluationEnroll = $busEvaluationEnroll->getEvaluationEnrollByGroup( $enrollId, $degreeId );

                        if ( count( $wsEvaluationEnroll ) > 0 )
                        {
                            unset( $evaluations );

                            foreach ( $wsEvaluationEnroll as $value )
                            {
                                list ( $evaluationId,
                                    $weight,
                                    $note,
                                    $enableGradeTyping ) = $value;

                                $evaluation = new stdClass();
                                $evaluation->evaluationId = $evaluationId;
                                $evaluation->weight = $weight;
                                $evaluation->note = $note;
                                $evaluation->enableGradeTyping = ($enableGradeTyping == DB_TRUE);

                                $degree->evaluations[] = $evaluation;
                            }
                        }

                        $degrees[] = $degree;
                    }

                    $group->degrees = $degrees;
                }

                $groups[] = $group;
            }

            $return->groups = $groups;
        }

        return $return;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return degree description
     *
     * @param: $enrollId (integer): Is enroll code
     *
     * @return (array): Return a array of objects with the degree
     */
    public function wsSearchDegreeDescription( $groupId )
    {
        $busDegree = new BusinessAcademicBusDegree();
        $wsDegreeDescription = $busDegree->searchDegreeDescription( $groupId );

        if ( count( $wsDegreeDescription ) > 0 )
        {
            foreach ( $wsDegreeDescription as $value )
            {
                list ( $degreeId,
                    $description,
                    $degreeNumber ) = $value;

                $degree = new stdClass();
                $degree->degreeId = $degreeId;
                $degree->description = $description;
                $degree->degreeNumber = $degreeNumber;

                $degrees[] = $degree;
            }
        }

        return $degrees;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return pupils and degree
     *
     * @param: $groupId (integer): Is group code
     *
     * @return (array): Return a array of objects with the degree
     */
    public function wsListPupilsDegrees( $groupId )
    {
        $busGradeTyping = new BusinessAcademicBusGradeTyping();
        $busDegree = new BusinessAcademicBusDegree();
        $busDegreeEnroll = new BusinessAcademicBusDegreeEnroll();

        $wsListGroupEnrolledPeople = $busGradeTyping->listGroupEnrolledPupils( $groupId );

        if ( count( $wsListGroupEnrolledPeople ) > 0 )
        {
            foreach ( $wsListGroupEnrolledPeople as $value )
            {
                list ( $enrollId,
                    $personId,
                    $name,
                    $courseId,
                    $statusId,
                    $statusDescription ) = $value;

                $group = new stdClass();
                $group->enrollId = $enrollId;
                $group->personId = $personId;
                $group->personName = $name;
                $group->statusDescription = $statusDescription;

                $wsDegreesPupil = $busDegree->getEnrollDegree( $groupId );

                if ( count( $wsDegreesPupil ) > 0 )
                {
                    foreach ( $wsDegreesPupil as $value1 )
                    {
                        list ( $degreeId,
                            $degreeNumber ) = $value1;

                        $degree = new stdClass();
                        $degree->degreeId = $degreeId;
                        $degree->degreeNumber = $degreeNumber;

                        $dataNote = $busDegreeEnroll->getDegreeEnrollHistory( $degreeId, $enrollId, $concept = false );

                        list ( $note,
                            $description,
                            $recordDate,
                            $username ) = $dataNote[0];

                        $degree->note = $note;

                        $degrees[] = $degree;
                    }

                    $group->degrees = $degrees;
                }

                $groups[] = $group;
            }
        }

        return $groups;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return evaluation description
     *
     * @param: $professorId (integer): Is professor code
     * @param: $degreeId (integer): Is degree code
     * @param: $groupId (integer): Is group code
     *
     * @return (array): Return a array of objects with the evaluation description
     */
    public function wsSearchEvaluationDescription( $professorId, $degreeId, $groupId )
    {
        $busEvaluation = new BusinessAcademicBusEvaluation();
        $wsEvaluationDescription = $busEvaluation->searchEvaluationDescription( $professorId, $degreeId, $groupId );

        if ( count( $wsEvaluationDescription ) > 0 )
        {
            foreach ( $wsEvaluationDescription as $value )
            {
                list ( $evaluationId,
                    $description ) = $value;

                $evaluation = new stdClass();
                $evaluation->evaluationId = $evaluationId;
                $evaluation->description = $description;

                $evaluations[] = $evaluation;
            }
        }

        return $evaluations;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return evaluation description
     *
     * @param: $professorId (integer): Is professor code
     * @param: $degreeId (integer): Is degree code
     * @param: $groupId (integer): Is group code
     *
     * @return (array): Return a array of objects with the evaluation description
     */
    public function wsGetEvaluation( $degreeId, $enrollId )
    {
        $busEvaluationEnroll = new BusinessAcademicBusEvaluationEnroll();
        $wsEvaluationEnroll = $busEvaluationEnroll->getEvaluationEnrollByGroup( $enrollId, $degreeId );

        if ( count( $wsEvaluationEnroll ) > 0 )
        {
            foreach ( $wsEvaluationEnroll as $value )
            {
                list ( $evaluationId,
                    $weight,
                    $note ) = $value;

                $evaluation = new stdClass();
                $evaluation->evaluationId = $evaluationId;
                $evaluation->weight = $weight;
                $evaluation->note = $note;

                $evaluations[] = $evaluation;
            }
        }

        return $evaluations;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return group schedule
     *
     * @param: $groupId (integer): Is code of group curricular component
     *
     * @return (array): Return a array of objects with the group schedule
     */
    public function wsGroupSchedule( $groupId )
    {
        $busSchedule = new BusinessAcademicBusSchedule();
        $busTimeSheet = new BusinessAcademicBusTimeSheet();

        $filters->groupId = $groupId;
        $wsSchedules = $busSchedule->searchSchedule( $filters );

        foreach ( $wsSchedules as $schedule )
        {
            list ( $scheduleId,
                $groupId,
                $unitId,
                $unitDescription,
                $periodId,
                $beginDate,
                $endDate ) = $schedule;

            $wsGroupSchedule = $busSchedule->getScheduleByGroup( $scheduleId );

            if ( count( $wsGroupSchedule->occurrenceDates ) > 0 )
            {
                foreach ( $wsGroupSchedule->occurrenceDates as $value )
                {
                    if ( count( $wsGroupSchedule->timeIds ) > 0 )
                    {
                        foreach ( $wsGroupSchedule->timeIds as $value1 )
                        {
                            $filters->timeId = $value1;
                            $timeSheet = $busTimeSheet->searchTime( $filters );

                            list ( $timeId,
                                $turnId,
                                $beginHour,
                                $endHour,
                                $numberMinutes ) = $timeSheet[0];

                            $valor = substr( $value, -4 ) . "-" . substr( $value, 3, 2 ) . "-" . substr( $value, 0, 2 );

                            $count = 0;
                            while ( array_key_exists( $valor . $count, $scheduleArray ) )
                            {
                                $count++;
                            }

                            $scheduleArray[$valor . $count] = array ( $scheduleId, $value, $timeId, $beginHour, $endHour, $numberMinutes );
                        }
                    }
                }
            }
        }

        if ( count( $scheduleArray ) > 0 )
        {
            ksort( $scheduleArray );

            unset( $schedule );
            foreach ( $scheduleArray as $value )
            {
                $schedule = new stdClass();
                $schedule->scheduleId = $value[0];
                $schedule->occurrenceDate = $value[1];
                $schedule->timeId = $value[2];
                $schedule->beginHour = $value[3];
                $schedule->endHour = $value[4];
                $schedule->numberMinutes = $value[5];

                $schedules[] = $schedule;
            }

            return $schedules;
        }

        return null;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return group schedule by date
     *
     * @param: $groupId (integer): Is code of group curricular component
     *
     * @return (array): Return a array of objects with the group schedule
     */
    public function wsGroupScheduleByDate( $groupId )
    {
        $busSchedule = new BusinessAcademicBusSchedule();
        $busTimeSheet = new BusinessAcademicBusTimeSheet();
        $busDiverseConsultation = new BusinessAcademicBusDiverseConsultation();

        $wsProfessorName = $busDiverseConsultation->getGroupProfessorNames( $groupId );

        $filters->groupId = $groupId;
        $schedules = $busSchedule->searchSchedule( $filters );

        foreach ( $schedules as $schedule )
        {
            list ( $scheduleId,
                $groupId,
                $unitId,
                $unitDescription,
                $periodId,
                $beginDate,
                $endDate ) = $schedule;

            $wsGroupSchedule = $busSchedule->getScheduleByGroup( $scheduleId );

            if ( count( $wsGroupSchedule->occurrenceDates ) > 0 )
            {
                foreach ( $wsGroupSchedule->occurrenceDates as $value )
                {
                    if ( count( $wsGroupSchedule->timeIds ) > 0 )
                    {
                        foreach ( $wsGroupSchedule->timeIds as $value1 )
                        {
                            $filters->timeId = $value1;
                            $timeSheet = $busTimeSheet->searchTime( $filters );

                            list ( $timeId,
                                $turnId,
                                $beginHour,
                                $endHour,
                                $numberMinutes ) = $timeSheet[0];

                            $valor = substr( $value, -4 ) . "-" . substr( $value, 3, 2 ) . "-" . substr( $value, 0, 2 );

                            $count = 0;
                            while ( array_key_exists( $valor . $count, $scheduleArray ) )
                            {
                                $count++;
                            }

                            $scheduleArray[$valor . $count] = array ( $value, $beginHour . ' - ' . $endHour, $unitDescription, $wsProfessorName[0] );
                        }
                    }
                }
            }
        }

        if ( count( $scheduleArray ) > 0 )
        {
            ksort( $scheduleArray );

            foreach ( $scheduleArray as $value )
            {
                $schedule = new stdClass();
                $schedule->occurrenceDate = $value[0];
                $schedule->time = $value[1];
                $schedule->unitDescription = $value[2];
                $schedule->professorName = $value[3];

                $schedules[] = $schedule;
            }
        }

        return $schedules;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return frequency
     *
     * @param: $enroll (integer): Is code of enroll
     *
     * @return (array): Return a array of objects with the frequency
     */
    public function wsGetFrequency( $enrollId, $scheduleId, $frequencyDate, $timeId )
    {
        $busFrequency = new BusinessAcademicBusFrequenceEnroll();
        $wsFrequency = $busFrequency->getEnrollFrequencyOnDate( $enrollId, $scheduleId, $frequencyDate, $timeId );

        return $wsFrequency;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Função que retorna um boolean indicando se o periodo cujo
     * groupId especificado está fechado ou não.
     *
     * @param int $groupId
     * @return boolean
     */
    public function wsPeriodIsClosed($groupId)
    {
        $busGradeTyping = new BusinessAcademicBusGradeTyping();

        $wsPeriodIsClosed = $busGradeTyping->periodIsClosed($groupId);

        return $wsPeriodIsClosed;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return pupils
     *
     * @param: $groupId (integer): Is group code
     *
     * @return (array): Return a array of objects with the pupils
     */
    public function wsListPupilsByGroup( $groupId )
    {
        $busGradeTyping = new BusinessAcademicBusGradeTyping();
        $busSchedule = new BusinessAcademicBusSchedule();
        $busTimeSheet = new BusinessAcademicBusTimeSheet();
        $busFrequenceEnroll = new BusinessAcademicBusFrequenceEnroll();

        $wsListGroupEnrolledPeople = $busGradeTyping->listGroupEnrolledPupils( $groupId );

        if ( count( $wsListGroupEnrolledPeople ) > 0 )
        {
            unset( $scheduleArray );

            foreach ( $wsListGroupEnrolledPeople as $value )
            {
                list ( $enrollId,
                    $personId,
                    $name,
                    $courseId,
                    $statusId,
                    $statusDescription,
                    $isClosed) = $value;

                $pupil = new stdClass();
                $pupil->enrollId = $enrollId;
                $pupil->personId = $personId;
                $pupil->personName = $name;
                $pupil->statusId = $statusId;
                $pupil->isClosed = ($isClosed == DB_TRUE);

                $filters->groupId = $groupId;
                $schedulesData = $busSchedule->searchSchedule( $filters );

                foreach ( $schedulesData as $scheduleData )
                {

                    list ( $scheduleId,
                        $groupId,
                        $unitId,
                        $unitDescription,
                        $periodId,
                        $beginDate,
                        $endDate ) = $scheduleData;

                    $wsGroupSchedule = $busSchedule->getScheduleByGroup( $scheduleId );

                    if ( count( $wsGroupSchedule->occurrenceDates ) > 0 )
                    {
                        foreach ( $wsGroupSchedule->occurrenceDates as $value )
                        {
                            if ( count( $wsGroupSchedule->timeIds ) > 0 )
                            {
                                foreach ( $wsGroupSchedule->timeIds as $value1 )
                                {
                                    $filters->timeId = $value1;
                                    $timeSheet = $busTimeSheet->searchTime( $filters );

                                    list ( $timeId,
                                        $turnId,
                                        $beginHour,
                                        $endHour,
                                        $numberMinutes ) = $timeSheet[0];

                                    $valor = substr( $value, -4 ) . "-" . substr( $value, 3, 2 ) . "-" . substr( $value, 0, 2 );

                                    $count = 0;
                                    while ( array_key_exists( $valor . $count, $scheduleArray ) )
                                    {
                                        $count++;
                                    }

                                    $wsFrequence = $busFrequenceEnroll->getEnrollFrequencyOnDate( $enrollId, $scheduleId, $value, $timeId );

                                    $scheduleArray[$valor . $count] = array ( $scheduleId, $value, $timeId, $numberMinutes, $wsFrequence );
                                }
                            }
                        }
                    }
                }

                if ( count( $scheduleArray ) > 0 )
                {
                    ksort( $scheduleArray );

                    foreach ( $scheduleArray as $value2 )
                    {
                        $schedule = new stdClass();
                        $schedule->scheduleId = $value2[0];
                        $schedule->occurrenceDate = $value2[1];
                        $schedule->timeId = $value2[2];
                        $schedule->numberMinutes = $value2[3];
                        $schedule->frequency = $value2[4];

                        $schedules[] = $schedule;
                    }

                    unset( $scheduleArray );
                }

                $pupil->schedules = $schedules;

                unset( $schedules );

                $pupils[] = $pupil;
            }
        }

        return $pupils;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return the list of professor periods
     *
     * @param: $professorId (integer): Is professor code
     *
     * @return (array): Return a array of objects with the periods of professor
     */
    public function wsListProfessorPeriods( $professorId )
    {
        $busProfessorCurricularComponent = new BusinessAcademicBusProfessorCurricularComponent();
        $wsProfessorPeriods = $busProfessorCurricularComponent->listProfessorPeriods( $professorId );

        if ( count( $wsProfessorPeriods ) > 0 )
        {
            foreach ( $wsProfessorPeriods as $value )
            {
                $period = new stdClass();
                $period->periodId = $value[0];
                $period->description = $value[1];

                $periods[] = $period;
            }
        }

        return $periods;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Funçao que verifica se o moodle esta instalado, caso nao esteja nao devera aparecer
     * o link "moodle" no portal do professor.
     *
     * @return (boolean): Returns true or false
     */
    public function wsMoodleInstalled()
    {
        $moodleInstalled = SAGU::getParameter( 'basic', 'MOODLE_INSTALLED' );

        return $moodleInstalled == "YES";
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return the list of professor curricular component
     *
     * @param: $professorId (integer): Is professor code
     * @param: $periodId (integer): Is period code
     *
     * @return (array): Return a array of objects with the professor name
     */
    public function wsListProfessorCurricularComponents( $professorId, $periodId, $groupId = null )
    {
        $busProfessorCurricularComponent = new BusinessAcademicBusProfessorCurricularComponent();
        $wsProfessorCurricularComponent = $busProfessorCurricularComponent->listProfessorCurricularComponents( $professorId, $periodId, $groupId );

        if ( count( $wsProfessorCurricularComponent ) > 0 )
        {
            foreach ( $wsProfessorCurricularComponent as $value )
            {
                $curricularComponent = new stdClass();
                $curricularComponent->groupId = $value[0];
                $curricularComponent->curricularComponentId = $value[1];
                $curricularComponent->curricularComponentName = $value[2];
                $curricularComponent->courseId = $value[3];
                $curricularComponent->courseName = $value[4];
                $curricularComponent->turnId = $value[5];
                $curricularComponent->turnDescription = $value[6];
                $curricularComponent->unitId = $value[7];
                $curricularComponent->unitDescription = $value[8];
                $curricularComponent->isCancellation = $value[9];

                $curricularComponents[] = $curricularComponent;
            }
        }

        return $curricularComponents;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that insert the frequency
     *
     * @param: $enrolls (object): Object
     *
     * @return $result (boolean): Return
     */
    public function wsCheckEnroll( $enrolls )
    {
        if ( count( $enrolls ) > 0 )
        {
            $busEnroll = new BusinessAcademicBusEnroll();
            $busContract = new BusinessAcademicBusContract();
            $busCurriculum = new BusinessAcademicBusCurriculum();
            $busEnrollConfig = new BusinessAcademicBusEnrollConfig();

            foreach ( $enrolls as $curricularComponent )
            {
                $curriculumId = $curricularComponent->curriculumId;
                $curricularComponentId = $curricularComponent->curricularComponentId;
                $curricularComponentVersion = $curricularComponent->curricularComponentVersion;
                $curricularComponentName = $curricularComponent->curricularComponentName;
                $learningPeriodId = $curricularComponent->learningPeriodId;
                $groupId = $curricularComponent->groupId;
                $contractId = $curricularComponent->contractId;
                $periodId = $curricularComponent->periodId;

                $data->groupId = $groupId[0];
                $data->curriculumId = $curriculumId[0];
                $data->curricularComponentId = $curricularComponentId[0];
                $data->curricularComponentVersion = $curricularComponentVersion[0];
                $data->learningPeriodId = $learningPeriodId[0];
                $data->periodId = $periodId[0];
                $data->contractId = $contractId[0];

                $array[$groupId[0]] = $data;
            }

            asort( $array );

            $wsContract = $busContract->getContract( $data->contractId );

            $enrollConfig = $busEnrollConfig->getCourseEnrollConfig( $wsContract->courseId, $wsContract->courseVersion, $wsContract->turnId, $wsContract->unitId );

            if ( $enrollConfig->checkScheduleShock )
            {
                unset( $hasShockingSchedule );
                unset( $curriculumSchokingSchedule );

                $count = 0;

                foreach ( $array as $groupId1 )
                {
                    foreach ( $array as $groupId2 )
                    {
                        if ( $groupId1->groupId > $groupId2->groupId )
                        {
                            $isScheduleShockGroupId1 = $busEnroll->isScheduleShock( $groupId1->contractId, $groupId1->learningPeriodId, $groupId1->curriculumId );
                            $isScheduleShockGroupId2 = $busEnroll->isScheduleShock( $groupId2->contractId, $groupId2->learningPeriodId, $groupId2->curriculumId );

                            if ( !$isScheduleShockGroupId1 && !$isScheduleShockGroupId2 )
                            {
                                $hasShockingSchedule = $busEnroll->hasShockingSchedule( $groupId1->contractId, $groupId2->contractId );

                                if ( $hasShockingSchedule )
                                {
                                    $curriculumSchokingSchedule[$count][] = array ( $groupId1->curriculumId, $groupId1->curricularComponentId, $groupId1->curricularComponentVersion, $groupId1->curricularComponentName );
                                    $curriculumSchokingSchedule[$count][] = array ( $groupId2->curriculumId, $groupId2->curricularComponentId, $groupId2->curricularComponentVersion, $groupId2->curricularComponentName );

                                    $count++;
                                }
                            }
                        }
                    }
                }
            }
        }

        return $curriculumSchokingSchedule;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that insert the enroll
     *
     * @param: $enrolls (object): Object:
     * $enrolls->curricularComponents
     *
     * @return $result (boolean): Return
     */
    public function wsInsertEnroll( $enrolls )
    {
        $errorResult = $this->wsCheckEnroll( $enrolls );

        if ( !count( $errorResult ) > 0 )
        {
            if ( count( $enrolls->curricularComponents ) > 0 )
            {
                $busEnroll = new BusinessAcademicBusEnroll();

                foreach ( $enrolls->curricularComponents as $curricularComponent )
                {
                    $curriculumId = $curricularComponent->curriculumId;
                    $learningPeriodId = $curricularComponent->learningPeriodId;
                    $groupId = $curricularComponent->groupId;
                    $contractId = $curricularComponent->contractId;
                    $periodId = $curricularComponent->periodId;

                    $data->contractId = $contractId[0];
                    $data->learningPeriodId = $learningPeriodId[0];
                    $data->curriculumId = $curriculumId[0];
                    $data->periodId = $periodId[0];
                    $array[$groupId[0]] = $curriculumId[0];
                }

                $data->groupId = $array;
                $data->isInternet = true;
                $data->isConfirm = true;
                $data->reasonId = SAGU::getParameter( 'academic', 'OLDER_REASON_ID' );

                $wsOk = $busEnroll->insertPersonEnrollNew( $data );
            }
        }

        return $wsOk;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Função responsável por inserir/atualizar as frequências do(s) aluno(s)
     */
    public function wsInsertFrequence( $frequencies )
    {
        if ( count( $frequencies ) > 0 )
        {
            $busFrequency = new BusinessAcademicBusFrequenceEnroll();
            $busEnroll = new BusinessAcademicBusEnroll();

            foreach ( $frequencies as $frequence )
            {
                $wsOk = $busFrequency->updateOrInsertFrequenceEnroll( $frequence );

                if ( !in_array($frequence->enrollId, $enrolls) )
                {
                    $enrolls[] = $frequence->enrollId;
                }
            }
            if ( count($enrolls)>0 )
            {
                foreach($enrolls as $cod=>$enroll)
                {
                    $frequency = $busFrequency->getSumFrequency($enroll);
                    $enrollData = $busEnroll->getEnroll($enroll);
                    $enrollData->frequency = $frequency;
                    $busEnroll->updateEnroll($enrollData);
                }
            }
        }

        return $wsOk;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that insert the degree
     *
     * @param: $pupils (array): A array of objects:
     * $pupil->enrollId
     * $pupil->degrees
     * $pupil->evaluations
     * $pupils = array ( $pupil );
     *
     * @return $result (boolean): Return
     */
    public function wsInsertGroupPupilsGrades( $pupils )
    {
        if ( count( $pupils ) > 0 )
        {
            $busEnroll = new BusinessAcademicBusEnroll();
            $busDegreeEnroll = new BusinessAcademicBusDegreeEnroll();
            $busEvaluationEnroll = new BusinessAcademicBusEvaluationEnroll();
            $busGradeTyping = new BusinessAcademicBusGradeTyping();

            foreach ( $pupils as $pupil )
            {
                $enrollData = $busEnroll->getEnroll( $pupil->enrollId );
                $groupData = $busGradeTyping->getGroupData( $enrollData->groupId );

                if ( count( $pupil->degrees ) > 0 )
                {
                    foreach ( $pupil->degrees as $degree )
                    {
                        $degreeData->degreeId = $degree->degreeId;
                        $degreeData->enrollId = $enrollData->enrollId;
                        $degreeData->description = $degree->description;
                        $degreeData->recordDate = date( SAGU::getParameter( 'BASIC', 'MASK_TIMESTAMP_PHP' ) );

                        if ( $groupData->useConcept == DB_TRUE )
                        {
                            $degreeData->concept = $degree->degreeValue;
                        }
                        else
                        {
                            $degreeData->note = $degree->degreeValue;
                        }

                        $ok = $busDegreeEnroll->insertOrUpdateDegreeEnroll( $degreeData );
                    }
                }

                if ( count( $pupil->evaluations ) > 0 )
                {
                    foreach ( $pupil->evaluations as $evaluation )
                    {
                        $evaluationData->evaluationId = $evaluation->evaluationId;
                        $evaluationData->enrollId = $enrollData->enrollId;
                        $evaluationData->description = $evaluation->description;
                        $evaluationData->recordDate = date( SAGU::getParameter( 'BASIC', 'MASK_TIMESTAMP_PHP' ) );

                        if ( $groupData->useConcept == DB_TRUE )
                        {
                            $evaluationData->concept = $evaluation->evaluationValue;
                        }
                        else
                        {
                            $evaluationData->note = $evaluation->evaluationValue;
                        }

                        $ok = $busEvaluationEnroll->insertOrUpdateEvaluationEnroll( $evaluationData );
                    }
                }
            }
        }

        return $ok;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return professor name
     *
     * @param: $groupId (int): Is code of the group
     *
     * @return $result (string): Name professor
     */
    public function wsGetGroupProfessorName( $groupId )
    {
        $busDiverseConsultation = new BusinessAcademicBusDiverseConsultation();
        $wsProfessorName = $busDiverseConsultation->getGroupProfessorNames( $groupId );

        if ( count( $wsProfessorName ) > 0 )
        {
            $professorName = new stdClass();
            $professorName->name = $wsProfessorName[0];
        }

        return $professorName;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return schedule data
     *
     * @param: $groupId (int): Is code of the group
     *
     * @return $result (string): schedule
     */
    public function wsGetGroupScheduleData( $groupId )
    {
        $busSchedule = new BusinessAcademicBusSchedule();
        $wsSchedule = $busSchedule->getGroupScheduleDataWithRooms( $groupId );

        if ( count( $wsSchedule ) > 0 )
        {
            unset( $scheduleArray );
            unset( $roomArray );
            foreach ( $wsSchedule as $scheduleInfo )
            {
                unset( $scheduleStr );
                if ( strlen( $scheduleInfo[0] ) > 0 )
                {
                    $scheduleStr = $scheduleInfo[0];
                }

                if ( strlen( $scheduleStr ) > 0 )
                {
                    $scheduleStr .= strlen( $scheduleInfo[1] ) ? '-' . $scheduleInfo[1] : '';
                }
                else
                {
                    $scheduleStr = $scheduleInfo[1];
                }

                if ( strlen( $scheduleStr ) > 0 )
                {
                    $scheduleArray[] = $scheduleStr;
                }

                unset( $roomStr );
                if ( strlen( $scheduleInfo[2] ) > 0 )
                {
                    $roomStr = $scheduleInfo[2];
                }

                if ( strlen( $roomStr ) > 0 )
                {
                    $roomStr .= strlen( $scheduleInfo[3] ) ? '-' . $scheduleInfo[3] : '';
                }
                else
                {
                    $roomStr = $scheduleInfo[3];
                }

                if ( strlen( $roomStr ) > 0 )
                {
                    $roomArray[] = $roomStr;
                }
            }

            unset( $str );
            if ( count( $scheduleArray ) > 0 )
            {
                $str = implode( '/', $scheduleArray );
            }

            if ( count( $roomArray ) > 0 )
            {
                if ( strlen( $str ) > 0 )
                {
                    $str .= "\n(" . implode( '/', $roomArray ) . ')';
                }
                else
                {
                    $str = implode( '/', $roomArray );
                }
            }

            $scheduleCurricularComponent = new stdClass();
            $scheduleCurricularComponent->schedule = $str;
        }

        return $scheduleCurricularComponent;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Function to webservices that return $emails
     *
     * @param: $groupId (int): Is code of the group
     *
     * @return $result (string): schedule
     */
    public function wsGetGroupEmail( $groupId )
    {
        $busGroup = new BusinessAcademicBusGroup();
        $wsGroup = $busGroup->getPupilEmailByGroup( $groupId );

        if ( count( $wsGroup ) > 0 )
        {
            foreach ( $wsGroup as $index => $value )
            {
                list ( $group->personId,
                    $group->personName,
                    $group->email ) = $value;

                $email = new stdClass();
                $email->personId = $group->personId;
                $email->personName = $group->personName;
                $email->email = $group->email;

                $emails[] = $email;
            }
        }

        return $emails;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * List student moodle subscription
     *
     * @param $groupId (string): id group
     *
     * @return (object): Retorna um objeto com dois arrays de objetos: um para alunos e um para professores
     */
    public function wsListStudentAndTeacherMoodleSubscription( $groupId )
    {
        //Instance of business BusMoodleSubscription
        $busMoodle = new BusinessAcademicBusMoodle();
        //Synchronize acdmoodlesubscription
        $busMoodle->synchronize( $groupId );
        //List Students
        $wsListStudentMoodleSubscription = $busMoodle->listStudentMoodleSubscription( $groupId );
        //List Teachers
        $wsListTeacherMoodleSubscription = $busMoodle->listTeacherMoodleSubscription( $groupId );

        //Travel list students
        if ( count( $wsListStudentMoodleSubscription ) > 0 )
        {
            foreach ( $wsListStudentMoodleSubscription as $student )
            {
                $studentsMoodleSubscription = new stdClass();
                $studentsMoodleSubscription->personId = $student[0];
                $studentsMoodleSubscription->personName = $student[1];
                $studentsMoodleSubscription->statusMoodle = $student[2];
                $studentsMoodleSubscription->statusReason = $student[3];

                $students[] = $studentsMoodleSubscription;
            }
        }

        //Travel list teacher
        if ( count( $wsListTeacherMoodleSubscription ) > 0 )
        {
            foreach ( $wsListTeacherMoodleSubscription as $teacher )
            {
                $teacherMoodleSubscription = new stdClass();
                $teacherMoodleSubscription->personId = $teacher[0];
                $teacherMoodleSubscription->personName = $teacher[1];
                $teacherMoodleSubscription->statusMoodle = $teacher[2];

                $teachers[] = $teacherMoodleSubscription;
            }
        }

        $return = new stdClass();
        $return->students = $students;
        $return->teachers = $teachers;

        return $return;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Make integration with moodle
     *
     * @param $groupId (string): id group
     *
     * @return (boolean): True if succeed, otherwise false
     */
    public function wsInsertMoodleSubscription( $groupId )
    {
        //Instance of business BusMoodleSubscription
        $busMoodle = new BusinessAcademicBusMoodle();
        //Make integration with moodle
        $result = $busMoodle->makeIntegrationWithMoodle( $groupId );

        return $result;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Get the description os schedule professor content
     *
     * @param $date
     * @param $timeId
     * @param $scheduleId
     * @return (boolean): True if succeed, otherwise false
     */
    public function wsGetScheduleProfessorContent( $date, $timeId, $scheduleId )
    {
        if ( strlen( $date ) > 0 && strlen( $timeId ) > 0 && strlen( $scheduleId ) > 0 )
        {
            $busScheduleProfessorContent = new BusinessAcademicBusScheduleProfessorContent();
            $busScheduleProfessor = new BusinessAcademicBusScheduleProfessor();

            // Search professorId:
            $filters = new stdClass();
            $filters->scheduleId = $scheduleId;
            $professorId = $busScheduleProfessor->searchScheduleProfessor( $filters );

            // Format date
            $dateFormating = explode( '/', $date );
            $dateFormated = $dateFormating[2] . '-' . $dateFormating[1] . '-' . $dateFormating[0];

            $scheduleProfessorId = $busScheduleProfessor->getScheduleProfessor( $scheduleId, $professorId[0][1] );
            $result = $busScheduleProfessorContent->getScheduleProfessorContent( $dateFormated, $timeId, $scheduleProfessorId->scheduleProfessorId );
        }
        else
        {
            $result = false;
        }

        return $result;
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Save the description os schedule professor content
     *
     * @param $professorId
     * @param $date
     * @param $timeId
     * @param $scheduleId
     * @param $description
     * @return (boolean): True if succeed, otherwise false
     */
    public function wsSaveScheduleProfessorContent( $professorId, $date, $timeId, $scheduleId, $description )
    {
        if ( strlen( $professorId ) > 0 && strlen( $date ) > 0 && strlen( $timeId ) > 0 && strlen( $scheduleId ) > 0 && strlen($description) > 0 )
        {
            $busScheduleProfessorContent = new BusinessAcademicBusScheduleProfessorContent();
            $busScheduleProfessor = new BusinessAcademicBusScheduleProfessor();

            // Format date
            $dateFormating = explode( '/', $date );
            $dateFormated = $dateFormating[2] . '-' . $dateFormating[1] . '-' . $dateFormating[0];

            $scheduleProfessorId = $busScheduleProfessor->getScheduleProfessor( $scheduleId, $professorId );
            $result = $busScheduleProfessorContent->deleteScheduleProfessorContent( $dateFormated, $timeId, $scheduleProfessorId->scheduleProfessorId );
            $result = $busScheduleProfessorContent->saveScheduleProfessorContent( $dateFormated, $timeId, $scheduleProfessorId->scheduleProfessorId, $description );
        }
        else
        {
            $result = false;
        }

        return $result;
    }

    /* Este método não é suportado pelo wsdl
     *
     * @param $message
     * @param $subject
     * @param $personId
     * @param $groupId
     * @param $fileDir
     * @param $fileName
     *
     * @return (object) $return - Example:
     * $return->send => (boolean)
     * $return->errors => (array) names
     */
    public function wsSendEmail($subject, $message, $personId, $groupId, $fileDir = null, $fileName = null)
    {
        // Objeto de retorno:
        $return = new stdClass();

        //Include class sendEmail
        $sendEmailDir = 'modules/basic/classes/sendEmail.class';
        if ( !(file_exists($sendEmailDir)) )
        {
            $return->send = false;
            $return->errors = "Não foi possível incluir a classe sendEmail.class. Por favor, contate o administrador.";
            return $return;
        }
        else
        {
            require_once $sendEmailDir;
        }

        // Business
        $busCompany = new BusinessBasicBusCompany();
        $busLegalPerson = new BusinessBasicBusLegalPerson();
        $busPerson = new BusinessBasicBusPerson();

        // Informações do professor
        $wsPerson = $busPerson->getPerson($personId);
        if ( (strlen($wsPerson->personId) > 0) )
        {
            $professorData = new stdClass();
            $professorData->personId = $wsPerson->personId;
            $professorData->personName = $wsPerson->name;
            $professorData->email = $wsPerson->email;
        }

        // Pega o email da instituiçao:
        $companyInfo = $busCompany->getCompany( SAGU::getParameter( 'BASIC', 'DEFAULT_COMPANY_CONF' ) );
        $wsLegalPerson = $busLegalPerson->getLegalPerson($companyInfo->personId);
        if ( $wsLegalPerson )
        {
            $instituitionEmail = $wsLegalPerson->email;
        }

        $dataAcademic = $this->wsGetGroupEmail( $groupId );
        if ( count( $dataAcademic ) > 0 )
        {
            // Seta como rementente o professor e email noreply:
            if ( $instituitionEmail )
            {
                $instituitionEmail = explode( "@", $instituitionEmail );
                $instituitionEmailResponse = "noreply@" . $instituitionEmail[1];
            }

            // Nome do professor, somente a primeira letra maiuscula...
            $professorName = explode( " ", strtolower( $professorData->personName ) );
            unset( $professorEmailName );
            foreach ( $professorName as $value )
            {
                $professorEmailName[] .= ucfirst( $value );
            }
            $professorEmailName = implode( " ", $professorEmailName );

            // Emails
            foreach ( $dataAcademic as $personData )
            {
                // Somente primeira letra do nome em maiúsulo
                $personNameArray = explode( " ", strtolower( $personData->personName ) );
                unset( $personName );
                foreach ( $personNameArray as $value )
                {
                    $personName[] .= ucfirst( $value );
                }
                $personName = implode( " ", $personName );

                // Se o aluno não tiver um email cadastrado, pula para o próximo
                if ( !strlen($personData->email) > 0 )
                {
                    // Array de nomes que não foi possível enviar o email
                    $return->errors[] = $personName;
                    continue;
                }

                // Parameters
                $from = $instituitionEmailResponse;
                $fromName = $professorEmailName;
                $recipient = strtolower($personData->email);
                $subject = $subject;
                $body = $message;

                // Instance of sendEmail
                $sendEmail = new sendEmail($from, $fromName, $recipient, $subject, $body, $bcc );

                // FIXME:Anexos
//                if ( (count( $fileDir ) > 0) && (count( $fileName ) > 0) )
//                {
//                    // Anexa os arquivos
//                    $sendEmail->setAttachments( $fileDir, $fileName );
//                }

                // Tenta enviar o e-mail e analisa o resultado
                $send = $sendEmail->sendEmail();
                if ( !$send )
                {
                    // Array de nomes que não foram possível enviar o email
                    $return->errors[] = $personName;
                }
            }

            if ( is_null( $return->errors ) )
            {
                $return->send = true;
                return $return;
            }
            else
            {
                $return->send = false;
                return $return;
            }
        }
    }

    /* Este método não é suportado pelo wsdl
     * 
     * Returna se é ou não nota conceitual (letras)
     *
     * @param  (int) $groupId - Código do grupo
     * @return (boolean)
     */
    public function wsIsConcept( $groupId )
    {
        $busGroup = new BusinessAcademicBusGroup();
        $group = $busGroup->getGroup($groupId);

        return $group->useConcept == DB_TRUE;
    }
    
    /**
     * Método utilizado para oferecer um curso (disciplina) no sistema.
     *
     * @param string $ESTADO Uf do estado 
     * @param string $CIDADE Cidade
     * @param string $NOME1 Nome do professor 1
     * @param string $CPF1 Cpf do professor 1
     * @param string $NOME2 Nome do professor 1
     * @param string $CPF2 Cpf do professor 2
     * @param string $DATA1 Data de ocorrência 1
     * @param string $DATA2 Data de ocorrência 2
     * @param string $DATA3 Data de ocorrência 3
     * @param string $DATA4 Data de ocorrência 4
     * @param string $DATA5 Data de ocorrência 5
     * @param string $DESCRICAO Descrição do recurso físico
     * @param string $ENDERECO Endereço do recurso físico
     * @param string $SALA Sala recurso físico
     * 
     * @return integer Código do oferecimento da disciplina em caso de sucesso 0 em caso de erro
     */
    public function wsOferecimento($ESTADO, $CIDADE, $NOME1, $CPF1, $NOME2, $CPF2, $DATA1, $DATA2, $DATA3, $DATA4, $DATA5, $DESCRICAO, $ENDERECO, $SALA)
    {   
        if( !strlen($ESTADO) > 0 || !strlen($CIDADE) > 0 )
        {
            return 'O estado e a cidade são parâmetros obrigatórios.';
        }
        
        if( !strlen($DATA1) > 0 || !strlen($DATA2) > 0 || !strlen($DATA3) > 0 || !strlen($DATA4) > 0 || !strlen($DATA5) > 0)
        {
            return 'Todas as 5 datas devem ser informadas.';
        }
        
        if( !strlen($NOME1) > 0 || !strlen($NOME2) > 0 || !strlen($CPF1) > 0 || !strlen($CPF2) > 0)
        {
            return 'Os campos NOME e CPF devem ser informados.';
        }
        
        $busUnit = new BusinessBasicBusUnit();
        
        $filters->description = $ESTADO; //'RS';   
        $unit = $busUnit->searchUnit($filters); //busca a unidade $unit[0][0]
        
        $filters->unitId = $unit[0][0];
        
        $busCourseOccurrence = new BusinessAcademicBusCurriculum();
        $ocorrenciaCurso = $busCourseOccurrence->searchCurriculum($filters, true);//busca ocorrencia de curso
        
        $filters->courseId = $ocorrenciaCurso[0][1];
        
        $busLearningPeriod = new BusinessAcademicBusLearningPeriod();
        $periodLetivo = $busLearningPeriod->searchLearningPeriod($filters, false, true );//busca o período letivo $periodLetivo[0][0] A.learningPeriodId
                
        $filtro->courseId = $ocorrenciaCurso[0][1]; //ocorrencia de curso
        $filtro->courseVersion = $ocorrenciaCurso[0][2]; //versão da ocorrencia de curso
        $filtro->unitId = $unit[0][0]; //unidade
        $filtro->curricularComponentId = 'DIS-AGS'; //Disciplina
              
        $busAcademicCurriculum = new BusinessAcademicBusCurriculum();
        $curriculo = $busAcademicCurriculum->searchCurriculum($filtro, true);
        
        $busGroup = new BusinessAcademicBusGroup();
                
        // Obtém dados do período letivo
        try
        {
            $busLearning = new BusinessAcademicBusLearningPeriod();
            $dataLearning = $busLearning->getLearningPeriod($periodLetivo[0][0], true);            
            
            if ($dataLearning->isClosed == DB_TRUE)
            {   
                $hasErrors = true;
                return 0;
                //throw new Exception('O período letivo selecionado está fechado e nenhuma oferecida pode ser cadastrada. Para o continuar o processo, reabra o período letivo ou selecione um período aberto.');
                
            }
        }
        catch (Exception $e)
        {
            $hasErrors = true;
            return 0;
            //throw new Exception('Erro ao buscar dados do período letivo.');
        } 
        
        // Obtém dados da versão do curso
        try
        {
            $busCourseVersion = new BusinessAcademicBusCourseVersion();
            $dataCourseVersion = $busCourseVersion->getCourseVersion($dataLearning->courseId, $dataLearning->courseVersion);
            
        }
        catch (Exception $e)
        {            
            $hasErrors = true;
            return 0;
            //throw new Exception('Erro ao buscar dados da versão do curso.');
        }
        
        //Verificacções antes de inserir uma disciplina oferecida
        // Prepara os filtros para obter os dados da matriz curricular **disciplina
        $filters->curricularComponentId = $curriculo[0][8];
        $filters->curricularComponentVersion = $curriculo[0][9];
        $filters->courseId = $curriculo[0][1];
        $filters->courseVersion = $curriculo[0][2];
        $filters->turnId = $periodLetivo[0][10];
        $filters->unitId = $periodLetivo[0][11];
        
        try
        {            
            $busCurr = new BusinessAcademicBusCurriculum();
            $curriculums = $busCurr->searchCurriculum($filters, true);
        }
        catch (Exception $e)
        {            
            //throw new Exception('Erro ao buscar dados da matriz curricular.');
            $hasErrors = true;
            return 0;
        }
        
        if (!$hasErrors)
        {
            SDatabase::beginTransaction();
            
            // Inserção
            try
            {
                $busClass = new BusinessAcademicBusClass();
                $turma = $busClass->obtemTurmaPeloCampoPersonalizado($ESTADO, $CIDADE);
                                
                if( !strlen($turma) > 0 )
                {
                    $filtersCidade->name = trim($CIDADE);
                    $filtersCidade->stateId = trim($ESTADO);
                    $busCity  = new BusinessBasicBusCity();
                    $cidade = $busCity->searchCity($filtersCidade);
                                                            
                    //Verifica se existe a cidade e marca a flag cidade sede
                    if( count($cidade) > 0)
                    {
                        $busCustomField = new BasCustomField(); 
                        $verficaSede = $busCustomField->getCustomValue('FrmCity', $cidade[0][0]);
                                                
                        $id = $busCustomField->getCustomFieldId('FrmCity', 'cidade_sede');
                        
                        //$value = $busCustomField->getCustomValue('cidade_sede', $cidade[0][0]);
                        
                        //Insere campo personalizado é sede no cadastro da cidade
                        $customValue = new MCustomValue();
                        $customValue->customizedId = $cidade[0][0];
                        $customValue->customFieldId = $id; //$customFieldId;
                        $customValue->value = 't';

                        if( strlen($verficaSede) > 0 )
                        {
                            $customValue->updateByData();
                        }
                        else
                        {
                            $customValue->insert();
                        }
                                      
                        $data->classId = 'TUR-ACS-'.trim($CIDADE);
                        $data->name = 'TURMA ACS '.trim($ESTADO).' '.trim($CIDADE);
                        $data->vacant = 9999;
                        $data->initialLearningPeriodId = $periodLetivo[0][0];
                        $data->unitId = $unit[0][0];
                        
                        $data->classId = substr($data->classId, 0, 20);
                        
                        $turma = $busClass->insertClass($data);
                        
                        $idClass = $busCustomField->getCustomFieldId('FrmClass', 'turma_cidade_sede');
                                                
                        $value = $cidade[0][0];
                        
                        //Insere campo personalizado cidade sede, no cadastro da turma
                        $customValue2 = new MCustomValue();
                        $customValue2->customizedId = $turma;
                        $customValue2->customFieldId = $idClass; 
                        $customValue2->value = $value;
                              
                        $customValue2->insert(); 
                    }
                }
                
                if (count($curriculums) != 1)
                {     
                    return 0;
                    //throw new Exception('A disciplina @1 não pertence a nenhum currículo.'. $curriculo[0][8] . '/' . $curriculo[0][9]);
                }                
                else
                {
                    $dados->learningPeriodId = $periodLetivo[0][0];
                    $dados->curriculumId = $curriculo[0][0];
                    $dados->vacant = '40';
                    $dados->regimenId = '1';
                    $dados->isClosed = 'f';
                    $dados->classId = $turma;
                    $dados->evaluationTypeId = '2';
                    $dados->financeCredits = '1';
                    $dados->curricularComponentId = $curriculo[0][8];
                    $dados->basicBibliographyRemoveAll = true;
                    $dados->complementaryBibliographyRemoveAll = true;
                    $dados->unitId = $unit[0][0];
                    
                    $busGroup = new BusinessAcademicBusGroup();
                    $groupId = $busGroup->insertGroup($dados);                    
                }               

            }
            catch (Exception $e)
            {
                $groupId = 0;
                return 0;
                //throw new Exception('Erro ao inserir um oferecimento de disciplina.');
            }            
        }
        
        if( strlen($groupId) > 0 && $groupId != 0 )
        {
            try
            { 
                if( strlen($DESCRICAO) > 0 )
                {
                    $filter->description = $DESCRICAO; //recusro físico
                    $scheduleDados->unitId = $unit[0][0];

                    $busPhysicalResource = new BusinessInstitutionalBusPhysicalResource();
                    $recursoFisico = $busPhysicalResource->searchPhysicalResource($filter);
                    /*
                    * Procura pela descrição o recurso físico, caso não encontre, insere um novo.
                    */
                    if($recursoFisico)
                    {
                        $recursoFisicoId = $recursoFisico[0][0];
                        $recursoFisicoVersao = $recursoFisico[0][1];

                    }else
                    {       
                        if( !strlen($SALA) > 0 )
                        {
                            return 'O parâmetro SALA deve ser informado.';
                        }
                        $filter->room =  $SALA;
                        $filter->physicalResourceVersion = '1';
                        $filter->dateVersion = date(SAGU::getParameter('BASIC', 'MASK_DATE_PHP'));
                        $filter->groupTypeId = SAGU::getParameter( 'ACADEMIC', 'CATEGORIA_PADRAO_DO_RECUSRO_FISICO' );
                        $filter->unitId = $scheduleDados->unitId;
                        $filter->description = $DESCRICAO;

                        $busPhysicalResource->insertPhysicalResource($filter);
                        
                        $recursoFisico = $busPhysicalResource->searchPhysicalResource($filter);
                        $recursoFisicoId = $recursoFisico[0][0];
                        $recursoFisicoVersao = $recursoFisico[0][1];
                        
                        $busCustomField = new BasCustomField(); 
                        $idRecursoFisico = $busCustomField->getCustomFieldId('FrmPhysicalResource', 'recurso_endereco');
                        
                        //Insere campo personalizado endereço, no cadastro de recurso físico
                        $customValue = new MCustomValue();
                        $customValue->customizedId = $recursoFisicoId;
                        $customValue->customFieldId = $idRecursoFisico; 
                        $customValue->value = $ENDERECO;

                        $customValue->insert();
                        
                    }
                }

                $businessScheduleProfessor = new BusinessAcademicBusScheduleProfessor();

                $CPF1 = SAGU::convertInCPFFormat($CPF1);
                $CPF2 = SAGU::convertInCPFFormat($CPF2);

                $filters->content = array($CPF1, $CPF2);

                foreach($filters->content as $k =>$filter)
                {
                    $filters->content = $filter;

                    $contentProfessor[$k] = $businessScheduleProfessor->searchScheduleProfessorSimple($filters);
                }     

                $scheduleDados->groupId = $groupId;            
                $scheduleDados->scheduleId = '';
                $scheduleDados->timeIds = array(8, 9);
                $scheduleDados->professor = '';
                $scheduleDados->timeSheetId = 5;
                $scheduleDados->learningPeriodId = $periodLetivo[0][0];
                $scheduleDados->physicalResourceId = $recursoFisicoId;
                $scheduleDados->physicalResourceVersion = $recursoFisicoVersao;
                $scheduleDados->occurrenceDates = array($DATA1, $DATA2, $DATA3, $DATA4, $DATA5);
                $scheduleDados->professorName = array($NOME1, $NOME2);
                $scheduleDados->professorId = array($contentProfessor[0][0][1], $contentProfessor[1][0][1]);
                $scheduleDados->isInstitutionalEvaluation = 'f';
                $scheduleDados->weight = '1';            
                $scheduleDados->session = ''; 
                                           
                $busLearningPeriod = new BusinessAcademicBusLearningPeriod();
                $learningPeriod = $busLearningPeriod->getLearningPeriod($periodLetivo[0][0]);

                if ( (is_array($scheduleDados->occurrenceDates)) && (in_array('error', $scheduleDados->occurrenceDates)) )
                {
                    //throw new Exception("As datas selecionadas não podem ser menores ou maiores que o intervalo de datas do período letivo " . $learningPeriod->periodDescription . ". Este inicia em " . $learningPeriod->beginDate . " e termina " . $learningPeriod->endDate . ".");
                    return 0;
                }
                $businessSchedule = new BusinessAcademicBusSchedule();
                $businessScheduleProfessor = new BusinessAcademicBusScheduleProfessor();

                if ( !is_array($scheduleDados->timeIds) )
                {
                    //throw new Exception('Deve ser informado, pelo menos, um horário');
                    return 0;
                }
                elseif ( !is_array($scheduleDados->occurrenceDates) )
                {
                    //throw new Exception('Deve ser informada a data em que a disciplina oferecida ocorrerá');
                    return 0;
                }

                if ( ( SAGU::getParameter('ACADEMIC', 'ENABLE_SCHEDULE_PROFESSOR_CHECK') == DB_TRUE ) && $businessSchedule->existeConflitoDeHorario($scheduleDados->groupId, $scheduleDados->unitId,$scheduleDados ->occurrenceDates, $scheduleDados->timeIds, $scheduleDados->scheduleId) )
                {
                    //throw new Exception('Os dados informados conflitam com um horário já existente para esta disciplina oferecida.');
                    return 0;
                }
                
                // Se for informado recurso físico e versão de recurso físico, verifica se existe conflito de alocação.
                $conflictPhysicalResource = ( strlen($scheduleDados->physicalResourceId) > 0 && strlen($scheduleDados->physicalResourceVersion) > 0 ) ? $businessSchedule->scheduleAlreadyExistsForPhysicalResource($scheduleDados->physicalResourceId, $scheduleDados->physicalResourceVersion, $scheduleDados->unitId, $scheduleDados->occurrenceDates, $scheduleDados->timeIds) : false;

                // Se existe conflito com o recurso físico.
                if ( $conflictPhysicalResource )
                {
                    $excPhysicalResource = $scheduleDados->physicalResourceId .'/'. $scheduleDados->physicalResourceVersion .' - '. $SALA;
                    $businessUnit = new BusinessBasicBusUnit();
                    $unit = $businessUnit->getUnit($data->unitId);
                    $excUnit = $data->unitId .' - '. $unit->description;
                    //throw new Exception( _M('O recurso físico @1 já está alocado na unidade @2 em algum dos horários informados.', $module, $excPhysicalResource, $excUnit) );
                    return 0;
                }

                $scheduleId = $businessSchedule->insertSchedule($scheduleDados);
                $msg[] = SAGU::getParameter('BASIC', 'MSG_RECORD_INSERTED');                

                // Faz a verificacao de carga horária excedente para o professor
                $_msg = $businessSchedule->workLoadProfessorCheck($scheduleDados->groupId);
                if ( strlen($_msg) > 0 )
                {
                    $_msg = 'Aviso: ' . $_msg . '<br><br>';
                    $msg = array_merge(array($_msg), $msg);
                }
                 
                foreach ( $scheduleDados->professorId as $value )
                {
                    $infoProfessor->scheduleId = $scheduleId;
                    $infoProfessor->professorId = $value;
                    $infoProfessor->weight = $scheduleDados->weight;
                    $infoProfessor->isInstitutionalEvaluation = $scheduleDados->isInstitutionalEvaluation;                        
                                        
                    $scheduleProfessor = $businessScheduleProfessor->getScheduleProfessor($scheduleId, $value);
                    if ( strlen($scheduleProfessor->scheduleProfessorId) == 0 )
                    { 
                        $businessScheduleProfessor->insertScheduleProfessor($infoProfessor);                        
                    }
                    else
                    {
                        $infoProfessor->scheduleProfessorId = $scheduleProfessor->scheduleProfessorId;
                        $businessScheduleProfessor->updateScheduleProfessor($infoProfessor);
                    }

                    if( SAGU::getParameter('ACADEMIC', 'ENABLE_SCHEDULE_PROFESSOR_CHECK') == DB_TRUE )
                    {
                        // Verifica se existe conflito de horarios para o professor
                        // deve ser executado apos insercao ou atualizacao, e caso exista, executa ROLLBACK
                        $businessSchedule->scheduleAlreadyExistsForProfessor($scheduleId, $infoProfessor->professorId, $scheduleDados->groupId);
                    }
                }
            
                SDatabase::commit();
                
                return $groupId;
            }
            catch ( Exception $e )
            {
                SDatabase::rollback();      
                
                //throw new Exception('Erro ao definir horário da disciplina oferecida.');                
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    
    /**
     * Método utilizado para matricular os alunos no oferecimento, além
     * de cadastrá-los como alunos caso ele ainda não exista no sistema.
     * Deve ser chamado para cada aluno a ser matriculado no sistema
     *
     * @param string $CODIGO_OFERECIMENTO  Recebe o código de oferecimento.
     * @param string $NOME Nome do aluno
     * @param string $CPF Cpf 
     * @param string $SEXO Sexo 
     * @param string $DATA_DE_NASCIMENTO Data de nascimento
     * @param string $EMAIL Email
     * @param string $TELEFONE_FIXO Telefone fixo
     * @param string $TELEFONE_CELULAR Telefone celular
     * @param string $MUNICIPIO_RESIDENCIA Município residência
     * @param string $ESTADO_RESIDENCIA Estado residência
     * @param string $CEP_RESIDENCIA Cep residência
     * @param string $BAIRRO_RESIDENCIA Bairro residência
     * @param string $LOGRADOURO_RESIDENCIA Logradouro residência
     * @param string $NUMERO_RESIDENCIA Número residência
     * @param string $COMPLEMENTO_RESIDENCIA Complemento residência
     * @param string $MUNICIPIO_PROFISSIONAL Município profissional
     * @param string $ESTADO_PROFISSIONAL Estado UF profissional
     * @param string $CEP_PROFISSIONAL Cep profissional
     * @param string $BAIRRO_PROFISSIONAL Bairro profissional
     * @param string $LOGRADOURO_PROFISSIONAL Logradouro profissional
     * @param string $NUMERO_PROFISSIONAL Numero profissional
     * @param string $COMPLEMENTO_PROFISSIONAL Complemento profissional
     * 
     * @return integer Código da pessoa inserida em caso de sucesso 0 em caso de erro
     */
    public function wsAluno($CODIGO_OFERECIMENTO, $NOME, $CPF, $SEXO, $DATA_DE_NASCIMENTO, $EMAIL, $TELEFONE_FIXO, $TELEFONE_CELULAR,
                            $MUNICIPIO_RESIDENCIA, $ESTADO_RESIDENCIA, $CEP_RESIDENCIA, $BAIRRO_RESIDENCIA, $LOGRADOURO_RESIDENCIA, $NUMERO_RESIDENCIA, $COMPLEMENTO_RESIDENCIA,
                            $MUNICIPIO_PROFISSIONAL, $ESTADO_PROFISSIONAL, $CEP_PROFISSIONAL, $BAIRRO_PROFISSIONAL, $LOGRADOURO_PROFISSIONAL, $NUMERO_PROFISSIONAL, $COMPLEMENTO_PROFISSIONAL)
    {
        $busPhysicalPerson = new BusinessBasicBusPhysicalPerson();
        $busPhysicalPersonStudent = new BusinessBasicBusPhysicalPersonStudent();
        $busDocument = new BusinessBasicBusDocument(); 
        $busCity = new BusinessBasicBusCity();        
        
        $cpf = $CPF; //CPF
        $groupId = $CODIGO_OFERECIMENTO; //CODIGO_OFERECIMENTO
        
        $cpf = SAGU::convertInCPFFormat($cpf);
        
        $filter->content = $cpf;
        
        $pessoa = $busPhysicalPerson->searchPhysicalPerson($filter); //verifica se existe pessoa
        
        SDatabase::beginTransaction();
        
        if($pessoa)
        { 
            $data->personId = $pessoa[0][0];
            
            $aluno = $busPhysicalPersonStudent->searchPhysicalPersonStudent($data);//verifica se a pessoa é aluno
            
            if(!$aluno) //se a pessoa não é aluno, insere ela como aluno
            {
                $aluno = $busPhysicalPersonStudent->insertOrUpdatePhysicalPersonStudent($data);
            }
            
           // return $aluno;
        }    
        else
        {   
            //busca cidade da pessoa
            $filtersCity->zipCode = $CEP_RESIDENCIA; // CEP_RESIDENCIA
            $filtersCity->name = strtoupper($MUNICIPIO_RESIDENCIA); //MUNICIPIO_RESIDENCIA
            $filtersCity->stateId = $ESTADO_RESIDENCIA; //ESTADO_RESIDENCIA
            $filtersCity->countryId = 'BRA';            

            $cidade = $busCity->searchCity($filtersCity);
            if($cidade)
            {
                $data->cityId = $cidade[0][0];
            }
            else
            {
                $cidade = $busCity->insertCity($filtersCity);
                $data->cityId = $cidade;            
            }
            
            //busca cidade do trabalho
            $filtersCityWork->zipCode = $CEP_PROFISSIONAL; // CEP_PROFISSIONAL
            $filtersCityWork->name = strtoupper($MUNICIPIO_PROFISSIONAL); //MUNICIPIO_PROFISSIONAL
            $filtersCityWork->stateId = $ESTADO_PROFISSIONAL ; //ESTADO_PROFISSIONAL
            $filtersCityWork->countryId = 'BRA';            

            $cidadeTrabalho = $busCity->searchCity($filtersCityWork);
            if($cidadeTrabalho)
            {
                $data->cityIdWork = $cidadeTrabalho[0][0];
            }
            else
            {
                $cidadeTrabalho = $busCity->insertCity($filtersCityWork);
                $data->cityIdWork = $cidadeTrabalho;            
            }
                 
             $data->name = strtoupper($NOME); //NOME
             $data->sex = strtoupper($SEXO); //SEXO
             $data->content = $cpf; //CPF
             $data->dateBirth = $DATA_DE_NASCIMENTO; // DATA_DE_NASCIMENTO
             $data->email = $EMAIL; // EMAIL
             $data->residentialPhone = $TELEFONE_FIXO; // TELEFONE_FIXO
             $data->cellPhone = $TELEFONE_CELULAR; // TELEFONE_CELULAR
             
             $data->zipCode = $CEP_RESIDENCIA;//CEP_RESIDENCIA
             $data->neighborhood = $BAIRRO_RESIDENCIA;//BAIRRO_RESIDENCIA
             $data->location = $LOGRADOURO_RESIDENCIA;// LOGRADOURO_RESIDENCIA
             $data->number = $NUMERO_RESIDENCIA; // NUMERO_RESIDENCIA
             $data->complement = $COMPLEMENTO_RESIDENCIA; //COMPLEMENTO_RESIDENCIA             
             
             $data->zipCodeWork = $CEP_PROFISSIONAL; //CEP_PROFISSIONAL
             $data->neighborhoodWork = $BAIRRO_PROFISSIONAL; //BAIRRO_PROFISSIONAL
             $data->locationWork = $LOGRADOURO_PROFISSIONAL; // LOGRADOURO_PROFISSIONAL
             // NUMERO_PROFISSIONAL
             $data->complementWork = $COMPLEMENTO_PROFISSIONAL; //COMPLEMENTO_PROFISSIONAL             
             
             $data->documentTypeId = '2'; //SAGU::getParameter('BASIC','DEFAULT_DOCUMENT_TYPE_ID_CPF');
             $data->isDelivered= 'f';
             
             $pessoaNova = $busPhysicalPerson->insertPhysicalPerson($data); //insere uma pessoa  
             
             $data->personId = $pessoaNova;
             
             $busDocument->insertOrUpdateDocument($data); //insere o cpf da pessoa
             
             $aluno = $busPhysicalPersonStudent->insertPhysicalPersonStudent($data); //insere a pessoa como aluno
             
        }
        
        if($aluno)
        {
            $busContract = new BusinessAcademicBusContract();
            $busGroup = new BusinessAcademicBusGroup();
            
            $disciplinaOferecida = $busGroup->getGroup($groupId, true);
            
            if($aluno->personId)
            {
                $filters->personId = $aluno->personId;
            }else
            {
                $filters->personId = $aluno[0][0];
            }
            
            $filters->courseId = $disciplinaOferecida->curriculumCourseId;
            $filters->courseVersion = $disciplinaOferecida->curriculumCourseVersion;
            $filters->turnId = $disciplinaOferecida->turnId;
            $filters->unitId = $disciplinaOferecida->unitId;

            $rows = $busContract->searchContract($filters, false, true); //verifica se existe contrato para o aluno na disciplina oferecida e na turma
            $contractId = $rows[0][0];
            
            if(!$contractId)
            {                
                $filters->isListener = 'f';
                $filters->isRequestAcademicDegree = 'f';
                $filters->exploitenrollsintransfer = 'f';
                
                $contractId = $busContract->insertContract($filters); //insere contrato para o aluno, caso ele não tenha
            }
        }
        
        if($contractId)
        {            
            $matricula = new BusinessAcademicBusEnroll();
            $groups = array($disciplinaOferecida->groupId => $disciplinaOferecida->curriculumId);            
            $learningPeriodId = $disciplinaOferecida->learningPeriodId;            
             
            try
            {
                $matricula->enroll($contractId, $learningPeriodId, $groups, true, false, false, false, false, true);
                $ok = $filters->personId;
            }
            catch(Exception $e)
            {   
                //throw new Exception('Erro ao gerar contrato.');
                $ok = 0;
            }                      
        }  
        
        SDatabase::commit();

        return $ok;
    }
    
    /**
     * Método utilizado para identificar o encerramento de um oferecimento, 
     * sendo que todos os passos foram dados e a turma é considerada concluída.
     *
     * @param  integer $CODIGO_OFERECIMENTO  Recebe o código de oferecimento.
     * @return string True ou false
     */
    public function wsEncerraOferecimento($CODIGO_OFERECIMENTO)
    {    
        $busGroup = new BusinessAcademicBusGroup();
        
        try
        {
             $busGroup->closeGroup($CODIGO_OFERECIMENTO, true);
             
             $ok = 'true';
        }
        catch (Exception $e)
        {                       
            $ok = 'false';
            
        }
        
        return $ok;
    }
    
}
?>