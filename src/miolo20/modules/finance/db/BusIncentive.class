<?php
/**
 * <--- Copyright 2005-2010 de Solis - Cooperativa de Soluções Livres Ltda.
 *
 * Este arquivo é parte do programa Sagu.
 *
 * O Sagu é um software livre; você pode redistribuí-lo e/ou modificá-lo
 * dentro dos termos da Licença Pública Geral GNU como publicada pela Fundação
 * do Software Livre (FSF); na versão 2 da Licença.
 *
 * Este programa é distribuído na esperança que possa ser útil, mas SEM
 * NENHUMA GARANTIA; sem uma garantia implícita de ADEQUAÇÃO a qualquer MERCADO
 * ou APLICAÇÃO EM PARTICULAR. Veja a Licença Pública Geral GNU/GPL em
 * português para maiores detalhes.
 *
 * Você deve ter recebido uma cópia da Licença Pública Geral GNU, sob o título
 * "LICENCA.txt", junto com este programa, se não, acesse o Portal do Software
 * Público Brasileiro no endereço www.softwarepublico.gov.br ou escreva para a
 * Fundação do Software Livre (FSF) Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA --->
 *
 * This file handles the connection and actions for finIncentive table
 *
 * @author Daniel Afonso Heisler [daniel@solis.coop.br]
 *
 * $version: $Id$
 *
 * \b Maintainers \n
 * Alexandre Heitor Schmidt [alexsmith@solis.coop.br]
 * Arthur Lehdermann [arthur@solis.coop.br]
 * Daniel Afonso Heisler [daniel@solis.coop.br]
 * Eduardo Beal Miglioransa [eduardo@solis.coop.br]
 * Jamiel Spezia [jamiel@solis.coop.br]
 * Samuel Koch [samuel@solis.coop.br]
 * William Prigol Lopes [william@solis.coop.br]
 *
 * @since
 * Class created on 02/12/2005
 */
/**
 * Class to manipulate the finIncentive table
 */
class BusinessFinanceBusIncentive extends sBusiness
{
    /**
     * Return a specific record from the database
     *
     * @param $incentiveId (integer): Primary key of the record to be retrieved
     * @return (object): Return an object of the type handled by the class
     */
    public function getIncentive($incentiveId)
    {
        $sql = 'SELECT A.incentiveId,
                       A.contractId,
                       TO_CHAR(A.startDate,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                       TO_CHAR(A.endDate,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                       A.incentiveTypeId,
                       A.valueIsPercent,
                       A.value,
                       A.supporterId,
                       A.agglutinate,
                       A.costCenterId,
                       TO_CHAR(A.cancellationDate,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                       A.userName,
                       TO_CHAR(A.dateTime,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                       A.ipAddress,
                       A.incentivoAditado,
                       TO_CHAR(A.pagamentoValorFinanciado,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                       concederSobre, 
                       prioridade
                  FROM finIncentive A
                 WHERE incentiveId = ? ';

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $incentiveId));

        $incentive = new FinIncentive( );

        list( $incentive->incentiveId,
                $incentive->contractId,
                $incentive->startDate,
                $incentive->endDate,
                $incentive->incentiveTypeId,
                $incentive->valueIsPercent,
                $incentive->value,
                $incentive->supporterId,
                $incentive->agglutinate,
                $incentive->costCenterId,
                $incentive->cancellationDate,
                $incentive->userName,
                $incentive->dateTime,
                $incentive->ipAddress,
                $incentive->incentivoAditado,
                $incentive->pagamentoValorFinanciado,
                $incentive->concederSobre,
                $incentive->prioridade ) = $result[0];

        return $incentive;
    }

    /**
     * Do a search on the database table handled by the class
     *
     * @param $filters (object): Search filters
     * @return (array): An array containing the search results
     */
    public function searchIncentive($filters)
    {
        $sql = 'SELECT C.incentiveId,
                       A.personId,
                       A.name,
                       C.supporterId,
                       D.name,
                       C.incentiveTypeId,
                       E.description,
                       TO_CHAR(C.startDate,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                       TO_CHAR(C.endDate,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                       C.valueIsPercent,
                       ROUND(C.value, \'' . SAGU::getParameter('BASIC', 'REAL_ROUND_VALUE') . '\'),
                       C.agglutinate,
                       C.costCenterId,
                       F.description,
                       TO_CHAR(C.cancellationDate, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                       (C.endDate IS NULL OR C.endDate >= now()::date) AND (C.cancellationDate IS NULL OR C.cancellationDate >= now()::date) AS active,
                       
                        (
                           select round(INV.value, GETPARAMETER(\'BASIC\', \'REAL_ROUND_VALUE\')::int)
                             from finentry E
                        left join fininvoice INV on INV.invoiceid = E.invoiceid
                            where E.contractid = C.contractid
                              and E.incentivetypeid = C.incentivetypeid
                              and BALANCE(INV.invoiceid) <> 0
                            order by INV.maturitydate
                            limit 1
                        ) AS valor_parcela,
                        
                        (
                           select obtermesextenso(extract(month from INV.maturitydate)::int) 
                             from finentry E
                        left join fininvoice INV on INV.invoiceid = E.invoiceid
                            where E.contractid = C.contractid
                              and E.incentivetypeid = C.incentivetypeid
                              and BALANCE(INV.invoiceid) <> 0
                            order by INV.maturitydate
                            limit 1
                        ) AS mes_referencia,
                       E.percentRenovacao,
                       C.incentivoAditado,
                       C.concederSobre
             FROM ONLY basPerson A
            INNER JOIN acdContract B
                    ON A.personId = B.personId
            INNER JOIN finIncentive C
                    ON B.contractId = C.contractId
        LEFT JOIN ONLY basPerson D
                    ON C.supporterId = D.personId
       INNER JOIN ONLY finIncentiveType E
                    ON C.incentiveTypeId = E.incentiveTypeId
             LEFT JOIN accCostCenter F
                    ON C.costCenterId = F.costCenterId';
        
        //Se for clicado no botao Localizar para pesquisar o incentivo, ignora esse filtro
        //Porque na tela de Incentivo esse filtro nao aparece para o usuário
        if ( strlen($filters->incentiveId) > 0 && $_REQUEST['__EVENTTARGETVALUE'] != 'btnSearch:click')
        {
            $where .= ' AND C.incentiveId = ? ';
            $args[] = $filters->incentiveId;
        }

        if ( strlen($filters->incentivos) > 0 )
        {
            $where .= " AND C.incentiveId IN ({$filters->incentivos}) ";
        }

        if ( strlen($filters->contractPersonId) > 0 )
        {
            $where .= ' AND B.personId = ? ';
            $args[] = $filters->contractPersonId;
        }

        if ( strlen($filters->personId) > 0 )
        {
            $where .= ' AND A.personId = ? ';
            $args[] = $filters->personId;
        }

        if ( strlen($filters->contractId) > 0 )
        {
            $where .= ' AND B.contractId = ? ';
            $args[] = $filters->contractId;
        }

        if ( strlen($filters->supporterId) > 0 )
        {
            $where .= ' AND C.supporterId = ? ';
            $args[] = $filters->supporterId;
        }

        if ( strlen($filters->startDate) > 0 )
        {
            $where .= ' AND C.startDate >= TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\') ';
            $args[] = $filters->startDate;
        }

        if ( strlen($filters->endDate) > 0 )
        {
            $where .= ' AND C.endDate <= TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\') ';
            $args[] = $filters->endDate;
        }

        if ( strlen($filters->incentiveTypeId) > 0 )
        {
            $where .= ' AND C.incentiveTypeId = ? ';
            $args[] = $filters->incentiveTypeId;
        }

        if ( strlen($filters->valueIsPercent) > 0 )
        {
            $where .= ' AND C.valueIsPercent = ? ';
            $args[] = $filters->valueIsPercent;
        }

        if ( strlen($filters->value) > 0 )
        {
            $where .= ' AND C.value = ? ';
            $args[] = $filters->value;
        }

        if ( strlen($filters->agglutinate) > 0 )
        {
            $where .= ' AND C.agglutinate = ? ';
            $args[] = $filters->agglutinate;
        }

        if ( strlen($filters->costCenterId) > 0 )
        {
            $where .= ' AND C.costCenterId = ? ';
            $args[] = $filters->costCenterId;
        }

        if ( strlen($filters->cancellationDate) > 0 )
        {
            $where .= ' AND C.cancellationDate = TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\') ';
            $args[] = $filters->cancellationDate;
        }
        
        if ( strlen($filters->fimIncentivo) > 0 )
        {
            $where .= ' AND C.endDate > TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\') ';
            $args[] = $filters->fimIncentivo;
        }
        
        if ( strlen($filters->vigenteNaData) > 0 )
        {
            $where .= ' AND TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\') BETWEEN C.startDate AND C.endDate ';
            $args[] = $filters->vigenteNaData;
        }
        
        $result = null;
        if ( strlen($where) > 0 )
        {
            $sql .= ' WHERE ' . substr($where, 4) . '
                  ORDER BY C.startDate ';

            $result = $this->getDatabase()->query(SAGU::prepare($sql, $args));
        }
        
        return $result;
    }

    /**
     * Search the incentive returning a simple information about that, it was primarly developed to diverse consultation
     *
     * FIXME: This method shouldn't exist. this->searchIncentives should be used instead.
     *
     * @param: $personId (int) Primary key for person (used to get all contracts related to the incentive).
     * @return: array containing the incentives.
     */
    public function searchIncentivesForPerson($personId)
    {
        $sql = 'SELECT C.incentiveId,
                       C.supporterId||\' - \'||D.name,
                       C.incentiveTypeId||\' - \'||E.description,
                       TO_CHAR(C.startDate,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                       TO_CHAR(COALESCE(C.cancellationDate, C.endDate), \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                       CASE WHEN valueIsPercent = \'' . DB_TRUE . '\' THEN ROUND(C.value, \'' . SAGU::getParameter('BASIC', 'REAL_ROUND_VALUE') . '\')::varchar||\'%\' ELSE ROUND(C.value, \'' . SAGU::getParameter('BASIC', 'REAL_ROUND_VALUE') . '\')::varchar END,
                       C.costCenterId||\' - \'||COALESCE(F.description, \'\'),
                       ROUND((select obtemValorNominalDeContratoQueTenhaIncentivo(B.contractId, C.incentiveId))::numeric,getParameter(\'BASIC\', \'REAL_ROUND_VALUE\')::integer ) as valornominal,
                       ROUND((select obtemValorDoIncentivoDeContratoQueTenhaIncentivo(B.contractId, C.incentiveId))::numeric,getParameter(\'BASIC\', \'REAL_ROUND_VALUE\')::integer ) as valorcomdesconto,
                       E.aditarIncentivo,
                       C.incentivoAditado
             FROM ONLY basPerson A
            INNER JOIN acdContract B
                    ON A.personId = B.personId
            INNER JOIN finIncentive C
                    ON B.contractId = C.contractId
        LEFT JOIN ONLY basPerson D
                    ON C.supporterId = D.personId
       INNER JOIN ONLY finIncentiveType E
                    ON C.incentiveTypeId = E.incentiveTypeId
             LEFT JOIN accCostCenter F
                    ON C.costCenterId = F.costCenterId
                 WHERE B.personId = ? ';

        $sql = SAGU::prepare($sql, array($personId));
        $result = $this->getDatabase()->query($sql);
        return $result;
    }

    /**
     * Insert a new record
     *
     * @param $data (object): An object of the type handled by the class
     * @return True if succed, otherwise False
     */
    public function insertIncentive($data)
    {
        $sql = 'SELECT NEXTVAL(\'seq_incentiveid\')';
        $ret = $this->getDatabase()->query($sql);
        $data->incentiveId = $ret[0][0];

        $sql = 'INSERT INTO finIncentive
                            (incentiveId,
                             contractId,
                             startDate,
                             endDate,
                             incentiveTypeId,
                             valueIsPercent,
                             value,
                             supporterId,
                             agglutinate,
                             costCenterId,
                             cancellationDate,
                             pagamentoValorFinanciado, 
                             concederSobre,
                             prioridade, 
                             opcaodeajuste)
                     VALUES (?,?,TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                             TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                             ?,?,?,?,?,?, TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'), ?, ?, ?, ?)';

        $args = array($data->incentiveId, $data->contractId, $data->startDate, $data->endDate, $data->incentiveTypeId, $data->valueIsPercent, $data->value, $data->supporterId, $data->agglutinate, $data->costCenterId, $data->cancellationDate, $data->pagamentoValorFinanciado, $data->concederSobre, $data->prioridade, $data->opcaoDeAjuste);

        $result = $this->getDatabase()->execute(SAGU::prepare($sql, $args));

        return $result;
    }

    /**
     * Update data from a specific record
     *
     * @param $data (object): Data which will replace the old record data
     * @return (boolean): True if succeed, otherwise False
     */
    public function updateIncentive($data)
    {
        $sql = 'UPDATE finIncentive
                   SET contractId = ?,
                       startDate = TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                       endDate = TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                       incentiveTypeId = ?,
                       valueIsPercent = ?,
                       value = ?,
                       supporterId = ?,
                       agglutinate = ?,
                       costCenterId = ?,
                       cancellationDate = TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                       pagamentoValorFinanciado = ?,
                       concederSobre = ?,
                       prioridade = ?,
                       opcaodeajuste = ?
                 WHERE incentiveId = ?';

        $args = array($data->contractId, $data->startDate, $data->endDate, $data->incentiveTypeId, $data->valueIsPercent, $data->value, $data->supporterId, $data->agglutinate, $data->costCenterId, $data->cancellationDate, $data->pagamentoValorFinanciado, $data->concederSobre, $data->prioridade, $data->opcaoDeAjuste, $data->incentiveId);

        $sqls = SAGU::prepare($sql, $args);
        for ( $i = 0; $i < count($sqls); $i++ )
        {
            $result = $this->getDatabase()->execute($sqls[$i]);
        }

        return $result;
    }

    /**
     * Delete a record
     *
     * @param $incentiveId (string): Primary key for deletion
     * @return (boolean): True if succeed, otherwise False
     */
    public function deleteIncentive($incentiveId)
    {
        $sql = 'DELETE FROM finIncentive
                      WHERE incentiveId = ? ';

        $result = $this->getDatabase()->execute(SAGU::prepare($sql, $incentiveId));

        return $result;
    }

    /**
     * Get the information for special incentives to show on diverse consultation
     *
     * @param $personId (int): Primary key for person to search
     * @return (array): Array containing special incentive information
     */
    public function getSpecialIncentive($personId)
    {
        $module = SAGU::getFileModule($file);

        $return = null;
        $args = array();
        $specialIncentives = '';

        $specialIncentiveId = SAGU::getParameter('FINANCE', 'SPECIAL_INCENTIVE_ID_TO_SHOW_ON_DIVERSE_CONSULTATION');
        if ( strlen($specialIncentiveId) > 0 )
        {
            $args[] = $personId;

            // Pode ter mais de 1 código...
            $specialIncentiveIds = explode(',', $specialIncentiveId);
            foreach ( $specialIncentiveIds as $specialIncentiveId )
            {
                $args[] = trim($specialIncentiveId);
                $specialIncentives .= ', ?';
            }
            $sql = 'SELECT C.description,
                           EXTRACT(month FROM A.startDate) as monthStartDate,
                           EXTRACT(year FROM A.startDate) as yearStartDate,
                           COALESCE(EXTRACT(month FROM A.cancellationDate), EXTRACT(month FROM A.endDate)) as monthEndDate,
                           COALESCE(EXTRACT(year FROM A.cancellationDate), EXTRACT(year FROM A.endDate)) as YearEndDate,
                           CASE WHEN COALESCE (A.cancellationDate, A.endDate) IS NULL
                             THEN true
                             ELSE false
                           END as isActive
                      FROM finIncentive A
                INNER JOIN acdContract B
                     USING (contractId)
           INNER JOIN ONLY finIncentiveType C
                     USING (incentiveTypeId)
                     WHERE B.personId = ?
                       AND A.incentiveTypeId IN (' . substr($specialIncentives, 1) . ')';

            $db = $this->getDatabase();
            $result = $db->query(SAGU::prepare($sql, $args));

            if ( is_array($result[0]) )
            {
                $res2 = array();
                foreach ( $result as $key => $res )
                {
                    $res2[$key][0] = $res[0];
                    while ( ($res[1] <= $res[3]) && ($res[2] <= $res[4]) )
                    {
                        if ( $res[1] == 13 )
                        {
                            $res[1] = 1;
                            $res[2]++;
                        }
                        $str[] = $res[1] . '-' . $res[2];
                        $res[1]++;
                    }
                    if ( count($str) > 0 )
                    {
                        $res2[$key][1] = implode(',', $str);
                    }
                    else
                    {
                        $res2[$key][1] = $res[1] . '-' . $res[2];
                    }
                    $res2[$key][2] = ($res[5] == DB_TRUE ? _M('Ativo', $module) : _M('Inativo', $module));
                    unset($str);
                }

                $return = $res2;
            }
        }

        return $return;
    }

    /**
     * Apply incentives for the specified contract id
     *
     * @param (integer) $contractId
     * @param (integer) $incentiveId Optional parameter indicating a specific incentive to generate. If left blank, all incentives
     * active for the specified contract id are generated.
     * @return (array) Array containing all generate income forecasts related to incentives applied.
     */
    public function generateIncentives($contractId, $incentiveId = null)
    {
        $MIOLO = MIOLO::getInstance();
        $module = 'finance';

        try
        {
            $return = array();

            // Obter a lista de operações sobre as quais deverão incidir os descontos
            $busDefaultOperations = new BusinessFinanceBusDefaultOperations();
            $defaultOperations = $busDefaultOperations->getDefaultOperations();
            $operationIds = array($defaultOperations->enrollOperation,
                $defaultOperations->addCurricularComponentOperation,
                $defaultOperations->cancelCurricularComponentOperation);

            $busIncomeForecast = new BusinessFinanceBusIncomeForecast();

            $busIncentiveType = new BusinessFinanceBusIncentiveType();

            if ( strlen(SAGU::getParameter('FINANCE', 'CURRICULAR_COMPONENT_DISCOUNT')) > 0 )
            {
                $operationIds = array_unique(array_merge($operationIds, explode(',', SAGU::getParameter('FINANCE', 'CURRICULAR_COMPONENT_DISCOUNT'))));
            }

            // obter valor total de cada parcela por operação, somando somente o que não foi processado
            $parcels = $busIncomeForecast->getParcelsByOperation($contractId, $operationIds, true);

            // Obter incentivos ativos para o contrato, se nenhum especificado
            if ( is_null($incentiveId) )
            {
                $incentives = $this->getIncentivesByContract($contractId, true);
            }
            else
            {
                $incentives = array($this->getIncentive($incentiveId));
            }

            // para cada incentivo
            for ( $i = 0; $i < count($incentives); $i++ )
            {
                $incentiveType = $busIncentiveType->getIncentiveType($incentives[$i]->incentiveTypeId);
                // para cada parcela, aplicar o incentivo
                for ( $j = 0; $j < count($parcels); $j++ )
                {
                    $parcel = new stdClass();
                    list ( $parcel->maturityDate,
                            $limbo,
                            $parcel->accountSchemeId,
                            $parcel->costCenterId,
                            $parcel->learningPeriodId,
                            $parcel->value ) = $parcels[$j];

                    // Um objeto stdClass deve ser utilizado, pois FinIncomeForecast inicializa
                    // alguns atributos automaticamente, prejudicando a busca
                    $filters = new stdClass();
                    $filters->contractId = $contractId;
                    $filters->operationId = $incentiveType->operationId;
                    $filters->maturityDate = $parcel->maturityDate;
                    $filters->isGenerated = DB_TRUE;
                    $filters->learningPeriodId = $parcel->learningPeriodId;
                    // Definição do valor da previsão. Será utilizado também para inserção, caso não exista.
                    if ( $incentives[$i]->valueIsPercent == DB_TRUE )
                    {
                        $filters->value = SAGU::calcNumber($incentives[$i]->value . ' * (' . $parcel->value . ' / 100)');
                    }
                    else
                    {
                        $filters->value = $incentives[$i]->value;
                    }

                    // Gerar previsão apenas se ainda não existir uma igual
                    if ( count($busIncomeForecast->searchIncomeForecast($filters)) == 0 )
                    {
                        // gerar incentivo
                        $incomeForecast = new FinIncomeForecast();
                        $incomeForecast->contractId = $contractId;
                        $incomeForecast->operationId = $incentiveType->operationId;
                        $incomeForecast->accountSchemeId = $parcel->accountSchemeId;
                        $incomeForecast->costCenterId = $parcel->costCenterId;
                        $incomeForecast->value = $filters->value;
                        $incomeForecast->comments = _M('Desconto sobre a parcela @1 de @2.', $module, $j + 1, count($parcels));
                        $incomeForecast->maturityDate = $parcel->maturityDate;
                        $incomeForecast->isGenerated = DB_TRUE;
                        $incomeForecast->learningPeriodId = $parcel->learningPeriodId;
                        $incomeForecast->incentiveId = $incentives[$i]->incentiveId;

                        $incomeForecast->incomeForecastId = $busIncomeForecast->insertIncomeForecast($incomeForecast);
                        if ( strlen($incomeForecast->incomeForecastId) == 0 )
                        {
                            throw new Exception(_M('Erro inserindo incentivo.', 'finance'));
                        }
                        // Armazenar dados estatísticos para retorno
                        $return[] = clone($incomeForecast);
                    }
                }
            }
        }
        catch ( Exception $e )
        {
            $MIOLO->error($e->getMessage());
        }

        return $return;
    }

    /**
     * Get incentives of the specified contract.
     *
     * @param unknown_type $contractId
     * @param unknown_type $activesOnly When TRUE, return only incentives which are active now (according to system date).
     */
    public function getIncentivesByContract($contractId, $activesOnly = false, $learningPeriodId = null)
    {
        $sql = 'SELECT incentiveId
    	          FROM finIncentive
    	         WHERE contractId = ?';
        
        $params[] = $contractId;

        if ( $activesOnly )
        {
            if ( empty($learningPeriodId) )
            {
                $sql .= ' AND startDate <= now()::date
                              AND (endDate IS NULL OR endDate >= now()::date)
                              AND (cancellationDate IS NULL OR cancellationDate >= now()::date)';
            }
            else
            {
                $busLearningPeriod = new BusinessAcademicBusLearningPeriod();
                $learningPeriod = $busLearningPeriod->getLearningPeriod($learningPeriodId);
                
                $sql .= ' AND (datetodb(?), datetodb(?)) OVERLAPS (startDate, endDate)
                          AND (cancellationDate IS NULL OR cancellationDate >= now()::date)';
                
                $params[] = $learningPeriod->beginDate;
                $params[] = $learningPeriod->endDate;
            }
        }

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $params));

        $return = array();
        for ( $i = 0; $i < count($result); $i++ )
        {
            $incentive = $this->getIncentive($result[$i][0]);
            $return[] = $incentive;
        }

        return $return;
    }

    public function generateIncentivesByInvoiceId($invoiceId)
    {
        $MIOLO = MIOLO::getInstance();
        $module = 'finance';

        // obter título a processar
        $busReceivableInvoice = new BusinessFinanceBusReceivableInvoice();
        $invoice = $busReceivableInvoice->getInvoice($invoiceId);

        // lançamentos do título
        $busEntry = new BusinessFinanceBusEntry();

        // tipo de incentivo
        $busIncentiveType = new BusinessFinanceBusIncentiveType();

        // definir operações sobre as quais os incentivos irão incidir
        $busDefaultOperations = new BusinessFinanceBusDefaultOperations();
        $operationIds = $busDefaultOperations->getEnrollOperations();

        // obter os contratos que um título possui em seus lançamentos
        $contracts = $busReceivableInvoice->getInvoiceContracts($invoiceId);

        // para cada contrato
        foreach ( $contracts as $contract )
        {
            // obter os incentivos a aplicar (apenas ativos na data de execução desta rotina)
            $incentives = $this->getIncentivesByContract($contract->contractId, true);
            // para cada incentivo a aplicar
            for ( $i = 0; $i < count($incentives); $i++ )
            {
                // obter o tipo de incentivo
                $incentiveType = $busIncentiveType->getIncentiveType($incentives[$i]->incentiveTypeId);
                $incentiveValue = null;

                // se incentivo é do tipo percentual, obter valor sobre o qual o percentual
                // deverá ser aplicado e definir o valor do incentivo.
                if ( $incentives[$i]->valueIsPercent == DB_TRUE )
                {
                    // obter o valor sobre o qual será aplicado o percentual
                    $totalPerOperations = $busReceivableInvoice->getTotalValuePerOperation($invoiceId, $operationIds, $contract->contractId);
                    // se não existem lançamentos sobre os quais deveria ser aplicado o incentivo
                    if ( !is_null($totalPerOperations) )
                    {
                        $incentiveValue = SAGU::calcNumber($totalPerOperations . ' * (' . $incentives[$i]->value . ' / 100)');
                    }
                }
                // se incentivo é do tipo valor, o  valor do incentivo será fixo
                else
                {
                    $incentiveValue = $incentives[$i]->value;
                }

                // se o valor do incentivo é nulo, ignorar este incentivo e partir
                // para o próximo incentivo, se houver
                if ( !is_null($incentiveValue) )
                {
                    // gerar novo lançamento ou atualizar existente
                    $entry = new FinEntry();
                    $entry->invoiceId = $invoiceId;
                    $entry->isAccounted = DB_FALSE;
                    $entry->creationType = 'A'; // gerado automaticamente pelo sistema
                    $entry->costCenterId = $invoice->costCenterId;
                    $entry->entryDate = SAGU::getDateNow();
                    $entry->operationId = $incentiveType->operationId;
                    $entry->contractId = $contract->contractId;
                    $entry->value = 0; // valor inicial do incentivo. o final será calculado a seguir
                    // Se já tiver sido aplicado um incentivo do mesmo tipo para o mesmo contrato
                    $filters = new stdClass();
                    $filters->invoiceId = $entry->invoiceId;
                    $filters->isAccounted = DB_FALSE;
                    $filters->contractId = $contract->contractId;
                    $filters->operationId = $entry->operationId;

                    $search = $busEntry->searchEntry($filters);

                    $valueIncentiveAgglutinate = 0;

                    if ( count($search) > 0 )
                    {
                        $existingEntry = $busEntry->getEntry($search[0][0]);
                        // se deve aglutinar lançamentos
                        if ( SAGU::getParameter('FINANCE', 'AGGLUTINATE_INVOICE_ENTRIES') == 'YES' )
                        {
                            // lançamento atual passa a ser o já existente
                            $entry = $existingEntry;
                            $valueIncentiveAgglutinate = $incentiveValue;
                        }
                        // se não deve aglutinar
                        else
                        {
                            $entry->comments = _M('Subtraído valor @1 de incentivo já gerado anteriormente.', $module, $existingEntry->value);
                            // o incentivo deve descontar o valor do já existente, caso houver
                            $incentiveValue = SAGU::calcNumber($incentiveValue . ' - ' . $existingEntry->value);
                        }
                    }

                    // $entry->value pode ser zero (quando não houver nada a aglutinar) ou pode
                    // já conter algum valor (quando há aglutinação). Quando já contiver algum valor,
                    // este já terá sido negativado para calcular corretamente.
                    $entry->value = SAGU::calcNumber($incentiveValue . '+' . $valueIncentiveAgglutinate, true, 2);


                    // se será inserido um novo lançamento
                    if ( strlen($entry->entryId) <= 0 )
                    {
                        if ( strlen($entry->comments) <= 0 )
                        {
                                $entry->comments = _M('Incentivo @1 no valor de @2.', $module, $incentiveType->description, SAGU::formatNumber($incentiveValue,2));
                        }
                        if ( !( strlen($busEntry->insertEntry($entry)) > 0 ) )
                        {
                            throw new Exception(_M('Erro inserindo novo lançamento de incentivo.', $module));
                        }
                    }
                    // se apenas será atualizado um lançamento já existente
                    else
                    {
                        $entry->comments .= "\n" . _M('Incentivo @1, no valor de @2, aglutinado.', $module, $incentiveType->description,  SAGU::formatNumber($incentiveValue,2));

                        if ( !$busEntry->updateEntry($entry) )
                        {
                            throw new Exception(_M('Erro atualizando lançamento de incentivo.', $module));
                        }
                    }
                }
            }
        }

        return true;
    }
    
    
    public function generateContractIncentivesByPeriod($contractId, $learningPeriodId)
    {           
        $sql = 'SELECT * FROM generateContractIncentivesByPeriod(?, ?);';        

        $result = $this->getDatabase()->execute( SAGU::prepare( $sql, array($contractId, $learningPeriodId) ) );

        return $result;
    }
    
    /*
     * Obtém percentual de aprovação
     * 
     * @parameters $contractId, $periodId
     * 
     */
    public function obterPercentualDeAprovacoes($contractId, $periodId)
    {
        $sql = ' SELECT * FROM obterPercentualDeAprovacoes( ? , ? ); ';
        
        $result = $this->getDatabase()->query( SAGU::prepare( $sql, array($contractId, $periodId) ) );

        return $result;
    }
    /*
     * 
     * 
     * Retorna o último período cursado.
     * 
     * @parameters $contractId, $beginDate, $endDate
     * 
     * 
     */
    public function obterUltimoPeriodoCursado( $contractId, $beginDate, $endDate )
    {
        $sql = 'SELECT A.periodId
		  FROM acdlearningperiod A 
	    INNER JOIN acdcontract B
		    ON (A.courseId,
		        A.courseVersion,
		        A.turnId,
		        A.unitId) = (B.courseId,
				     B.courseVersion,
				     B.turnId,
				     B.unitId)

                WHERE A.enddate BETWEEN TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\') AND TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
                  AND A.enddate < NOW()::DATE
                  AND B.contractId = ? ';

        $sql .= ' ORDER BY A.endDate DESC 
                     LIMIT 1 ';
        
        $parameters[] = $beginDate;
        $parameters[] = $endDate;
        $parameters[] = $contractId;
        
        $result = $this->getDatabase()->query( SAGU::prepare( $sql, $parameters ) );

        return $result;

    }
    
    public function aditaIncentivo($incetiveId, $reverter = false)
    {
        $incentivoAditado = $reverter ? DB_FALSE : DB_TRUE;
        
        $sql = 'UPDATE finIncentive
                   SET incentivoAditado = ?
                 WHERE incentiveId = ?';

        $args = array($incentivoAditado, $incetiveId);

        $result = $this->getDatabase()->execute(SAGU::prepare($sql, $args));
        

        return $result;
        
    }
    
    /*
     * Ao cancelar um incentivo e existir lançamentos referentes a este incentivo, ele é excluído.
     */
    public function excluiLancamentosDoIncentivo( $incentiveId, $contractId, $paymentOperationIds )
    {
        $sql = " DELETE FROM finentry 
                       WHERE entryid IN (
					SELECT A.entryid
					  FROM finentry A
			       INNER JOIN ONLY finincentivetype B 
					 using (incentivetypeid)
				    INNER JOIN finreceivableinvoice C 
					 using (invoiceid)
				    INNER JOIN (SELECT DISTINCT contractid, invoiceid FROM finentry) D 
					    ON (D.invoiceid = C.invoiceid)
				    INNER JOIN (SELECT DISTINCT periodid, invoiceid 
						           FROM finentry X 
						     INNER JOIN acdlearningperiod Y 
						          USING (learningperiodid)) E 
					    ON (E.invoiceid = C.invoiceid)
					 WHERE NOT EXISTS (SELECT 1 
						             FROM finincentive 
						            WHERE (incentivetypeid = B.incentivetypeid ) 
						              AND (contractid = D.contractid OR contractid IN (SELECT contractid 
						                                                                 FROM acdcontract 
						                                                                WHERE personid = C.personid)) 
						             AND C.maturitydate BETWEEN startdate AND enddate
							     AND incentiveId != ?)
					   AND A.creationtype = 'A'
					   AND D.contractId = ?
					   AND NOT EXISTS (SELECT 1 FROM finentry WHERE operationid IN (?) AND invoiceid = C.invoiceid)
				       ) ; ";
        $params[] = $incentiveId;
        $params[] = $contractId;
        $params[] = $paymentOperationIds;
        
        $result = $this->getDatabase()->execute(SAGU::prepare($sql, $params));
        
        return $result;
    }
    
    /**
     * Verifica se algum dos incentivos vigentes do contrato esta aditado,
     * para bloqueio de ajustes de matrícula.
     * 
     * @param int $contractId
     * @return boolean
     */
    public static function verificaSePossuiIncentivoAditado($contractId)
    {
        $MIOLO   = MIOLO::getInstance();
        $aditado = false;
        
        if ( SAGU::getParameter('FINANCE', 'PERMITIR_ADITAR_INCENTIVOS') == DB_TRUE )
        {
            //Filtrar apenas os incentivos que não estão cancelados
            $filters = new stdClass();
            $filters->contractId   = $contractId;
            $filters->fimIncentivo = SAGU::getDateNow();
        
            $busIncentive = new BusinessFinanceBusIncentive();
            $incentivos = $busIncentive->searchIncentive($filters);
            
            foreach($incentivos as $incentivo)
            {
                if($incentivo[19] == DB_TRUE)
                {   
                    $aditado = true;
                    $msg = _M('Não é possível efetuar ajuste de matrícula, pois o contrato possuí o incentivo aditado.');
                    $MIOLO->error($msg);
                }
            }
        }
        
        return $aditado;
    }
    
    /**
     * Função desenvolvida para poder executar teste unitário 
     * 
     * @param type $personId
     * @param type $invoiceId
     * @param type $entryId
     * @param type $incentiveId
     * @return type
     */
    public function gerarTitulosDoIncentivo($personId, $invoiceId, $entryId, $incentiveId)
    {
        $sql = " SELECT gerarTitulosDoIncentivo({$personId}, {$invoiceId}, {$entryId}, {$incentiveId}) ";
        
        $result = $this->getDatabase()->execute($sql);
        
        return $result;
    }
    
    /**
     * Verifica se existe um incentivo com a mesma prioridade no mesmo período 
     * 
     * @param type $data contractId, startDate, endDate, prioridade
     * @return boolean 
     */
    public static function verificaPrioridadeDoIncentivo($data)
    {
        $sql = " SELECT COUNT(*) > 0
                   FROM finIncentive 
                  WHERE contractId = ?
                    AND (datetodb(?), datetodb(?)) OVERLAPS (startDate, endDate) 
                    AND prioridade = ? ";
        
        $args[] = $data->contractId;
        $args[] = $data->startDate;
        $args[] = $data->endDate;
        $args[] = $data->prioridade;
        
        if ( strlen($data->incentiveId) > 0 )
        {
            $sql .= " AND incentiveId <> ? ";
            $args[] = $data->incentiveId;
        }
        
        $result = SDatabase::query($sql, $args);
        
        return $result[0][0];
    }
}
?>
