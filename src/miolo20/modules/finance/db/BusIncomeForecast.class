<?php
/**
 * <--- Copyright 2005-2010 de Solis - Cooperativa de Soluções Livres Ltda.
 * 
 * Este arquivo é parte do programa Sagu.
 * 
 * O Sagu é um software livre; você pode redistribuí-lo e/ou modificá-lo
 * dentro dos termos da Licença Pública Geral GNU como publicada pela Fundação
 * do Software Livre (FSF); na versão 2 da Licença.
 * 
 * Este programa é distribuído na esperança que possa ser útil, mas SEM
 * NENHUMA GARANTIA; sem uma garantia implícita de ADEQUAÇÃO a qualquer MERCADO
 * ou APLICAÇÃO EM PARTICULAR. Veja a Licença Pública Geral GNU/GPL em
 * português para maiores detalhes.
 * 
 * Você deve ter recebido uma cópia da Licença Pública Geral GNU, sob o título
 * "LICENCA.txt", junto com este programa, se não, acesse o Portal do Software
 * Público Brasileiro no endereço www.softwarepublico.gov.br ou escreva para a
 * Fundação do Software Livre (FSF) Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA --->
 *
 * This file handles the connection and actions for finIncomeForecast table
 *
 * @author Alexandre Heitor Schmidt [alexsmith@solis.coop.br]
 *
 * @maintainer: William Prigol Lopes [william@solis.coop.br]
 *
 * $version: $Id$
 *
 * \b Maintainers \n
 * Alexandre Heitor Schmidt [alexsmith@solis.coop.br]
 * Daniel Afonso Heisler [daniel@solis.coop.br]
 * Eduardo Beal Miglioransa [eduardo@solis.coop.br]
 * Jamiel Spezia [jamiel@solis.coop.br]
 * Rafael Luís Spengler [rafael@solis.coop.br]
 * Samuel Koch [samuel@solis.coop.br]
 * William Prigol Lopes [william@solis.coop.br]
 * Eduardo Beal Miglioransa [eduardo@solis.coop.br]
 * Vinícius Becker [vinicius@solis.coop.br]
 *
 * @since
 * Class created on 06/12/2005
 *
 **/

/**
 * Class to manipulate the finIncomeForecast table
 **/
class BusinessFinanceBusIncomeForecast extends sBusiness
{
    /**
     * @var unknown_type Keeps information about the income forecast generation process
     */
    public $generationData;

    /**
     * Return a specific record from the database
     *
     * @param $incomeForecastId (integer): Primary key of the record to be retrieved
     *
     * @return (object): Return an object of the type handled by the class
     *
     **/
    public function getIncomeForecast($incomeForecastId)
    {
        $sql = '    SELECT A.incomeForecastId,
                           C.personId,
                           getPersonName(C.personId),
                           A.contractId,
                           C.courseId,
                           C.courseVersion,
                           G.name,
                           A.operationId,
                           D.description,
                           A.accountSchemeId,
                           E.description,
                           A.costCenterId,
                           F.description,
                           A.value,
                           A.comments,
                           TO_CHAR(A.recordDate,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                           TO_CHAR(A.maturityDate,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                           A.isAccounted,
                           A.isProcessed,
                           A.isGenerated,
                           A.incentiveId,
                           A.isSupressed,
                           A.userName,
                           TO_CHAR(A.dateTime,\'' . SAGU::getParameter('BASIC', 'MASK_TIMESTAMP') . '\'),
                           A.learningPeriodId,
                           A.invoiceid
                      FROM finIncomeForecast A
                INNER JOIN acdContract C
                        ON C.contractId = A.contractId
                INNER JOIN finOperation D
                        ON D.operationId = A.operationId
                INNER JOIN accAccountScheme E
                        ON E.accountSchemeId = A.accountSchemeId
                INNER JOIN accCostCenter F
                        ON F.costCenterId = A.costCenterId
                INNER JOIN acdCourse G
                        ON G.courseId = C.courseId
                     WHERE A.incomeForecastId = ?';

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $incomeForecastId));

        $incomeForecast = new FinIncomeForecast();

        list ( $incomeForecast->incomeForecastId,
               $incomeForecast->contractPersonId,
               $incomeForecast->contractPersonName,
               $incomeForecast->contractId,
               $incomeForecast->contractCourseId,
               $incomeForecast->contractCourseVersion,
               $incomeForecast->contractCourseName,
               $incomeForecast->operationId,
               $incomeForecast->operationDescription,
               $incomeForecast->accountSchemeId,
               $incomeForecast->accountSchemeDescription,
               $incomeForecast->costCenterId,
               $incomeForecast->costCenterDescription,
               $incomeForecast->value,
               $incomeForecast->comments,
               $incomeForecast->recordDate,
               $incomeForecast->maturityDate,
               $incomeForecast->isAccounted,
               $incomeForecast->isProcessed,
               $incomeForecast->isGenerated,
               $incomeForecast->incentiveId,
               $incomeForecast->isSupressed,
               $incomeForecast->userName,
               $incomeForecast->dateTime,
               $incomeForecast->learningPeriodId,
               $incomeForecast->invoiceId ) = $result[0];

        return $incomeForecast;
    }

    /**
     * Do a search on the database table handled by the class
     *
     * @param $filters (object): Search filters
     *
     * @return (array): An array containing the search results
     */
    public function searchIncomeForecast($data)
    {
        $sql = 'SELECT A.userName,
                       TO_CHAR(A.dateTime,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                       A.ipAddress,
                       A.incomeForecastId,
                       A.contractId,
                       A.operationId,
                       B.description,
                       B.operationTypeId,
                       A.accountSchemeId,
                       C.description,
                       A.costCenterId,
                       D.description,
                       A.value,
                       A.comments,
                       TO_CHAR(A.recordDate,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                       TO_CHAR(A.maturityDate,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                       A.isAccounted,
                       A.isProcessed,
                       A.isGenerated,
                       A.incentiveId,
                       A.isSupressed,
                       A.learningPeriodId,
                       E.personId,
                       E.courseId,
                       E.courseVersion,
                       E.turnId,
                       E.unitId,
                       E.maturityDay,
                       E.bankAccountId,
                       G.incomeSourceId,
                       F.name AS personName,
                       A.invoiceid
                  FROM finIncomeForecast A
            INNER JOIN finOperation B
                    ON B.operationId = A.operationId
            INNER JOIN accAccountScheme C
                    ON C.accountSchemeId = A.accountSchemeId
            INNER JOIN accCostCenter D
                    ON D.costCenterId = A.costCenterId
            INNER JOIN acdContract E
                    ON E.contractId = A.contractId
       INNER JOIN ONLY basPerson F
                    ON F.personId = E.personId
            INNER JOIN acdCourse G
                    ON G.courseId = E.courseId';

        $where = '';
        $args = array();

        if ( count($data->incomeForecastIds) )
        {
            $ids = count($data->incomeForecastIds);
            $where .= ' AND A.incomeForecastId IN (' . substr(str_repeat(',?', $ids),1) . ')';
            $args = array_merge($args, $data->incomeForecastIds);
        }
        if ( strlen($data->incomeForecastId) > 0 )
        {
            $where .= ' AND A.incomeForecastId = ?';
            $args[] = $data->incomeForecastId;
        }
        if ( strlen($data->contractId) > 0 )
        {
            $where .= ' AND A.contractId = ?';
            $args[] = $data->contractId;
        }
        if ( strlen($data->operationId) > 0 )
        {
            $where .= ' AND A.operationId = ?';
            $args[] = $data->operationId;
        }
        if ( strlen($data->operationTypeId) > 0 )
        {
            $where .= ' AND A.operationTypeId = ?';
            $args[] = $data->operationTypeId;
        }
        if ( strlen($data->accountSchemeId) > 0 )
        {
            $where .= ' AND A.accountSchemeId = ?';
            $args[] = $data->accountSchemeId;
        }
        if ( strlen($data->costCenterId) > 0 )
        {
            $where .= ' AND A.costCenterId = ?';
            $args[] = $data->costCenterId;
        }
        if ( strlen($data->value) > 0 )
        {
            $where .= ' AND A.value = ?';
            $args[] = $data->value;
        }
        if ( strlen($data->comments) > 0 )
        {
            $where .= ' AND A.comments ILIKE ?';
            $args[] = $data->comments;
        }
        if ( strlen($data->recordDate) > 0 )
        {
            $where .= ' AND A.recordDate = TO_DATE(?, \'' . SAGU::getParameter('basic', 'MASK_DATE') . '\')';
            $args[] = $data->recordDate;
        }
        if ( strlen($data->maturityDate) > 0 )
        {
            $where .= ' AND A.maturityDate = TO_DATE(?, \'' . SAGU::getParameter('basic', 'MASK_DATE') . '\')';
            $args[] = $data->maturityDate;
        }
        if ( strlen($data->isAccounted) > 0 )
        {
            $where .= ' AND A.isAccounted = ?';
            $args[] = $data->isAccounted;
        }
        if ( strlen($data->isProcessed) > 0 )
        {
            $where .= ' AND A.isProcessed = ?';
            $args[] = $data->isProcessed;
        }
        if ( strlen($data->isGenerated) > 0 )
        {
            $where .= ' AND A.isGenerated = ?';
            $args[] = $data->isGenerated;
        }
        if ( strlen($data->incenTiveId) > 0 )
        {
            $where .= ' AND A.incentiveId = ?';
            $args[] = $data->incenTiveId;
        }
        if ( strlen($data->isSupressed) > 0 )
        {
            $where .= ' AND A.isSupressed = ?';
            $args[] = $data->isSupressed;
        }
        if ( strlen($data->learningPeriodId) > 0 )
        {
            $where .= ' AND A.learningPeriodId = ?';
            $args[] = $data->learningPeriodId;
        }
        if ( strlen($data->periodId) > 0 )
        {
            $where .= ' AND A.learningPeriodId IN (SELECT learningPeriodId
                                                     FROM acdLearningPeriod
                                                    WHERE periodId = ?)';
             
            $args[] = $data->periodId;
        }
        if ( strlen($data->personId) > 0 )
        {
            $where .= ' AND E.personId = ?';
            $args[] = $data->personId;
        }
        if ( strlen($data->maturityYear) > 0 )
        {
            $where .= ' AND EXTRACT(YEAR FROM A.maturityDate) = ?';
            $args[] = $data->maturityYear;
        }
        if ( strlen($data->maturityMonth) > 0 )
        {
            $where .= ' AND EXTRACT(MONTH FROM A.maturityDate) = ?';
            $args[] = $data->maturityMonth;
        }
        if ( strlen($data->invoiceId) > 0 )
        {
            $where .= ' AND invoiceid = ?';
            $args[] = $data->invoiceId;
        }

        if ( strlen($where) > 0 )
        {
            $sql .= $where . ' ORDER BY A.contractId,
                                        A.maturityDate,
                                        A.incomeForecastId';

            $result = $this->getDatabase()->query(SAGU::prepare($sql, $args));
        }

        return $result;
    }

    /**
     * Insert a new record
     *
     * @param $data (object): An object of the type handled by the class
     *
     * @return On success, return the record id. Otherwise return null
     *
     **/
    public function insertIncomeForecast($data)
    {
        $sql = 'SELECT NEXTVAL(\'seq_incomeforecastid\')';

        $retVal = $this->getDatabase()->query($sql);

        $incomeForecastId = null;
        if ( isset($retVal) )
        {
            $incomeForecastId = $retVal[0][0];
            
            // NOT NULL fields
            $fields[] = array('incomeForecastId', '?');
            $args[] = $incomeForecastId;
            $fields[] = array('contractId', '?');
            $args[] = $data->contractId;
            $fields[] = array('operationId', '?');
            $args[] = $data->operationId;
            $fields[] = array('accountSchemeId', '?');
            $args[] = $data->accountSchemeId;
            $fields[] = array('costCenterId', '?');
            $args[] = $data->costCenterId;
            $fields[] = array('value', '?');
            $args[] = $data->value;

            if ( strlen($data->comments) > 0 )
            {
                $fields[] = array('comments', '?');
                $args[] = $data->comments;
            }
            if ( strlen($data->recordDate) > 0 )
            {
                $fields[] = array('recordDate', 'TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')');
                $args[] = $data->recordDate;
            }
            if ( strlen($data->maturityDate) > 0 )
            {
                $fields[] = array('maturityDate', 'TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')');
                $args[] = $data->maturityDate;
            }
            if ( strlen($data->isAccounted) > 0 )
            {
                $fields[] = array('isAccounted', '?');
                $args[] = $data->isAccounted;
            }
            if ( strlen($data->isProcessed) > 0 )
            {
                $fields[] = array('isProcessed', '?');
                $args[] = $data->isProcessed;
            }
            if ( strlen($data->isGenerated) > 0 )
            {
                $fields[] = array('isGenerated', '?');
                $args[] = $data->isGenerated;
            }
            if ( strlen($data->incentiveId) > 0 )
            {
                $fields[] = array('incentiveId', '?');
                $args[] = $data->incentiveId;
            }
            if ( strlen($data->isSupressed) > 0 )
            {
                $fields[] = array('isSupressed', '?');
                $args[] = $data->isSupressed;
            }
            if ( strlen($data->learningPeriodId) > 0 )
            {
                $fields[] = array('learningPeriodId', '?');
                $args[] = $data->learningPeriodId;
            }
            if ( strlen($data->invoiceId) > 0 )
            {
                $fields[] = array('invoiceId', '?');
                $args[] = $data->invoiceId;
            }
            
            // Build main SQL
            $sql = 'INSERT INTO finIncomeForecast (';
            // Create FIELDS section and VALUES section of the SQL
            for ( $i=0; $i<count($fields); $i++ )
            {
                $sql .= $fields[$i][0] . ',';
                $values .= $fields[$i][1] . ',';
            }
            // Create final SQL cutting off the last ","
            $sql = substr($sql, 0, strlen($sql)-1) . ') VALUES (' . substr($values, 0, strlen($values)-1) . ')';

            if ( !$this->getDatabase()->execute(SAGU::prepare($sql, $args)) )
            {
                unset($incomeForecastId);
            }
        }
        return $incomeForecastId;
    }

    /**
     * Update data from a specific record
     *
     * @param $data (object): Data which will replace the old record data
     *
     * @return (boolean): True if succeed, otherwise False
     *
     **/
    public function updateIncomeForecast($data)
    {
        $module = MIOLO::getCurrentModule();
        
        try
        {
            $incomeForecast = $this->getIncomeForecast($data->incomeForecastId);
            
            if ( $incomeForecast->isSupressed == DB_TRUE )
            {
                throw new Exception(_M('Previsão de lançamento suprimida.', $module));
            }
            if ( $incomeForecast->isAccounted == DB_TRUE )
            {
                throw new Exception(_M('Previsão de lançamento já contabilizada.', $module));
            }
            if ( $incomeForecast->isProcessed == DB_TRUE )
            {
                throw new Exception(_M('Previsão de lançamento já processada.', $module));
            }
            
            $sql = 'UPDATE finIncomeForecast
                       SET contractId        = ?,
                           operationId       = ?,
                           accountSchemeId   = ?,
                           costCenterId      = ?,
                           value             = ?,
                           comments          = ?,
                           recordDate        = TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                           maturityDate      = TO_DATE(?,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                           isProcessed       = ?,
                           isSupressed       = ?,
                           invoiceId         = ?
                     WHERE incomeForecastId  = ?';
    
            $args = array($data->contractId,
                          $data->operationId,
                          $data->accountSchemeId,
                          $data->costCenterId,
                          $data->value,
                          $data->comments,
                          $data->recordDate,
                          $data->maturityDate,
                          $data->isProcessed,
                          $data->isSupressed,
                          $data->invoiceId,
                          $data->incomeForecastId);
    
            $sqls = SAGU::prepare($sql, $args);
    
            for ( $i = 0; $i < count($sqls); $i++ )
            {
                $result = $this->getDatabase()->execute($sqls[$i]);
            }
        }
        catch ( Exception $e )
        {
            $result = false;
            $this->addError($e->getMessage());
        }

        return $result;
    }

    /**
     * Delete a record
     *
     * @param $incomeForecastId (string): Primary key for deletion
     *
     * @return (boolean): True if succeed, otherwise False
     *
     **/
    public function deleteIncomeForecast($incomeForecastId)
    {
        $module = MIOLO::getCurrentModule();
        
        try
        {
            $incomeForecast = $this->getIncomeForecast($incomeForecastId);

            if ( $incomeForecast->isSupressed == DB_TRUE )
            {
                throw new Exception(_M('Previsão de lançamento suprimida.', $module));
            }
            if ( $incomeForecast->isAccounted == DB_TRUE )
            {
                throw new Exception(_M('Previsão de lançamento já contabilizada.', $module));
            }
            if ( $incomeForecast->isProcessed == DB_TRUE )
            {
                throw new Exception(_M('Previsão de lançamento já processada.', $module));
            }
            
            $sql = 'DELETE FROM finIncomeForecast
                          WHERE incomeForecastId = ?';
    
            $args = array($incomeForecastId);
            $result = $this->getDatabase()->execute(SAGU::prepare($sql, $incomeForecastId));
        }
        catch ( Exception $e )
        {
            $result = false;
            $this->addError($e->getMessage());
        }

        return $result;
    }

    /**
     * Get all income forecasts for the specified contract, within the specified learning period and the specified
     * year and month maturidy.
     * 
     * @param $contractId
     * @param $learningPeriodId
     * @param $year
     * @param $month
     * 
     * @return An array containing all income forecasts matching the selection criteria
     */
    public function getIncomeForecastPerson($personId, $year, $month)
    {
        $sql = '   SELECT A.incomeForecastId,
                          B.courseId || \'/\' || B.courseVersion || \' - \' || getCourseName(B.courseId),
                          A.comments,
                          C.operationId||\' - \'||C.description,
                          C.operationTypeId,
                          B.unitId,
                          E.description AS unitDescription,
                          TO_CHAR(A.recorddate, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                          TO_CHAR(A.maturityDate, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                          ROUND(A.value, 2) AS value,
                          A.isProcessed,
                          A.isGenerated,
                          A.isSupressed
                     FROM finIncomeForecast A
               INNER JOIN acdContract B
                       ON B.contractId = A.contractId
               INNER JOIN finOperation C
                       ON C.operationId = A.operationId
               INNER JOIN basUnit E
                       ON E.unitId = B.unitId
                LEFT JOIN acdLearningPeriod D
                       ON D.learningPeriodId = A.learningPeriodId
                    WHERE B.personId = ?
                      AND EXTRACT(YEAR FROM A.maturitydate) = ?
                      AND EXTRACT(MONTH FROM A.maturitydate) = ?
                 ORDER BY A.recordDate';

        $res = $this->getDatabase()->query(SAGU::prepare($sql, array($personId, $year, $month)));

        return $res;
    }

    /**
     * get income forecast person where incomeForecastId for edit.
     *
     * @param  contractId, learningPeriodId, incomeForecastId
     *
     * @return One IncomeForecast data
     *
     **/
    public function getIncomeForecastEditPerson($incomeForecastId, $contractId, $learningPeriodId)
    {
        $sql = 'SELECT A.contractId,
                    A.incomeForecastId,
                    C.operationId,
                    C.description,
                    C.operationTypeId,
                    to_char(A.recorddate, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                    A.value,
                    A.isAccounted,
                    D.learningPeriodId,
                    to_char(A.maturityDate, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                    A.accountSchemeid,
                    A.costCenterId,
                    A.comments,
                    A.isGenerated,
                    A.isProcessed,
                    A.userName,
                    TO_CHAR(A.dateTime,\'' . SAGU::getParameter('BASIC', 'MASK_TIMESTAMP') . '\')
               FROM finIncomeForecast A,
                    acdContract B,
                    finOperation C,
                    acdLearningPeriod D
              WHERE A.contractId = B.contractId
                AND B.courseId = D.courseId
                AND B.courseVersion = D.courseVersion
                AND C.operationId = A.operationId
                AND B.unitId = D.unitId
                AND B.turnId = D.turnId
                AND B.contractId = ?
                AND D.learningPeriodId = ?
                AND A.incomeForecastId = ?
                AND A.maturityDate BETWEEN D.beginDate AND D.endDate
           ORDER BY A.recorddate ';

        $res = $this->getDatabase()->query(SAGU::prepare($sql, array($contractId, $learningPeriodId, $incomeForecastId)));

        list ( $income->contractId,
               $income->incomeForecastId,
               $income->operationId,
               $income->description,
               $income->operationTypeId,
               $income->recordDate,
               $income->value,
               $income->isAccounted,
               $income->learningPeriodId,
               $income->maturityDate,
               $income->accountSchemeId,
               $income->costCenterId,
               $income->comments,
               $income->isGenerated,
               $income->isProcessed,
               $income->userName,
               $income->dateTime ) = $res[0];

       return $income;
    }

    /**
     * get mount and total off month and learningPeriodId on incomeforecast period
     *
     * @param  contractId, learningPeriodId, A.maturityDate BETWEEN D.beginDate AND D.endDate
     *
     * @return mount and total off month for a current month
     *
     **/
    public function getCurrentMonthValue($data = null)
    {
        $sql = ' SELECT month,
                          sum( round(sumValue, 2) )
                    FROM ( SELECT extract(MONTH FROM A.maturitydate) as month,
                                  A.value * (CASE WHEN C.operationTypeId = \'D\' THEN 1 WHEN
                                  C.operationTypeId = \'C\' THEN -1 END)  as sumValue
                             FROM finIncomeForecast A,
                                  acdContract B,
                                  finOperation C,
                                  acdLearningPeriod D
                            WHERE A.contractId = B.contractId
                              AND B.courseId = D.courseId
                              AND B.courseVersion = D.courseVersion
                              AND C.operationId = A.operationId
                              AND B.unitId = D.unitId
                              AND B.turnId = D.turnId
                              AND B.contractId = ?
                              AND D.learningPeriodId = ?
                              AND extract(MONTH FROM A.maturitydate) = extract(MONTH FROM TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'))
                              AND A.maturityDate BETWEEN D.beginDate AND D.endDate
                              ORDER BY 1 )
                                    AS A
                    GROUP BY 1 ';

        $res = $this->getDatabase()->query(SAGU::prepare($sql, array($data->contractId, $data->learningPeriodId, $data->maturityDate)));

        return $res;
    }

    /**
     * Get months of income forecasts belonging the specified contract and lying within the specified learning period
     *
     * @param (integer) contractId
     * @param (integer) learningPeriodId
     *
     * @return (array) All months with existent income forecasts.
     *
     **/
    public function getMonthlyBalance($personId, $startDate = null, $endDate = null)
    {
        $sql = 'SELECT EXTRACT(YEAR FROM A.maturityDate) AS year,
                       EXTRACT(MONTH FROM A.maturityDate) AS month,
                       SUM(A.value * (CASE WHEN C.operationTypeId = \'D\' THEN -1 ELSE 1 END)) AS balance
                  FROM finIncomeForecast A
            INNER JOIN acdContract B
                    ON B.contractId = A.contractId
            INNER JOIN finOperation C
                    ON C.operationId = A.operationId
                 WHERE B.personId = ?';
        
        $args = array($personId);
        
        if ( strlen($startDate) > 0 && strlen($endDate) > 0 )
        {
            $sql .= ' AND A.recordDate BETWEEN TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
                                           AND TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')';
            $args[] = $startDate;
            $args[] = $endDate;
        }
        elseif ( strlen($startDate) > 0 )
        {
            $sql .= ' AND A.recordDate >= TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')';
            $args[] = $startDate;
        }
        elseif ( strlen($endDate) > 0 )
        {
            $sql .= ' AND A.recordDate <= TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')';
            $args[] = $endDate;
        }
        
        $sql .= 'GROUP BY 1, 2
                 ORDER BY 1, 2';

        $res = $this->getDatabase()->query(SAGU::prepare($sql, $args));
        return $res;
    }

    /**
     * get income forecast id from a period
     *
     * @param  contractId, learningPeriodId, A.maturityDate BETWEEN D.beginDate AND D.endDate
     *
     * @return any incomeForecastIds
     *
     **/
    public function getIncomeForecastIds($data = null)
    {
        $sql = ' SELECT A.incomeForecastId
                        FROM finIncomeForecast A,
                             acdContract B,
                             finOperation C,
                             acdLearningPeriod D
                       WHERE A.contractId = B.contractId
                         AND B.courseId = D.courseId
                         AND B.courseVersion = D.courseVersion
                         AND C.operationId = A.operationId
                         AND B.unitId = D.unitId
                         AND B.turnId = D.turnId
                         AND B.contractId = ?
                         AND D.learningPeriodId = ?
                         AND extract(MONTH FROM A.maturitydate) =
                                        extract(MONTH FROM TO_DATE( ? , \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'))
                         AND A.maturityDate BETWEEN D.beginDate AND D.endDate
                         ORDER BY 1 ';

        $res = $this->getDatabase()->query(SAGU::prepare($sql, array($data->contractId, $data->learningPeriodId, $data->maturityDate)));

        return $res;

    }

    public function getMonthlyFeeForPeriod($data = null)
    {
        $MIOLO = MIOLO::getInstance();

        $sql = ' SELECT DISTINCT extract(MONTH FROM A.maturityDate)
                             FROM finIncomeForecast A,
                                  acdContract B,
                                  finOperation C,
                                  acdLearningPeriod D
                            WHERE A.contractId = B.contractId
                              AND B.courseId = D.courseId
                              AND B.courseVersion = D.courseVersion
                              AND C.operationId = A.operationId
                              AND B.unitId = D.unitId
                              AND B.turnId = D.turnId
                              AND B.contractId = ?
                              AND D.learningPeriodId = ?
                              AND C.operationId = ?
                              AND A.maturityDate BETWEEN D.beginDate AND D.endDate
                              ORDER BY 1 ';

        $res = $this->getDatabase()->query(SAGU::prepare($sql, array($data->contractId,
                                                          $data->learningPeriodId,
                                                          SAGU::getParameter('FINANCE', 'DEFAULT_OPERATIONID_MONTHLY_FEE'))));

        return $res;

    }

    /**
     * Generate update finincomeforecast  SET isprocessed = true
     *
     * @param  incomeforecastid
     *
     * @return true or false
     *
     **/
    public function generateUpdateIncomeForecast($data = null)
    {
        $return = true;

        for ( $i = 0; $i < count($data); $i++ )
        {
            $sql = 'UPDATE finincomeforecast
                           SET isprocessed = true
                         WHERE incomeforecastid = ? ';

            $res = $this->getDatabase()->execute(SAGU::prepare($sql, $data[$i][0]));

            if ( $this->getDatabase()->getErrors() )
            {
                $return = false;
            }
        }

        return $return;
    }

    /**
     * Verify if is processed
     *
     * @param $incomeForecastId (int): Primary key for income forecast
     *
     * @return True if runs otherwise is false
     *
     */
    public function isProcessed($incomeForecastId)
    {
        $sql = ' SELECT isProcessed
                   FROM finIncomeForecast
                  WHERE incomeForecastId = ? ';

        $res = $this->getDatabase()->query(SAGU::prepare($sql, $incomeForecastId));

        return $res[0][0];
    }

    /**
     * Generate update finInvoice  SET value = balance
     *
     * @param  value ( balance ())
     *
     * @return true or false
     *
     **/
    public function updateInvoiceValue($value, $invoiceId)
    {
        $sql = 'UPDATE finInvoice SET value = ? WHERE invoiceId = ? ';
        $res = $this->getDatabase()->execute(SAGU::prepare($sql, array($value, $invoiceId)));

        if ( $this->getDatabase()->getErrors() )
        {
            $return = false;
        }

        return $return;
    }

    /**
     * Insert a new record
     *
     * @param $data (object): An object of the type handled by the class
     *
     * @return If succed, return the invoice id. Otherwise return FALSE.
     *
     **/
    public function insertEntry($data)
    {
        $sql = ' INSERT INTO finEntry
                            ( invoiceId,
                              operationId,
                              entryDate,
                              value,
                              costCenterId,
                              comments,
                              bankReturnCode,
                              isAccounted,
                              creationType
                            )
                      VALUES (?, ?, to_date(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'), ?, ?, ?, ?, ?, ?) ';

        $args = array($data->invoiceId,
                      $data->operationId,
                      $data->entryDate,
                      $data->value,
                      $data->costCenterId,
                      $data->comments,
                      $data->bankReturnCode,
                      $data->isAccounted,
                      $data->creationType);

        $return = $this->getDatabase()->execute(SAGU::prepare($sql, $args));

        if ( $this->getDatabase()->getErrors() )
        {
            $return = false;
        }

        return $return;
    }

    /**
     *
     * Mark a incomeForecast as supressed
     *
     * @param: #$incomeForecastId (int): Primary key for income forecast
     *
     * @return: True if runs otherwise false
     *
     */
    public function setIsSupressed($incomeForecastId)
    {
        $sql = ' UPDATE finIncomeForecast
                    SET isSupressed = ?
                  WHERE incomeForecastId = ? ';

        $args = array(DB_TRUE, $incomeForecastId);
        $return = $this->getDatabase()->execute($sql, $args);

        return $return;
    }

    /**
     *
     * Process incentives in income forecasts
     *
     * @param: $data (object): Object containing necessary data to make this process
     *
     * @return (object): Object containing information about process
     *
     */
    public function processIncentives($data)
    {
        set_time_limit(0);
        $MIOLO = MIOLO::getInstance();
        $module = MIOLO::getCurrentModule();
        
        // FIXME: Rever esta função e verificar impacto.
        $MIOLO->error('Deprecated: File ' . __FILE__ . ', ' . __METHOD__  . ', line ' . __LINE__ . '. Use BusIncentives method instead.');
        
        $this->getDatabase()->execute('BEGIN TRANSACTION');

        $sql = '     SELECT A.incentiveId,
                            A.valueIsPercent,
                            A.value,
                            A.costCenterId,
                            B.operationId,
                            C.description
                       FROM finIncentive A
                 INNER JOIN finIncentiveType B
                      USING (incentiveTypeId)
                 INNER JOIN finOperation C
                      USING (operationId)
                      WHERE incentiveId = ? ';

        $args          = array($data->incentiveId);
        $incentiveData = $this->getDatabase()->query(SAGU::prepare($sql, $args));

        if ( !is_array($incentiveData[0]) )
        {
            throw new Exception(_M('Não foram encontradas informações relativas a incentivos', $module));
        }

        $incentiveData = $incentiveData[0];

        // Obtain incomeForecast date period
        $sql = ' SELECT TO_CHAR(beginDate, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                        TO_CHAR(endDate, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
                   FROM acdLearningPeriod
                  WHERE learningPeriodId = ? ';

        $args               = array($data->learningPeriodId);
        $learningPeriodData = $this->getDatabase()->query(SAGU::prepare($sql, $args));

        if ( !is_array($learningPeriodData[0]) )
        {
            throw new Exception(_M('Desculpe, não é um período válido', $module));
        }

        $businessDefaultOperations = new BusinessFinanceBusDefaultOperations();
        $defaultOperations         = $businessDefaultOperations->getDefaultOperations();
        $operationsToFilter        = array($defaultOperations->enrollOperation,
                                           $defaultOperations->addCurricularComponentOperation,
                                           $defaultOperations->cancelCurricularComponentOperation);

        if ( SAGU::getParameter('FINANCE', 'CURRICULAR_COMPONENT_DISCOUNT') )
        {
            $ccd = explode(',', SAGU::getParameter('FINANCE', 'CURRICULAR_COMPONENT_DISCOUNT'));
            $operationsToFilter = array_unique(array_merge($operationsToFilter, $ccd));
        }

        // Obtain the income forecasts relative for that contract and the
        // specific learningPeriod
        $learningPeriodData = $learningPeriodData[0];
        $sql = '     SELECT TO_CHAR(maturityDate, \'mm\') as month,
                            TO_CHAR(maturityDate, \'yyyy\') as year,
                            accountSchemeId,
                            costCenterId,
                            sum(CASE WHEN B.operationTypeId = \'D\'
                                     THEN A.value
                                     ELSE A.value*-1
                                 END) as balance,
                            TO_CHAR(maturityDate, \'dd\') as day
                       FROM finIncomeForecast A
                 INNER JOIN finOperation B
                      USING (operationId)
                      WHERE A.maturityDate
                    BETWEEN TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
                        AND TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
                        AND A.contractId = ?
                        AND A.operationId IN (' . implode(',', $operationsToFilter) . ')
                   GROUP BY 1,
                            2,
                            3,
                            4,
                            6
                   ORDER BY 2,
                            1 ';

        $args = array($learningPeriodData[0],
                      $learningPeriodData[1],
                      $data->contractId);

        // Obtain the balance relative to enroll operations and institution discounts
        // to apply the discount
        $incomeForecastData = $this->getDatabase()->query(SAGU::prepare($sql, $args));

        if ( ! is_array($incomeForecastData[0]) )
        {
            throw new Exception(_M('Não há previsões de lançamento a processar', $module));
        }
        // Get the maturityDay from contract
        $sql = ' SELECT maturityDay
                   FROM acdContract
                  WHERE contractId = ? ';

        $args         = array($data->contractId);
        $contractData = $this->getDatabase()->query(SAGU::prepare($sql, $args));

        if ( is_array($contractData[0]) )
        {
            if ( !strlen($contractData[0][0]) > 0 )
            {
                throw new Exception(_M('A data de vencimento precisa ser preenchida para o contrato @1', $module, $data->contractId));
            }

            $maturityDay = $contractData[0][0];
            $keepGoing = false;
        }

        $periodData[0] = date('m');
        $periodData[1] = date('Y');
        $periodData[2] = date('d');
        $toProcess = false;

        // For each income forecast verify the period getting an analysis
        // about maturity period, if maturity period is before
        // the actual date then process the income forecast
        // else ignore it.
        foreach ( $incomeForecastData as $icd )
        {
            // Verify if the incentive has value or percentage
            // calculation mode
            // TRUE -> Percentage
            if ( $incentiveData[1] == DB_TRUE )
            {
                $value = SAGU::CalcNumber($icd[4] . '*(' . $incentiveData[2] . '/100)');
            }
            // FALSE -> Full value
            else
            {
                $value = SAGU::formatNumber(SAGU::calcNumber($incentiveData[2] . '/' . SAGU::formatNumber(sizeof($incomeForecastData))));

                if ( SAGU::calcNumber($incentiveData[2] . '-' . $value) < 0 )
                {
                    $incomeForecast->warning = _M('O valor do incentivo é maior do que o saldo de matrícula', $module);
                    $value = SAGU::formatNumber($value);
                }
            }

            $incomeForecast->contractId      = $data->contractId;
            $incomeForecast->operationId     = $incentiveData[4];
            $incomeForecast->accountSchemeId = $icd[2];
            $incomeForecast->costCenterId    = strlen($incentiveData[3]) > 0 ? $incentiveData[3] : $icd[3];
            $incomeForecast->value           = $value;
            $incomeForecast->comments        = defined('MESSAGE_TO_INCENTIVE_PROCESS_IN_INCOME_FORECAST') ? MESSAGE_TO_INCENTIVE_PROCESS_IN_INCOME_FORECAST : '';
            $maturityDate                    = SAGU::toDefaultDate($maturityDay . '/' . $icd[0] . '/' . $icd[1], 'dd/mm/yyyy');

            while ( (int)SAGU::formatDate($maturityDate, 'mm') != (int)$icd[0] )
            {
                $maturityDate = SAGU::addIntervalInDate($maturityDate, 'd', '1', '-');
            }

            $incomeForecast->maturityDate         = $maturityDate;
            $incomeForecast->isProcessed          = DB_FALSE;
            $incomeForecast->isGenerated          = DB_FALSE;
            $incomeForecast->operationDescription = $incentiveData[5];

            if ( $icd[1] == $periodData[1] )
            {
                if ( $icd[0] > $periodData[0] )
                {
                    $incomeForecasts[] = clone ($incomeForecast);
                    unset($incomeForecast);

                }
                elseif ( $icd[0] == $periodData[0] )
                {
                    if ( $icd[5] > $periodData[2] )
                    {
                        $incomeForecasts[] = clone ($incomeForecast);
                        unset($incomeForecast);
                    }
                    else
                    {
                        $incomeForecast->reason = _M('Data atual alcançou a data de vencimento', $module);
                        $nincomeForecasts[] = clone ($incomeForecast);
                        unset($incomeForecast);
                    }
                }
                else
                {
                    $incomeForecast->reason = _M('Período contabilizado', $module);
                    $nincomeForecasts[] = clone ($incomeForecast);
                    unset($incomeForecast);
                }
            }
            elseif ( $icd[1] > $periodData[1] )
            {
                $incomeForecasts[] = clone ($incomeForecast);
                unset($incomeForecast);
            }
        }

        if ( !is_array($incomeForecasts) )
        {
            throw new Exception(_M('Não há previsões de lançamento a processar', $module));
        }

        $keepGoing = true;

        foreach ( $incomeForecasts as $key => $ic )
        {
            $incomeForecastId = $this->insertIncomeForecast($ic);

            if ( $incomeForecastId !== false )
            {
                $incomeForecasts[$key]->incomeForecastId = $incomeForecastId;
            }

            $this->getDatabase()->execute(($keepGoing === true) ? 'COMMIT' : 'ROLLBACK');

            // Income forecasts procssed
            if ( is_array($incomeForecasts) )
            {
                foreach ( $incomeForecasts as $key => $ic )
                {
                    $processed[$key] = array($ic->incomeForecastId,
                                             $ic->costCenterId,
                                             $ic->operationId . ' - ' . $ic->operationDescription,
                                             $ic->maturityDate,
                                             SAGU::formatNumber($ic->value));

                }

                $statisticsData->processed = $processed;
            }

            // Income forecasts not processed to show in tableraw
            if ( is_array($nincomeForecasts) )
            {
                foreach ( $nincomeForecasts as $key => $ic )
                {
                    $nprocessed[$key] = array($ic->incomeForecastId,
                                              $ic->costCenterId,
                                              $ic->operationId . ' - ' . $ic->operationDescription,
                                              $ic->maturityDate,
                                              SAGU::formatNumber($ic->value), $ic->reason);

                }

                $statisticsData->notProcessed = $nprocessed;
            }

            $statisticsData->status = $keepGoing;

            return $statisticsData;
        }
    }
    
    /**
     * Get all maturity existing maturity dates within the specified learning period and for the specified contract.
     *  
     * @param $contractId
     * @param $learningPeriodId
     * 
     * @return (array) Array containing all existing maturity dates for the specified period.
     */
    public function getMaturityDates($contractId, $learningPeriodId)
    {
        // Second column (maturityDate) is necessary to sort results correctly
        $sql = 'SELECT DISTINCT TO_CHAR(maturityDate,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                       maturityDate
                  FROM finIncomeForecast
                 WHERE contractId = ?
                   AND learningPeriodId = ?
              ORDER BY maturityDate';

        $args = array($contractId, $learningPeriodId);
        
        $result = $this->getDatabase()->query(SAGU::prepare($sql, $args));
        
        $maturityDates = array();
        for ( $i=0; $i<count($result); $i++ )
        {
            $maturityDates[] = $result[$i][0];
        }

        return $maturityDates;
    }

    /**
     * Get all income forecasts for the specified contractId, grouped by operation id..
     * 
     * @param (integer) $contractId Contract id whose income forecasts will be calculated. 
     * @param (array) $operationIds Array containing the operation ids which will be returned.
     * @param (boolean) $unprocessedOnly TRUE means only unprocessed income forecasts will be considered. FALSE will consider all income forecasts. 
     */
    public function getParcelsByOperation($contractId, $operationIds, $unprocessedOnly = true)
    {
        if ( ! is_array($operationIds) )
        {
            $operationIds = array($operationIds);
        }
        
        $sql = 'SELECT TO_CHAR(maturityDate,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                       maturityDate,
                       accountSchemeId,
                       costCenterId,
                       learningPeriodId,
                       SUM(value)
                  FROM finIncomeForecast
                 WHERE contractId = ?
                   AND operationId IN (';
        
        $args = array();
        $args[] = $contractId;
        for ( $i=0; $i<count($operationIds); $i++ )
        {
            $sql .= '?,';
            $args[] = $operationIds[$i];
        }
        $sql = substr($sql, 0, strlen($sql)-1) . ')';
        
        if ( $unprocessedOnly )
        {
            $sql .= ' AND isProcessed = FALSE';
        }
        
        $sql .= ' GROUP BY 1, 2, 3, 4, 5
                  ORDER BY maturityDate';
        
        $result = $this->getDatabase()->query(SAGU::prepare($sql, $args));
        
        return $result;
    }
    
    /**
     * Function to get the incomes forecasts by the invoice id
     * @param integer $invoiceId - Id of the Invoice
     * @param integer $operationId - Id of the operation
     */
    public function getIncomeForecastByInvoice($invoiceId, $operationId)
    {
        $sql = '    SELECT A.incomeForecastId,
                           C.personId,
                           getPersonName(C.personId),
                           A.contractId,
                           C.courseId,
                           C.courseVersion,
                           G.name,
                           A.operationId,
                           D.description,
                           A.accountSchemeId,
                           E.description,
                           A.costCenterId,
                           F.description,
                           A.value,
                           A.comments,
                           TO_CHAR(A.recordDate,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                           TO_CHAR(A.maturityDate,\'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'),
                           A.isAccounted,
                           A.isProcessed,
                           A.isSupressed,
                           A.userName,
                           TO_CHAR(A.dateTime,\'' . SAGU::getParameter('BASIC', 'MASK_TIMESTAMP') . '\'),
                           A.learningPeriodId,
                           A.invoiceid
                      FROM finIncomeForecast A
                INNER JOIN acdContract C
                        ON C.contractId = A.contractId
                INNER JOIN finOperation D
                        ON D.operationId = A.operationId
                INNER JOIN accAccountScheme E
                        ON E.accountSchemeId = A.accountSchemeId
                INNER JOIN accCostCenter F
                        ON F.costCenterId = A.costCenterId
                INNER JOIN acdCourse G
                        ON G.courseId = C.courseId
                     WHERE A.incomeForecastId = ?';
        
        $args[] = $invoiceId;
        
        if ( $operationId )
        {
            $sql .= ' AND A.operationid = ?';
            $args[] = $operationId;
        }
        $result = $this->getDatabase()->query(SAGU::prepare($sql, $args));

        if (is_array($result))
        {
            foreach ($result as $lineResult)
            {
                $incomeForecast = new FinIncomeForecast();
                list ( $incomeForecast->incomeForecastId,
                       $incomeForecast->contractPersonId,
                       $incomeForecast->contractPersonName,
                       $incomeForecast->contractId,
                       $incomeForecast->contractCourseId,
                       $incomeForecast->contractCourseVersion,
                       $incomeForecast->contractCourseName,
                       $incomeForecast->operationId,
                       $incomeForecast->operationDescription,
                       $incomeForecast->accountSchemeId,
                       $incomeForecast->accountSchemeDescription,
                       $incomeForecast->costCenterId,
                       $incomeForecast->costCenterDescription,
                       $incomeForecast->value,
                       $incomeForecast->comments,
                       $incomeForecast->recordDate,
                       $incomeForecast->maturityDate,
                       $incomeForecast->isAccounted,
                       $incomeForecast->isProcessed,
                       $incomeForecast->isSupressed,
                       $incomeForecast->userName,
                       $incomeForecast->dateTime,
                       $incomeForecast->learningPeriodId,
                       $incomeForecast->invoiceid ) = $lineResult;
                       
                       $return[] = $incomeForecast;
            }
        }
        return $return;
    }
}

?>
