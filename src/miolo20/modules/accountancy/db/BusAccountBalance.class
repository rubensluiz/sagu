<?php
/**
 * <--- Copyright 2005-2010 de Solis - Cooperativa de Soluções Livres Ltda.
 * 
 * Este arquivo é parte do programa Sagu.
 * 
 * O Sagu é um software livre; você pode redistribuí-lo e/ou modificá-lo
 * dentro dos termos da Licença Pública Geral GNU como publicada pela Fundação
 * do Software Livre (FSF); na versão 2 da Licença.
 * 
 * Este programa é distribuído na esperança que possa ser útil, mas SEM
 * NENHUMA GARANTIA; sem uma garantia implícita de ADEQUAÇÃO a qualquer MERCADO
 * ou APLICAÇÃO EM PARTICULAR. Veja a Licença Pública Geral GNU/GPL em
 * português para maiores detalhes.
 * 
 * Você deve ter recebido uma cópia da Licença Pública Geral GNU, sob o título
 * "LICENCA.txt", junto com este programa, se não, acesse o Portal do Software
 * Público Brasileiro no endereço www.softwarepublico.gov.br ou escreva para a
 * Fundação do Software Livre (FSF) Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA --->
 * 
 *
 * This file handles the connection and actions for accAccountBalance table
 *
 * @author Daniel Afonso Heisler [daniel@solis.coop.br]
 *
 * $version: $Id$
 *
 * \b Maintainers \n
 * Armando Taffarel Neto [taffarel@solis.coopb.br]
 * Alexandre Heitor Schmidt [alexsmith@solis.coop.br]
 * Daniel Afonso Heisler [daniel@solis.coop.br]
 * Jamiel Spezia [jamiel@solis.coop.br]
 * Samuel Koch [samuel@solis.coop.br] 
 * William Prigol Lopes [william@solis.coop.br]
 * 
 * @since
 * Class created on 25/06/2006
 *
 **/

/**
 * Class to manipulate the accAccountBalance table
 **/
class BusinessAccountancyBusAccountBalance extends sBusiness
{
    /**
     * Get the last top date from accAccountBalance
     *
     * @param: None
     *
     * @returns (array): Return an array with the years
     *
     **/
    public function getLastDate()
    {
        $MIOLO    = MIOLO::getInstance();
        $module   = MIOLO::getCurrentModule();
        $action   = MIOLO::getCurrentAction();

        $sql = 'SELECT TO_CHAR((max(balanceDate) + 1)::date, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
                  FROM accAccountBalance';

        $result = $this->getDatabase()->query(SAGU::prepare($sql, null));

        return $result[0][0];
    }

    /**
     * List all distinct top dates from accAccountBalance
     *
     * @param: None
     *
     * @returns (array): Return an array with the years
     *
     **/
    public function getTopDates()
    {
        $MIOLO    = MIOLO::getInstance();
        $module   = MIOLO::getCurrentModule();
        $action   = MIOLO::getCurrentAction();

        $sql = 'SELECT DISTINCT balanceDate,
                                TO_CHAR(balanceDate, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
                           FROM accAccountBalance
                       ORDER BY balanceDate ASC';

        $result = $this->getDatabase()->query(SAGU::prepare($sql, null));

        return $result;
    }

    /**
     * List all distinct top dates from accAccountBalance from one date
     *
     * @param: balanceDate(date): filtered top date
     * @param: type(text): stored balance type: forecast, entry or all
     *
     * @returns (array): Return an array with respective data
     *
     **/
    public function getStoredBalance($balanceDate, $type=null)
    {
        $MIOLO    = MIOLO::getInstance();
        $module   = MIOLO::getCurrentModule();
        $action   = MIOLO::getCurrentAction();

        if ( strtoupper($type) == 'FORECAST' )
        {
            $par = ' AND A.source = \'P\' ';
        }
        elseif ( strtoupper($type) == 'ENTRY' )
        {
            $par = ' AND A.source = \'L\' ';
        }

        $sql = 'SELECT A.accountSchemeId,
                       A.courseId, 
                       getCourseName(A.courseId) as courseName, 
                       A.unitId,
                       A.source, 
                       C.description,
                       round(A.value,' . SAGU::getParameter('BASIC', 'REAL_ROUND_VALUE') . ')
                  FROM accCourseBalance A
             LEFT JOIN accAccountBalance D
                    ON (     A.accountSchemeId = D.accountSchemeId 
                         AND A.source          = D.source
                         AND A.balanceDate     = D.balanceDate )
             LEFT JOIN accCourseAccount B
                    ON (     A.courseId      = B.courseId
                         AND A.courseVersion = B.courseVersion
                         AND A.unitId        = B.unitId )
            INNER JOIN accAccountScheme C
                    ON ( A.accountSchemeId = C.accountSchemeId )
                 WHERE A.balanceDate = TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')' . $par . '
              ORDER BY A.accountSchemeId,
                       A.courseId';

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $balanceDate));

        return $result;
    }

    /**
     * List all distinct top dates from accAccountBalance
     *
     * @param: balanceDate(date): filtered top date
     * @param: type(text): stored balance type: forecast, entry or all
     *
     * @returns (array): Return an array with respective data
     *
     **/
    public function getAllStoredBalance($balanceDate, $type=null)
    {
        $MIOLO    = MIOLO::getInstance();
        $module   = MIOLO::getCurrentModule();
        $action   = MIOLO::getCurrentAction();

        if ( strtoupper($type) == 'FORECAST' )
        {
            $par = ' AND A.source = \'P\' ';
        }
        elseif ( strtoupper($type) == 'ENTRY' )
        {
            $par = ' AND A.source = \'L\' ';
        }

        $sql = 'SELECT A.accountSchemeId,
                       A.courseId, 
                       getCourseName(A.courseId) as courseName, 
                       A.unitId,
                       A.source, 
                       C.description,
                       round(sum(A.value),' . SAGU::getParameter('BASIC', 'REAL_ROUND_VALUE') . ')
                  FROM accCourseBalance A
             LEFT JOIN accAccountBalance D
                    ON (     A.accountSchemeId = D.accountSchemeId 
                         AND A.source          = D.source
                         AND A.balanceDate     = D.balanceDate )
             LEFT JOIN accCourseAccount B
                    ON (     A.courseId      = B.courseId
                         AND A.courseVersion = B.courseVersion
                         AND A.unitId        = B.unitId )
            INNER JOIN accAccountScheme C
                    ON ( A.accountSchemeId = C.accountSchemeId )
                 WHERE A.balanceDate <= TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')' . $par . '
                   AND A.value <> 0
              GROUP BY A.accountSchemeId,
                       A.courseId, 
                       courseName, 
                       A.unitId,
                       A.source, 
                       C.description
                HAVING sum(A.value) <> 0
              ORDER BY A.accountSchemeId,
                       A.courseId';

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $balanceDate));

        return $result;
    }

    /**
     * List all distinct top dates from accAccountBalance from onde date
     *
     * @param: balanceDate(date): filtered top date
     * @param: balanceDate(date): filtered account scheme code
     * @param: type(text): stored balance type: forecast, entry or all
     *
     * @returns (array): Return an array with the data
     *
     **/
    public function getAccountStoredBalance($balanceDate, $accountSchemeId=null, $type=null)
    {
        $MIOLO    = MIOLO::getInstance();
        $module   = MIOLO::getCurrentModule();
        $action   = MIOLO::getCurrentAction();

        if ( strtoupper($type) == 'FORECAST' )
        {
            $par = ' AND source = \'P\' ';
        }
        elseif ( strtoupper($type) == 'ENTRY' )
        {
            $par = ' AND source = \'L\' ';
        }

        if ( is_null($accountSchemeId) )
        {
            $sql = 'SELECT round(sum(value),' . SAGU::getParameter('BASIC', 'REAL_ROUND_VALUE') . ')
                      FROM accAccountBalance
                     WHERE balanceDate = TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')' . $par;
            $args   = array($balanceDate);
        }
        else
        {
            $sql = 'SELECT round(sum(value),' . SAGU::getParameter('BASIC', 'REAL_ROUND_VALUE') . ')
                      FROM accAccountBalance
                     WHERE balanceDate = TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
                       AND accountSchemeId = ?' . $par;
            $args   = array($balanceDate, $accountSchemeId);
        }

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $args));

        $result = $result[0][0];

        return $result;
    }

    /**
     * List all distinct top dates from accAccountBalance
     *
     * @param: balanceDate(date): filtered top date
     * @param: accountSchemeId(text): filtered account scheme code
     * @param: type(text): stored balance type: forecast, entry or all
     *
     * @returns (array): Return an array with the data
     *
     **/
    public function getAllAccountStoredBalance($balanceDate, $accountSchemeId=null, $type=null)
    {
        $MIOLO    = MIOLO::getInstance();
        $module   = MIOLO::getCurrentModule();
        $action   = MIOLO::getCurrentAction();

        if ( strtoupper($type) == 'FORECAST' )
        {
            $par = ' AND source = \'P\' ';
        }
        elseif ( strtoupper($type) == 'ENTRY' )
        {
            $par = ' AND source = \'L\' ';
        }

        if ( is_null($accountSchemeId) )
        {
            $sql = 'SELECT round(sum(value),' . SAGU::getParameter('BASIC', 'REAL_ROUND_VALUE') . ')
                      FROM accAccountBalance
                     WHERE balanceDate <= TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')' . $par;
            $args   = array($balanceDate);
        }
        else
        {
            $sql = 'SELECT round(sum(value),' . SAGU::getParameter('BASIC', 'REAL_ROUND_VALUE') . ')
                      FROM accAccountBalance
                     WHERE balanceDate <= TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
                       AND accountSchemeId = ?' . $par;
            $args   = array($balanceDate, $accountSchemeId);
        }

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $args));

        $result = $result[0][0];

        return $result;
    }

    /**
     * List all values from accountbalance + forecasts
     *
     * @param: initialDate(date): Begin date
     * @param: limitDate(date): End date
     *
     * @returns (array): Return an array with respective data
     *
     **/
    public function getForecasts($initialDate, $limitDate)
    {
        $MIOLO    = MIOLO::getInstance();
        $module   = MIOLO::getCurrentModule();
        $action   = MIOLO::getCurrentAction();

        $sql = 'SELECT A.accountSchemeId,
                       A.courseId, 
                       getCourseName(A.courseId) as courseName, 
                       A.unitId,
                       A.source || \'_\',
                       C.description,
                       round(sum(A.value),' . SAGU::getParameter('BASIC', 'REAL_ROUND_VALUE') . ')
                  FROM accCourseBalance A
             LEFT JOIN accAccountBalance D
                    ON (     A.accountSchemeId = D.accountSchemeId 
                         AND A.source          = D.source
                         AND A.balanceDate     = D.balanceDate )
             LEFT JOIN accCourseAccount B
                    ON (     A.courseId      = B.courseId
                         AND A.courseVersion = B.courseVersion
                         AND A.unitId        = B.unitId )
            INNER JOIN accAccountScheme C
                    ON ( A.accountSchemeId = C.accountSchemeId )
                 WHERE A.balanceDate < TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
                   AND A.source = \'P\'
                   AND A.value <> 0
              GROUP BY A.accountSchemeId,
                       A.courseId, 
                       courseName, 
                       A.unitId,
                       A.source, 
                       C.description
                HAVING sum(A.value) <> 0
                 UNION
                SELECT A.accountSchemeId,
                       getContractCourseId(A.contractId) as courseId,
                       getCourseName(getContractCourseId(A.contractId)) as courseName, 
                       getContractUnitId(A.contractId) as unitId,
                       \'P\' as source,
                       C.description,
                       round(SUM( CASE WHEN B1.operationTypeId = \'D\' THEN ( 1 * A.value ) 
                                 WHEN B1.operationTypeId = \'C\' THEN ( -1 * A.value ) END ),' . SAGU::getParameter('BASIC', 'REAL_ROUND_VALUE') . ') as value
                  FROM finIncomeForecast A
            INNER JOIN finOperation B1
                    ON ( A.operationId = B1.operationId )
            INNER JOIN accAccountScheme C
                    ON ( A.accountSchemeId = C.accountSchemeId )
                 WHERE length(trim(getContractCourseId(A.contractId))) > 0
                   AND A.recordDate IS NOT NULL
                   AND A.recordDate >= TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
                   AND A.recordDate <= TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
              GROUP BY A.accountSchemeId,
                       getContractCourseId(A.contractId),
                       courseName, 
                       getContractUnitId(A.contractId),
                       source,
                       C.description
                HAVING sum(A.value) <> 0
              ORDER BY 1';

        $args = array($initialDate, $initialDate, $limitDate);

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $args));

        return $result;
    }


    /**
     * List all values from accountbalance + entries + forecasts
     *
     * @param: initialDate(date): Begin date
     * @param: limitDate(date): End date
     *
     * @returns (array): Return an array with respective data
     *
     **/
    public function getForecastsAndInvoices($initialDate, $limitDate)
    {
        $MIOLO    = MIOLO::getInstance();
        $module   = MIOLO::getCurrentModule();
        $action   = MIOLO::getCurrentAction();

        $sql = 'SELECT A.accountSchemeId,
                       A.courseId, 
                       getCourseName(A.courseId) as courseName, 
                       A.unitId,
                       A.source || \'_\', 
                       C.description,
                       round(sum(A.value),' . SAGU::getParameter('BASIC', 'REAL_ROUND_VALUE') . ')
                  FROM accCourseBalance A
             LEFT JOIN accAccountBalance D
                    ON (     A.accountSchemeId = D.accountSchemeId 
                         AND A.source          = D.source
                         AND A.balanceDate     = D.balanceDate )
             LEFT JOIN accCourseAccount B
                    ON (     A.courseId      = B.courseId
                         AND A.courseVersion = B.courseVersion
                         AND A.unitId        = B.unitId )
            INNER JOIN accAccountScheme C
                    ON ( A.accountSchemeId = C.accountSchemeId )
                 WHERE A.balanceDate < TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
                   AND A.value <> 0
              GROUP BY A.accountSchemeId,
                       A.courseId, 
                       courseName, 
                       A.unitId,
                       A.source, 
                       C.description
                HAVING sum(A.value) <> 0
                 UNION
                SELECT A.accountSchemeId,
                       getContractCourseId(A.contractId) as courseId,
                       getCourseName(getContractCourseId(A.contractId)) as courseName, 
                       getContractUnitId(A.contractId) as unitId,
                       \'P\' as source,
                       C.description,
                       round(SUM( CASE WHEN B1.operationTypeId = \'D\' THEN ( 1 * A.value ) 
                                 WHEN B1.operationTypeId = \'C\' THEN ( -1 * A.value ) END ),' . SAGU::getParameter('BASIC', 'REAL_ROUND_VALUE') . ') as value
                  FROM finIncomeForecast A
            INNER JOIN finOperation B1
                    ON ( A.operationId = B1.operationId )
            INNER JOIN accAccountScheme C
                    ON ( A.accountSchemeId = C.accountSchemeId )
                 WHERE length(trim(getContractCourseId(A.contractId))) > 0
                   AND A.recordDate IS NOT NULL
                   AND A.recordDate >= TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
                   AND A.recordDate <= TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
              GROUP BY A.accountSchemeId,
                       getContractCourseId(A.contractId),
                       courseName, 
                       getContractUnitId(A.contractId),
                       source,
                       C.description
                HAVING sum(A.value) <> 0
                 UNION
                SELECT A.accountSchemeId,
                       A.courseId,
                       getCourseName(A.courseId) as courseName, 
                       A.unitId,
                       \'L\' as source,
                       C.description,
                       round(SUM( CASE WHEN B1.operationTypeId = \'D\' THEN ( 1 * B.value ) 
                                 WHEN B1.operationTypeId = \'C\' THEN ( -1 * B.value ) END ),' . SAGU::getParameter('BASIC', 'REAL_ROUND_VALUE') . ') as value
             FROM ONLY finInvoice A
            INNER JOIN finEntry B
                    ON ( A.invoiceId = B.invoiceId )
            INNER JOIN finOperation B1
                    ON ( B.operationId = B1.operationId )
            INNER JOIN accAccountScheme C
                    ON ( A.accountSchemeId = C.accountSchemeId )
                 WHERE length(trim(A.courseId)) > 0
                   AND B.entryDate >= TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
                   AND B.entryDate <= TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
                   AND A.iscanceled = FALSE
                   AND A.invoiceIdDependence IS NULL
              GROUP BY A.accountSchemeId,
                       A.courseId,
                       courseName, 
                       A.unitId,
                       source,
                       C.description
                HAVING sum(B.value) <> 0
              ORDER BY 1';

        $args = array($initialDate, $initialDate, $limitDate, $initialDate, $limitDate);

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $args));

        return $result;
    }

    /**
     * Get the sum of the values from forecasts and accountancy balances
     *
     * @param: initialDate(date): Begin date
     * @param: limitDate(date): End date
     * @param: accountSchemeId(text): filtered account scheme code
     *
     * @returns (array): Return an array with respective data
     *
     **/
    public function getForecastsBalance($initialDate, $limitDate, $accountSchemeId=null)
    {
        $MIOLO    = MIOLO::getInstance();
        $module   = MIOLO::getCurrentModule();
        $action   = MIOLO::getCurrentAction();

        $args[] = $initialDate;

        $sql = 'SELECT round(sum(value),' . SAGU::getParameter('BASIC', 'REAL_ROUND_VALUE') . ') FROM (
                SELECT sum(A.value) as Value
                  FROM accCourseBalance A
                 WHERE A.balanceDate < TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
                   AND A.source = \'P\' ';

        if ( ! is_null($accountSchemeId) )
        {
            $sql .= ' AND A.accountSchemeId = ? ';
            $args[] = $accountSchemeId;
        }

        $sql .= ' UNION
                SELECT SUM( CASE WHEN B1.operationTypeId = \'D\' THEN ( 1 * A.value ) 
                                 WHEN B1.operationTypeId = \'C\' THEN ( -1 * A.value ) END ) as value
                  FROM finIncomeForecast A
            INNER JOIN finOperation B1
                    ON ( A.operationId = B1.operationId )
            INNER JOIN accAccountScheme C
                    ON ( A.accountSchemeId = C.accountSchemeId )
                 WHERE length(trim(getContractCourseId(A.contractId))) > 0
                   AND A.recordDate IS NOT NULL
                   AND A.recordDate >= TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
                   AND A.recordDate <= TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\') ';

        $args[] = $initialDate;
        $args[] = $limitDate;

        if ( ! is_null($accountSchemeId) )
        {
            $sql .= ' AND A.accountSchemeId = ? ';
            $args[] = $accountSchemeId;
        }

        $sql .= ' ) as X';

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $args));

        return $result[0][0];
    }

    /**
     * Get the sum of the values from forecasts, entries and accountancy balances
     *
     * @param: initialDate(date): Begin date
     * @param: limitDate(date): End date
     * @param: accountSchemeId(text): filtered account scheme code
     *
     * @returns (array): Return an array with respective data
     *
     **/
    public function getForecastsAndInvoicesBalance($initialDate, $limitDate, $accountSchemeId=null)
    {
        $MIOLO    = MIOLO::getInstance();
        $module   = MIOLO::getCurrentModule();
        $action   = MIOLO::getCurrentAction();

        $args[] = $initialDate;

        $sql = 'SELECT round(sum(value),' . SAGU::getParameter('BASIC', 'REAL_ROUND_VALUE') . ') FROM (
                SELECT sum(A.value) as Value
                  FROM accCourseBalance A
                 WHERE A.balanceDate < TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\') ';

        if ( ! is_null($accountSchemeId) )
        {
            $sql .= ' AND A.accountSchemeId = ? ';
            $args[] = $accountSchemeId;
        }

        $sql .= ' UNION
                SELECT SUM( CASE WHEN B1.operationTypeId = \'D\' THEN ( 1 * A.value ) 
                                 WHEN B1.operationTypeId = \'C\' THEN ( -1 * A.value ) END ) as value
                  FROM finIncomeForecast A
            INNER JOIN finOperation B1
                    ON ( A.operationId = B1.operationId )
            INNER JOIN accAccountScheme C
                    ON ( A.accountSchemeId = C.accountSchemeId )
                 WHERE length(trim(getContractCourseId(A.contractId))) > 0
                   AND A.recordDate IS NOT NULL
                   AND A.recordDate >= TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
                   AND A.recordDate <= TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\') ';

        $args[] = $initialDate;
        $args[] = $limitDate;

        if ( ! is_null($accountSchemeId) )
        {
            $sql .= ' AND A.accountSchemeId = ? ';
            $args[] = $accountSchemeId;
        }

        $sql .= ' UNION
                SELECT SUM( CASE WHEN B1.operationTypeId = \'D\' THEN ( 1 * B.value ) 
                                 WHEN B1.operationTypeId = \'C\' THEN ( -1 * B.value ) END ) as value
             FROM ONLY finInvoice A
            INNER JOIN finEntry B
                    ON ( A.invoiceId = B.invoiceId )
            INNER JOIN finOperation B1
                    ON ( B.operationId = B1.operationId )
            INNER JOIN accAccountScheme C
                    ON ( A.accountSchemeId = C.accountSchemeId )
                 WHERE length(trim(A.courseId)) > 0
                   AND B.entryDate >= TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
                   AND B.entryDate <= TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
                   AND A.iscanceled = FALSE
                   AND A.invoiceIdDependence IS NULL';

        $args[] = $initialDate;
        $args[] = $limitDate;

        if ( ! is_null($accountSchemeId) )
        {
            $sql .= ' AND A.accountSchemeId = ? ';
            $args[] = $accountSchemeId;
        }

        $sql .= ' ) as X';

        $result = $this->getDatabase()->query(SAGU::prepare($sql, $args));

        return $result[0][0];
    }

    /**
     * Process to generate accountancy balances
     *
     * @param: initialDate(date): Begin date
     * @param: limitDate(date): End date
     *
     * @returns (bool): True if generate with success otherwise false
     *
     **/
    public function generateAccountancyBalance($initialDate, $limitDate)
    {
        $MIOLO    = MIOLO::getInstance();
        $module   = MIOLO::getCurrentModule();
        $action   = MIOLO::getCurrentAction();

        $this->beginTransaction();

        $balanceDate = $limitDate;

        //cria a tabela temporaria
        $sql = 'CREATE TEMP TABLE tmpBalance (
                                  accountSchemeId VARCHAR(30) NOT NULL,
                                  source CHAR(1),
                                  value NUMERIC(14,4),
                                  courseId VARCHAR(10),
                                  courseVersion INTEGER,
                                  unitId INTEGER,
                                  personId INTEGER )';

        $this->getDatabase()->execute($sql);

        //insere lancamentos
        $sql = 'INSERT INTO tmpBalance ( accountSchemeId, source, value, courseId, courseVersion, unitId, personId )
                SELECT A.accountSchemeId,
                       \'L\' as source,
                       SUM( CASE WHEN B1.operationTypeId = \'D\' THEN ( 1 * B.value ) 
                                 WHEN B1.operationTypeId = \'C\' THEN ( -1 * B.value ) 
END ) as value,
                       A.courseId,
                       A.courseVersion,
                       A.unitId,
                       A.personId
             FROM ONLY finInvoice A
            INNER JOIN finEntry B
                    ON ( A.invoiceId = B.invoiceId )
            INNER JOIN finOperation B1
                    ON ( B.operationId = B1.operationId )
                 WHERE length(trim(A.courseId)) > 0
                   AND B.entryDate >= TO_DATE(\'' . $initialDate . '\', \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
                   AND B.entryDate <= TO_DATE(\'' . $limitDate . '\', \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
                   AND A.iscanceled = FALSE
                   AND A.invoiceIdDependence IS NULL
              GROUP BY A.accountSchemeId,
                       source,
                       A.courseId,
                       A.courseVersion,
                       A.unitId,
                       A.personId';

        $this->getDatabase()->execute($sql);

        //insere previsoes
        $sql = 'INSERT INTO tmpBalance ( accountSchemeId, source, value, courseId, courseVersion, unitId, personId )
                SELECT A.accountSchemeId,
                       \'P\' as source,
                       SUM( CASE WHEN B.operationTypeId = \'D\' THEN ( 1 * A.value ) 
                                 WHEN B.operationTypeId = \'C\' THEN ( -1 * A.value ) END ) as value,
                       getContractCourseId(A.contractId),
                       getContractCourseVersion(A.contractId),
                       getContractUnitId(A.contractId),
                       getContractPersonId(A.contractId)
                  FROM finIncomeForecast A
            INNER JOIN finOperation B
                    ON ( A.operationId = B.operationId )
                 WHERE length(trim(getContractCourseId(A.contractId))) > 0
                   AND A.recordDate IS NOT NULL
                   AND A.recordDate >= TO_DATE(\'' . $initialDate . '\', \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
                   AND A.recordDate <= TO_DATE(\'' . $limitDate . '\', \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')
              GROUP BY A.accountSchemeId,
                       source,
                       getContractCourseId(A.contractId),
                       getContractCourseVersion(A.contractId),
                       getContractUnitId(A.contractId),
                       getContractPersonId(A.contractId)';

        $this->getDatabase()->execute($sql);

        //apaga saldos contábeis da data limite
        $sql = 'DELETE FROM accCourseBalance WHERE balanceDate = TO_DATE(\'' . $limitDate . '\', \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')';
        $this->getDatabase()->execute($sql);

        $sql = 'DELETE FROM accAccountBalance WHERE balanceDate = TO_DATE(\'' . $limitDate . '\', \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')';
        $this->getDatabase()->execute($sql);

        $sql = 'DELETE FROM accPersonBalance WHERE balanceDate = TO_DATE(\'' . $limitDate . '\', \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\')';
        $this->getDatabase()->execute($sql);

        $chave = 0;

        //consulta tabela temporária para insercao na accAccountBalance
        $sql = 'SELECT A.accountSchemeId,
                       A.source,
                       SUM(A.value) as value
             FROM ONLY tmpBalance A
                 WHERE A.value <> 0
              GROUP BY A.accountSchemeId,
                       A.source
              ORDER BY A.accountSchemeId';

        $result = $this->getDatabase()->query($sql);

        if ( count($result) > 0 )
        {

            //percorre os saldos a serem inseridos
            foreach ( $result as $row )
            {
                list ( $accountSchemeId,
                       $source,
                       $value ) = $row;

                //insere os saldos totais dos cursos
                $sql = 'INSERT INTO accAccountBalance
                                    (accountSchemeId,
                                     source,
                                     balanceDate,
                                     value)
                              VALUES (?, ?, TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'), ?)';

                $args = array ( $accountSchemeId,
                                $source,
                                $balanceDate,
                                $value );

                $this->getDatabase()->execute(SAGU::PREPARE($sql, $args));
            }
            $chave = 1;
        }

        //consulta tabela temporária para insercao na accCourseBalance
        $sql = 'SELECT A.accountSchemeId,
                       A.source,
                       SUM(A.value) as value,
                       A.courseId,
                       A.courseVersion,
                       A.unitId
             FROM ONLY tmpBalance A
                 WHERE A.value <> 0
              GROUP BY A.accountSchemeId,
                       A.source,
                       A.courseId,
                       A.courseVersion,
                       A.unitId
              ORDER BY A.accountSchemeId';

        $result = $this->getDatabase()->query($sql);

        if ( count($result) > 0 && $chave == 1 )
        {

            //percorre os saldos a serem inseridos
            foreach ( $result as $row )
            {
                list ( $accountSchemeId,
                       $source,
                       $value,
                       $courseId,
                       $courseVersion,
                       $unitId ) = $row;

                //insere dados nos saldos parciais dos cursos
                $sql = 'INSERT INTO accCourseBalance
                                    (accountSchemeId,
                                     source,
                                     balanceDate,
                                     courseId,
                                     courseVersion,
                                     unitId,
                                     value)
                              VALUES (?, ?, TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'), ?, ?, ?, ?)';

                $args = array ( $accountSchemeId,
                                $source,
                                $balanceDate,
                                $courseId,
                                $courseVersion,
                                $unitId,
                                $value );

                $this->getDatabase()->execute(SAGU::PREPARE($sql, $args));
            }
        }

        //consulta tabela temporária para insercao na accPersonBalance
        $sql = 'SELECT A.accountSchemeId,
                       A.source,
                       SUM(A.value) as value,
                       A.courseId,
                       A.courseVersion,
                       A.unitId,
                       A.personId
             FROM ONLY tmpBalance A
                 WHERE A.value <> 0
              GROUP BY A.accountSchemeId,
                       A.source,
                       A.courseId,
                       A.courseVersion,
                       A.unitId,
                       A.personId
              ORDER BY A.accountSchemeId';

        $result = $this->getDatabase()->query($sql);

        if ( count($result) > 0 && $chave == 1 )
        {

            //percorre os saldos a serem inseridos
            foreach ( $result as $row )
            {
                list ( $accountSchemeId,
                       $source,
                       $value,
                       $courseId,
                       $courseVersion,
                       $unitId,
                       $personId ) = $row;

                //insere os saldos totais dos alunos
                $sql = 'INSERT INTO accPersonBalance
                                    (accountSchemeId,
                                     personId,
                                     source,
                                     balanceDate,
                                     courseId,
                                     courseVersion,
                                     unitId,
                                     value)
                              VALUES (?, ?, ?, TO_DATE(?, \'' . SAGU::getParameter('BASIC', 'MASK_DATE') . '\'), ?, ?, ?, ?)';

                $args = array ( $accountSchemeId,
                                $personId,
                                $source,
                                $balanceDate,
                                $courseId,
                                $courseVersion,
                                $unitId,
                                $value );

                $this->getDatabase()->execute(SAGU::PREPARE($sql, $args));

            }

        }

        return $this->commit();
    }
}
?>
