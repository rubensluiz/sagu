--
-- PostgreSQL database dump
--

SET statement_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;

--
-- Name: bas; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA bas;


ALTER SCHEMA bas OWNER TO postgres;

--
-- Name: SCHEMA bas; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA bas IS 'BÃ¡sico';


--
-- Name: fin; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA fin;


ALTER SCHEMA fin OWNER TO postgres;

--
-- Name: SCHEMA fin; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA fin IS 'Financeiro';


--
-- Name: hur; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA hur;


ALTER SCHEMA hur OWNER TO postgres;

--
-- Name: SCHEMA hur; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA hur IS 'Recursos humanos';


--
-- Name: ins; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA ins;


ALTER SCHEMA ins OWNER TO postgres;

--
-- Name: SCHEMA ins; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA ins IS 'Institucional';


--
-- Name: res; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA res;


ALTER SCHEMA res OWNER TO postgres;

--
-- Name: SCHEMA res; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA res IS 'ResidÃªncia';


--
-- Name: spr; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA spr;


ALTER SCHEMA spr OWNER TO postgres;

--
-- Name: SCHEMA spr; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA spr IS 'Processo seletivo';


--
-- Name: tra; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA tra;


ALTER SCHEMA tra OWNER TO postgres;

--
-- Name: SCHEMA tra; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA tra IS 'EstÃ¡gio';


--
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


SET search_path = public, pg_catalog;

--
-- Name: academiccalendarreportevt; Type: TYPE; Schema: public; Owner: solis
--

CREATE TYPE academiccalendarreportevt AS (
	datas date[],
	evento text
);


ALTER TYPE public.academiccalendarreportevt OWNER TO solis;

--
-- Name: academiccalendarreporttype; Type: TYPE; Schema: public; Owner: solis
--

CREATE TYPE academiccalendarreporttype AS (
	datas text,
	eventos text
);


ALTER TYPE public.academiccalendarreporttype OWNER TO solis;

--
-- Name: dblink_pkey_results; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE dblink_pkey_results AS (
	"position" integer,
	colname text
);


ALTER TYPE public.dblink_pkey_results OWNER TO postgres;

--
-- Name: getcontractcurrentclasstype; Type: TYPE; Schema: public; Owner: solis
--

CREATE TYPE getcontractcurrentclasstype AS (
	classid character varying,
	name text,
	contractid integer,
	begindate date
);


ALTER TYPE public.getcontractcurrentclasstype OWNER TO solis;

--
-- Name: getcourseaccounttype; Type: TYPE; Schema: public; Owner: solis
--

CREATE TYPE getcourseaccounttype AS (
	courseid character varying,
	coursversion integer,
	coursename text,
	unitid integer,
	accountschemeid character varying,
	accountschemedescription text,
	costcenterid character varying,
	costcenterdescription text
);


ALTER TYPE public.getcourseaccounttype OWNER TO solis;

--
-- Name: getcurriculumnumberhours; Type: TYPE; Schema: public; Owner: solis
--

CREATE TYPE getcurriculumnumberhours AS (
	academicnumberhours double precision,
	practicalnumberhours double precision,
	theoreticalnumberhours double precision
);


ALTER TYPE public.getcurriculumnumberhours OWNER TO solis;

--
-- Name: lo; Type: DOMAIN; Schema: public; Owner: postgres
--

CREATE DOMAIN lo AS oid;


ALTER DOMAIN public.lo OWNER TO postgres;

--
-- Name: obterprecotype; Type: TYPE; Schema: public; Owner: solis
--

CREATE TYPE obterprecotype AS (
	value double precision,
	startdate date,
	bankaccountid integer,
	parcelsnumber integer,
	fixedvalue double precision,
	maturityday integer,
	firstparcelatsight boolean,
	firstparcelatsightfreshman boolean,
	valueisfixed boolean,
	valorcreditoferias double precision,
	parceltype character(1)
);


ALTER TYPE public.obterprecotype OWNER TO solis;

--
-- Name: t_professortimesheet; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE t_professortimesheet AS (
	professorid integer,
	courseid character varying,
	courseversion integer,
	unitid integer,
	turnid integer,
	queryyear integer,
	querymonth integer,
	availableprogrammedhours double precision,
	availablerealizedhours double precision,
	programmedteachhours double precision,
	realizedteachhours double precision,
	programmedpreparationhours double precision,
	realizedpreparationhours double precision,
	directionhours double precision,
	internalexternalactivitiesprogrammedhours double precision,
	internalexternalactivitiesrelizedhours double precision,
	totalprogrammedhours double precision,
	totalrealizedhours double precision
);


ALTER TYPE public.t_professortimesheet OWNER TO postgres;

--
-- Name: type_bibliography_data; Type: TYPE; Schema: public; Owner: solis
--

CREATE TYPE type_bibliography_data AS (
	controlnumber integer,
	fieldid character varying,
	subfieldid character varying,
	content character varying
);


ALTER TYPE public.type_bibliography_data OWNER TO solis;

--
-- Name: type_multa; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE type_multa AS (
	personid bigint,
	loanid integer,
	begindate timestamp without time zone,
	value numeric(10,2),
	observation text,
	waspaid boolean,
	fineid integer,
	operator character varying,
	allowance boolean,
	allowancejustify text,
	enddate timestamp without time zone,
	returnoperator character varying,
	slipthrough boolean
);


ALTER TYPE public.type_multa OWNER TO postgres;

--
-- Name: type_multas_em_aberto; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE type_multas_em_aberto AS (
	codigodamulta integer,
	codigodoemprestimo integer,
	valor numeric(10,2),
	observacao text,
	datahora timestamp without time zone
);


ALTER TYPE public.type_multas_em_aberto OWNER TO postgres;

--
-- Name: type_obter_restricoes; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE type_obter_restricoes AS (
	tipo text,
	quantidade bigint
);


ALTER TYPE public.type_obter_restricoes OWNER TO postgres;

--
-- Name: type_suggestion_material; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE type_suggestion_material AS (
	idperson bigint,
	number integer
);


ALTER TYPE public.type_suggestion_material OWNER TO postgres;

--
-- Name: typedegreeenrollcurrentgrade; Type: TYPE; Schema: public; Owner: solis
--

CREATE TYPE typedegreeenrollcurrentgrade AS (
	nota character varying,
	description text,
	recorddate character varying,
	username character varying
);


ALTER TYPE public.typedegreeenrollcurrentgrade OWNER TO solis;

SET search_path = ins, pg_catalog;

--
-- Name: getmaterialstatus(integer, timestamp without time zone, timestamp without time zone, integer); Type: FUNCTION; Schema: ins; Owner: postgres
--

CREATE FUNCTION getmaterialstatus(p_materialid integer, p_begindate timestamp without time zone, p_enddate timestamp without time zone, p_materialloanidtoignore integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: ins.getMaterialStatus
  PURPOSE: Retorna o status de um material, verificando solicitações, empréstimos e
  retiradas. A função retorna várias strings separadas por <br /> ou NULL, caso não
  haja movimentações ativas para o material selecionado.

  REVISIONS:
  Ver       Date       Author                Description
  --------- ---------- -------------------- ------------------------------------
  1.0       22/07/2011 Alex Smith           1. Função criada.
  1.1       07/12/2011 Moises Heberle       1. Corrigido bug "v_row" has no field "materialLoanId"
**************************************************************************************/
DECLARE
    v_row RECORD;
    v_retVal text[];
    v_timestampMask varchar;
BEGIN
    -- formato de timestamp padrao do sistema
    SELECT A.value || ' ' || B.value INTO v_timestampMask
      FROM basConfig A,
           basConfig B
     WHERE A.moduleConfig = 'BASIC'
       AND A.parameter = 'MASK_DATE'
       AND B.moduleConfig = 'BASIC'
       AND B.parameter = 'MASK_TIME';

    -- verificar status do material (extraviado, disponivel, etc)
    SELECT * INTO v_row
      FROM ins.material
     WHERE materialId = p_materialId;

    v_retVal := NULL;
    IF NOT v_row.isAvailable THEN
        v_retVal := array_append(v_retVal, 'Material indisponível');
    END IF;

    -- verifica se existe alguma solicitacao no mesmo horario
    FOR v_row IN SELECT *
                   FROM ins.materialRequest A
             INNER JOIN ins.material B
                     ON B.materialId = A.materialId
             INNER JOIN ins.materialType C
                     ON C.materialTypeId = B.materialTypeId
                  WHERE A.materialId = p_materialId
                    AND C.availabilityControl
                    AND A.beginDate <= p_endDate
                    AND A.endDate >= p_beginDate
                    AND A.cancelDate IS NULL
                    AND NOT EXISTS (SELECT 1
                                      FROM ins.materialLoan X
                                     WHERE X.materialRequestId = A.materialRequestId
                                       AND COALESCE(X.materialLoanId != p_materialLoanIdToIgnore, TRUE))
    LOOP
        v_retVal := array_append(v_retVal, 'Solicitação ' || v_row.materialRequestId || ' (de ' || TO_CHAR(v_row.beginDate, v_timestampMask) || ' a ' || TO_CHAR(v_row.endDate, v_timestampMask) || ') possui data conflitante.');
    END LOOP;

    -- verifica se existe algum empréstimo no mesmo horario
    FOR v_row IN SELECT *
                   FROM ins.materialLoan A
             INNER JOIN ins.material B
                     ON B.materialId = A.materialId
             INNER JOIN ins.materialType C
                     ON C.materialTypeId = B.materialTypeId
                  WHERE A.materialId = p_materialId
                    AND C.availabilityControl
                    AND A.beginDate <= p_endDate
                    AND A.expectedEndDate >= p_beginDate
                    AND A.cancelDate IS NULL
                    AND A.endDate IS NULL
                    AND COALESCE(A.materialLoanId != p_materialLoanIdToIgnore, TRUE)
    LOOP
        v_retVal := array_append(v_retVal, 'Empréstimo ' || v_row.materialLoanId || ' (de ' || TO_CHAR(v_row.beginDate, v_timestampMask) || ' a ' || TO_CHAR(v_row.expectedEndDate, v_timestampMask) || ') possui data conflitante.');
    END LOOP;

    -- verifica se o material consta como emprestado atualmente
    FOR v_row IN SELECT *
                   FROM ins.materialLoan A
             INNER JOIN ins.material B
                     ON B.materialId = A.materialId
             INNER JOIN ins.materialType C
                     ON C.materialTypeId = B.materialTypeId
                  WHERE A.materialId = p_materialId
                    AND C.availabilityControl
                    AND A.loanDate IS NOT NULL
                    AND A.endDate IS NULL
                    AND COALESCE(A.materialLoanId != p_materialLoanIdToIgnore, TRUE)
    LOOP
        v_retVal := array_append(v_retVal, 'Material consta como retirado no empréstimo ' || v_row.materialLoanId || '. Data prevista de devolução: ' || TO_CHAR(v_row.expectedEndDate, v_timestampMask));
    END LOOP;

    RETURN array_to_string(v_retVal, '<br />');
END;
$$;


ALTER FUNCTION ins.getmaterialstatus(p_materialid integer, p_begindate timestamp without time zone, p_enddate timestamp without time zone, p_materialloanidtoignore integer) OWNER TO postgres;

--
-- Name: getstatusdescription(integer); Type: FUNCTION; Schema: ins; Owner: postgres
--

CREATE FUNCTION getstatusdescription(p_statusid integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: ins.getStatusDescription
  PURPOSE: Retorna a descrição que corresponde ao status passado por parâmetro. O
  status passado por parâmetro pode ser obtido através das funções
  ins.material(Loan|Request)StatusId().

  REVISIONS:
  Ver       Date       Author                Description
  --------- ---------- -------------------- ------------------------------------
  1.0       22/07/2011 Alex Smith           1. Função criada.
**************************************************************************************/
DECLARE
    v_row RECORD;
    v_statusDescription varchar[];
BEGIN
    v_statusDescription = ARRAY[
        'Solicitação efetuada',
        'Solicitação cancelada',
        'Empréstimo agendado',
        'Empréstimo cancelado',
        'Retirada efetuada',
        'Data de devolução expirada',
        'Material devolvido'
    ];

    RETURN v_statusDescription[p_statusId];
END;
$$;


ALTER FUNCTION ins.getstatusdescription(p_statusid integer) OWNER TO postgres;

--
-- Name: materialloanstatusid(integer); Type: FUNCTION; Schema: ins; Owner: postgres
--

CREATE FUNCTION materialloanstatusid(p_materialloanid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: ins.materialLoanStatusId
  PURPOSE: Retorna um inteiro que corresponde a um dos possíveis estados de um
  empréstimo de material.

  REVISIONS:
  Ver       Date       Author                Description
  --------- ---------- -------------------- ------------------------------------
  1.0       22/07/2011 Alex Smith           1. Função criada.
**************************************************************************************/
DECLARE
    v_row RECORD;
    v_statusId integer;
BEGIN
    SELECT A.materialLoanId,
           A.cancelDate AS loanCancelDate,
           A.loanDate,
           A.endDate AS loanEndDate,
           A.expectedEndDate AS loanExpectedEndDate
      INTO v_row
      FROM ins.materialLoan A
     WHERE A.materialLoanId = p_materialLoanId;

    IF v_row.loanEndDate IS NOT NULL THEN
        v_statusId := 7; -- STATUS_LOAN_RETURNED
    ELSIF v_row.loanExpectedEndDate < now() THEN
        v_statusId := 6; -- STATUS_LOAN_EXPIRED
    ELSIF v_row.loanDate IS NOT NULL THEN
        v_statusId := 5; -- STATUS_LOAN_TAKEN
    ELSIF v_row.loanCancelDate IS NOT NULL THEN
        v_statusId := 4; -- STATUS_LOAN_CANCELED
    ELSIF v_row.materialLoanId IS NOT NULL THEN
        v_statusId := 3; -- STATUS_LOAN_SCHEDULED
    ELSE
        v_statusId := NULL;
    END IF;

    RETURN v_statusId;
END;
$$;


ALTER FUNCTION ins.materialloanstatusid(p_materialloanid integer) OWNER TO postgres;

--
-- Name: materialrequeststatusid(integer); Type: FUNCTION; Schema: ins; Owner: postgres
--

CREATE FUNCTION materialrequeststatusid(p_materialrequestid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: ins.materialRequestStatusId
  PURPOSE: Retorna um inteiro que corresponde a um dos possíveis estados de uma
  solicitação de material.

  REVISIONS:
  Ver       Date       Author                Description
  --------- ---------- -------------------- ------------------------------------
  1.0       22/07/2011 Alex Smith           1. Função criada.
**************************************************************************************/
DECLARE
    v_row RECORD;
    v_statusId integer;
BEGIN
    SELECT A.materialRequestId,
           A.cancelDate AS requestCancelDate,
           B.materialLoanId,
           B.cancelDate AS loanCancelDate,
           B.loanDate,
           B.endDate AS loanEndDate,
           B.expectedEndDate AS loanExpectedEndDate
      INTO v_row
      FROM ins.materialRequest A
 LEFT JOIN ins.materialLoan B
        ON B.materialRequestId = A.materialRequestId
     WHERE A.materialRequestId = p_materialRequestId;

    IF v_row.materialLoanId IS NOT NULL THEN
        v_statusId := ins.materialLoanStatusId(v_row.materialLoanId);
    ELSIF v_row.requestCancelDate IS NOT NULL THEN
        v_statusId := 2; -- STATUS_REQUEST_CANCELED
    ELSIF v_row.materialRequestId IS NOT NULL THEN
        v_statusId := 1; -- STATUS_REQUEST_MADE
    ELSE
        v_statusId := NULL;
    END IF;

    RETURN v_statusId;
END;
$$;


ALTER FUNCTION ins.materialrequeststatusid(p_materialrequestid integer) OWNER TO postgres;

SET search_path = public, pg_catalog;

--
-- Name: acd_frequenciasregistradas(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION acd_frequenciasregistradas(p_groupid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE

    v_todasregistradas boolean;
    v_frequencia double precision;

BEGIN

    v_todasregistradas := true;

    FOR v_frequencia IN SELECT frequency FROM acdenroll WHERE groupid = p_groupid LOOP
        IF ( v_frequencia IS NULL ) THEN
            v_todasregistradas := false;
        END IF;
    END LOOP;

    RETURN v_todasregistradas;

END;
$$;


ALTER FUNCTION public.acd_frequenciasregistradas(p_groupid integer) OWNER TO postgres;

--
-- Name: acd_todasnotasregistradas(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION acd_todasnotasregistradas(p_groupid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE

    v_todasregistradas boolean;
    v_notaobrigatoria integer;
    v_valornotaobrigatoria double precision;
    v_learningperiodid integer;

BEGIN

    v_todasregistradas := true;

    SELECT INTO v_learningperiodid learningperiodid FROM acdgroup WHERE groupid = p_groupid;
    FOR v_notaobrigatoria IN SELECT degreeid FROM acddegree WHERE learningperiodid = v_learningperiodId AND maybenull = false AND degreeid NOT IN (SELECT parentdegreeid FROM acddegree WHERE learningperiodid = v_learningperiodId AND parentdegreeid IS NOT NULL) LOOP
    
        SELECT INTO v_valornotaobrigatoria note FROM acddegreeenroll WHERE enrollid IN (SELECT enrollid FROM acdenroll WHERE groupid = p_groupid) AND degreeid = v_notaobrigatoria ORDER BY recorddate DESC LIMIT 1;
        IF ( v_valornotaobrigatoria IS NULL ) THEN
        BEGIN
            v_todasregistradas = false;
        END;
        END IF;
        
    END LOOP;
    
    RETURN v_todasregistradas;

END;
$$;


ALTER FUNCTION public.acd_todasnotasregistradas(p_groupid integer) OWNER TO postgres;

--
-- Name: acddegreecheckfather(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION acddegreecheckfather(p_degreeid integer, p_learningperiodid integer, p_parentdegreeid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    -- Foi feito esta logica devido a condicao abaixo nao funcionar como esperado
    IF p_parentDegreeId IS NULL AND p_degreeId = (SELECT degreeId FROM acdDegree WHERE p_learningPeriodId = learningPeriodId AND p_degreeId = degreeId AND parentDegreeId IS NULL)
    THEN
        RETURN TRUE;
    END IF;

    -- Retorna FALSE para o check quando ja existir um grau pai vazio para o periodo letivo passado.
    RETURN (
        CASE WHEN
            ( p_parentDegreeId IS NULL
            AND 
             (SELECT COUNT(*)
                FROM acdDegree
               WHERE learningPeriodId = p_learningPeriodId
                 AND p_parentDegreeId IS NULL
                 AND p_degreeId != degreeId) > 0 )
        THEN
            FALSE
        ELSE
            TRUE
        END
    );
END;
$$;


ALTER FUNCTION public.acddegreecheckfather(p_degreeid integer, p_learningperiodid integer, p_parentdegreeid integer) OWNER TO postgres;

--
-- Name: acdenroll_detail_update(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION acdenroll_detail_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: acdenroll_detail_update
  PURPOSE: Caso a matrícula não tenha estado detalhado, coloca o estado detalhado padrão.
**************************************************************************************/
DECLARE
    v_enrollid integer;
    v_oldDetailEnrollStatusId integer;
BEGIN
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE'
    THEN
        v_enrollid := NEW.enrollid;
    END IF;

    IF TG_OP = 'INSERT'
    THEN
        v_oldDetailEnrollStatusId := NULL;
    ELSE
        v_oldDetailEnrollStatusId := OLD.detailenrollstatusid;
    END IF;

    -- Atualiza estado detalhado para o padrão da tabela acddetailenrollstatus
    IF  (NEW.detailenrollstatusid IS NULL)
    AND (v_oldDetailEnrollStatusId IS NULL)
    AND ((SELECT detailenrollstatusid FROM acdenroll WHERE enrollid = v_enrollid) is NULL) 
    AND ((SELECT COUNT(*) FROM acddetailenrollstatus WHERE parentstatus = NEW.statusid ) > 0 )
        THEN
        NEW.detailenrollstatusid = (
        SELECT detailenrollstatusid 
        FROM acddetailenrollstatus 
        WHERE defaultstatus = TRUE
        AND parentstatus = NEW.statusid
        );
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION public.acdenroll_detail_update() OWNER TO postgres;

--
-- Name: acdenrollconfig_checkenroll(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION acdenrollconfig_checkenroll() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    _enrollconfigid INTEGER;

BEGIN
    SELECT INTO _enrollconfigid enrollconfigid 
	   FROM acdenrollconfig 
	  WHERE courseid = new.courseid 
	    AND courseversion = new.courseversion 
	    AND turnid=new.turnid 
	    AND unitid=new.unitid 
	    AND ( SELECT ( new.begindate, COALESCE(new.enddate, NOW()::DATE)::DATE) 
	        OVERLAPS ( COALESCE(begindate, '1900-01-01'::DATE)::DATE, COALESCE(enddate, '3000-01-01'::DATE)::DATE ) ) 
	    AND new.enrollconfigid != enrollconfigid;

    IF FOUND THEN
        RAISE EXCEPTION 'Este curso possui uma configuraç?o ativa.';
    END IF;

    IF GETPARAMETER('BASIC', 'ATIVAR_MULTIUNIDADE') <> 't' THEN
        SELECT INTO _enrollconfigid enrollconfigid 
               FROM acdenrollconfig 
	      WHERE courseid IS NULL 
	        AND ( SELECT (new.begindate, COALESCE(new.enddate, NOW()::DATE)::DATE) 
	            OVERLAPS ( COALESCE(begindate, '1900-01-01'::DATE)::DATE, COALESCE(enddate, '3000-01-01'::DATE)::DATE ) ) 
	        AND new.enrollconfigid != enrollconfigid 
                AND new.courseid IS NULL;
    ELSE
        SELECT INTO _enrollconfigid enrollconfigid 
               FROM unit_acdenrollconfig 
	      WHERE courseid IS NULL 
	        AND ( SELECT (new.begindate, COALESCE(new.enddate, NOW()::DATE)::DATE) 
	            OVERLAPS ( COALESCE(begindate, '1900-01-01'::DATE)::DATE, COALESCE(enddate, '3000-01-01'::DATE)::DATE ) ) 
	        AND new.enrollconfigid != enrollconfigid 
                AND new.courseid IS NULL
                AND unitid = obterunidadelogada();
    END IF;

    IF FOUND THEN
        RAISE EXCEPTION 'Já existe uma configuraç?o ativa para este intervalo de datas.';
    END IF;

    RETURN NEW;

END 
$$;


ALTER FUNCTION public.acdenrollconfig_checkenroll() OWNER TO postgres;

--
-- Name: acdschedule_checktimeids(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION acdschedule_checktimeids() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
        timeIds INT[];
        timeRow RECORD;
    BEGIN
        IF NEW.timeIds IS NULL THEN
            RETURN NEW;
        ELSE
            FOR timeRow IN SELECT DISTINCT timeId FROM acdTime WHERE timeId = ANY(NEW.timeIds) LOOP
                timeIds := array_append(timeIds, timeRow.timeId);    
            END LOOP;
            IF (timeIds <@ NEW.timeIds) AND (timeIds @> NEW.timeIds) THEN
                RETURN NEW;
            ELSE
                RAISE EXCEPTION 'You have selected a timeId that doesn''t exists, the insert or update data do not have all values selected in the array';
            END IF;
        END IF;
    END 
$$;


ALTER FUNCTION public.acdschedule_checktimeids() OWNER TO postgres;

--
-- Name: acdtime_checktimeids(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION acdtime_checktimeids() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
        timeIds int[];
        schedules RECORD;
    BEGIN
        IF (TG_OP = 'DELETE') THEN
            FOR schedules IN SELECT scheduleId FROM acdSchedule WHERE OLD.timeId = ANY (acdSchedule.timeIds) LOOP
                RAISE EXCEPTION 'You trying to delete a row that have references to acdSchedule table';
            END LOOP;
			RETURN OLD;
        ELSIF (TG_OP = 'UPDATE') THEN
            IF (OLD.timeId <> NEW.timeId) THEN
                FOR schedules IN SELECT scheduleId FROM acdSchedule WHERE OLD.timeId = ANY (acdSchedule.timeIds) LOOP
                    RAISE EXCEPTION 'You trying to update a row that have references to acdSchedule table';
                END LOOP;
				RETURN NEW;
            ELSE
                   RETURN NEW;
            END IF;
        END IF;
    END
$$;


ALTER FUNCTION public.acdtime_checktimeids() OWNER TO postgres;

--
-- Name: acdunique_course_occurrence(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION acdunique_course_occurrence() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: acdunique_course_occurrence
  PURPOSE: Verifica se tem um contrato com o mesmo personId, courseId, courseVersion,  unitId, turnId e se está fechado.

  REVISIONS:
  Ver       Date       Author               Description
  --------- ---------- -------------------- ------------------------------------
  1.0       23/08/2011 Jonas Gualberto Diel 1. Função criada.
  2.0       08/05/2014 Nataniel I. da Silva 2.Alterada função para permitir alteração/inserção caso o contrato esteja fechado.
**************************************************************************************/
DECLARE
	v_count int;

	--Verifica se o contrato atualizado está fechado
	v_verificaContrato boolean;
BEGIN
	IF TG_OP = 'UPDATE' 
	THEN --Ação de update
		SELECT count(*) INTO v_count
		      FROM acdContract
		     WHERE courseId = NEW.courseId
		       AND courseVersion = NEW.courseVersion
		       AND turnId = NEW.turnId
		       AND unitId = NEW.unitId
		       AND personId = NEW.personId
		       AND contractId != NEW.contractId
		       AND getContractState(contractId) IN (SELECT stateContractId
							      FROM acdStateContract
							     WHERE inOutTransition != 'O');
 
	ELSE
		SELECT count(*) INTO v_count
		      FROM acdContract
		     WHERE courseId = NEW.courseId
		       AND courseVersion = NEW.courseVersion
		       AND turnId = NEW.turnId
		       AND unitId = NEW.unitId
		       AND personId = NEW.personId
		       AND getContractState(contractId) IN (SELECT stateContractId
							      FROM acdStateContract
							     WHERE inOutTransition != 'O');		
	END IF;

	--Verifica se o contrato que está sento atualizado está fechado
	SELECT count(*) > 0 INTO v_verificaContrato 
	  FROM acdcontract
	 WHERE contractid = NEW.contractId
	   AND ( SELECT isclosecontract 
		   FROM acdstatecontract
		  WHERE statecontractid = getContractState(contractId) ) = TRUE;

	IF ( v_count >= 1 ) THEN
	    IF ( v_verificaContrato = FALSE ) THEN
		RAISE EXCEPTION 'A Pessoa % já possui um contrato para o curso %/%, unidade %, turno %.', NEW.personId, NEW.courseId, NEW.courseVersion, NEW.unitId, NEW.turnId;
	    END IF;
	END IF;
 		       
	RETURN NEW;
END;
$$;


ALTER FUNCTION public.acdunique_course_occurrence() OWNER TO postgres;

--
-- Name: acp_gerarocorrenciahorariooferta(integer); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION acp_gerarocorrenciahorariooferta(p_ofertacursoid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: acp_gerarhorariosdaofertadocomponente
  PURPOSE: Gera as ocorrências de aulas dinamicamente para uma oferta de componente curricular

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       10/12/2013 Jonas Diel        1. Função criada.
**************************************************************************************/
DECLARE
    v_horarioofertacomponente RECORD;
    v_ofertacomponentecurricular RECORD;
    v_ofertaturma RECORD;
    v_ofertacurso RECORD;
    v_ocorrenciacurso RECORD;
    v_curso RECORD;
    v_matrizcurricular RECORD;
    v_perfilcurso RECORD;
    v_gradehorario RECORD;
    v_horariosOcorrencias RECORD;
    v_evento RECORD;
    v_datassemaula DATE[];
    v_datainicial DATE;
BEGIN

    SELECT INTO v_ofertacurso * FROM acpofertacurso WHERE ofertacursoid = p_ofertacursoid;
    SELECT INTO v_ocorrenciacurso * FROM acpocorrenciacurso WHERE ocorrenciacursoid = v_ofertacurso.ocorrenciacursoid;
    SELECT INTO v_curso * FROM acpcurso WHERE cursoid = v_ocorrenciacurso.cursoid;
    SELECT INTO v_matrizcurricular * FROM acpmatrizcurricular WHERE cursoid = v_curso.cursoid;
    SELECT INTO v_perfilcurso * FROM acpperfilcurso WHERE perfilcursoid = v_curso.perfilcursoid;
    SELECT INTO v_gradehorario * FROM acpgradehorario WHERE gradehorarioid = v_ofertacurso.gradehorarioid;

    --Carrega datas sem aula segundo calendário acadêmico
    FOR v_evento IN SELECT * FROM acpcalendarioacademicoevento WHERE data BETWEEN v_ofertacurso.datainicialaulas AND v_ofertacurso.datafinalaulas AND ( ocorrenciacursoid IS NULL OR ocorrenciacursoid =  v_ocorrenciacurso.ocorrenciacursoid) AND temaula IS FALSE
    LOOP
        v_datassemaula := ARRAY_APPEND(v_datassemaula,v_evento.data);
    END LOOP;

    --Seta primeira ocorrência de aula como data inicial das aulas da oferta do curso
    v_datainicial := v_ofertacurso.datainicialaulas;

    --Percorre todas ofertas de turma da oferta de curso
    FOR v_ofertaturma IN SELECT * FROM acpofertaturma WHERE ofertacursoid = v_ofertacurso.ofertacursoid
    LOOP
        --Percorre todas ofertas de componentes curriculares da oferta de turma
        FOR v_ofertacomponentecurricular IN SELECT * FROM acpofertacomponentecurricular INNER JOIN acpcomponentecurricular ON acpofertacomponentecurricular.componentecurricularid = acpcomponentecurricular.componentecurricularid WHERE ofertaturmaid = v_ofertaturma.ofertaturmaid ORDER BY acpcomponentecurricular.ordem DESC
        LOOP
            --Forma Sequencial
            IF v_perfilcurso.formacursarcomponentescurriculares = 'S'
            THEN
                FOR v_horariosOcorrencias IN SELECT * FROM acp_obterOcorrenciaSequencial(v_ofertacomponentecurricular.ofertacomponentecurricularid, v_gradehorario.gradehorarioid, v_datainicial, v_datassemaula)
                LOOP
                    INSERT INTO acpOcorrenciaHorarioOferta(horarioofertacomponentecurricularid, dataAula, possuiFrequencia, cancelada, horarioid) VALUES (v_horariosOcorrencias.horarioofertacomponentecurricular, v_horariosOcorrencias.data, false, false, v_horariosOcorrencias.horarioid);
                END LOOP;

                IF v_horariosOcorrencias.data IS NOT NULL
                THEN
                    v_datainicial := v_horariosOcorrencias.data;
                END IF;
                
            ELSE --FIXME Concomitante
                FOR v_horariosOcorrencias IN SELECT * FROM acp_obterOcorrenciaConcomitante(v_ofertacomponentecurricular.ofertacomponentecurricularid, v_gradehorario.gradehorarioid, v_datainicial, v_datassemaula)
                LOOP
                    INSERT INTO acpOcorrenciaHorarioOferta(horarioofertacomponentecurricularid, dataAula, possuiFrequencia, cancelada, horarioid) VALUES (v_horariosOcorrencias.horarioofertacomponentecurricular, v_horariosOcorrencias.data, false, false, v_horariosOcorrencias.horarioid);
                END LOOP;

                IF v_horariosOcorrencias.data IS NOT NULL
                THEN
                    v_datainicial := v_horariosOcorrencias.data;
                END IF;
                
            END IF;
            
        END LOOP;
    END LOOP;
    
    RETURN TRUE;
    
END;
$$;


ALTER FUNCTION public.acp_gerarocorrenciahorariooferta(p_ofertacursoid integer) OWNER TO solis;

--
-- Name: acp_obterocorrenciaconcomitante(integer, integer, date, date[]); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION acp_obterocorrenciaconcomitante(p_ofertacomponentecurricularid integer, p_gradehorarioid integer, p_iniciodasaulas date, p_datassemaula date[]) RETURNS TABLE(data date, horarioid integer, horarioofertacomponentecurricular integer, professorid integer, physicalresourceid integer, physicalresourceversion integer)
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: acp_obterOcorrenciaConcomitante
  PURPOSE: Obtém as ocorrências de aulas para uma forma de cursar Concomitante

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       10/12/2013 Jonas Diel        1. Função criada.
**************************************************************************************/
DECLARE
    v_horarioofertacomponente RECORD;
    v_gradehorario RECORD;
    v_horario RECORD;
    v_numerodeaulas INT;
    v_dias INT;
    v_count INT;
    v_data DATE;
    v_return_data date[];
    v_return_horariooferta int[];
    v_return_horario int[];
    v_return_professor int[];
    v_return_physicalresourceid int[];
    v_return_physicalresourceversion int[];
    v_countaulas INT;
    v_semana INT;
    v_count_horariocomponente INT;
BEGIN
    --Obtém as informações da grade de horário
    SELECT INTO v_gradehorario * FROM acpgradehorario WHERE gradehorarioid = p_gradehorarioid;
    
    --Percorre horario oferta do componente para obter as informações do professor, sala e número de aulas
    v_count_horariocomponente := 0;
    FOR v_horarioofertacomponente IN (SELECT o.numerodeaulas, o.horarioofertacomponentecurricularid, o.personid, o.physicalresourceid, o.physicalresourceversion, h.diasemana, h.horarioid FROM acphorarioofertacomponentecurricular o INNER JOIN acphorario h ON h.horarioid = o.horarioid WHERE o.ofertacomponentecurricularid = p_ofertacomponentecurricularid)
    LOOP
        --Número de aulas
        v_numerodeaulas := v_horarioofertacomponente.numerodeaulas;

        --Conta e percorre o número de aulas da oferta
        v_count := 0;
        v_countaulas := v_numerodeaulas;
        WHILE v_count < v_numerodeaulas LOOP

            --Obtém horario da aula
            SELECT INTO v_horario * FROM acpHorario WHERE acphorario.horarioid = v_horarioofertacomponente.horarioid;
 
               --Define a primeira data de ocorrência como data de inicio das aulas
                IF v_data IS NULL
                THEN
                    v_data := p_iniciodasaulas;
                ELSE
                    --Numero da semana
                    v_semana := EXTRACT('WEEK' FROM v_data);
                END IF;

                IF v_count_horariocomponente = 0 
                THEN
                    --Calcula o numero de dias para proximo horario de aula da grade
                    v_dias := v_horarioofertacomponente.diasemana - EXTRACT('DOW' FROM v_data);
                    IF v_dias < 0 THEN
                        v_dias := v_dias + 7;
                    END IF;
                END IF; 

                --Define a proxima data
                v_data := v_data + v_dias;

                --Se não tem aula adia para próxima ocorrência
                IF( p_datassemaula @> ARRAY[v_data] ) THEN
                    v_countaulas := v_countaulas + 1;
                ELSE
                   v_return_data := ARRAY_APPEND(v_return_data, v_data);
                    v_return_horariooferta := ARRAY_APPEND(v_return_horariooferta, v_horarioofertacomponente.horarioofertacomponentecurricularid);
                    v_return_horario := ARRAY_APPEND(v_return_horario, v_horario.horarioid);
                    v_return_professor := ARRAY_APPEND(v_return_professor, v_horarioofertacomponente.personid);
                    v_return_physicalresourceid := ARRAY_APPEND(v_return_physicalresourceid, v_horarioofertacomponente.physicalresourceid);
                    v_return_physicalresourceversion := ARRAY_APPEND(v_return_physicalresourceversion, v_horarioofertacomponente.physicalresourceversion);
                END IF;
                v_count := v_count +1;

                --Caso a periodicidade for quinzenal pula uma semana
                IF v_gradehorario.periodicidade = 'Q' THEN
                    IF v_semana != EXTRACT('WEEK' FROM v_data)
                    THEN
                        v_data := v_data+7;
                    END IF;
                END IF;

                --Caso atingiu o limite de aulas
                IF v_count >= v_countaulas THEN
                    EXIT;
                END IF;

        END LOOP;
        v_count_horariocomponente := v_count_horariocomponente +1;
    END LOOP;

    RETURN QUERY SELECT UNNEST(v_return_data), UNNEST(v_return_horario), UNNEST(v_return_horariooferta), UNNEST(v_return_professor), UNNEST(v_return_physicalresourceid), UNNEST(v_return_physicalresourceversion) order by 1,2;
END;
$$;


ALTER FUNCTION public.acp_obterocorrenciaconcomitante(p_ofertacomponentecurricularid integer, p_gradehorarioid integer, p_iniciodasaulas date, p_datassemaula date[]) OWNER TO solis;

--
-- Name: acp_obterocorrenciasequencial(integer, integer, date, date[]); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION acp_obterocorrenciasequencial(p_ofertacomponentecurricularid integer, p_gradehorarioid integer, p_iniciodasaulas date, p_datassemaula date[]) RETURNS TABLE(data date, horarioid integer, horarioofertacomponentecurricular integer, professorid integer, physicalresourceid integer, physicalresourceversion integer)
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: acp_obterOcorrenciaSequencial
  PURPOSE: Obtém as ocorrências de aulas para uma forma de cursar Sequencial

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       10/12/2013 Jonas Diel        1. Função criada.
**************************************************************************************/
DECLARE
    v_horarioofertacomponente RECORD;
    v_gradehorario RECORD;
    v_horario RECORD;
    v_numerodeaulas INT;
    v_dias INT;
    v_count INT;
    v_data DATE;
    v_return_data date[];
    v_return_horariooferta int[];
    v_return_horario int[];
    v_return_professor int[];
    v_return_physicalresourceid int[];
    v_return_physicalresourceversion int[];
    v_countaulas INT;
    v_semana INT;
    v_count_horariocomponente INT;
BEGIN
    --Obtém as informações da grade de horário
    SELECT INTO v_gradehorario * FROM acpgradehorario WHERE gradehorarioid = p_gradehorarioid;
    
    --Percorre horario oferta do componente para obter as informações do professor, sala e número de aulas
    v_count_horariocomponente := 0;

    FOR v_horarioofertacomponente IN (SELECT o.numerodeaulas, o.horarioofertacomponentecurricularid, o.personid, o.physicalresourceid, o.physicalresourceversion, h.diasemana, h.horarioid FROM acphorarioofertacomponentecurricular o INNER JOIN acphorario h ON h.horarioid = o.horarioid WHERE o.ofertacomponentecurricularid = p_ofertacomponentecurricularid)
    LOOP
        --Número de aulas
        v_numerodeaulas := v_horarioofertacomponente.numerodeaulas;

        --Conta e percorre o número de aulas da oferta
        v_count := 0;
        v_countaulas := v_numerodeaulas;
        WHILE v_count < v_numerodeaulas LOOP
        
            --Percorre cada horário da grade de horários
            FOR v_horario IN SELECT * FROM acpHorario WHERE gradehorarioid = v_gradehorario.gradehorarioid
            LOOP
                --Define a primeira data de ocorrência como data de inicio das aulas
                IF v_data IS NULL
                THEN
                    v_data := p_iniciodasaulas;
                ELSE
                    --Numero da semana
                    v_semana := EXTRACT('WEEK' FROM v_data);
                END IF;

                IF v_count_horariocomponente = 0 
                THEN
                    --Calcula o numero de dias para proximo horario de aula da grade
                    v_dias := v_horario.diasemana - EXTRACT('DOW' FROM v_data);
                    IF v_dias < 0 THEN
                        v_dias := v_dias + 7;
                    END IF;
                END IF;

                --Define a proxima data
                v_data := v_data + v_dias;

                --Se não tem aula adia para próxima ocorrência
                IF( p_datassemaula @> ARRAY[v_data] ) THEN
                    v_countaulas := v_countaulas + 1;
                ELSE
                    v_return_data := ARRAY_APPEND(v_return_data, v_data);
                    v_return_horariooferta := ARRAY_APPEND(v_return_horariooferta, v_horarioofertacomponente.horarioofertacomponentecurricularid);
                    v_return_horario := ARRAY_APPEND(v_return_horario, v_horario.horarioid);
                    v_return_professor := ARRAY_APPEND(v_return_professor, v_horarioofertacomponente.personid);
                    v_return_physicalresourceid := ARRAY_APPEND(v_return_physicalresourceid, v_horarioofertacomponente.physicalresourceid);
                    v_return_physicalresourceversion := ARRAY_APPEND(v_return_physicalresourceversion, v_horarioofertacomponente.physicalresourceversion);
                END IF;
                v_count := v_count +1;

                --Caso a periodicidade for quinzenal pula uma semana
                IF v_gradehorario.periodicidade = 'Q' THEN
                    IF v_semana != EXTRACT('WEEK' FROM v_data)
                    THEN
                        v_data := v_data+7;
                    END IF;
                END IF;

                --Caso atingiu o limite de aulas
                IF v_count >= v_countaulas THEN
                    EXIT;
                END IF;
            END LOOP;
        END LOOP;
        v_count_horariocomponente := v_count_horariocomponente +1;
    END LOOP;
        
    RETURN QUERY SELECT UNNEST(v_return_data), UNNEST(v_return_horario), UNNEST(v_return_horariooferta), UNNEST(v_return_professor), UNNEST(v_return_physicalresourceid), UNNEST(v_return_physicalresourceversion)   order by 1,2;
END;
$$;


ALTER FUNCTION public.acp_obterocorrenciasequencial(p_ofertacomponentecurricularid integer, p_gradehorarioid integer, p_iniciodasaulas date, p_datassemaula date[]) OWNER TO solis;

--
-- Name: acp_obtersituacaomatricula(integer); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION acp_obtersituacaomatricula(p_matriculaid integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: acp_obtersituacaomatricula
  PURPOSE: Retorna a situação por extenso da matricula passada por parâmetro
  DESCRIPTION: vide "PURPOSE".
 REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       06/06/2014 Jonas G. Diel        Função criada.    
**************************************************************************************/
DECLARE
    v_situacao acpmatricula.situacao%TYPE;
BEGIN
    SELECT INTO v_situacao situacao FROM acpmatricula WHERE matriculaid = p_matriculaid;
    RETURN CASE v_situacao 
        WHEN 'I' THEN 'Inscrito'
        WHEN 'M' THEN 'Matriculado'
        WHEN 'T' THEN 'Trancado'
        WHEN 'C' THEN 'Cancelado'
        WHEN 'V' THEN 'Reativado'
        WHEN 'A' THEN 'Aprovado'
        WHEN 'R' THEN 'Reprovado'
        WHEN 'F' THEN 'Reprovado por faltas'
    END;
END;
$$;


ALTER FUNCTION public.acp_obtersituacaomatricula(p_matriculaid integer) OWNER TO solis;

--
-- Name: applychanges(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION applychanges(p_changes text, p_changeid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    RAISE NOTICE 'Executando Changeid % : Comando %', p_changeid, p_changes;
    EXECUTE p_changes;

    RETURN TRUE;
    EXCEPTION WHEN OTHERS
    THEN
        UPDATE dbchanges set error = SQLERRM, applieddate = now() WHERE changeid = p_changeid;

        RETURN FALSE;
    END;

$$;


ALTER FUNCTION public.applychanges(p_changes text, p_changeid integer) OWNER TO postgres;

--
-- Name: atende_requisitos(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION atende_requisitos(p_curriculo integer, p_contrato integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
  v_disciplinas_requisitos record;
  v_creditos_requisitos integer;
  v_horas_requisitos integer;
  v_cursadas record;
begin
  for v_disciplinas_requisitos in select conditioncurriculumid from acdcondition 
      where conditioncurriculumid is not null and type = 'P' and curriculumid = p_curriculo
  loop
    if not exists (select enrollid
                     from acdenroll a
                    where a.curriculumid = v_disciplinas_requisitos.conditioncurriculumid
                      and contractid = p_contrato
                      and statusid in (1,2,7)) then
      return false;
    end if;
  end loop;

  select into v_creditos_requisitos sum(credits) from acdcondition where curriculumid = p_curriculo;

  select into v_horas_requisitos sum(numberhour) from acdcondition where curriculumid = p_curriculo;

  if v_creditos_requisitos > 0 or v_horas_requisitos > 0 then
    select into v_cursadas sum(academiccredits) as creditos, sum(academicnumberhours) as horas
      from acdenroll a
     inner join acdcurriculum d on (d.curriculumid = a.curriculumid)
     inner join acdcurricularcomponent e on (e.curricularcomponentid = d.curricularcomponentid and e.curricularcomponentversion = d.curricularcomponentversion) 
     where statusid in (1, 2, 7)
       and a.contractid = p_contrato;

    if v_cursadas.creditos < v_creditos_requisitos or v_cursadas.horas < v_horas_requisitos then
      return false;
    end if;
  end if;

  return true;
end
$$;


ALTER FUNCTION public.atende_requisitos(p_curriculo integer, p_contrato integer) OWNER TO postgres;

--
-- Name: atualiza_fininfotitulo(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION atualiza_fininfotitulo() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
                DECLARE
                    v_infotitulo fininfotitulo;
                    v_lancamento finentry;
                    v_contrato acdcontract;
                BEGIN   
                    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
                        v_lancamento = NEW;
                    END IF;

                    IF TG_OP = 'DELETE' THEN
                        v_lancamento = OLD;
                    END IF;

                    SELECT INTO v_infotitulo * FROM fininfotitulo WHERE titulo = v_lancamento.invoiceid;

                    IF v_infotitulo.periodo_letivo IS NULL OR v_infotitulo.contrato IS NULL THEN
                        IF v_lancamento.learningperiodid IS NOT NULL THEN
                            v_infotitulo.periodo_letivo = v_lancamento.learningperiodid;

                            SELECT INTO v_infotitulo.periodo periodid FROM acdlearningperiod WHERE learningperiodid = v_lancamento.learningperiodid;
                        END IF;

                        IF v_lancamento.contractid IS NOT NULL THEN
                            SELECT INTO v_contrato * FROM acdcontract WHERE contractid = v_lancamento.contractid;

                            v_infotitulo.contrato := v_contrato.contractid;

                            SELECT INTO v_infotitulo.unidade description FROM basunit WHERE unitid = v_contrato.unitid;

                            SELECT INTO v_infotitulo.curso name FROM acdcourse WHERE courseid = v_contrato.courseid;

                            SELECT INTO v_infotitulo.turno description FROM basturn WHERE turnid = v_contrato.turnid;
                        END IF;
                    END IF;

                    -- Valor nominal
                    SELECT INTO v_infotitulo.valor_nominal COALESCE(SUM(value), 0) 
                      FROM finentry 
                     WHERE operationid IN (SELECT operationid FROM finoperation WHERE operationtypeid = 'D' UNION
                                           SELECT cancelcurricularcomponentoperation FROM findefaultoperations)
                       AND operationid NOT IN (SELECT interestoperation FROM findefaultoperations UNION 
                                               SELECT otheradditionsoperation FROM findefaultoperations)
                       AND invoiceid = v_infotitulo.titulo;

                    -- Incentivos
                    SELECT INTO v_infotitulo.valor_incentivos COALESCE(SUM(value), 0)
                      FROM finentry
                     WHERE operationid IN (SELECT operationid FROM finincentivetype)
                       AND invoiceid = v_infotitulo.titulo;

                    -- Descontos
                    SELECT INTO v_infotitulo.valor_descontos COALESCE(SUM(value), 0)
                      FROM finentry a
                     WHERE operationid NOT IN (SELECT operationid FROM finincentivetype UNION 
                                               SELECT paymentoperation FROM findefaultoperations UNION 
                                               SELECT banktaxoperation FROM findefaultoperations)
                       AND EXISTS (SELECT operationid FROM finoperation WHERE operationtypeid = 'C' AND operationid = a.operationid)
                       AND invoiceid = v_infotitulo.titulo;

                    -- Valor pago
                    SELECT INTO v_infotitulo.valor_pago COALESCE(SUM(value), 0)
                      FROM finentry
                     WHERE operationid IN (SELECT paymentoperation FROM findefaultoperations UNION
                                           SELECT banktaxoperation FROM findefaultoperations)
                       AND invoiceid = v_infotitulo.titulo;

                    IF (v_lancamento.operationid IN (SELECT paymentoperation FROM findefaultoperations) AND
                        v_lancamento.entrydate > v_infotitulo.vencimento) THEN

                        -- Inadimplência
                        v_infotitulo.inadimplencia := v_infotitulo.valor_nominal - v_infotitulo.valor_incentivos - v_infotitulo.valor_descontos ;
                    END IF;

                    -- Juros
                    SELECT INTO v_infotitulo.valor_juros_multas COALESCE(SUM(value), 0)
                      FROM finentry
                     WHERE operationid IN (SELECT interestoperation FROM findefaultoperations UNION 
                                           SELECT otheradditionsoperation FROM findefaultoperations)
                       AND invoiceid = v_infotitulo.titulo;

                    -- Taxa
                    SELECT INTO v_infotitulo.valor_taxa COALESCE(SUM(value), 0)
                      FROM finentry
                     WHERE operationid IN (SELECT banktaxoperation FROM findefaultoperations)
                       AND invoiceid = v_infotitulo.titulo;

                    UPDATE fininfotitulo SET  
                        unidade = v_infotitulo.unidade,
                        curso = v_infotitulo.curso,
                        turno = v_infotitulo.turno,
                        periodo = v_infotitulo.periodo,
                        valor_nominal = v_infotitulo.valor_nominal,
                        valor_incentivos = v_infotitulo.valor_incentivos,
                        valor_descontos = v_infotitulo.valor_descontos,
                        valor_pago = v_infotitulo.valor_pago,
                        valor_juros_multas = v_infotitulo.valor_juros_multas,
                        valor_taxa = v_infotitulo.valor_taxa,
                        inadimplencia = v_infotitulo.inadimplencia,
                        periodo_letivo = v_infotitulo.periodo_letivo,
                        contrato = v_infotitulo.contrato
                    WHERE titulo = v_infotitulo.titulo ;

                    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
                        RETURN NEW;
                    END IF;

                    IF TG_OP = 'DELETE' THEN
                        RETURN OLD;
                    END IF;
                END;
                $$;


ALTER FUNCTION public.atualiza_fininfotitulo() OWNER TO postgres;

--
-- Name: atualiza_tabelas_com_heranca_incorreta(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION atualiza_tabelas_com_heranca_incorreta() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    -- #######################################################################
    -- TABELA basphysicalpersonemployee
    -- #######################################################################
    RAISE NOTICE 'Atualizando basphysicalpersonemployee';

    ALTER TABLE "basemployee" DROP CONSTRAINT "basemployee_personid_fkey";
    ALTER TABLE "ccppayrolldiscount" DROP CONSTRAINT "ccppayrolldiscount_personid_fkey";
    ALTER TABLE "ccprequest" DROP CONSTRAINT "ccprequest_personid_fkey";
    ALTER TABLE "finopencounter" DROP CONSTRAINT "finopencounter_operatorid_fkey";
    ALTER TABLE "finpayrolldiscounttarget" DROP CONSTRAINT "finpayrolldiscounttarget_employeeid_fkey";

    CREATE TEMP TABLE teste AS
    SELECT "username",
           datetime,
           ipaddress,
           personid,
           persondv,
           personmask,
           "name",
           shortname,
           cityid,
           zipcode,
           "location",
           "number",
           complement,
           neighborhood,
           email,
           emailalternative,
           url,
           datein,
           "password",
           isallowpersonaldata,
           miolousername,
           locationtypeid,
           sentemail,
           photoid,
           sex,
           maritalstatusid,
           residentialphone,
           workphone,
           cellphone,
           messagephone,
           messagecontact,
           datebirth,
           cityidbirth,
           countryidbirth,
           responsablelegalid,
           carplate,
           specialnecessityid,
           specialnecessitydescription,
           cityidwork,
           zipcodework,
           locationwork,
           complementwork,
           neighborhoodwork,
           ethnicoriginid,
           datedeath,
           persontitleid,
           locationtypeidwork,
           mothername,
           fathername,
           workemployername,
           workfunction,
           workstartdate,
           workenddate,
           workathome
      FROM basphysicalpersonemployee;

    DROP TABLE basphysicalpersonemployee;
    CREATE TABLE basphysicalpersonemployee (PRIMARY KEY (personId)) INHERITS (basPhysicalPerson);
    INSERT INTO basphysicalpersonemployee (
           "username",
           datetime,
           ipaddress,
           personid,
           persondv,
           personmask,
           "name",
           shortname,
           cityid,
           zipcode,
           "location",
           "number",
           complement,
           neighborhood,
           email,
           emailalternative,
           url,
           datein,
           "password",
           isallowpersonaldata,
           miolousername,
           locationtypeid,
           sentemail,
           photoid,
           sex,
           maritalstatusid,
           residentialphone,
           workphone,
           cellphone,
           messagephone,
           messagecontact,
           datebirth,
           cityidbirth,
           countryidbirth,
           responsablelegalid,
           carplate,
           specialnecessityid,
           specialnecessitydescription,
           cityidwork,
           zipcodework,
           locationwork,
           complementwork,
           neighborhoodwork,
           ethnicoriginid,
           datedeath,
           persontitleid,
           locationtypeidwork,
           mothername,
           fathername,
           workemployername,
           workfunction,
           workstartdate,
           workenddate,
           workathome)
    SELECT "username",
           datetime,
           ipaddress,
           personid,
           persondv,
           personmask,
           "name",
           shortname,
           cityid,
           zipcode,
           "location",
           "number",
           complement,
           neighborhood,
           email,
           emailalternative,
           url,
           datein,
           "password",
           isallowpersonaldata,
           miolousername,
           locationtypeid,
           sentemail,
           photoid,
           sex,
           maritalstatusid,
           residentialphone,
           workphone,
           cellphone,
           messagephone,
           messagecontact,
           datebirth,
           cityidbirth,
           countryidbirth,
           responsablelegalid,
           carplate,
           specialnecessityid,
           specialnecessitydescription,
           cityidwork,
           zipcodework,
           locationwork,
           complementwork,
           neighborhoodwork,
           ethnicoriginid,
           datedeath,
           persontitleid,
           locationtypeidwork,
           mothername,
           fathername,
           workemployername,
           workfunction,
           workstartdate,
           workenddate,
           workathome
      FROM teste;
      
    ALTER TABLE "basemployee" ADD CONSTRAINT "basemployee_personid_fkey" FOREIGN KEY (personid) REFERENCES basphysicalpersonemployee(personid);
    ALTER TABLE "ccppayrolldiscount" ADD CONSTRAINT "ccppayrolldiscount_personid_fkey" FOREIGN KEY (personid) REFERENCES basphysicalpersonemployee(personid);
    ALTER TABLE "ccprequest" ADD CONSTRAINT "ccprequest_personid_fkey" FOREIGN KEY (personid) REFERENCES basphysicalpersonemployee(personid);
    ALTER TABLE "finopencounter" ADD CONSTRAINT "finopencounter_operatorid_fkey" FOREIGN KEY (operatorid) REFERENCES basphysicalpersonemployee(personid);
    ALTER TABLE "finpayrolldiscounttarget" ADD CONSTRAINT "finpayrolldiscounttarget_employeeid_fkey" FOREIGN KEY (employeeid) REFERENCES basphysicalpersonemployee(personid);

    DROP TABLE teste;

    -- #######################################################################
    -- TABELA basphysicalpersonprofessor
    -- #######################################################################
    RAISE NOTICE 'Atualizando basphysicalpersonprofessor';

    ALTER TABLE "acdcenter" DROP CONSTRAINT "acdcenter_directorid_fkey";
    ALTER TABLE "acdcoursecoordinator" DROP CONSTRAINT "acdcoursecoordinator_coordinatorid_fkey";
    ALTER TABLE "acdevaluation" DROP CONSTRAINT "acdevaluation_professorid_fkey";
    ALTER TABLE "acdgroup" DROP CONSTRAINT "acdgroup_professorresponsible_fkey";
    ALTER TABLE "acdprofessorcurricularcomponent" DROP CONSTRAINT "acdprofessorcurricularcomponent_professorid_fkey";
    ALTER TABLE "acdscheduleprofessor" DROP CONSTRAINT "acdscheduleprofessor_professorid_fkey";
    ALTER TABLE "acdprofessorcenter" DROP CONSTRAINT "basprofessorcenter_professorid_fkey";
    ALTER TABLE "basprofessorcommitment" DROP CONSTRAINT "basprofessorcommitment_personid_fkey";
    ALTER TABLE "acdprofessorformation" DROP CONSTRAINT "basprofessorformation_professorid_fkey";

    CREATE TEMP TABLE teste AS
    SELECT "username",
           datetime,
           ipaddress,
           personid,
           persondv,
           personmask,
           "name",
           shortname,
           cityid,
           zipcode,
           "location",
           "number",
           complement,
           neighborhood,
           email,
           emailalternative,
           url,
           datein,
           "password",
           isallowpersonaldata,
           miolousername,
           locationtypeid,
           sentemail,
           photoid,
           sex,
           maritalstatusid,
           residentialphone,
           workphone,
           cellphone,
           messagephone,
           messagecontact,
           datebirth,
           cityidbirth,
           countryidbirth,
           responsablelegalid,
           carplate,
           specialnecessityid,
           specialnecessitydescription,
           cityidwork,
           zipcodework,
           locationwork,
           complementwork,
           neighborhoodwork,
           ethnicoriginid,
           datedeath,
           persontitleid,
           locationtypeidwork,
           mothername,
           fathername,
           workemployername,
           workfunction,
           workstartdate,
           workenddate,
           workathome
      FROM basphysicalpersonprofessor;

    DROP TABLE basphysicalpersonprofessor;
    CREATE TABLE basphysicalpersonprofessor (PRIMARY KEY (personId)) INHERITS (basPhysicalPerson);
    INSERT INTO basphysicalpersonprofessor (
           "username",
           datetime,
           ipaddress,
           personid,
           persondv,
           personmask,
           "name",
           shortname,
           cityid,
           zipcode,
           "location",
           "number",
           complement,
           neighborhood,
           email,
           emailalternative,
           url,
           datein,
           "password",
           isallowpersonaldata,
           miolousername,
           locationtypeid,
           sentemail,
           photoid,
           sex,
           maritalstatusid,
           residentialphone,
           workphone,
           cellphone,
           messagephone,
           messagecontact,
           datebirth,
           cityidbirth,
           countryidbirth,
           responsablelegalid,
           carplate,
           specialnecessityid,
           specialnecessitydescription,
           cityidwork,
           zipcodework,
           locationwork,
           complementwork,
           neighborhoodwork,
           ethnicoriginid,
           datedeath,
           persontitleid,
           locationtypeidwork,
           mothername,
           fathername,
           workemployername,
           workfunction,
           workstartdate,
           workenddate,
           workathome)
    SELECT "username",
           datetime,
           ipaddress,
           personid,
           persondv,
           personmask,
           "name",
           shortname,
           cityid,
           zipcode,
           "location",
           "number",
           complement,
           neighborhood,
           email,
           emailalternative,
           url,
           datein,
           "password",
           isallowpersonaldata,
           miolousername,
           locationtypeid,
           sentemail,
           photoid,
           sex,
           maritalstatusid,
           residentialphone,
           workphone,
           cellphone,
           messagephone,
           messagecontact,
           datebirth,
           cityidbirth,
           countryidbirth,
           responsablelegalid,
           carplate,
           specialnecessityid,
           specialnecessitydescription,
           cityidwork,
           zipcodework,
           locationwork,
           complementwork,
           neighborhoodwork,
           ethnicoriginid,
           datedeath,
           persontitleid,
           locationtypeidwork,
           mothername,
           fathername,
           workemployername,
           workfunction,
           workstartdate,
           workenddate,
           workathome
      FROM teste;

    ALTER TABLE "acdcenter" ADD CONSTRAINT "acdcenter_directorid_fkey" FOREIGN KEY (directorid) REFERENCES basphysicalpersonprofessor(personid);
    ALTER TABLE "acdcoursecoordinator" ADD CONSTRAINT "acdcoursecoordinator_coordinatorid_fkey" FOREIGN KEY (coordinatorid) REFERENCES basphysicalpersonprofessor(personid);
    ALTER TABLE "acdevaluation" ADD CONSTRAINT "acdevaluation_professorid_fkey" FOREIGN KEY (professorid) REFERENCES basphysicalpersonprofessor(personid);
    ALTER TABLE "acdgroup" ADD CONSTRAINT "acdgroup_professorresponsible_fkey" FOREIGN KEY (professorresponsible) REFERENCES basphysicalpersonprofessor(personid);
    ALTER TABLE "acdprofessorcurricularcomponent" ADD CONSTRAINT "acdprofessorcurricularcomponent_professorid_fkey" FOREIGN KEY (professorid) REFERENCES basphysicalpersonprofessor(personid);
    ALTER TABLE "acdscheduleprofessor" ADD CONSTRAINT "acdscheduleprofessor_professorid_fkey" FOREIGN KEY (professorid) REFERENCES basphysicalpersonprofessor(personid);
    ALTER TABLE "acdprofessorcenter" ADD CONSTRAINT "basprofessorcenter_professorid_fkey" FOREIGN KEY (professorid) REFERENCES basphysicalpersonprofessor(personid);
    ALTER TABLE "basprofessorcommitment" ADD CONSTRAINT "basprofessorcommitment_personid_fkey" FOREIGN KEY (personid) REFERENCES basphysicalpersonprofessor(personid);
    ALTER TABLE "acdprofessorformation" ADD CONSTRAINT "basprofessorformation_professorid_fkey" FOREIGN KEY (professorid) REFERENCES basphysicalpersonprofessor(personid);
    
    DROP TABLE teste;

    -- #######################################################################
    -- TABELA basphysicalpersonstudent
    -- #######################################################################
    RAISE NOTICE 'Atualizando basphysicalpersonstudent';

    ALTER TABLE "acdcontract" DROP CONSTRAINT "acdcontract_personid_fkey";
    ALTER TABLE "acdgroup" DROP CONSTRAINT "acdgroup_leaderid_fkey";
    ALTER TABLE "acdgroup" DROP CONSTRAINT "acdgroup_subleaderid_fkey";

    CREATE TEMP TABLE teste AS
    SELECT username,
     datetime,
     ipaddress,
     personid,
     persondv,
     personmask,
     name,
     shortname,
     cityid,
     zipcode,
     location,
     number,
     complement,
     neighborhood,
     email,
     emailalternative,
     url,
     datein,
     password,
     isallowpersonaldata,
     miolousername,
     locationtypeid,
     sentemail,
     photoid,
     sex,
     maritalstatusid,
     residentialphone,
     workphone,
     cellphone,
     messagephone,
     messagecontact,
     datebirth,
     cityidbirth,
     countryidbirth,
     responsablelegalid,
     carplate,
     specialnecessityid,
     specialnecessitydescription,
     cityidwork,
     zipcodework,
     locationwork,
     complementwork,
     neighborhoodwork,
     ethnicoriginid,
     datedeath,
     persontitleid,
     locationtypeidwork,
     mothername,
     fathername,
     workemployername,
     workfunction,
     workstartdate,
     workenddate,
     workathome,
     externalcourseidhs,
     institutionidhs,
     cityidhs,
     yearhs,
     isinsured,
     passive
    FROM basphysicalpersonstudent;

    DROP TABLE basphysicalpersonstudent;
    CREATE TABLE basphysicalpersonstudent (
        externalcourseidhs integer,
        institutionidhs integer,
        cityidhs integer,
        yearhs integer,
        isinsured boolean not null default false,
        passive character varying(20),
        PRIMARY KEY (personId),
        FOREIGN KEY (cityidhs) REFERENCES bascity(cityid),
        FOREIGN KEY (externalcourseidhs) REFERENCES acdexternalcourse(externalcourseid),
        FOREIGN KEY (institutionidhs) REFERENCES baslegalperson(personid)
    ) INHERITS (basPhysicalPerson);

    INSERT INTO basphysicalpersonstudent (
     username,
     datetime,
     ipaddress,
     personid,
     persondv,
     personmask,
     name,
     shortname,
     cityid,
     zipcode,
     location,
     number,
     complement,
     neighborhood,
     email,
     emailalternative,
     url,
     datein,
     password,
     isallowpersonaldata,
     miolousername,
     locationtypeid,
     sentemail,
     photoid,
     sex,
     maritalstatusid,
     residentialphone,
     workphone,
     cellphone,
     messagephone,
     messagecontact,
     datebirth,
     cityidbirth,
     countryidbirth,
     responsablelegalid,
     carplate,
     specialnecessityid,
     specialnecessitydescription,
     cityidwork,
     zipcodework,
     locationwork,
     complementwork,
     neighborhoodwork,
     ethnicoriginid,
     datedeath,
     persontitleid,
     locationtypeidwork,
     mothername,
     fathername,
     workemployername,
     workfunction,
     workstartdate,
     workenddate,
     workathome,
     externalcourseidhs,
     institutionidhs,
     cityidhs,
     yearhs,
     isinsured,
     passive)
 SELECT username,
     datetime,
     ipaddress,
     personid,
     persondv,
     personmask,
     name,
     shortname,
     cityid,
     zipcode,
     location,
     number,
     complement,
     neighborhood,
     email,
     emailalternative,
     url,
     datein,
     password,
     isallowpersonaldata,
     miolousername,
     locationtypeid,
     sentemail,
     photoid,
     sex,
     maritalstatusid,
     residentialphone,
     workphone,
     cellphone,
     messagephone,
     messagecontact,
     datebirth,
     cityidbirth,
     countryidbirth,
     responsablelegalid,
     carplate,
     specialnecessityid,
     specialnecessitydescription,
     cityidwork,
     zipcodework,
     locationwork,
     complementwork,
     neighborhoodwork,
     ethnicoriginid,
     datedeath,
     persontitleid,
     locationtypeidwork,
     mothername,
     fathername,
     workemployername,
     workfunction,
     workstartdate,
     workenddate,
     workathome,
     externalcourseidhs,
     institutionidhs,
     cityidhs,
     yearhs,
     isinsured,
     passive
    FROM teste;

    ALTER TABLE "acdcontract" ADD CONSTRAINT "acdcontract_personid_fkey" FOREIGN KEY (personid) REFERENCES basphysicalpersonstudent(personid);
    ALTER TABLE "acdgroup" ADD CONSTRAINT "acdgroup_leaderid_fkey" FOREIGN KEY (leaderid) REFERENCES basphysicalpersonstudent(personid);
    ALTER TABLE "acdgroup" ADD CONSTRAINT "acdgroup_subleaderid_fkey" FOREIGN KEY (subleaderid) REFERENCES basphysicalpersonstudent(personid);

    DROP TABLE teste;

    -- #######################################################################
    -- TABELA ccpperson
    -- #######################################################################
    RAISE NOTICE 'Atualizando ccpperson';

    ALTER TABLE "ccppersoncopy" DROP CONSTRAINT "ccppersoncopy_personid_fkey";
    ALTER TABLE "ccppersonperiod" DROP CONSTRAINT "ccppersonperiod_personid_fkey";
    ALTER TABLE "ccppersonprinter" DROP CONSTRAINT "ccppersonprinter_personid_fkey";
    ALTER TABLE "ccppersonsector" DROP CONSTRAINT "ccppersonsector_personid_fkey";

    CREATE TEMP TABLE teste AS
    SELECT 
        username,
        datetime,
        ipaddress,
        personid,
        persondv,
        personmask,
        name,
        shortname,
        cityid,
        zipcode,
        location,
        number,
        complement,
        neighborhood,
        email,
        emailalternative,
        url,
        datein,
        password,
        isallowpersonaldata,
        miolousername,
        locationtypeid,
        sentemail,
        photoid,
        sex,
        maritalstatusid,
        residentialphone,
        workphone,
        cellphone,
        messagephone,
        messagecontact,
        datebirth,
        cityidbirth,
        countryidbirth,
        responsablelegalid,
        carplate,
        specialnecessityid,
        specialnecessitydescription,
        cityidwork,
        zipcodework,
        locationwork,
        complementwork,
        neighborhoodwork,
        ethnicoriginid,
        datedeath,
        persontitleid,
        locationtypeidwork,
        mothername,
        fathername,
        workemployername,
        workfunction,
        workstartdate,
        workenddate,
        workathome,
        canexceed
    FROM ONLY ccpperson;

    DROP TABLE ccpperson;
    CREATE TABLE ccpperson (canexceed boolean not null default false, PRIMARY KEY (personId)) INHERITS (basPhysicalPerson);
    INSERT INTO ccpperson (
        username,
        datetime,
        ipaddress,
        personid,
        persondv,
        personmask,
        name,
        shortname,
        cityid,
        zipcode,
        location,
        number,
        complement,
        neighborhood,
        email,
        emailalternative,
        url,
        datein,
        password,
        isallowpersonaldata,
        miolousername,
        locationtypeid,
        sentemail,
        photoid,
        sex,
        maritalstatusid,
        residentialphone,
        workphone,
        cellphone,
        messagephone,
        messagecontact,
        datebirth,
        cityidbirth,
        countryidbirth,
        responsablelegalid,
        carplate,
        specialnecessityid,
        specialnecessitydescription,
        cityidwork,
        zipcodework,
        locationwork,
        complementwork,
        neighborhoodwork,
        ethnicoriginid,
        datedeath,
        persontitleid,
        locationtypeidwork,
        mothername,
        fathername,
        workemployername,
        workfunction,
        workstartdate,
        workenddate,
        workathome,
        canexceed)
    SELECT 
        username,
        datetime,
        ipaddress,
        personid,
        persondv,
        personmask,
        name,
        shortname,
        cityid,
        zipcode,
        location,
        number,
        complement,
        neighborhood,
        email,
        emailalternative,
        url,
        datein,
        password,
        isallowpersonaldata,
        miolousername,
        locationtypeid,
        sentemail,
        photoid,
        sex,
        maritalstatusid,
        residentialphone,
        workphone,
        cellphone,
        messagephone,
        messagecontact,
        datebirth,
        cityidbirth,
        countryidbirth,
        responsablelegalid,
        carplate,
        specialnecessityid,
        specialnecessitydescription,
        cityidwork,
        zipcodework,
        locationwork,
        complementwork,
        neighborhoodwork,
        ethnicoriginid,
        datedeath,
        persontitleid,
        locationtypeidwork,
        mothername,
        fathername,
        workemployername,
        workfunction,
        workstartdate,
        workenddate,
        workathome,
        canexceed
    FROM teste;

    ALTER TABLE "ccppersoncopy" ADD CONSTRAINT "ccppersoncopy_personid_fkey" FOREIGN KEY (personid) REFERENCES ccpperson(personid);
    ALTER TABLE "ccppersonperiod" ADD CONSTRAINT "ccppersonperiod_personid_fkey" FOREIGN KEY (personid) REFERENCES ccpperson(personid);
    ALTER TABLE "ccppersonprinter" ADD CONSTRAINT "ccppersonprinter_personid_fkey" FOREIGN KEY (personid) REFERENCES ccpperson(personid);
    ALTER TABLE "ccppersonsector" ADD CONSTRAINT "ccppersonsector_personid_fkey" FOREIGN KEY (personid) REFERENCES ccpperson(personid);

    DROP TABLE teste;

    -- #######################################################################
    -- TABELA ccppersonprinter
    -- #######################################################################
    RAISE NOTICE 'Atualizando ccppersonprinter';

    CREATE TEMP TABLE teste AS
    SELECT username,
           datetime,
           ipaddress,
           personprinterid,
           printerid,
           personid
      FROM ccppersonprinter;

    DROP TABLE ccppersonprinter;
    CREATE TABLE ccppersonprinter (
        personprinterid integer not null default nextval('seq_personprinterid'::regclass),
        printerid integer not null,
        personid integer not null,
        PRIMARY KEY (personprinterid),
        FOREIGN KEY (personid) REFERENCES ccpperson(personid),
        FOREIGN KEY (printerid) REFERENCES ccpprinter(printerid)
    ) INHERITS (baslog);

    INSERT INTO ccppersonprinter (
        username,
        datetime,
        ipaddress,
        personprinterid,
        printerid,
        personid)
    SELECT username,
           datetime,
           ipaddress,
           personprinterid,
           printerid,
           personid
      FROM teste;

    DROP TABLE teste;

    -- #######################################################################
    -- TABELA ccppersonsector
    -- #######################################################################
    RAISE NOTICE 'Atualizando ccppersonsector';

    CREATE TEMP TABLE teste AS
    SELECT username,
           datetime,
           ipaddress,
           sectorpersonid,
           personid,
           sectorid,
           begintime,
           endtime
      FROM ccppersonsector;

    DROP TABLE ccppersonsector;
    CREATE TABLE ccppersonsector (
        sectorpersonid integer not null default nextval('seq_sectorpersonid'::regclass),
        personid integer not null,
        sectorid integer not null,
        begintime time without time zone,
        endtime time without time zone,
        PRIMARY KEY (sectorpersonid),
        FOREIGN KEY (personid) REFERENCES ccpperson(personid),
        FOREIGN KEY (sectorid) REFERENCES ccpsector(sectorid)
    ) INHERITS (baslog);

    INSERT INTO ccppersonsector (
        username,
        datetime,
        ipaddress,
        sectorpersonid,
        personid,
        sectorid,
        begintime,
        endtime)
    SELECT username,
           datetime,
           ipaddress,
           sectorpersonid,
           personid,
           sectorid,
           begintime,
           endtime
      FROM ccppersonsector;

    DROP TABLE teste;

    -- #######################################################################
    -- TABELA ccpprinter
    -- #######################################################################
    RAISE NOTICE 'Atualizando ccpprinter';

    ALTER TABLE "ccpcopy" DROP CONSTRAINT "ccpcopy_printerid_fkey";
    ALTER TABLE "ccppersonprinter" DROP CONSTRAINT "ccppersonprinter_printerid_fkey";
    ALTER TABLE "ccpsectorprinter" DROP CONSTRAINT "ccpsectorprinter_printerid_fkey";

    CREATE TEMP TABLE teste AS
    SELECT username,
           datetime,
           ipaddress,
           printerid,
           name,
           physicalresourceid,
           physicalresourceversion
      FROM ccpprinter;

    DROP TABLE ccpprinter;
    CREATE TABLE ccpprinter (
        printerid integer not null default nextval('seq_printerid'::regclass),
        name character varying not null,
        physicalresourceid integer,
        physicalresourceversion integer,
        PRIMARY KEY (printerid),
        FOREIGN KEY (physicalresourceid, physicalresourceversion) REFERENCES insphysicalresource(physicalresourceid, physicalresourceversion)
    ) INHERITS (baslog);

    INSERT INTO ccpprinter (
        username,
        datetime,
        ipaddress,
        printerid,
        name,
        physicalresourceid,
        physicalresourceversion
    )
    SELECT username,
           datetime,
           ipaddress,
           printerid,
           name,
           physicalresourceid,
           physicalresourceversion
      FROM teste;

    ALTER TABLE "ccpcopy" ADD CONSTRAINT "ccpcopy_printerid_fkey" FOREIGN KEY (printerid) REFERENCES ccpprinter(printerid);
    ALTER TABLE "ccppersonprinter" ADD CONSTRAINT "ccppersonprinter_printerid_fkey" FOREIGN KEY (printerid) REFERENCES ccpprinter(printerid);
    ALTER TABLE "ccpsectorprinter" ADD CONSTRAINT "ccpsectorprinter_printerid_fkey" FOREIGN KEY (printerid) REFERENCES ccpprinter(printerid);

    DROP TABLE teste;

    -- #######################################################################
    -- TABELA ccpsectorprinter
    -- #######################################################################
    RAISE NOTICE 'Atualizando ccpsectorprinter';

    CREATE TEMP TABLE teste AS
    SELECT username,
           datetime,
           ipaddress,
           personsectorid,
           printerid,
           sectorid
      FROM ccpsectorprinter;

    DROP TABLE ccpsectorprinter;
    CREATE TABLE ccpsectorprinter (
        personsectorid integer not null default nextval('seq_personsectorid'::regclass),
        printerid integer not null,
        sectorid integer not null,
        PRIMARY KEY (personsectorid),
        FOREIGN KEY (printerid) REFERENCES ccpprinter(printerid),
        FOREIGN KEY (sectorid) REFERENCES ccpsector(sectorid)
    ) INHERITS (baslog);

    INSERT INTO ccpsectorprinter (
        username, 
        datetime, 
        ipaddress,
        personsectorid,
        printerid,
        sectorid
    )
    SELECT username, 
           datetime, 
           ipaddress,
           personsectorid,
           printerid,
           sectorid
      FROM teste;

    DROP TABLE teste;

    RETURN TRUE;
END;
$$;


ALTER FUNCTION public.atualiza_tabelas_com_heranca_incorreta() OWNER TO postgres;

--
-- Name: atualizabalanco(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION atualizabalanco() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: atualizabalanco
  PURPOSE: Atualiza o estado do titulo (valor aberto) de acordo com os lancamentos.
**************************************************************************************/
DECLARE
    v_tituloid integer;
BEGIN
    IF TG_OP = 'UPDATE' OR TG_OP = 'INSERT'
    THEN
        v_tituloid := NEW.tituloid;
    END IF;

    IF TG_OP = 'DELETE'
    THEN
        v_tituloid := OLD.tituloid;
    END IF;

    -- Atualiza o valor aberto (saldo devedor)
    UPDATE capTitulo SET valoraberto = (
        SELECT SUM( (CASE WHEN tipolancamento = 'C' THEN valor ELSE (valor * -1) END) )
        FROM capLancamento
        WHERE tituloId = v_tituloid
    )
    WHERE tituloId = v_tituloid;

    -- Atualiza flag de titulo aberto (baseando-se no valor aberto)
    UPDATE capTitulo SET tituloaberto = ( valoraberto > 0 ) WHERE tituloId = v_tituloid;

    RETURN NEW;
END;
$$;


ALTER FUNCTION public.atualizabalanco() OWNER TO postgres;

--
-- Name: atualizabuscapessoa(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION atualizabuscapessoa() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.namesearch := REPLACE(REGEXP_REPLACE(LOWER(UNACCENT(TRIM(NEW.name))), '[^a-zA-Z ]', '', 'g'), ' ', '%') || '%';
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.atualizabuscapessoa() OWNER TO postgres;

--
-- Name: atualizarmediasconcluintes(); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION atualizarmediasconcluintes() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE

    v_contractId integer;    
    v_globalAverage double precision;

BEGIN

    FOR v_contractId IN SELECT DISTINCT contractid FROM acdmovementcontract WHERE statecontractid = getParameter('ACADEMIC', 'STATE_CONTRACT_ID_CONCLUSION_ALL_CURRICULAR_COMPONENT')::INT LOOP
    BEGIN
        SELECT INTO v_globalAverage obterMediaGlobal(v_contractId);

        IF ( v_globalAverage IS NOT NULL ) THEN
        BEGIN
            UPDATE acdcontract SET globalaverage = v_globalAverage WHERE contractid = v_contractId;
        END;
        END IF;
        
    END;
    END LOOP;
    
    RETURN true;

END;
$$;


ALTER FUNCTION public.atualizarmediasconcluintes() OWNER TO solis;

--
-- Name: atualizavinculoaluno(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION atualizavinculoaluno() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: atualizavinculoaluno
  PURPOSE: Insere ou atualiza vinculo de aluno
**************************************************************************************/
DECLARE
    v_dateValidate DATE;
    v_personId INT;
BEGIN
    -- Caso a movimentacao contratual sendo inserida fecha contrato (isCloseContract = TRUE), define a data final do vinculo como a data da movimentacao, senao, como vazio.
    IF (SELECT isCloseContract FROM acdStateContract WHERE stateContractId = NEW.stateContractId) IS TRUE
    THEN
        v_dateValidate := NEW.stateTime::date;
    ELSE
        v_dateValidate := NULL;
    END IF;

    v_personId := (SELECT personId FROM acdContract WHERE contractId = NEW.contractId);

    IF EXISTS(SELECT 1 FROM baspersonlink WHERE personid = v_personId AND linkId = GETPARAMETER('BASIC', 'PERSON_LINK_STUDENT')::int)
    THEN
        UPDATE basPersonLink SET dateValidate = v_dateValidate WHERE personid = v_personId AND linkId = GETPARAMETER('BASIC', 'PERSON_LINK_STUDENT')::int;
    ELSE
        INSERT INTO basPersonLink (personId, linkId, dateValidate) VALUES (v_personId, GETPARAMETER('BASIC', 'PERSON_LINK_STUDENT')::int, v_dateValidate);
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION public.atualizavinculoaluno() OWNER TO postgres;

--
-- Name: atualizavinculofuncionario(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION atualizavinculofuncionario() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: atualizavinculofuncionario
  PURPOSE: Insere ou exclui o vinculo
**************************************************************************************/
BEGIN
    IF TG_OP = 'DELETE'
    THEN
        UPDATE basPersonLink SET dateValidate = NOW()::date WHERE personId = OLD.personId;
        RETURN OLD;
    ELSE
        INSERT INTO basPersonLink (personId, linkId) VALUES (NEW.personId, GETPARAMETER('BASIC', 'PERSON_LINK_EMPLOYEE')::int);
        RETURN NEW;
    END IF;
END;
$$;


ALTER FUNCTION public.atualizavinculofuncionario() OWNER TO postgres;

--
-- Name: atualizavinculoprofessor(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION atualizavinculoprofessor() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: atualizavinculoprofessor
  PURPOSE: Insere ou exclui o vinculo
**************************************************************************************/
BEGIN
    IF TG_OP = 'DELETE'
    THEN
        UPDATE basPersonLink SET dateValidate = NOW()::date WHERE personId = OLD.personId;
        RETURN OLD;
    ELSE
        INSERT INTO basPersonLink (personId, linkId) VALUES (NEW.personId, GETPARAMETER('BASIC', 'PERSON_LINK_PROFESSOR')::int);
        RETURN NEW;
    END IF;
END;
$$;


ALTER FUNCTION public.atualizavinculoprofessor() OWNER TO postgres;

--
-- Name: auditar_todas_tabelas(); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION auditar_todas_tabelas() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/***************************************************************
  NAME: auditar_todas_tabelas
  PURPOSE: Verifica se configuração está ativa e insere a 
           trigger de auditoria em todas as tabelas.
****************************************************************/
DECLARE
    --Valor configurado do parâmetro AUDITAR_TODAS_TABELAS
    v_auditarTodasTabelas TEXT;

    --Recebe as tabelas que possíveis de auditoria que não estão sendo auditadas
    v_tabelas RECORD;

    --Recebe o nome da trigger que será criada
    v_trigger TEXT;

    --Recebe o nome da tabela concatenada com o esquema
    v_trigger_on TEXT;
    
BEGIN
    v_auditarTodasTabelas := GETPARAMETER('BASIC', 'AUDITAR_TODAS_TABELAS');
    
    --Insere em todas as tabelas se parâmetro estiver habilitado
    IF( v_auditarTodasTabelas = 't' ) THEN

	    --Obtém todas as tabelas possíveis de auditorias que não estão sendo auditadas
	    FOR v_tabelas IN SELECT nspname,
				    relname
			       FROM pg_class 
			 INNER JOIN pg_namespace
				 ON relnamespace = pg_namespace.oid
			      WHERE relkind = 'r'
				AND nspname NOT LIKE 'pg_%'
				AND nspname != 'information_schema'
				AND relname NOT IN ('miolo_audit', 'miolo_audit_detail')
				AND relname NOT IN ( SELECT UNNEST(STRING_TO_ARRAY(GETPARAMETER('BASIC', 'TABELAS_QUE_NAO_PODEM_SER_AUDITADAS'), ',')) )
				AND pg_class.oid NOT IN ( SELECT tgrelid
							    FROM pg_trigger 
						      INNER JOIN pg_proc
							      ON tgfoid = pg_proc.oid
							   WHERE proname = 'miolo_audit_it' )
			   ORDER BY nspname, relname
	    LOOP  
		v_trigger := 'maudit_' || v_tabelas.nspname || '_' || v_tabelas.relname;
		v_trigger_on := v_tabelas.nspname || '.' || v_tabelas.relname;
	        
                BEGIN
		    EXECUTE 'CREATE TRIGGER ' || v_trigger || '
				     BEFORE UPDATE OR DELETE 
				         ON ' || v_trigger_on || '
			           FOR EACH ROW EXECUTE PROCEDURE miolo_audit_it()';
		    EXCEPTION
		        WHEN OTHERS THEN
			    --RAISE EXCEPTION 'Não foi possível inserir a trigger de auditoria na tabela %.%.', v_tabelas.nspname,v_tabelas.relname;
			    RETURN FALSE;
		END;        
	    END LOOP;
    END IF;

    RETURN TRUE;
	 
END;
$$;


ALTER FUNCTION public.auditar_todas_tabelas() OWNER TO solis;

--
-- Name: balance(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION balance(integer) RETURNS numeric
    LANGUAGE sql
    AS $_$
SELECT SUM( CASE WHEN A.operationTypeId = 'D' THEN ( 1 * B.value ) 
                 WHEN A.operationTypeId = 'C' THEN ( -1 * B.value ) 
            END 
          )
  FROM finOperation A, 
       finEntry B 
 WHERE A.operationId = B.operationId 
   AND B.invoiceId = $1
$_$;


ALTER FUNCTION public.balance(integer) OWNER TO postgres;

--
-- Name: balanceretorno(integer, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION balanceretorno(p_invoiceid integer, p_date date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: balanceretorno
  PURPOSE: Calcula o saldo de um tï¿½tulo, se fosse baixado em p_data. Leva em
  consideraï¿½ï¿½o as polï¿½ticas que regem o tï¿½tulo.
  DESCRIPTION: vide "PURPOSE".

**************************************************************************************/
DECLARE
    v_policyInfo RECORD;
    v_invoiceInfo RECORD;
    v_balance NUMERIC;
    V_actualDate DATE;
    v_interestValue NUMERIC;
    v_fineValue NUMERIC;
    v_discountValue NUMERIC;
    v_convenantValue NUMERIC;
    v_numDays NUMERIC;
    v_interestPercent NUMERIC;
    v_retVal NUMERIC;
    v_decimals INTEGER;
BEGIN
    -- Inicialização de variáveis
    SELECT INTO v_decimals value::integer FROM basConfig WHERE parameter LIKE 'REAL_ROUND_VALUE';

    v_discountValue := ROUND(tmp_getInvoiceDiscountValue(p_invoiceId), v_decimals);
    v_fineValue := ROUND(tmp_getInvoiceFineValue(p_invoiceId, p_date), v_decimals);
    v_interestValue := ROUND(tmp_getInvoiceInterestValue(p_invoiceId, p_date), v_decimals);
    v_convenantValue := ROUND(tmp_getInvoiceConvenantValue(p_invoiceId), v_decimals);
    v_actualDate := p_date;
    v_retVal := 0;

    SELECT INTO v_balance ROUND(SUM( CASE WHEN A.operationTypeId = 'D' THEN ( 1 * B.value ) END ), getParameter('BASIC', 'REAL_ROUND_VALUE')::INT )             
           FROM finOperation A,                                                    
                finEntry B                                                         
          WHERE A.operationId = B.operationId                                      
            AND B.invoiceId = p_invoiceId;

    -- Dados do título
    SELECT INTO v_invoiceInfo *
      FROM ONLY finReceivableInvoice
     WHERE invoiceId = p_invoiceId;

    -- Dados da política
    SELECT INTO v_policyInfo *
      FROM finPolicy
     WHERE policyId = v_invoiceInfo.policyId;

    IF v_invoiceInfo.parcelnumber = 0 THEN
        RETURN v_balance + v_interestValue + v_fineValue;
    END IF;

    --RAISE NOTICE 'BALANCE % JUROS % MULTAS % CONVENIO % DESCONTO %', v_balance, v_interestValue, v_fineValue, v_convenantValue, v_discountValue;
	
    RETURN v_balance + v_interestValue + v_fineValue - v_convenantValue - v_discountValue;
END
$$;


ALTER FUNCTION public.balanceretorno(p_invoiceid integer, p_date date) OWNER TO postgres;

--
-- Name: balancetemporariodoretornobancario(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION balancetemporariodoretornobancario(p_invoiceid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_balance numeric := ( SELECT balance(p_invoiceId) );
    v_balance_temporario numeric := 0;
BEGIN
    SELECT INTO v_balance_temporario 
		ROUND( SUM( CASE WHEN A.operationTypeId = 'D' 
			         THEN 
				      ( 1 * B.value ) 
			         WHEN A.operationTypeId = 'C' 
			         THEN 
				      ( -1 * B.value ) 
			    END ), getParameter('BASIC', 'REAL_ROUND_VALUE')::INT )
	  FROM finOperation A, 
	       temp_bank_movement_entries B 
	 WHERE A.operationId = B.operationId 
	   AND B.invoiceId = p_invoiceId;

     RETURN v_balance + v_balance_temporario;
END;
$$;


ALTER FUNCTION public.balancetemporariodoretornobancario(p_invoiceid integer) OWNER TO postgres;

--
-- Name: balancewithbetweendates(integer, date, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION balancewithbetweendates(integer, date, date) RETURNS numeric
    LANGUAGE sql
    AS $_$
SELECT SUM( CASE WHEN A.operationTypeId = 'D' THEN ( 1 * B.value )
                 WHEN A.operationTypeId = 'C' THEN ( -1 * B.value )
            END
          )::numeric
  FROM finOperation A,
       ( SELECT value,
                operationId,
                invoiceId,
                entryDate
           FROM finEntry
           ) AS B
 WHERE invoiceId = $1
       AND entryDate >= $2
       AND entryDate <= $3
       AND A.operationId = B.operationId$_$;


ALTER FUNCTION public.balancewithbetweendates(integer, date, date) OWNER TO postgres;

--
-- Name: balancewithenddate(integer, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION balancewithenddate(integer, date) RETURNS numeric
    LANGUAGE sql
    AS $_$
SELECT SUM( CASE WHEN A.operationTypeId = 'D' THEN ( 1 * B.value )
                 WHEN A.operationTypeId = 'C' THEN ( -1 * B.value )
            END
          )::numeric
  FROM finOperation A,
       ( SELECT value,
                operationId,
                invoiceId,
                entryDate
           FROM finEntry 
          WHERE invoiceId = $1
            AND entryDate <= $2 ) AS B
 WHERE A.operationId = B.operationId$_$;


ALTER FUNCTION public.balancewithenddate(integer, date) OWNER TO postgres;

--
-- Name: balancewithpoliciesdated(integer, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION balancewithpoliciesdated(p_invoiceid integer, p_date date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
  /*************************************************************************************
  NAME: balanceWithPoliciesDated
  PURPOSE: Calcula o saldo de um título, se fosse baixado em p_data. Leva em
  consideração as políticas que regem o título.
  DESCRIPTION: vide "PURPOSE".

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       22/11/2010 AlexSmith         1. Função criada.
  1.1       01/12/2010 AlexSmith         1. Adicionado arredondamento em duas casas
                                            decimais, já que é o padrão utilizado.
  1.2       07/12/2010 Leovan            1. Adicionado controle dos convênios.
  1.3       22/07/2014 Bruno Fuhr        1. Retornar zero se a soma de todos os valores for nulo.
**************************************************************************************/
DECLARE
    v_policyInfo RECORD;
    v_invoiceInfo RECORD;
    v_balance NUMERIC;
    V_actualDate DATE;
    v_interestValue NUMERIC;
    v_fineValue NUMERIC;
    v_discountValue NUMERIC;
    v_convenantValue NUMERIC;
    v_numDays NUMERIC;
    v_interestPercent NUMERIC;
    v_retVal NUMERIC;
    v_decimals INTEGER;
    v_return NUMERIC;
BEGIN
    -- Inicialização de variáveis
    SELECT INTO v_decimals value::integer FROM basConfig WHERE parameter LIKE 'REAL_ROUND_VALUE';

    v_discountValue := ROUND(getInvoiceDiscountValue(p_invoiceId, p_date), v_decimals);
    v_fineValue := ROUND(getInvoiceFineValue(p_invoiceId, p_date), v_decimals);
    v_interestValue := ROUND(getInvoiceInterestValue(p_invoiceId, p_date), v_decimals);
    v_convenantValue := ROUND(getInvoiceConvenantValue(p_invoiceId, p_date), v_decimals);
    v_balance := ROUND(balance(p_invoiceId), v_decimals);
    v_actualDate := p_date;
    v_retVal := 0;

    -- Dados do título
    SELECT INTO v_invoiceInfo *
      FROM ONLY finReceivableInvoice
     WHERE invoiceId = p_invoiceId;

    -- Dados da política
    SELECT INTO v_policyInfo *
      FROM finPolicy
     WHERE policyId = v_invoiceInfo.policyId;

    v_return := v_balance + v_interestValue + v_fineValue - v_convenantValue - v_discountValue;
    IF v_return IS NULL THEN
      v_return := 0;
    END IF;

    RETURN v_return;
END;
$$;


ALTER FUNCTION public.balancewithpoliciesdated(p_invoiceid integer, p_date date) OWNER TO postgres;

--
-- Name: bas_chk_domain(character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION bas_chk_domain(p_domain character varying, p_key character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_result boolean;
BEGIN

    --Se o valor do dominio for nulo permite inserir pois, em alguns casos, o campo da tabela em questão pode aceitar NULL.
    IF p_key IS NULL
    THEN
        RETURN TRUE;
    END IF;

    PERFORM * FROM basDomain LIMIT 1;
    IF NOT FOUND
    THEN
        RETURN TRUE; --Caso não haja nenhum dado na basDomain retorna como true. Isso é para resolver o bug do postgres que não ignora os check no dump
    END IF;

    SELECT INTO v_result count(*) > 0
        FROM basDomain
        WHERE domainId = p_domain
            AND key = p_key;

    RETURN v_result;

END;
$$;


ALTER FUNCTION public.bas_chk_domain(p_domain character varying, p_key character varying) OWNER TO postgres;

--
-- Name: bi_obter_estados_contratuais_matriculados(character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION bi_obter_estados_contratuais_matriculados(p_periodo character varying, p_curso character varying, p_unidade integer) RETURNS TABLE(contrato integer, periodo character varying, estado_contratual text)
    LANGUAGE plpgsql
    AS $$
declare
  v_consulta text;
  v_filtros text;
begin
  v_consulta := 'select distinct
                         C.contractid as contrato,
                         F.periodid as periodo,
                         case when exists ( select enrollid
                                               from acdenroll AA
                                              inner join acdgroup BB using (groupid)
                                              inner join acdlearningperiod CC on (CC.learningperiodid = BB.learningperiodid)
                                              where AA.contractid = C.contractid
                                                and CC.periodid <> F.periodid
                                                and CC.begindate < F.begindate
                                                and AA.statusid not in (5, 6, 7) ) then
                                   -- rematrÃ­cula: neste caso, Ã© reingresso ou rematrÃ­cula mesmo
                                   -- Ã© reingresso se encontrar uma mov de reingresso no perÃ­odo
                                   case when exists ( select 1 
                                                        from acdmovementcontract XA
                                                       inner join acdlearningperiod XB using (learningperiodid)
                                                       where XB.periodid = F.periodid
                                                         and XA.statecontractid = 6
                                                         and XA.contractid = C.contractid ) then
                                            ''REINGRESSO''
                                        else
                                            ''REMATRÍCULA''
                                   end
                              else
                                   -- para calouros (primeira matrí­cula) vale o estado de entrada
                                   -- obtem-se, então, a primeira movimentação contratual
                                   coalesce( 
                                   (select case when XA.statecontractid = 1 then ''VESTIBULAR''
                                               when XA.statecontractid = 2 then ''TRANSFERÊNCIA DE OUTRA INSTITUIÇÃO''
                                               when XA.statecontractid = 3 then ''PORTADOR DE DIPLOMA''
                                               when XA.statecontractid = 14 then ''INSCRIÇÃO''
                                               when XA.statecontractid = 19 then ''MATRÍCULA ISOLADA''
                                               when XA.statecontractid = 8 then ''TRANSFERÊNCIA DE OUTRO CURSO''
                                          else
                                              ''OUTRAS FORMAS DE INGRESSO''
                                          end as estado
                                     from acdmovementcontract XA
                                    inner join acdstatecontract XB using (statecontractid)
                                    where XA.contractid = C.contractid
                                      and XA.statecontractid not in (4, 16)
                                    order by XA.statetime limit 1)
                                   ,
                                   ''INDETERMINADO'')
                        end as estado_contratual --estado_contratual_id
                  from acdcontract C
                  inner join acdlearningperiod F 
                     on (F.courseid = C.courseid and 
                         F.courseversion = C.courseversion and
                         F.unitid = C.unitid and
                         F.turnid = C.turnid)
                  where exists (select contractid
                                  from acdenroll AA
                                 inner join acdgroup BB using (groupid)
                                 inner join acdlearningperiod CC on (CC.learningperiodid = BB.learningperiodid)
                                 where AA.contractid = C.contractid
                                   and CC.periodid = F.periodid
                                   and AA.statusid not in (5, 6, 7))';

  if (p_periodo is not null) then
    v_filtros := ' and F.periodid = ''' || p_periodo || '''';
  end if;

  if (p_curso is not null) then
    if (v_filtros is not null) then
      v_filtros := v_filtros || ' and C.courseid = ''' || p_curso || '''';
    else
      v_filtros := ' and C.courseid = ''' || p_curso || '''';
    end if;
  end if;

  if (p_curso is not null) then
    if (v_filtros is not null) then
      v_filtros := v_filtros || ' and C.unitid = ' || p_unidade;
    else
      v_filtros := ' and C.unitid = ' || p_unidade;
    end if;
  end if;

  if (v_filtros is not null) then
    v_consulta := v_consulta || v_filtros;
  end if;

  return query execute v_consulta;
end;
$$;


ALTER FUNCTION public.bi_obter_estados_contratuais_matriculados(p_periodo character varying, p_curso character varying, p_unidade integer) OWNER TO postgres;

--
-- Name: bi_obter_evasoes(character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION bi_obter_evasoes(p_periodo character varying, p_curso character varying, p_unidade integer) RETURNS TABLE(cod_unidade integer, cod_curso character varying, cod_turno integer, cod_aluno bigint, periodo character varying, data_inicial_periodo date, data_estado_contratual date, sexo text, idade double precision, cod_cidade integer, estado_contratual text, contrato integer, etnia text, necessidade_especial text)
    LANGUAGE plpgsql
    AS $$
declare
  v_consulta text;
  v_filtros text;
begin
  v_consulta := 'select * from (
                 select distinct 
                         C.unitid as cod_unidade,
                         C.courseid as cod_curso,
                         C.turnid as cod_turno,
                         C.personid::bigint as cod_aluno,
                         COALESCE(D.periodid, (select periodid
                                                 from acdlearningperiod
                                                where courseid = C.courseid
                                                  and courseversion = C.courseversion
                                                  and unitid = C.unitid
                                                  and turnid = C.turnid
                                                  and A.statetime between begindate and enddate)) as periodo,
                         COALESCE(D.begindate, A.statetime::date) as data_inicial_periodo,
                         A.statetime::date as data_estado_contratual,
                         CASE WHEN upper(E.sex) = ''M'' THEN ''MASCULINO'' ELSE ''FEMININO'' END as sexo,
                         extract(year from age(coalesce(E.datebirth, date(now())))) as idade,
                         E.cityid as cod_cidade,
                         case when A.statecontractid = 5 then ''TRANCAMENTO''
                              when A.statecontractid = 7 then ''MUDANÇA DE CURSO''
                              when A.statecontractid in (9, 10, 11) then ''CONCLUSÃO''
                              when A.statecontractid in (12, 18) then ''TRANSFERÊNCIA PARA OUTRA INSTITUIÇÃO''
                              when A.statecontractid in (13, 17) then ''CANCELAMENTO''
                              else ''OUTRAS SAÍDAS''
                         end as estado_contratual,
                         C.contractid as contrato,
                         G.description as etnia,
                         F.description as necessidade_especial
                  from acdmovementcontract A
                   inner join acdstatecontract B using (statecontractid)
                   inner join acdcontract C using (contractid)
                   inner join basphysicalpersonstudent E using (personid)
                    left join acdlearningperiod D using (learningperiodid)
                    left join basspecialnecessity F using (specialnecessityid)
                    left join basethnicorigin G using (ethnicoriginid)
                   where B.isclosecontract is true
                     and not exists ( select enrollid
                                        from acdenroll AA
                                       inner join acdgroup BB using (groupid)
                                       inner join acdlearningperiod CC on (CC.learningperiodid = BB.learningperiodid)
                                       where AA.contractid = A.contractid
                                         and ( CC.periodid = D.periodid or 
                                               (D.periodid is null and
                                                A.statetime::date between CC.begindate and CC.enddate ) )
                                         and AA.statusid not in (5, 6, 7) ) ) as sel';

  if (p_periodo is not null) then
    v_filtros := ' and sel.periodo = ''' || p_periodo || '''';
  end if;

  if (p_curso is not null) then
    if (v_filtros is not null) then
      v_filtros := v_filtros || ' and sel.cod_curso = ''' || p_curso || '''';
    else
      v_filtros := ' and sel.cod_curso = ''' || p_curso || '''';
    end if;
  end if;

  if (p_curso is not null) then
    if (v_filtros is not null) then
      v_filtros := v_filtros || ' and sel.cod_unidade = ' || p_unidade;
    else
      v_filtros := ' and sel.cod_unidade = ' || p_unidade;
    end if;
  end if;

  if (v_filtros is not null) then
    v_filtros := ' where ' || substr(v_filtros, 5);

    v_consulta := v_consulta || v_filtros;
  end if;

  return query execute v_consulta;
end;
$$;


ALTER FUNCTION public.bi_obter_evasoes(p_periodo character varying, p_curso character varying, p_unidade integer) OWNER TO postgres;

--
-- Name: bi_obter_matriculas(character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION bi_obter_matriculas(p_periodo character varying, p_curso character varying, p_unidade integer) RETURNS TABLE(cod_unidade integer, cod_curso character varying, cod_turno integer, cod_aluno bigint, cod_professor bigint, sexo text, periodo character varying, idade double precision, cod_cidade integer, serie integer, contrato integer, cod_oferecida integer, cod_estado integer, data_inicial_periodo date, frequencia double precision, nota double precision, conceito text, etnia text, necessidade_especial text, data_matricula date)
    LANGUAGE plpgsql
    AS $$
declare
  v_consulta text;
  v_filtros text;
begin
  v_consulta := 'select B.unitid as cod_unidade,--unidade_id
                       B.courseid as cod_curso,--curso_id
                       B.turnid as cod_turno,--turno_id
                       B.personid::bigint as cod_aluno,--aluno_id
                       case when C.professorresponsible is not null then
                                C.professorresponsible::bigint
                            else
                                (select professorid 
                                   from acdscheduleprofessor AA
                                  inner join acdschedule BB using (scheduleid)
                                  where BB.groupid = C.groupid
                                  order by AA.scheduleprofessorid
                                  limit 1)
                       end as cod_professor, --professor_id
                       CASE WHEN upper(E.sex) = ''M'' THEN ''MASCULINO'' ELSE ''FEMININO'' END as sexo,--sexo_id
                       D.periodid as periodo,--periodo_id
                       extract(year from age(coalesce(E.datebirth, date(now())))) as idade,--faixa_etaria_id
                       E.cityid as cod_cidade,--geografia_id
                       CU.semester as serie,
                       A.contractid as contrato,--contrato_id
                       A.groupid as cod_oferecida,--disciplina_id
                       A.statusid as cod_estado,--situacao_matricula_id
                       D.begindate as data_inicial_periodo,--data_periodo_id
                       A.frequency as frequencia,--frequencia
                       A.finalnote as nota,--nota
                       A.concept as conceito,--conceito
                       G.description as etnia,
                       H.description as necessidade_especial,
                       MAX(A.dateenroll) as data_matricula --data_matricula_id
                from acdenroll A
                inner join acdcontract B using (contractid)
                inner join acdgroup C using (groupid)
                inner join acdcurriculum as CU on (C.curriculumid = CU.curriculumid)
                inner join acdlearningperiod D on (D.learningperiodid = C.learningperiodid)
                inner join basphysicalpersonstudent E using (personid)
                 left join basethnicorigin G using (ethnicoriginid)
                 left join basspecialnecessity H using (specialnecessityid)
                 left join acdsemestercontractperiod F on (F.contractid = B.contractid and F.periodid = D.periodid)';

  if (p_periodo is not null) then
    v_filtros := ' and D.periodid = ''' || p_periodo || '''';
  end if;

  if (p_curso is not null) then
    if (v_filtros is not null) then
      v_filtros := v_filtros || ' and B.courseid = ''' || p_curso || '''';
    else
      v_filtros := ' and B.courseid = ''' || p_curso || '''';
    end if;
  end if;

  if (p_curso is not null) then
    if (v_filtros is not null) then
      v_filtros := v_filtros || ' and B.unitid = ' || p_unidade;
    else
      v_filtros := ' and B.unitid = ' || p_unidade ;
    end if;
  end if;

  if (v_filtros is not null) then
    v_filtros := ' where ' || substr(v_filtros, 5);

    v_consulta := v_consulta || v_filtros;
  end if;

  v_consulta := v_consulta || ' group by 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19';

  return query execute v_consulta;
end;
$$;


ALTER FUNCTION public.bi_obter_matriculas(p_periodo character varying, p_curso character varying, p_unidade integer) OWNER TO postgres;

--
-- Name: bi_obter_titulos(character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION bi_obter_titulos(p_periodo character varying, p_curso character varying, p_unidade integer) RETURNS TABLE(titulo integer, cod_unidade integer, cod_curso character varying, cod_turno integer, cod_aluno integer, sexo text, data_inicial_periodo date, data_vencimento date, contrato integer, serie integer, periodo character varying, cod_cidade integer, idade double precision, valor_nominal numeric, valor_incentivos numeric, valor_descontos numeric, valor_pago numeric, valor_juros_multas numeric, valor_taxa numeric, valor_inadimplencia numeric, parcela integer)
    LANGUAGE plpgsql
    AS $$
declare
  v_consulta text;
  v_filtros text;
begin
  v_consulta := 'select
                      A.titulo as cod_titulo,-- titulo_id 
                      C.unitid as cod_unidade,-- unidade_id
                      C.courseid as cod_curso,-- curso_id
                      C.turnid as cod_turno,-- turno_id
                      A.matricula as cod_aluno,-- aluno_id
                      CASE WHEN upper(B.sex) = ''M'' THEN ''MASCULINO'' ELSE ''FEMININO'' END as sexo,-- sexo_id 
                      F.begindate as data_inicial_periodo, -- data_periodo_id 
                      A.vencimento as data_vencimento,-- data_vencimento_id
                      A.contrato as contrato,-- contrato_id 
                      G.semester as serie,-- serie_id
                      A.periodo as periodo,-- periodo_id 
                      B.cityid as cod_cidade,-- geografia_id 
                      extract(year from age(coalesce(B.datebirth, date(now())))) as idade,-- faixa_etaria_id 
                      A.valor_nominal,-- valor_nominal 
                      A.valor_incentivos,-- valor_incentivos 
                      A.valor_descontos + getinvoicediscountvalue(A.titulo, now()::date) + getinvoiceconvenantvalue(A.titulo, now()::date) as valor_descontos,-- valor_descontos 
                      A.valor_pago as valor_recebido,-- valor_recebido
                      A.valor_juros_multas,
                      A.valor_taxa, 
                      CASE WHEN A.inadimplencia > 0 THEN A.inadimplencia
                           ELSE CASE WHEN A.vencimento < now()::date and D.balance > 0 THEN D.balance
                           ELSE 0::numeric END
                      END as valor_inadimplencia,-- valor_inadimplencia 
                      D.parcelnumber as parcela-- parcela
                from fininfotitulo A
                inner join basphysicalpersonstudent B on (B.personid = A.matricula)    
                inner join acdcontract C on (C.contractid = A.contrato)
                inner join only finreceivableinvoice D on (D.invoiceid = A.titulo)
                inner join acdlearningperiod F on (F.learningperiodid = A.periodo_letivo)
                left join acdsemestercontractperiod G on (G.contractid = C.contractid and G.periodid = F.periodid)
                where D.iscanceled IS FALSE
                and EXISTS (select entryid from finentry where invoiceid = A.titulo)';

  if (p_periodo is not null) then
    v_filtros := ' and F.periodid = ''' || p_periodo || '''';
  end if;

  if (p_curso is not null) then
    if (v_filtros is not null) then
      v_filtros := v_filtros || ' and C.courseid = ''' || p_curso || '''';
    else
      v_filtros := ' and C.courseid = ''' || p_curso || '''';
    end if;
  end if;

  if (p_curso is not null) then
    if (v_filtros is not null) then
      v_filtros := v_filtros || ' and C.unitid = ' || p_unidade;
    else
      v_filtros := ' and C.unitid = ' || p_unidade;
    end if;
  end if;

  if (v_filtros is not null) then
    v_consulta := v_consulta || v_filtros;
  end if;

  return query execute v_consulta;
end;
$$;


ALTER FUNCTION public.bi_obter_titulos(p_periodo character varying, p_curso character varying, p_unidade integer) OWNER TO postgres;

--
-- Name: bibliographys(text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION bibliographys(p_data text[]) RETURNS text
    LANGUAGE plpgsql
    AS $$ 
DECLARE
    v_id TEXT;
    v_content text;
    v_result text;
BEGIN

    v_result := '';

    FOR v_id IN SELECT * FROM unnest(p_data)
    LOOP
        FOR v_content IN (SELECT content FROM SEA_BIBLIOGRAPHY_DATA( v_id::int, NULL, NULL, '100.a,700.a,245.a,250.a,260.a,260.b,260.c' ))
        LOOP
            v_result := v_result || ( CASE WHEN CHAR_LENGTH(v_result) > 0 THEN ', ' ELSE '' END ) || v_content;
        END LOOP;

        IF CHAR_LENGTH(v_result) > 0
        THEN
            v_result := v_result || '\n';
        END IF;
    END LOOP;
        
    RETURN RTRIM(v_result);
END; 
$$;


ALTER FUNCTION public.bibliographys(p_data text[]) OWNER TO postgres;

--
-- Name: buscarportariavigente(character varying, integer, integer, integer, date); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION buscarportariavigente(p_courseid character varying, p_courseversion integer, p_turnid integer, p_unitid integer, p_datareconhecimento date) RETURNS text
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN ( SELECT documentoreconhecimento
               FROM acdreconhecimentodecurso 
              WHERE courseid = p_courseid
                AND courseversion = p_courseversion
                AND turnid = p_turnid
                AND unitid = p_unitid
                AND ( datareconhecimento <= p_dataReconhecimento OR 
                      datareconhecimento IS NULL ) 
           ORDER BY datareconhecimento 
         DESC LIMIT 1 );
END;
$$;


ALTER FUNCTION public.buscarportariavigente(p_courseid character varying, p_courseversion integer, p_turnid integer, p_unitid integer, p_datareconhecimento date) OWNER TO solis;

--
-- Name: calculamediaglobal(); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION calculamediaglobal() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    
    v_globalAverage double precision;

BEGIN
    
    IF ( NEW.statecontractid = getParameter('ACADEMIC', 'STATE_CONTRACT_ID_CONCLUSION_ALL_CURRICULAR_COMPONENT')::INT ) THEN
    BEGIN
        SELECT INTO v_globalAverage obterMediaGlobal(NEW.contractid);
        UPDATE acdcontract SET globalaverage = v_globalAverage WHERE contractid = NEW.contractid;
    END;
    END IF;
    
    RETURN NEW;
    
END;
$$;


ALTER FUNCTION public.calculamediaglobal() OWNER TO solis;

--
-- Name: calculanota(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION calculanota(p_enrollid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: calculanota
  DESCRIPTION: 

  REVISIONS:
  Ver       Date       Author             Description
  --------- ---------- -----------------  ------------------------------------
  1.0       10-12-2012 ftomasini          FUNÇÃO responsável por calcular 
                                          composição de graus acadêmicos
******************************************************************************/
DECLARE

    v_fatherdegree record;
    v_learningperiodId integer;
    v_media float;
    v_notas record;
    v_exame record;
    v_conta_notas integer;
    v_somatorio_notas float;
    v_nota_antiga float;
    v_conta_alteracoes integer;
    v_escala double precision;
    v_calcula boolean;
    v_notaobrigatoria integer;
    v_valornotaobrigatoria double precision;
    v_notaobrigatoriaparent integer;
    v_recorddate_excluida timestamp;
    v_isclosed boolean;
    v_notaexame record;
    v_soma_grau integer;
    v_soma_grau_final integer;
    
BEGIN
    --verifica se a disciplia oferecida está fechada e não realiza a verificação das notas/graus/obrigatóriedade
    SELECT A.isclosed INTO v_isclosed
      FROM acdgroup A 
INNER JOIN acdenroll B
        ON A.groupid = B.groupid
     WHERE B.enrollid = p_enrollid;

    IF v_isclosed = TRUE THEN
        RETURN FALSE;
    END IF;

       v_conta_alteracoes:=0;
       SELECT INTO v_escala getParameter('ACADEMIC', 'ESCALA_DE_ARREDONDAMENTO_DO_GRAU_FINAL')::float;

    -- Obtém o período letivo da matrí­cula  
    SELECT b.learningperiodid INTO v_learningperiodId
      FROM acdenroll A
INNER JOIN acdgroup B
        ON A.groupid = B.groupid
     WHERE enrollid = p_enrollid;

    -- Obtem a nota de exame
    SELECT INTO v_notaexame * FROM acddegree WHERE learningperiodid = v_learningperiodId AND isexam LIMIT 1;

    RAISE NOTICE 'Período letivo % ',v_learningperiodId ;
    
    v_calcula := true;
    -- Verifica se todas as notas obrigatórias foram informadas
    FOR v_notaobrigatoria IN SELECT degreeid FROM acddegree WHERE learningperiodid = v_learningperiodId AND maybenull = false AND NOT isexam AND degreeid NOT IN (SELECT parentdegreeid FROM acddegree WHERE learningperiodid = v_learningperiodId AND parentdegreeid IS NOT NULL) LOOP
    
        IF GETPARAMETER('ACADEMIC', 'CONSIDER_HIGHER_PUNCTUATION_DEGREE') = 't' THEN
        BEGIN
            SELECT INTO v_recorddate_excluida recorddate FROM acddegreeenroll WHERE enrollid = p_enrollid AND degreeid = v_notaobrigatoria AND note IS NULL ORDER BY recorddate DESC LIMIT 1;
            IF v_recorddate_excluida IS NULL THEN
                v_recorddate_excluida := '2000-01-01'::timestamp;
            END IF;
            SELECT INTO v_valornotaobrigatoria note FROM acddegreeenroll WHERE enrollid = p_enrollid AND degreeid = v_notaobrigatoria AND recorddate > v_recorddate_excluida ORDER BY note DESC LIMIT 1;
        END;
        ELSE
            SELECT INTO v_valornotaobrigatoria note FROM acddegreeenroll WHERE enrollid = p_enrollid AND degreeid = v_notaobrigatoria ORDER BY recorddate DESC LIMIT 1;
        END IF;
        
        IF ( v_valornotaobrigatoria IS NOT NULL ) THEN
        BEGIN
            RAISE NOTICE 'Nota % : %', v_notaobrigatoria, v_valornotaobrigatoria ;
        END;
        ELSE
        BEGIN
            RAISE NOTICE 'Uma nota obrigatoria nao foi preenchida e por isso as medias nao serao calculadas.';

            -- Se ja tiver valor na media, remove.
            SELECT INTO v_notaobrigatoriaparent parentdegreeid FROM acddegree  WHERE degreeid = v_notaobrigatoria;
            SELECT INTO v_soma_grau count(*) FROM acddegreeenroll WHERE enrollid = p_enrollid AND degreeid = v_notaobrigatoriaparent;
            IF ( v_soma_grau > 0 ) THEN
            BEGIN
                INSERT INTO acddegreeenroll (note,enrollid,degreeid,recorddate,description) VALUES (NULL,p_enrollid,v_notaobrigatoriaparent, now() - interval '4 second', 'NOTA EXCLUÍDA AUTOMATICAMENTE');
                EXCEPTION WHEN unique_violation THEN
                RAISE NOTICE 'UNIQUE EXCEPTION: enrollid: %, degreeid: %', p_enrollid, v_notaobrigatoriaparent;
            END;
            END IF;

            -- Verifica se a nota pai da media tem valor. Se sim, remove.
            SELECT INTO v_fatherdegree parentdegreeid FROM acddegree WHERE degreeid = v_notaobrigatoriaparent;
            SELECT INTO v_soma_grau_final count(*) FROM acddegreeenroll WHERE enrollid = p_enrollid AND degreeid = v_fatherdegree.parentdegreeid;
            IF ( v_soma_grau_final > 0 ) THEN
            BEGIN
                INSERT INTO acddegreeenroll (note,enrollid,degreeid,recorddate,description) VALUES (NULL,p_enrollid,v_fatherdegree.parentdegreeid, now() - interval '3 second', 'NOTA EXCLUÍDA AUTOMATICAMENTE');
                EXCEPTION WHEN unique_violation THEN
                RAISE NOTICE 'UNIQUE EXCEPTION: enrollid: %, degreeid: %', p_enrollid, v_fatherdegree.parentdegreeid;
            END;
            END IF;
            
            v_calcula := false;
        END;
        END IF;
        
    END LOOP;
    
    IF ( v_calcula ) THEN
    BEGIN
        --Verifica se tem nota de exame para a matrícula
        SELECT B.note, A.examcalcmethod INTO v_exame
          FROM acddegree A
    INNER JOIN acddegreeenroll B 
            ON b.degreeid = a.degreeid
         WHERE enrollid = p_enrollid
           AND isexam ='t'
           AND note IS NOT NULL 
      ORDER BY recorddate desc 
         LIMIT 1;

        --Percorre todas as notas que devem ser calculadas média, nota final
        FOR v_fatherdegree IN SELECT AA.degreeid,
                                     AA.parentdegreeid,
                                     AA.degreenumber
                                FROM acddegree AA
                               WHERE AA.degreeid IN (SELECT parentdegreeid
                                                       FROM acddegree A 
                                                      WHERE A.learningperiodid = v_learningperiodId
                                                   GROUP BY 1
                                                     HAVING count(parentdegreeid) >1)
                            GROUP BY AA.degreeid,AA.parentdegreeid,AA.parentdegreeid,AA.degreenumber
                            ORDER BY AA.parentdegreeid ASC, AA.degreenumber
                                                   
        LOOP

            RAISE NOTICE 'Nota pai % ',v_fatherdegree.degreeid ;

            --zera a média
            v_media:= -1;
            --
            --Percorre as notas e mostra seu valor
            --
            v_conta_notas:=0;
            v_somatorio_notas:=0;
            
            IF GETPARAMETER('ACADEMIC', 'CONSIDER_HIGHER_PUNCTUATION_DEGREE') = 't' THEN
            BEGIN
                FOR v_notas
                IN SELECT (SELECT AA.note
                                        FROM acddegreeenroll AA
                                       WHERE AA.enrollId = B.enrollid  
                                         AND AA.degreeid = A.degreeid AND recorddate > (SELECT CASE WHEN (
                                         SELECT recorddate FROM acddegreeenroll 
                                         WHERE enrollid = B.enrollid AND degreeid = A.degreeid AND note IS NULL 
                                         ORDER BY recorddate DESC LIMIT 1) IS NULL THEN '2000-01-01'::timestamp ELSE
                                         (SELECT recorddate FROM acddegreeenroll 
                                         WHERE enrollid = B.enrollid AND degreeid = A.degreeid AND note IS NULL 
                                         ORDER BY recorddate DESC LIMIT 1)
                                         END)
                                         ORDER BY aa.note desc LIMIT 1) AS note,
                                     A.description,
                                     A.weight
                                FROM acddegree A
                          INNER JOIN acddegreeenroll B 
                                  ON b.degreeid = a.degreeid
                               WHERE A.parentdegreeid = v_fatherdegree.degreeid
                                 AND enrollid = p_enrollid
                                 AND isexam ='f' 
                                  AND note IS NOT NULL
                            GROUP BY a.description, a.degreeid, b.enrollid, A.weight
               LOOP
                   RAISE NOTICE 'Nota filho nome -  % - valor: %',v_notas.description, v_notas.note;
                   v_conta_notas:= v_conta_notas + v_notas.weight;
                   v_somatorio_notas:= v_somatorio_notas + (v_notas.note * v_notas.weight);

               END LOOP;
            END;
            ELSE
            BEGIN
                FOR v_notas
                IN SELECT (SELECT AA.note
                                        FROM acddegreeenroll AA
                                       WHERE AA.enrollId = B.enrollid  
                                         AND AA.degreeid = A.degreeid ORDER BY aa.recorddate desc LIMIT 1) AS note,
                                     A.description,
                                     A.weight
                                FROM acddegree A
                          INNER JOIN acddegreeenroll B 
                                  ON b.degreeid = a.degreeid
                               WHERE A.parentdegreeid = v_fatherdegree.degreeid
                                 AND enrollid = p_enrollid
                                 AND isexam ='f' 
                                  AND note IS NOT NULL
                            GROUP BY a.description, a.degreeid, b.enrollid, A.weight
               LOOP
                   RAISE NOTICE 'Nota filho nome -  % - valor: %',v_notas.description, v_notas.note;
                   v_conta_notas:= v_conta_notas + v_notas.weight;
                   v_somatorio_notas:= v_somatorio_notas + (v_notas.note * v_notas.weight);

               END LOOP;
            END;
            END IF;

            --Cálculo da média
            IF ( v_conta_notas::integer != 0 )
            THEN
                v_media:= (v_somatorio_notas/v_conta_notas::integer);
            END IF;

            RAISE NOTICE ' A média será %',v_media;
            
            IF ( v_escala > 0 ) THEN
            BEGIN
                SELECT INTO v_media round((v_media + 0.01)/v_escala) * v_escala;
            END;
            END IF;
            
             --Testa se for grau final
            IF (v_fatherdegree.parentdegreeid IS NULL)
            THEN
                --Se existe nota de exame para a matricula
                IF(v_exame.note IS NOT NULL)
                THEN
                    --Se a forma de calculo for (substitui grau pai)
                    IF(v_exame.examcalcmethod = 'S')
                    THEN
                        RAISE NOTICE 'Exame substitui grau final % ',v_exame.note;
                        v_media:= v_exame.note;
                    END IF;
                    --Se a forma de calculo for (media com grau pai)
                    IF(v_exame.examcalcmethod = 'M')
                    THEN
                        RAISE NOTICE 'Exame média com grau final % ',((v_exame.note + v_media)/2);
                        v_media:= ((v_exame.note + v_media)/2);
                    END IF;
                ELSE
                    -- Se nota de exame for requerida, nao pode calcular grau final quando aluno estiver em exame e nao tiver sido registrada nota de exame
                    IF ( v_notaexame.maybenull = 'f' AND (v_media >= v_notaexame.examminimumnote AND v_media < v_notaexame.exammaximumnote) ) THEN
                        v_media := -1;
                        SELECT INTO v_soma_grau_final count(*) FROM acddegreeenroll WHERE enrollid = p_enrollid AND degreeid = v_fatherdegree.degreeid;
                        IF ( v_soma_grau_final > 0 ) THEN
                            INSERT INTO acddegreeenroll (note,enrollid,degreeid,recorddate,description) VALUES (NULL,p_enrollid,v_fatherdegree.degreeid, now() - interval '2 second', 'NOTA EXCLUÍDA AUTOMATICAMENTE');                        
                        END IF;
                    END IF;
                END IF;
             END IF;
           
           
           v_nota_antiga:= AA.note 
                           FROM acddegreeenroll AA
                          WHERE AA.enrollId = p_enrollid  
                            AND AA.degreeid = v_fatherdegree.degreeid ORDER BY aa.recorddate desc LIMIT 1;

           RAISE NOTICE ' DEBUG ANTIGA % NOVA %',v_nota_antiga,round(v_media::numeric,2);

           -- GRAVA
           --Se a média foi recalculada
           --E
           ----não havia nota antes
           ----OU Se a nota recalculada for diferente da antiga
           IF( v_media != -1 AND ( v_nota_antiga IS NULL OR (v_nota_antiga != round(v_media::numeric,2)) ) )
           --IF( (v_nota_antiga IS NULL AND v_media != -1) OR (v_nota_antiga != round(v_media::numeric,2)) )
           THEN
           v_conta_alteracoes:= v_conta_alteracoes+1;
               RAISE NOTICE 'note = %,
                             recorddate = %
                             enrollid = %
                             degreeid = % ',v_media, now(),p_enrollid,v_fatherdegree.degreeid  ;
                             
               IF GETPARAMETER('ACADEMIC', 'CONSIDER_HIGHER_PUNCTUATION_DEGREE') = 't' THEN
                    INSERT INTO acddegreeenroll (note,enrollid,degreeid,recorddate,description) VALUES (NULL,p_enrollid,v_fatherdegree.degreeid, now() - interval '1 second', 'NOTA EXCLUÍDA AUTOMATICAMENTE');
               END IF;
                          
               INSERT INTO acddegreeenroll (note,enrollid,degreeid,recorddate,description) VALUES (round(v_media::numeric,2),p_enrollid,v_fatherdegree.degreeid, now(), 'Média recalculada automaticamente por alteração em uma das notas que compõem essa nota');
           END IF;
           RAISE NOTICE 'notas modificadas %',v_conta_alteracoes;
        END LOOP;
    END;
    END IF;
    RETURN TRUE;
END;
$$;


ALTER FUNCTION public.calculanota(p_enrollid integer) OWNER TO postgres;

--
-- Name: calculanota_unemat(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION calculanota_unemat() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: calculanota
  DESCRIPTION: 

  REVISIONS:
  Ver       Date       Author             Description
  --------- ---------- -----------------  ------------------------------------
  1.0       10-12-2012 ftomasini          FUNÇÃO responsável por calcular 
                                          composição de graus acadêmicos
******************************************************************************/
DECLARE

    v_fatherdegree record;
    v_learningperiodId integer;
    v_media float;
    v_notas record;
    v_exame record;
    v_conta_notas integer;
    v_somatorio_notas float;
    v_nota_antiga float;
    v_conta_alteracoes integer;
    v_notas_obrigatorias record;
    v_notas_obrigatorias_preenchidas boolean;
    v_groupId integer;
    v_media_atual double precision;
    v_isclosed boolean;

BEGIN
    --verifica se a disciplia oferecida está fechada e não realiza a verificação das notas/graus/obrigatóriedade
    SELECT A.isclosed INTO v_isclosed
      FROM acdgroup A 
INNER JOIN acdenroll B
        ON A.groupid = B.groupid
     WHERE B.enrollid = NEW.enrollId;

    IF v_isclosed = TRUE THEN
        RETURN NEW;
    END IF;

       v_conta_alteracoes:=0;
       v_notas_obrigatorias_preenchidas = TRUE;

    -- Obtém o período letivo da matrícula  
    SELECT b.learningperiodid INTO v_learningperiodId
      FROM acdenroll A
INNER JOIN acdgroup B
        ON A.groupid = B.groupid
     WHERE enrollid = NEW.enrollId;

    -- Obtém a disciplina oferecida
    SELECT b.groupid INTO v_groupId
      FROM acdenroll A
INNER JOIN acdgroup B
        ON A.groupid = B.groupid
     WHERE enrollid = NEW.enrollId;

    RAISE NOTICE 'Período letivo % ',v_learningperiodId ;

    --Verifica se tem nota de exame para a matrícula
    SELECT B.note, A.examcalcmethod INTO v_exame
      FROM acddegree A
INNER JOIN acddegreeenroll B 
        ON b.degreeid = a.degreeid
     WHERE enrollid = NEW.enrollId
       AND isexam ='t'
       AND note IS NOT NULL 
  ORDER BY recorddate desc 
     LIMIT 1;

    --Percorre todas as notas que devem ser calculadas média, nota final
    FOR v_fatherdegree IN SELECT AA.degreeid,
                                 AA.parentdegreeid,
                                 AA.degreenumber
                            FROM acddegree AA
                           WHERE AA.degreeid IN (SELECT parentdegreeid
                                                   FROM acddegree A 
                                                  WHERE A.learningperiodid = v_learningperiodId
                                               GROUP BY 1
                                                 HAVING count(parentdegreeid) >1)
                        GROUP BY AA.degreeid,AA.parentdegreeid,AA.parentdegreeid,AA.degreenumber
                        ORDER BY AA.parentdegreeid ASC, AA.degreenumber

    LOOP

        RAISE NOTICE 'Nota pai % ',v_fatherdegree.degreeid ;

        --zera a média
        v_media:= -1;
        --
        --Percorre as notas e mostra seu valor
        --
        v_conta_notas:=0;
        v_somatorio_notas:=0;

        FOR v_notas
         IN SELECT (SELECT AA.note 
                                 FROM acddegreeenroll AA
                                WHERE AA.enrollId = B.enrollid  
                                  AND AA.degreeid = A.degreeid ORDER BY aa.recorddate desc LIMIT 1) AS note,
                              a.description
                         FROM acddegree A
                   INNER JOIN acddegreeenroll B 
                           ON b.degreeid = a.degreeid
                        WHERE A.parentdegreeid = v_fatherdegree.degreeid
                          AND enrollid = NEW.enrollId
                          AND isexam ='f' 
                          AND note IS NOT NULL
                     GROUP BY a.description, a.degreeid, b.enrollid
        LOOP
            IF ( v_notas.note IS NOT NULL ) THEN
            BEGIN
                RAISE NOTICE 'Nota filho nome -  % - valor: %',v_notas.description, v_notas.note;
                v_conta_notas:= v_conta_notas +1;
                v_somatorio_notas:= v_somatorio_notas + v_notas.note;
            END;
            END IF;

        END LOOP;

        --Cálculo da média
        IF ( v_conta_notas::integer != 0 )
        THEN
            v_media:= (v_somatorio_notas/v_conta_notas::integer);
        END IF;

        RAISE NOTICE ' A média será %',v_media;

         --Testa se for grau final
        IF (v_fatherdegree.parentdegreeid IS NULL)
        THEN
            --Se existe nota de exame para a matricula
            IF(v_exame.note IS NOT NULL)
            THEN
                --Se a forma de calculo for (substitui grau pai)
                IF(v_exame.examcalcmethod = 'S')
                THEN
                    RAISE NOTICE 'Exame substitui grau final % ',v_exame.note;
                    v_media:= v_exame.note;
                END IF;
                --Se a forma de calculo for (media com grau pai)
                IF(v_exame.examcalcmethod = 'M')
                THEN
                    RAISE NOTICE 'Exame média com grau final % ',((v_exame.note + v_media)/2);
                    v_media:= ((v_exame.note + v_media)/2);
                END IF;
            END IF;
         END IF;

       v_nota_antiga:= AA.note 
                       FROM acddegreeenroll AA
                      WHERE AA.enrollId = NEW.enrollId  
                        AND AA.degreeid = v_fatherdegree.degreeid ORDER BY aa.recorddate desc LIMIT 1;

       RAISE NOTICE ' DEBUG ANTIGA % NOVA %',v_nota_antiga,round(v_media::numeric,2);

       -- Verifica se todas as notas obrigatórias foram preenchidas
       FOR v_notas_obrigatorias IN SELECT i.degreeid
                                     FROM acdgroup g
                               INNER JOIN acdlearningperiod h
                                       ON g.learningperiodid = h.learningperiodid
                               INNER JOIN acddegree i
                                       ON i.learningperiodid = h.learningperiodid  
                                    WHERE g.groupid =  v_groupId
                                      AND isexam ='f'
                                      AND parentdegreeid = v_fatherdegree.degreeid
                                      AND maybenull = 'f'
                                      AND i.degreeid NOT IN (SELECT degreeid FROM acddegree WHERE parentdegreeid = i.degreeid)
       LOOP
           IF ((SELECT note FROM acddegreeenroll WHERE degreeid = v_notas_obrigatorias.degreeid AND enrollid = NEW.enrollId ORDER BY recorddate DESC LIMIT 1) IS NULL)
           THEN            
               v_notas_obrigatorias_preenchidas = FALSE;
           END IF;    
       END LOOP;

       IF ( v_notas_obrigatorias_preenchidas IS FALSE ) THEN
       BEGIN
            SELECT INTO v_media_atual note FROM acddegreeenroll WHERE degreeid = v_fatherdegree.degreeid AND enrollid = NEW.enrollId ORDER BY recorddate DESC LIMIT 1;
            IF v_media_atual IS NOT NULL THEN
            INSERT INTO acddegreeenroll (note,enrollid,degreeid,recorddate,description) VALUES (NULL,NEW.enrollId,v_fatherdegree.degreeid, now(), 'Média excluída por falta de uma nota obrigatória.');
            END IF;
       END;
       END IF;

       -- GRAVA
       --Se a média foi recalculada
       --E
       --Notas obrigatórias preenchidas
       --E
       ----não havia nota antes
       ----OU Se a nota recalculada for diferente da antiga
       IF( v_notas_obrigatorias_preenchidas AND v_media != -1 AND ( v_nota_antiga IS NULL OR (v_nota_antiga != round(v_media::numeric,2)) ) )
       --IF( (v_nota_antiga IS NULL AND v_media != -1) OR (v_nota_antiga != round(v_media::numeric,2)) )
       THEN
       v_conta_alteracoes:= v_conta_alteracoes+1;
           RAISE NOTICE 'note = %,
                         recorddate = %
                         enrollid = %
                         degreeid = % ',v_media, now(),NEW.enrollId,v_fatherdegree.degreeid  ;

           INSERT INTO acddegreeenroll (note,enrollid,degreeid,recorddate,description) VALUES (round(v_media::numeric,2),NEW.enrollId,v_fatherdegree.degreeid, NEW.recorddate + interval '30 second' * random(), 'Média recalculada automaticamente por alteração em uma das notas que compõem essa nota');

       END IF;
       RAISE NOTICE 'notas modificadas %',v_conta_alteracoes;
    END LOOP;
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.calculanota_unemat() OWNER TO postgres;

--
-- Name: capitalize_string(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION capitalize_string(p_texto character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*********************************************************************************************
  NAME: capitalize_string
  PURPOSE: Aplica estilo "Camel Case" em uma string, nome de cidade por exemplo.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       30/08/2011 Arthur Lehdermann 1. FUNÇÃO criada.
*********************************************************************************************/
DECLARE
    v_palavra VARCHAR;
    v_texto VARCHAR[];
    v_texto_retorno VARCHAR;
BEGIN
    v_texto_retorno := '';
    -- Percorre as palavras para alterar para "Camel Case"
    FOR v_palavra IN SELECT explode_array(string_to_array(p_texto, ' '))
    LOOP
        -- Se for alguma dessas palavras deixa minúscula a palavra
        IF LOWER(v_palavra) IN ( 'da', 'de', 'do', 'das', 'dos', 'os', 'as', 'e', 'a', 'ou' )
        THEN
            v_palavra := LOWER(v_palavra);
        ELSE -- Caso contrério a primeira letra maiúscula
            v_palavra := initcap(v_palavra);
        END IF;

        -- Vai remontando o texto
        v_texto_retorno := v_texto_retorno || ' ' || v_palavra;
    END LOOP;

    -- Retorna o texto recebido por parémetro em "Camel Case"
    RETURN v_texto_retorno;
END
$$;


ALTER FUNCTION public.capitalize_string(p_texto character varying) OWNER TO postgres;

--
-- Name: centercoordinatorprofessorstimesheets(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION centercoordinatorprofessorstimesheets(p_directorid integer, p_querymonth integer, p_queryyear integer) RETURNS SETOF t_professortimesheet
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: centerCoordinatorProfessorsTimeSheets
  PURPOSE: Retorna a planilha de horas de todos os professores vinculados ao
  coordenador de centro passado por parâmetro, no mês e ano especificados.
  DESCRIPTION: Faz uma busca pelos professores que têm aula em cursos dos quais a
  pessoa passada por parâmetro (p_directorId) é coordenador de centro. Para
  cada professor encontrado, retorna a sua planilha de horas.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       01/07/2011 Alexandre Schmidt 1. Função criada.
**************************************************************************************/
DECLARE
    v_row RECORD;
    v_subrow RECORD;
BEGIN
    -- seleciona todos os professors que dão aula em cursos
    -- de centros dos quais p_directorId é diretor
    FOR v_row IN SELECT DISTINCT F.professorId
                   FROM acdCenter A
             INNER JOIN acdCourse B
                     ON B.centerId = A.centerId
             INNER JOIN acdCurriculum C
                     ON C.courseId = B.courseId
             INNER JOIN acdGroup D
                     ON D.curriculumId = C.curriculumId
             INNER JOIN acdSchedule E
                     ON E.groupId = D.groupId
             INNER JOIN acdScheduleProfessor F
                     ON F.scheduleId = E.scheduleId
                  WHERE A.directorId = p_directorId
               ORDER BY 1
    LOOP
        -- para cada professor encontrado, retornar a planilha de horas
        FOR v_subrow IN SELECT *
                             FROM professorTimeSheet(v_row.professorId,
                                                     p_queryMonth,
                                                     p_queryYear,
                                                     p_queryMonth,
                                                     p_queryYear,
                                                     NULL,
                                                     NULL,
                                                     NULL,
                                                     NULL) A
        LOOP
            RETURN NEXT v_subrow;
        END LOOP;
    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION public.centercoordinatorprofessorstimesheets(p_directorid integer, p_querymonth integer, p_queryyear integer) OWNER TO postgres;

--
-- Name: certifiednumber_generate(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION certifiednumber_generate() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
   BEGIN
       UPDATE acdcertified SET certifiednumber = (SELECT CASE WHEN (max(certifiednumber)) > 0 THEN max(certifiednumber) + 1 ELSE 1 END FROM acdCertified WHERE EXTRACT('year' FROM dateIssue) = (SELECT EXTRACT('year' FROM NEW.dateIssue))) WHERE certifiedid = NEW.certifiedid;
       return NULL;
   END;
   $$;


ALTER FUNCTION public.certifiednumber_generate() OWNER TO postgres;

--
-- Name: check_acphorario(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION check_acphorario() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
            DECLARE
                existe int;
            BEGIN

                SELECT count(*) INTO existe from acphorario where gradehorarioid=NEW.gradehorarioid and horainicio=NEW.horainicio and horafim=NEW.horafim and diasemana=NEW.diasemana;

                IF existe>0 THEN
                    RAISE EXCEPTION 'Eu já tenho registrado este horário para esta disciplina. Não posso deixar você cadastrá-lo novamente, pois me daria uma enorme dor de cabeça.';
                END IF;

        RETURN NEW;
            END;
        $$;


ALTER FUNCTION public.check_acphorario() OWNER TO postgres;

--
-- Name: check_acphorarioofertacomponentecurricular(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION check_acphorarioofertacomponentecurricular() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
            DECLARE
                existe int;
            BEGIN

                SELECT count(*) INTO existe from acpHorarioOfertaComponenteCurricular where ofertaComponenteCurricularId=NEW.ofertaComponenteCurricularId and personId=NEW.personId and horarioId=NEW.horarioId and physicalResourceId=NEW.physicalResourceId and diaSemana=NEW.diaSemana;

                IF existe>0 THEN
                    RAISE EXCEPTION 'Eu já tenho cadastrada uma ocorrência de horário para esta disciplina com estes mesmos parâmetros que você está tentando inserir. Verifique as ocorrências de horários já existentes para esta disciplina, pois de outra forma não poderei deixar você continuar o que está fazendo.<br><br>Me desculpe, não é nada pessoal, mas minha obrigação é manter a integridade de dados do sistema.';
                END IF;

        RETURN NEW;
            END;
        $$;


ALTER FUNCTION public.check_acphorarioofertacomponentecurricular() OWNER TO postgres;

--
-- Name: checktimeiddependance(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION checktimeiddependance() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: checkTimeIdDependance
  PURPOSE: Evitar que registros da acdSchedule sofram alterações sem checagem de
           dependência.
  DESCRIPTION:
  Trigger que aborta qualquer operação sobre a acdSchedule se já existirem frequências
  registradas para algum horário que está se tentando remover da lista de horários da
  disciplina.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       10/06/2011 Alex Smith        1. Função criada.
  1.1       06/01/2012 Moises Heberle    1. Trocado de RAISE WARNING para
                                             RAISE EXCEPTION para exibir erro
                                             no formulario
                                             Horario da disciplina oferecida.
                                         2. Adicionado verificacao de datas que
                                             ja possuem frequencias registradas.
**************************************************************************************/
DECLARE
    v_abort boolean;
    v_error_msg text[];
    v_retVal RECORD;
BEGIN
    IF TG_OP = 'UPDATE' THEN
        IF OLD.timeIds != NEW.timeIds OR NEW.timeIds IS NULL OR OLD.timeIds IS NULL OR
           OLD.occurrenceDates != NEW.occurrenceDates OR NEW.occurrenceDates IS NULL OR OLD.occurrenceDates IS NULL
        THEN
            -- Verifica existência de alguma frequência em um
            -- timeId que será excluído se a operação for
            -- realizada.
            IF (SELECT COUNT(*)
              FROM acdFrequenceEnroll
             WHERE scheduleId = OLD.scheduleId
               AND timeId IN (SELECT UNNEST(OLD.timeIds)
                              EXCEPT
                              SELECT UNNEST(NEW.timeIds))) > 0
            THEN
                v_error_msg = array_append(v_error_msg, 'Há registros de frequência registrados dependentes do(s) horário(s) desmarcado(s).');
            END IF;

            --
            -- Verifica se alguma das datas removidas tem registro de frequencia na acdFrequenceEnroll
            --
            IF (SELECT COUNT(*)
              FROM acdFrequenceEnroll
             WHERE scheduleId = OLD.scheduleId
               AND frequencyDate IN (SELECT UNNEST(OLD.occurrenceDates)
                                     EXCEPT
                                     SELECT UNNEST(NEW.occurrenceDates))) > 0
            THEN
                v_error_msg = array_append(v_error_msg, 'Há registros de frequência registrados dependentes da(s) data(s) desmarcada(s).');
            END IF;

            -- Exibe erro caso tenha e aborta atualizacao de registro
            IF (SELECT COUNT(*) FROM UNNEST(v_error_msg)) > 0
            THEN
                RAISE EXCEPTION 'Alteração abortada.<br> %s', ARRAY_TO_STRING(v_error_msg, '<br>');
                RETURN NULL;
            ELSE
                RETURN NEW;
            END IF;
        ELSE
            RETURN NEW;
        END IF;
    ELSIF TG_OP = 'DELETE' THEN
        -- Verifica existência de alguma frequência em um
        -- timeId que será excluído se a operação for
        -- realizada.
        SELECT COUNT(*) > 0 INTO v_abort
          FROM acdFrequenceEnroll
         WHERE scheduleId = OLD.scheduleId
           AND timeId = ANY(OLD.timeIds);

        IF v_abort THEN
            RAISE EXCEPTION 'Exclusão abortada. Há registros de frequência dependentes deste horário.';
            RETURN NULL;
        ELSE
            RETURN OLD;
        END IF;
    END IF;
END;
$$;


ALTER FUNCTION public.checktimeiddependance() OWNER TO postgres;

--
-- Name: checkvalidparameter(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION checkvalidparameter(p_module text, p_parameter text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/***************************************************************
  NAME: checkValidParameter
  PURPOSE: Retorna verdadeiro se o parâmetro existe, e falso
           caso contrário.
****************************************************************/
DECLARE
    v_exits boolean;
    
BEGIN

    SELECT INTO v_exits count(*) > 0 FROM basconfig WHERE UPPER(parameter) = UPPER(p_parameter) AND UPPER(moduleconfig) = UPPER(p_module);

    IF v_exits THEN
        RETURN true;
    ELSE    
        RETURN false;
    END IF;

END;
$$;


ALTER FUNCTION public.checkvalidparameter(p_module text, p_parameter text) OWNER TO postgres;

--
-- Name: chk_accountschemeid_not_used_in_operations(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION chk_accountschemeid_not_used_in_operations(p_accountschemeid character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: chk_accountschemeid_not_used_in_operations
  PURPOSE: Verifica se o plano de contas selecionado não possui operações vinculadas
  DESCRIPTION:

  REVISIONS: 
  Ver       Date       Author            Description 
  --------- ---------- ----------------- ------------------------------------ 
  1.0       22/11/2010 Fabiano Tomasini 1. Função criada.
**************************************************************************************/ 
DECLARE
    v_count integer;
BEGIN
    SELECT COUNT(*) INTO v_count
      FROM finoperation A
     WHERE A.accountschemeid = p_accountschemeid;
   
    IF ( v_count != 0 ) THEN
    RAISE NOTICE 'The account scheme % selected has operations linked.', p_accountschemeid;
    END IF;

    RETURN (v_count = 0);

END;
$$;


ALTER FUNCTION public.chk_accountschemeid_not_used_in_operations(p_accountschemeid character varying) OWNER TO postgres;

--
-- Name: chk_evaluation_control_method(integer, boolean, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION chk_evaluation_control_method(p_learningperiodid integer, p_useconcept boolean, p_curriculumid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: chk_evaluation_control_method
  PURPOSE: Verifica se o método de avalição do período letivo for por grupo de disciplinas,
  caso seja e o método de avalição seja diferente em uma disciplina  já inserida que esteja
  no mesmo eixo temático, aborta inserção da oferecida.
           .
  DESCRIPTION:

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       22/02/2011 Fabiano Tomasini 1. Função criada.
**************************************************************************************/
DECLARE
    v_count integer;
    v_evaluationControlMethodId integer;
    v_curricularComponentGroupId integer;

BEGIN
    v_count:=0;

    --Obtem o método de avaliação do período letivo
    SELECT evaluationControlMethodId INTO v_evaluationControlMethodId FROM acdlearningperiod WHERE learningperiodid = p_learningPeriodId;

    --Obtem o eixo temático da disciplina
    SELECT curricularcomponentgroupdocumentendcourseid INTO v_curricularComponentGroupId FROM acdcurriculum WHERE curriculumid = p_curriculumId;

    IF ( v_evaluationControlMethodId = 2)
    THEN
        SELECT COUNT(*) INTO v_count
          FROM acdGroup A
    INNER JOIN acdLearningPeriod B
            ON (B.learningPeriodId = A.learningPeriodId)
    INNER JOIN acdCurriculum C
            ON (C.curriculumId = A.curriculumId)
    INNER JOIN acdCurricularComponent D
            ON (D.curricularComponentId = C.curricularComponentId AND
                D.curricularComponentVersion = C.curricularComponentVersion)
         WHERE B.learningperiodId = p_learningPeriodId
           AND A.useconcept != p_useConcept
           AND C.curricularcomponentgroupdocumentendcourseid = v_curricularComponentGroupId;
    END IF;

    IF ( v_count != 0 ) THEN
    RAISE WARNING 'O método de controle de avaliação é diferente das displinas já oferecidas do mesmo eixo temático';
    END IF;

    RETURN (v_count = 0);

END;
$$;


ALTER FUNCTION public.chk_evaluation_control_method(p_learningperiodid integer, p_useconcept boolean, p_curriculumid integer) OWNER TO postgres;

--
-- Name: chk_evaluation_control_method_learning_period(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION chk_evaluation_control_method_learning_period(p_learningperiodid integer, p_evaluationcontrolmethodid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: chk_evaluation_control_method_learning_period
  PURPOSE: Não deixar alterar o método de avalição caso seja por grupo de disciplinas e exista
 disciplinas no mesmo periodo e no mesmo eixo com forma de avaliação diferentes (conceito/nota).
           .
  DESCRIPTION:

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       22/02/2011 Fabiano Tomasini  1. Função criada.
  1.1       15/04/2011 Moises Heberle    1. Funcao modificada para exibir na tela
                                            o erro (estava usando RAISE NOTICE)
**************************************************************************************/
DECLARE
    v_count integer;

BEGIN
    v_count:=0;

    IF ( p_evaluationcontrolmethodid = 2)
    THEN
        SELECT count (DISTINCT B.useconcept) INTO v_count
          FROM acdLearningPeriod A
    INNER JOIN acdGroup B
            ON (B.learningperiodId = A.learningperiodId)
    INNER JOIN acdCurriculum C
            ON (B.curriculumId = C.curriculumId)
         WHERE  A.learningperiodId = p_learningPeriodId;
    END IF;

    IF ( v_count > 1) THEN
        RAISE EXCEPTION 'O método de controle de avaliação não pode ser ser mudado para grupo de disciplinas pois existem displinas já oferecidas neste mesmo período letivo com tipos diferentes de avaliação (conceito/nota)';
    END IF;

    RETURN (v_count <= 1);
END;
$$;


ALTER FUNCTION public.chk_evaluation_control_method_learning_period(p_learningperiodid integer, p_evaluationcontrolmethodid integer) OWNER TO postgres;

--
-- Name: chk_insert_policy_discount(boolean, double precision, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION chk_insert_policy_discount(p_ispercent boolean, p_discountvalue double precision, p_beginclassperiod integer, p_endclassperiod integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: chk_insert_policy_discount
  PURPOSE: (Se percentual for Sim então Valor não pode ser maior que 100) e 
  (Se Periodo inicial for preenchido, então Periodo final também deve ser e vice-versa)

  REVISIONS: 
  Ver       Date       Author            Description 
  --------- ---------- ----------------- ------------------------------------ 
  1.0       26/11/2010 Fabiano Tomasini 1. Função criada.
**************************************************************************************/ 
DECLARE
    v_return boolean;

BEGIN
    
    IF (p_ispercent = TRUE AND p_discountValue > 100 )
    THEN
        RAISE NOTICE 'O valor percentual % é maior que 100.', p_discountValue;
        v_return = FALSE;
    END IF;

    IF ((p_beginclassperiod IS NOT NULL ) OR (p_endclassperiod IS NOT NULL))
    THEN
        IF ((p_beginclassperiod IS NULL ))
        THEN
            RAISE NOTICE 'Um registro não foi preenchido com o período inicial.';
            v_return = FALSE;
        END IF;

        IF ((p_endclassperiod  IS NULL ))
        THEN
            RAISE NOTICE 'Um registro não foi preenchido com o período final.';
            v_return = FALSE;
        END IF;
    END IF;

    RETURN v_return;

END;
$$;


ALTER FUNCTION public.chk_insert_policy_discount(p_ispercent boolean, p_discountvalue double precision, p_beginclassperiod integer, p_endclassperiod integer) OWNER TO postgres;

--
-- Name: chk_unique_course_occurrence(bigint, character varying, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION chk_unique_course_occurrence(p_personid bigint, p_courseid character varying, p_courseversion integer, p_unitid integer, p_turnid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: chk_unique_course_occurrence
  PURPOSE: Verifica se tem um contrato com o mesmo personId, courseId, courseVersion,
  unitId, turnId e se esté fechado.
  DESCRIPTION:

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       18/11/2010 Alexandre Schmidt 1. FUNÇÃO criada.
  1.1       23/12/2010 Arthur Lehdermann 1. Alterado texto do alerta.
  1.2       22/06/2011 Alexandre Schmidt 1. Corrigido bug que impedia alteraçães em
                                            contratos jé desativados.
**************************************************************************************/
DECLARE
    v_count integer;
BEGIN
    SELECT COUNT(*) INTO v_count
      FROM acdContract
     WHERE courseId = p_courseId
       AND courseVersion = p_courseVersion
       AND turnId = p_turnId
       AND unitId = p_unitId
       AND personId = p_personId
       AND getContractState(contractId) IN (SELECT stateContractId
                                              FROM acdStateContract
                                             WHERE inOutTransition != 'O');

    IF ( v_count > 1 ) THEN
        RAISE NOTICE 'Pessoa % possui mais de um contrato para o curso %/%, unidade %, turno %.', p_personId, p_courseId, p_courseVersion, p_unitId, p_turnId;
    END IF;

    RETURN (v_count < 2);

END;
$$;


ALTER FUNCTION public.chk_unique_course_occurrence(p_personid bigint, p_courseid character varying, p_courseversion integer, p_unitid integer, p_turnid integer) OWNER TO postgres;

--
-- Name: compareyearperiod(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION compareyearperiod(searchcontent character varying, field1 character varying, field2 character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE

        auxF1 varchar;
        auxF2 varchar;
        f1 varchar;
        f2 varchar;

        BEGIN

            IF strpos(searchContent, '-') <= 0 THEN
                RETURN FALSE;
            END IF;

            RAISE NOTICE ' == SearchContent: %, field1: %, field2: %; ', searchContent, field1, field2;

            auxF1   := getSearchContentToYearCompare(split_part(searchContent, '-', 1), FALSE);
            auxF2   := getSearchContentToYearCompare(split_part(searchContent, '-', 2), FALSE);
            f1      := getSearchContentToYearCompare(field1, FALSE);
            f2      := getSearchContentToYearCompare(field2, FALSE);

            IF char_length(auxF1) = 0 THEN
                auxF1 = 0;
            END IF;

            IF char_length(auxF2) = 0 THEN
                auxF2 = date_part('year', now());
            END IF;

            RAISE NOTICE ' == (split 1 % >= field1 % ) AND ( split2 % <= field2 % )', auxF1, f1,  auxF2,  f2;

            RETURN ((auxF1::integer >= f1::integer) AND (auxF2::integer <= f2::integer));

        END;

$$;


ALTER FUNCTION public.compareyearperiod(searchcontent character varying, field1 character varying, field2 character varying) OWNER TO postgres;

--
-- Name: convertdegrees(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION convertdegrees() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    learningPeriodLine RECORD;
    enrollLine RECORD;
    totalLp int;
    totalEn int;
    finalDegreeId int;
    averageDegreeId int;
    examDegreeId int;
BEGIN
    totalLp := 0;
    totalEn := 0;
    
    RAISE NOTICE 'Beginning conversion...';
    FOR learningPeriodLine IN SELECT * FROM acdLearningPeriod LOOP
        SELECT acdDegree.degreeId INTO finalDegreeId FROM acdDegree WHERE acdDegree.learningPeriodId = learningPeriodLine.learningPeriodId AND acdDegree.parentDegreeId IS NULL AND acdDegree.degreeNumber = 0;
    
        IF finalDegreeId IS NULL THEN
            SELECT nextVal('seq_degreeId') INTO finalDegreeId;
            
            INSERT INTO acdDegree (degreeId, learningPeriodId, description, degreeNumber) VALUES (finalDegreeId, learningPeriodLine.learningPeriodId, 'NOTA FINAL', 0);
            
            SELECT nextVal('seq_degreeId') INTO examDegreeId;
            
            INSERT INTO acdDegree (degreeId, learningPeriodId, description, degreeNumber, parentDegreeId, mayBeNull) VALUES (examDegreeId, learningPeriodLine.learningPeriodId, 'EXAME', 2, finalDegreeId, true);
            
            SELECT nextVal('seq_degreeId') INTO averageDegreeId;
            
            INSERT INTO acdDegree (degreeId, learningPeriodId, description, degreeNumber, parentDegreeId) VALUES (averageDegreeId, learningPeriodLine.learningPeriodId, 'MEDIA', 1, finalDegreeId);
            
            UPDATE acdDegree SET parentDegreeId = averageDegreeId WHERE learningPeriodId = learningPeriodLine.learningPeriodId AND degreeId NOT IN (finalDegreeId, averageDegreeId, examDegreeId);
            
            FOR enrollLine IN SELECT A.enrollId, A.note, A.examNote, A.finalNote, A.concept FROM acdEnroll A INNER JOIN acdGroup B ON (B.groupId = A.groupId) WHERE B.learningPeriodId = learningPeriodLine.learningPeriodId LOOP
                IF (enrollLine.note IS NOT NULL) THEN
                    INSERT INTO acdDegreeEnroll (degreeId, enrollId, note) VALUES (averageDegreeId, enrollLine.enrollId, enrollLine.note);
                END IF;
                
                IF (enrollLine.examNote IS NOT NULL) THEN
                    INSERT INTO acdDegreeEnroll (degreeId, enrollId, note) VALUES (examDegreeId, enrollLine.enrollId, enrollLine.examNote);
                END IF;
                
                IF (enrollLine.finalNote IS NOT NULL OR enrollLine.concept IS NOT NULL) THEN
                    INSERT INTO acdDegreeEnroll (degreeId, enrollId, note, concept) VALUES (finalDegreeId, enrollLine.enrollId, enrollLine.finalNote, enrollLine.concept);
                END IF;
                
                totalEn := totalEn + 1;
            END LOOP;
        ELSE
            RAISE NOTICE 'Learning period % already has a final degree registered. The changes must be made manually.', learningPeriodLine.learningPeriodId;
        END IF;
        
        totalLp := totalLp + 1;
    END LOOP;
    RAISE NOTICE '% learning periods readed and the data of % enrolls was processed.', totalLp, totalEn;
    RETURN TRUE;
END 
$$;


ALTER FUNCTION public.convertdegrees() OWNER TO postgres;

--
-- Name: convertschedule(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION convertschedule() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    scheduleLine RECORD;
    academicLine RECORD;
    occurrenceDates_ date[];
    total int;
BEGIN
    total := 0;
	CREATE TEMP TABLE log_conversion(message text, datetime timestamp default now());
    RAISE NOTICE 'Beginning conversion...';
    FOR scheduleLine IN SELECT * FROM acdSchedule LOOP
        FOR academicLine IN SELECT occurrenceDate FROM acdAcademicCalendar WHERE acdAcademicCalendar.learningPeriodId = scheduleLine.learningPeriodId AND acdAcademicCalendar.weekDayId = scheduleLine.weekDayId AND occurrenceDate NOT IN (SELECT occurrenceDate FROM acdAcademicCalendarAdjustments WHERE acdAcademicCalendarAdjustments.learningPeriodId = scheduleLine.learningPeriodId AND inOut = FALSE) UNION SELECT occurrenceDate FROM acdAcademicCalendarAdjustments WHERE acdAcademicCalendarAdjustments.learningPeriodId = scheduleLine.learningPeriodId AND inOut = TRUE LOOP
            occurrenceDates_ := array_append(occurrenceDates_, academicLine.occurrenceDate);
        END LOOP;
        IF occurrenceDates_  IS NULL THEN
			-- Quando não existir datas de ocorrência, exclui a linha atual do acdSchedule - Ticket #1824
			INSERT INTO log_conversion (message) VALUES ('SCHEDULE ID: '||scheduleLine.scheduleId);
			-- RAISE NOTICE 'ScheduleId % not converted, actual scheduleId do not have ocurrence dates registered', scheduleLine.scheduleId;
        ELSE
            UPDATE acdSchedule SET occurrenceDates = occurrenceDates_ WHERE scheduleId = scheduleLine.scheduleId;
            occurrenceDates_ := NULL;
            UPDATE acdSchedule SET timeIds = timeIds||scheduleLine.scheduleLearningPeriodId WHERE scheduleId = scheduleLine.scheduleId;
            total := total+1;
        END IF;
    END LOOP;
    RAISE NOTICE '% schedule keys converted', total;
	INSERT INTO log_conversion (message)VALUES (total||' schedule keys converted');
	COPY log_conversion TO '/tmp/log_conversion.log' DELIMITER '|';
	RAISE NOTICE 'Conversion data saved on /tmp/log_conversion.log on database server cluster, containing data information about schedule keys data that don''t have occurrence dates registered';
    RETURN TRUE;
END 
$$;


ALTER FUNCTION public.convertschedule() OWNER TO postgres;

--
-- Name: coordinatorprofessorstimesheets(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION coordinatorprofessorstimesheets(p_coordinatorid integer, p_querymonth integer, p_queryyear integer) RETURNS SETOF t_professortimesheet
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: coordinatorProfessorsTimeSheets
  PURPOSE: Retorna a planilha de horas de todos os professores vinculados ao
  coordenador de curso passado por parâmetro, no mês e ano especificados.
  DESCRIPTION: Faz uma busca pelos professores que têm aula em cursos dos quais a
  pessoa passada por parâmetro (p_coordinatorId) é coordenador. Para cada professor
  encontrado, retorna a sua planilha de horas.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       01/07/2011 Alexandre Schmidt 1. Função criada.
  1.1       09/01/2014 Bruno E. Fuhr     2. Ajuste ao chamar a função professorTimeSheet
**************************************************************************************/
DECLARE
    v_row RECORD;
    v_subrow RECORD;
    v_subsubrow RECORD;
BEGIN
    -- seleciona todos os professors que dão aula em cursos
    -- coordenados pelo v_coordinatorId
    FOR v_row IN SELECT DISTINCT A.professorId
                            FROM acdScheduleProfessor A
                      INNER JOIN acdSchedule B
                              ON B.scheduleId = A.scheduleId
                      INNER JOIN acdGroup C
                              ON C.groupId = B.groupId
                      INNER JOIN acdCurriculum D
                              ON D.curriculumId = C.curriculumId
                      INNER JOIN acdCourseCoordinator E
                              ON E.courseId = D.courseId
                             AND E.courseVersion = D.courseVersion
                             AND E.unitId = D.unitId
                             AND E.turnId = D.turnId
                           WHERE E.coordinatorId = p_coordinatorId
                        ORDER BY 1
    LOOP
        -- para cada professor encontrado, retornar a planilha de horas
        FOR v_subsubrow IN SELECT *
                             FROM professorTimeSheet(v_row.professorId::int,
                                                     p_queryMonth,
                                                     p_queryYear,
                                                     p_queryMonth,
                                                     p_queryYear,
                                                     NULL,
                                                     NULL,
                                                     NULL,
                                                     NULL) A
        LOOP
        BEGIN
            RAISE NOTICE '%', v_row.professorId;
            RETURN NEXT v_subsubrow;
        END;
        END LOOP;
    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION public.coordinatorprofessorstimesheets(p_coordinatorid integer, p_querymonth integer, p_queryyear integer) OWNER TO postgres;

--
-- Name: corrigeindicadores(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION corrigeindicadores() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    DECLARE

        row_data RECORD;

        BEGIN

            FOR row_data IN (SELECT DISTINCT controlNumber, fieldid, indicator1, indicator2 FROM gtcmaterial
                            WHERE subfieldid = '#' AND (char_length(indicator1) > 0 OR char_length(indicator2) > 0) )
            LOOP
                UPDATE  gtcMaterial
                SET     indicator1      = row_data.indicator1,
                        indicator2      = row_data.indicator2
                WHERE   controlNumber   = row_data.controlNumber
                AND     fieldid         = row_data.fieldid;
            END LOOP;

            DELETE FROM gtcmaterial WHERE subfieldid = '#';

            RETURN TRUE;

        END;

$$;


ALTER FUNCTION public.corrigeindicadores() OWNER TO postgres;

--
-- Name: corrigemovimentacoescontratuaisdematricula(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION corrigemovimentacoescontratuaisdematricula() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: corrigeMovimentacoesContratuaisDeMatricula
  PURPOSE: Corrige as movimentações de matrícula sem período letivo.
  DESCRIPTION: vide "PURPOSE".
 REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       18/12/2013 Augusto A. Silva  1. Função criada.
**************************************************************************************/
DECLARE
	V_MOVIMENTACOES RECORD;
	V_CONTRATO RECORD;
	V_PERIODOS_LETIVOS RECORD;
	V_PERIODO_LETIVO INT;
BEGIN

	FOR V_MOVIMENTACOES IN
		( SELECT DISTINCT contractid,
			 statecontractid,
			 statetime
		    FROM acdmovementcontract
		   WHERE statecontractid = getParameter('BASIC', 'STATE_CONTRACT_ID_ENROLLED')::INT
		     AND learningPeriodId IS NULL )
	LOOP
		SELECT INTO V_CONTRATO 
			    contractId,
			    courseId,
			    courseVersion,
			    turnId,
			    unitId
		       FROM acdContract
		      WHERE contractid = V_MOVIMENTACOES.contractid;

		
		SELECT INTO V_PERIODO_LETIVO learningPeriodId
		       FROM acdLearningPeriod
		      WHERE V_MOVIMENTACOES.statetime::DATE BETWEEN beginDate AND endDate
			AND ( courseId,
			      courseVersion,
			      turnId,
			      unitId ) = ( V_CONTRATO.courseId,
					   V_CONTRATO.courseVersion,
					   V_CONTRATO.turnId,
					   V_CONTRATO.unitId );

		UPDATE acdmovementcontract
		   SET learningPeriodId = V_PERIODO_LETIVO
		 WHERE ( contractid,
			 statecontractid,
			 statetime ) = ( V_MOVIMENTACOES.contractid,
					 V_MOVIMENTACOES.statecontractid,
					 V_MOVIMENTACOES.statetime );

		RAISE NOTICE 'contractId = %, stateContractId = %, statetime = %, learningPeriodId = %', V_MOVIMENTACOES.contractid, V_MOVIMENTACOES.statecontractid, V_MOVIMENTACOES.statetime, V_PERIODO_LETIVO;
		
	END LOOP;
	
	RETURN TRUE;
END;
$$;


ALTER FUNCTION public.corrigemovimentacoescontratuaisdematricula() OWNER TO postgres;

--
-- Name: coursecoordinatorsheet(integer, integer, integer, integer, integer, character varying, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION coursecoordinatorsheet(p_professorid integer, p_beginmonth integer, p_beginyear integer, p_endmonth integer, p_endyear integer, p_courseid character varying, p_courseversion integer, p_unitid integer, p_turnid integer) RETURNS TABLE(courseid character varying, courseversion integer, unitid integer, turnid integer, year integer, month integer, availableprogrammedhours double precision, availablerealizedhours double precision, programmedteachhours double precision, realizedteachhours double precision, programmedpreparationhours double precision, realizedpreparationhours double precision, directionhours double precision, internalexternalactivitiesprogrammedhours double precision, internalexternalactivitiesrelizedhours double precision, totalprogrammedhours double precision, totalrealizedhours double precision)
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: courseCoordinatorSheet
  PURPOSE: Monta a tabela de horas do professor, por intervalo de tempo.
  DESCRIPTION: Recebe por parãmetro um professor, mês/ano inicial e mês/ano final.
  Opcionalmente pode receber também uma ocorrência de curso. Retorna o total de horas
  prestadas nas diferentes categorias.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       15/06/2011 Alexandre Schmidt 1. Função criada.
**************************************************************************************/
DECLARE
    v_beginDate date;
    v_endDate date;

    v_row RECORD;
BEGIN
    -- evitar ocorrências de curso informadas parcialmente (deve ser completa ou nula)
    IF COALESCE(p_courseId, p_courseVersion::varchar, p_unitId::varchar, p_turnId::varchar) IS NOT NULL THEN
        IF (p_courseId || p_courseVersion || p_unitId || p_turnId) IS NULL THEN
            RAISE EXCEPTION 'Informe uma ocorrência de curso completa (curso, versão, unidade e turno) ou deixe todos os campos em branco.';
        END IF;
    END IF;

    IF (p_beginMonth + p_beginYear+ p_endMonth + p_endYear) IS NULL THEN
        RAISE EXCEPTION 'Informe mês e ano inicial e final.';
    END IF;

    -- primeiro dia do mes escolhido como inicial
    v_beginDate = TO_DATE('01' || '/' || LPAD(p_beginMonth::varchar, 2) || '/' || LPAD(p_endYear::varchar, 4), 'dd/mm/yyyy');
    -- ultimo dia do mes escolhido como final
    v_endDate   = (TO_DATE('01' || '/' || LPAD(p_endMonth::varchar, 2)  || '/' || LPAD(p_endYear::varchar, 4), 'dd/mm/yyyy') + '1 MONTH'::interval)::date - 1;

    RAISE NOTICE 'begin: %, end: %', v_beginDate, v_endDate;

    RETURN QUERY SELECT 'CURSO'::varchar, -- curso
                        ((RANDOM()*5)::integer)::integer, -- versao
                        ((RANDOM()*5)::integer)::integer, -- unidade
                        ((RANDOM()*5)::integer)::integer, -- turno
                        ((RANDOM()*2011)::integer)::integer, -- ano
                        ((RANDOM()*12)::integer)::integer, -- mes
                        ((RANDOM()*100))::float, -- availableProgrammedHours
                        ((RANDOM()*100))::float, -- availableRealizedHours
                        ((RANDOM()*100))::float, -- programmedTeachHours
                        ((RANDOM()*100))::float, -- realizedTeachHours
                        ((RANDOM()*100))::float, -- programmedPreparationHours
                        ((RANDOM()*100))::float, -- realizedPreparationHours
                        ((RANDOM()*100))::float, -- directionHours
                        ((RANDOM()*100))::float, -- internalExternalActivitiesProgrammedHours
                        ((RANDOM()*100))::float, -- internalExternalActivitiesRelizedHours
                        ((RANDOM()*100))::float, -- totalProgrammedHours
                        ((RANDOM()*100))::float -- total
                   FROM acdCourseOccurrence;
    
END;
$$;


ALTER FUNCTION public.coursecoordinatorsheet(p_professorid integer, p_beginmonth integer, p_beginyear integer, p_endmonth integer, p_endyear integer, p_courseid character varying, p_courseversion integer, p_unitid integer, p_turnid integer) OWNER TO postgres;

--
-- Name: criarbasededadosmioloauditexterna(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION criarbasededadosmioloauditexterna(p_stringconf text, p_database text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/***************************************************************
  NAME: criarBaseDeDadosMioloAudit
  PURPOSE: Cria base de dados utilizando o db_link
  PARAMETERS: 
  p_stringConf - Configuração do host de acesso (host, user, password, port)
  p_database - nome da base a ser criada                
****************************************************************/
DECLARE
        
BEGIN

    BEGIN
	PERFORM (SELECT dblink_exec(''|| p_stringConf::TEXT ||'', 'CREATE DATABASE '|| p_database::TEXT ||';'));    
    EXCEPTION
         WHEN others THEN
             RAISE NOTICE 'NÃO FOI POSSÍVEL CRIAR A BASE DE DADOS PARA A MIOLO AUDIT CONFIGURADA NO PARAMETRO (MIOLO_AUDIT_DATABASE). Erro: % ', SQLERRM;
	     RETURN FALSE;
    END;
	 
    RETURN TRUE;
END;
$$;


ALTER FUNCTION public.criarbasededadosmioloauditexterna(p_stringconf text, p_database text) OWNER TO postgres;

--
-- Name: criatabela(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION criatabela() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
foiCriada INTEGER :=0;
tabela RECORD;
BEGIN

SELECT INTO tabela tablename FROM pg_tables where tablename='dbchanges' and schemaname = ANY (current_schemas(true));

IF tabela.tablename IS NULL
THEN
    CREATE TABLE dbChanges
        (changeId SERIAL,
         change TEXT NOT NULL,
         applied BOOLEAN NOT NULL DEFAULT 'f',
         applicationVersion INTEGER NOT NULL,
         orderchange integer,
         error text,
         applieddate TIMESTAMP);

foiCriada = 1;

END IF;
RETURN foiCriada;
END;
$$;


ALTER FUNCTION public.criatabela() OWNER TO postgres;

--
-- Name: cross_attendance_report(integer, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION cross_attendance_report(p_groupid integer, p_photopath character varying) RETURNS TABLE(order_column integer, person text, ftime text, frequency text, upload text)
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: CROSS_ATTENDANCE_REPORT
  PURPOSE: Utilizada pelo iReport, na geraÃ§Ã£o de caderno de chamada e ata de exame
  DESCRIPTION:
  Gera uma lista dos alunos matriculados em uma oferecida, juntamente com todos
  os horÃ¡rios de ocorrÃªncia desta disciplina, frequÃªncias registradas em cada
  horÃ¡rio, notas existentes e notas digitadas para cada aluno.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       11/11/2010 Fabiano Tomasini  1. FunÃ§Ã£o criada.
  1.1       11/02/2011 Alex Smith        1. FunÃ§Ã£o reescrita.
  1.2       11/02/2011 Jonas Diel        1. Adicionada condiÃ§Ã£o para obter 
  apenas a ultima ocorrencia de alteraÃ§Ã£o de cada nota
******************************************************************************/

DECLARE
    v_hasTimesAndDates BOOLEAN;
BEGIN    
    SELECT COUNT(*) > 0 INTO v_hasTimesAndDates
      FROM acdSchedule
     WHERE groupId = p_groupId
       AND array_length(occurrenceDates,1) > 0
       AND array_length(timeIds,1) > 0;

    RAISE NOTICE '%', CASE WHEN v_hasTimesAndDates THEN 'SIM' ELSE 'NAO' END;

    RETURN QUERY
        SELECT A.order_by,
               (D.name || ' - ' || D.personId)::text,
               CASE
                   WHEN A.order_by = 1 THEN (TO_CHAR(A.occurrenceDate, 'mm') || E'\n' || TO_CHAR(A.occurrenceDate, 'dd') || E'\n' || TO_CHAR(A.beginHour, 'HH24:MI') || E'\n' || TO_CHAR(A.endHour, 'HH24:MI'))::text
                   ELSE A.description::text
               END AS outData,
               CASE
                   WHEN A.order_by = 1 THEN E.frequency::text
                   ELSE COALESCE(ROUND(F.note::numeric,2)::text, F.concept::text)
               END,
               (COALESCE(p_photoPath,'') || (SELECT value FROM basconfig WHERE parameter = 'PHOTO_PATH' AND moduleConfig = 'BASIC') || D.personId || '.' || (SELECT value FROM basConfig WHERE parameter = 'PHOTO_FORMAT' AND moduleConfig = 'BASIC'))::text
          FROM (SELECT 1 AS order_by, A.groupId, B.occurrenceDate, C.timeId, D.beginHour, D.endHour, NULL AS degreeId, NULL AS description, NULL AS parentDegreeId, NULL AS degreeNumber
                  FROM acdGroup A
            INNER JOIN (SELECT A.groupId, UNNEST(A.occurrenceDates) AS occurrenceDate
                          FROM acdSchedule A
                         WHERE A.groupId = p_groupId) B
                    ON B.groupId = A.groupId
            INNER JOIN (SELECT A.groupId, UNNEST(A.timeIds) AS timeId
                          FROM acdSchedule A
                         WHERE A.groupId = p_groupId) C
                    ON C.groupId = A.groupId
            INNER JOIN acdTime D
                    ON D.timeId = C.timeId
                 WHERE A.groupId = p_groupId
             UNION ALL
                -- se nao ha horarios, instanciar dias vazios
                SELECT UNNEST(CASE WHEN NOT v_hasTimesAndDates THEN ARRAY[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1] ELSE ARRAY[]::integer[] END) AS order_by, p_groupId, NULL, NULL, NULL, NULL, NULL::integer AS degreeId, NULL AS description, NULL::integer AS parentDegreeId, NULL::integer AS degreeNumber
             UNION ALL
                SELECT (2+row_number() OVER (ORDER BY COALESCE(A.parentDegreeId, 0) DESC, A.degreeNumber))::integer AS order_by, B.groupId, NULL, NULL, NULL, NULL, A.degreeId, A.description, A.parentDegreeId, A.degreeNumber
                  FROM acdDegree A
            INNER JOIN acdGroup B
                    ON B.learningPeriodId = A.learningPeriodId
             WHERE B.groupId = p_groupId) A
         -- obter lista de pessoas
         LEFT JOIN acdEnroll B
                ON B.groupId = A.groupId
        INNER JOIN acdContract C
                ON C.contractId = B.contractId
        INNER JOIN ONLY basPhysicalPerson D
                ON D.personId = C.personId
         -- obter frequencias de cada pessoa
         LEFT JOIN acdFrequenceEnroll E
                ON E.enrollId = B.enrollId
               AND E.frequencyDate = A.occurrenceDate
               AND E.timeId = A.timeId
         -- obter notas de cada pessoa
         LEFT JOIN acdDegreeEnroll F
                ON F.enrollId = B.enrollId
               AND F.degreeId = A.degreeId
               AND F.recorddate = (SELECT MAX(G.recorddate) FROM acdDegreeEnroll G WHERE G.enrollId=F.enrollId AND G.degreeId=F.degreeId)--Adicionar somente a ultima ocorrencia de nota da pessoa
          ORDER BY D.name, A.occurrenceDate, A.beginHour, A.endHour, A.order_by;
END;
$$;


ALTER FUNCTION public.cross_attendance_report(p_groupid integer, p_photopath character varying) OWNER TO postgres;

--
-- Name: cross_attendance_report(integer, character varying, date, date, integer, boolean, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION cross_attendance_report(p_groupid integer, p_photopath character varying, p_begindate date, p_enddate date, p_numcolumns integer, p_filldata boolean, p_showcancelled boolean) RETURNS TABLE(order_column integer, person text, ftime text, frequency text, upload text)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_hasTimesAndDates BOOLEAN;
BEGIN
    SELECT COUNT(*) > 0 INTO v_hasTimesAndDates
      FROM acdSchedule
     WHERE groupId = p_groupId
       AND array_length(occurrenceDates,1) > 0
       AND array_length(timeIds,1) > 0
       AND p_fillData;

    RAISE NOTICE '%', CASE WHEN v_hasTimesAndDates THEN 'SIM' ELSE 'NAO' END;

    RETURN QUERY
        SELECT A.order_by,
               (CASE
                    WHEN B.statusId = getParameter('ACADEMIC', 'ENROLL_STATUS_CANCELLED')::int THEN '* '
                    WHEN B.statusId = getparameter('ACADEMIC', 'ENROLL_STATUS_DESISTING')::int THEN '** '
                    WHEN B.isexploitation IS TRUE THEN '*** '
                ELSE
                    ''
                END) || (D.name || ' - ' || D.personId)::text,
               CASE
                   WHEN A.order_by = 1 THEN (TO_CHAR(A.occurrenceDate, 'mm') || E'\n' || TO_CHAR(A.occurrenceDate, 'dd') || E'\n' || TO_CHAR(A.beginHour, 'HH24:MI') || E'\n' || TO_CHAR(A.endHour, 'HH24:MI'))::text
                   ELSE
			A.description::text
               END AS outData,
               CASE
                   WHEN A.order_by = 1
                   THEN
			E.frequency::text
                   ELSE
			CASE WHEN A.order_by = 3
			THEN
				( CASE WHEN B.frequency > H.academicNumberHours
				THEN
				   '100'::text
				ELSE
				    ROUND( ((B.frequency * 100) / H.academicNumberHours)::NUMERIC, getParameter('BASIC', 'GRADE_ROUND_VALUE')::int)::text
				END )
			ELSE
				COALESCE(ROUND(F.note::numeric, getParameter('BASIC', 'GRADE_ROUND_VALUE')::int)::text, ( SELECT COALESCE(subtitle, description)
															    FROM acdConcept
															   WHERE description = F.concept::text ))

			END
               END,
               (SELECT filepath || fileid::text FROM basfile WHERE fileid = D.photoId)::text
          FROM (
		SELECT 1 AS order_by,
			 A.groupId,
			 B.occurrenceDate,
			 C.timeId,
			 D.beginHour,
			 D.endHour,
			 NULL AS degreeId,
			 NULL AS description,
			 NULL AS parentDegreeId,
			 NULL AS degreeNumber
                  FROM acdGroup A
            INNER JOIN (SELECT A.groupId, UNNEST(A.occurrenceDates) AS occurrenceDate, A.scheduleID as scheduleID
                          FROM acdSchedule A
                         WHERE A.groupId = p_groupId) B
                    ON B.groupId = A.groupId
            INNER JOIN (SELECT A.groupId, UNNEST(A.timeIds) AS timeId, A.scheduleId
                          FROM acdSchedule A
                         WHERE A.groupId = p_groupId) C
                    ON (C.groupId = A.groupId
                        AND C.scheduleId = B.scheduleId)
            INNER JOIN acdTime D
                    ON D.timeId = C.timeId
                 WHERE A.groupId = p_groupId
                   --Filtra o intervalo de datas
                   AND ( CASE WHEN p_beginDate IS NOT NULL AND p_endDate IS NOT NULL
			THEN
				--Data inicial e final
				B.occurrenceDate BETWEEN p_beginDate AND p_endDate
			ELSE
				( CASE WHEN p_beginDate IS NOT NULL
				THEN
					--Data inicial
					B.occurrenceDate >= p_beginDate
				ELSE
					( CASE WHEN p_endDate IS NOT NULL
					THEN
						--Data final
						B.occurrenceDate <= p_endDate
					ELSE
						TRUE
					END )
				END )
			END)
                   AND p_fillData
             UNION ALL
                -- se nao ha horarios, instanciar dias vazios
                SELECT generate_series(-p_numColumns, CASE WHEN v_hasTimesAndDates THEN NULL ELSE -1 END, 1) AS order_by, p_groupId, NULL, NULL, NULL, NULL, NULL::integer AS degreeId, NULL AS description, NULL::integer AS parentDegreeId, NULL::integer AS degreeNumber
             UNION ALL
                SELECT (4+row_number() OVER (ORDER BY COALESCE(A.parentDegreeId, 0) DESC, A.degreeNumber))::integer AS order_by, B.groupId, NULL, NULL, NULL, NULL, A.degreeId, A.description, A.parentDegreeId, A.degreeNumber
                  FROM acdDegree A
            INNER JOIN acdGroup B
                    ON B.learningPeriodId = A.learningPeriodId
             WHERE B.groupId = p_groupId

	     UNION ALL
	     --Adiciona coluna da frequencia
	     SELECT 3, p_groupId, NULL, NULL, NULL, NULL, NULL::integer AS degreeId, 'FREQ (%)' AS description, NULL::integer AS parentDegreeId, NULL::integer AS degreeNumber
             ) A
             
         -- obter lista de pessoas
         LEFT JOIN acdEnroll B
                ON B.groupId = A.groupId

                -- Pega apenas a ULTIMA matricula, ordenando pela data de matricula
                AND (
                    B.enrollId = (
                        SELECT EE.enrollId
                          FROM acdEnroll EE
                         WHERE EE.contractId = B.contractId
                           AND EE.groupId = B.groupId
                           
                            -- Exibe ou nao os cancelados
                            AND (CASE WHEN
                                     p_showCancelled IS FALSE
                                 THEN
                                     EE.statusId != getParameter('ACADEMIC', 'ENROLL_STATUS_CANCELLED')::int
                                 ELSE
                                     TRUE
                                 END)
                                 
                      ORDER BY EE.dateEnroll::varchar || EE.hourEnroll::varchar DESC
                         LIMIT 1
                    )
                )
                
        INNER JOIN acdContract C
                ON C.contractId = B.contractId
        INNER JOIN ONLY basPhysicalPerson D
                ON D.personId = C.personId
        INNER JOIN unit_acdLearningPeriod LP
                ON LP.learningPeriodId = ( SELECT learningPeriodId
                                             FROM unit_acdGroup
                                            WHERE groupId = p_groupId )
         -- obter frequencias de cada pessoa
         LEFT JOIN acdFrequenceEnroll E
                ON E.enrollId = B.enrollId
               AND E.frequencyDate = A.occurrenceDate
               AND E.timeId = A.timeId
               AND p_fillData
         -- obter notas de cada pessoa
         LEFT JOIN acdDegreeEnroll F
                ON F.enrollId = B.enrollId
               AND F.degreeId = A.degreeId
               AND p_fillData
               AND F.recorddate = (SELECT MAX(G.recorddate) FROM acdDegreeEnroll G WHERE G.enrollId=F.enrollId AND G.degreeId=F.degreeId)--Adicionar somente a ultima ocorrencia de nota da pessoa
	 LEFT JOIN acdCurriculum G
   	        ON G.curriculumId = ( SELECT curriculumId
					FROM acdGroup
				       WHERE groupid = p_groupId )
   	        AND p_fillData
	 LEFT JOIN acdCurricularComponent H
		ON (H.curricularComponentId = G.curricularComponentId AND
		    H.curricularComponentVersion = G.curricularComponentVersion)
		AND p_fillData
              WHERE B.statusId <> GETPARAMETER('ACADEMIC', 'ENROLL_STATUS_PRE_ENROLLED')::int
                AND verificaPrimeiraParcela(B.enrollId, LP.periodId)
      ORDER BY (CASE WHEN B.statusId = getParameter('ACADEMIC', 'ENROLL_STATUS_CANCELLED')::int THEN 1 ELSE 0 END), (D.name || ' - ' || D.personId)::TEXT, A.occurrenceDate, A.beginHour, A.endHour, A.order_by;
END;
$$;


ALTER FUNCTION public.cross_attendance_report(p_groupid integer, p_photopath character varying, p_begindate date, p_enddate date, p_numcolumns integer, p_filldata boolean, p_showcancelled boolean) OWNER TO postgres;

--
-- Name: dataporextenso(date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dataporextenso(p_data date) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: dataPorExtenso
  PURPOSE: Gera a representação por extenso de uma data fornecida por parâmetro

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       19/07/2011 Alex Smith        1. FUNÇÃO criada.
**************************************************************************************/
BEGIN
    RETURN EXTRACT(day FROM p_data) || ' de ' || obterMesExtenso(EXTRACT(month FROM p_data)::int) || ' de ' || EXTRACT(year FROM p_data);
END;
$$;


ALTER FUNCTION public.dataporextenso(p_data date) OWNER TO postgres;

--
-- Name: datetodb(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION datetodb(p_date character varying) RETURNS date
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: dateToDb
  PURPOSE: Converte uma data do usuario para o banco de dados
**************************************************************************************/
BEGIN
    RETURN TO_DATE(p_date, 'dd/mm/yyyy');
END;
$$;


ALTER FUNCTION public.datetodb(p_date character varying) OWNER TO postgres;

--
-- Name: datetouser(date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION datetouser(p_date date) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: dateToUser
  PURPOSE: Converte uma data vinda da base para o usuario.
**************************************************************************************/
BEGIN
    RETURN TO_CHAR(p_date, 'dd/mm/yyyy');
END;
$$;


ALTER FUNCTION public.datetouser(p_date date) OWNER TO postgres;

--
-- Name: dblink(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink(text) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_record';


ALTER FUNCTION public.dblink(text) OWNER TO postgres;

--
-- Name: dblink(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink(text, text) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_record';


ALTER FUNCTION public.dblink(text, text) OWNER TO postgres;

--
-- Name: dblink(text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink(text, boolean) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_record';


ALTER FUNCTION public.dblink(text, boolean) OWNER TO postgres;

--
-- Name: dblink(text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink(text, text, boolean) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_record';


ALTER FUNCTION public.dblink(text, text, boolean) OWNER TO postgres;

--
-- Name: dblink_build_sql_delete(text, int2vector, integer, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_build_sql_delete(text, int2vector, integer, text[]) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_build_sql_delete';


ALTER FUNCTION public.dblink_build_sql_delete(text, int2vector, integer, text[]) OWNER TO postgres;

--
-- Name: dblink_build_sql_insert(text, int2vector, integer, text[], text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_build_sql_insert(text, int2vector, integer, text[], text[]) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_build_sql_insert';


ALTER FUNCTION public.dblink_build_sql_insert(text, int2vector, integer, text[], text[]) OWNER TO postgres;

--
-- Name: dblink_build_sql_update(text, int2vector, integer, text[], text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_build_sql_update(text, int2vector, integer, text[], text[]) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_build_sql_update';


ALTER FUNCTION public.dblink_build_sql_update(text, int2vector, integer, text[], text[]) OWNER TO postgres;

--
-- Name: dblink_cancel_query(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_cancel_query(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_cancel_query';


ALTER FUNCTION public.dblink_cancel_query(text) OWNER TO postgres;

--
-- Name: dblink_close(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_close(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_close';


ALTER FUNCTION public.dblink_close(text) OWNER TO postgres;

--
-- Name: dblink_close(text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_close(text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_close';


ALTER FUNCTION public.dblink_close(text, boolean) OWNER TO postgres;

--
-- Name: dblink_close(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_close(text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_close';


ALTER FUNCTION public.dblink_close(text, text) OWNER TO postgres;

--
-- Name: dblink_close(text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_close(text, text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_close';


ALTER FUNCTION public.dblink_close(text, text, boolean) OWNER TO postgres;

--
-- Name: dblink_connect(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_connect(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_connect';


ALTER FUNCTION public.dblink_connect(text) OWNER TO postgres;

--
-- Name: dblink_connect(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_connect(text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_connect';


ALTER FUNCTION public.dblink_connect(text, text) OWNER TO postgres;

--
-- Name: dblink_connect_u(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_connect_u(text) RETURNS text
    LANGUAGE c STRICT SECURITY DEFINER
    AS '$libdir/dblink', 'dblink_connect';


ALTER FUNCTION public.dblink_connect_u(text) OWNER TO postgres;

--
-- Name: dblink_connect_u(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_connect_u(text, text) RETURNS text
    LANGUAGE c STRICT SECURITY DEFINER
    AS '$libdir/dblink', 'dblink_connect';


ALTER FUNCTION public.dblink_connect_u(text, text) OWNER TO postgres;

--
-- Name: dblink_current_query(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_current_query() RETURNS text
    LANGUAGE c
    AS '$libdir/dblink', 'dblink_current_query';


ALTER FUNCTION public.dblink_current_query() OWNER TO postgres;

--
-- Name: dblink_disconnect(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_disconnect() RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_disconnect';


ALTER FUNCTION public.dblink_disconnect() OWNER TO postgres;

--
-- Name: dblink_disconnect(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_disconnect(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_disconnect';


ALTER FUNCTION public.dblink_disconnect(text) OWNER TO postgres;

--
-- Name: dblink_error_message(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_error_message(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_error_message';


ALTER FUNCTION public.dblink_error_message(text) OWNER TO postgres;

--
-- Name: dblink_exec(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_exec(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_exec';


ALTER FUNCTION public.dblink_exec(text) OWNER TO postgres;

--
-- Name: dblink_exec(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_exec(text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_exec';


ALTER FUNCTION public.dblink_exec(text, text) OWNER TO postgres;

--
-- Name: dblink_exec(text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_exec(text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_exec';


ALTER FUNCTION public.dblink_exec(text, boolean) OWNER TO postgres;

--
-- Name: dblink_exec(text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_exec(text, text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_exec';


ALTER FUNCTION public.dblink_exec(text, text, boolean) OWNER TO postgres;

--
-- Name: dblink_fetch(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_fetch(text, integer) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_fetch';


ALTER FUNCTION public.dblink_fetch(text, integer) OWNER TO postgres;

--
-- Name: dblink_fetch(text, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_fetch(text, integer, boolean) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_fetch';


ALTER FUNCTION public.dblink_fetch(text, integer, boolean) OWNER TO postgres;

--
-- Name: dblink_fetch(text, text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_fetch(text, text, integer) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_fetch';


ALTER FUNCTION public.dblink_fetch(text, text, integer) OWNER TO postgres;

--
-- Name: dblink_fetch(text, text, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_fetch(text, text, integer, boolean) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_fetch';


ALTER FUNCTION public.dblink_fetch(text, text, integer, boolean) OWNER TO postgres;

--
-- Name: dblink_get_connections(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_get_connections() RETURNS text[]
    LANGUAGE c
    AS '$libdir/dblink', 'dblink_get_connections';


ALTER FUNCTION public.dblink_get_connections() OWNER TO postgres;

--
-- Name: dblink_get_pkey(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_get_pkey(text) RETURNS SETOF dblink_pkey_results
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_get_pkey';


ALTER FUNCTION public.dblink_get_pkey(text) OWNER TO postgres;

--
-- Name: dblink_get_result(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_get_result(text) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_get_result';


ALTER FUNCTION public.dblink_get_result(text) OWNER TO postgres;

--
-- Name: dblink_get_result(text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_get_result(text, boolean) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_get_result';


ALTER FUNCTION public.dblink_get_result(text, boolean) OWNER TO postgres;

--
-- Name: dblink_is_busy(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_is_busy(text) RETURNS integer
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_is_busy';


ALTER FUNCTION public.dblink_is_busy(text) OWNER TO postgres;

--
-- Name: dblink_open(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_open(text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_open';


ALTER FUNCTION public.dblink_open(text, text) OWNER TO postgres;

--
-- Name: dblink_open(text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_open(text, text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_open';


ALTER FUNCTION public.dblink_open(text, text, boolean) OWNER TO postgres;

--
-- Name: dblink_open(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_open(text, text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_open';


ALTER FUNCTION public.dblink_open(text, text, text) OWNER TO postgres;

--
-- Name: dblink_open(text, text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_open(text, text, text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_open';


ALTER FUNCTION public.dblink_open(text, text, text, boolean) OWNER TO postgres;

--
-- Name: dblink_send_query(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_send_query(text, text) RETURNS integer
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_send_query';


ALTER FUNCTION public.dblink_send_query(text, text) OWNER TO postgres;

--
-- Name: degreelearningperiodunique(); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION degreelearningperiodunique() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: degreelearningperiodunique
  DESCRIPTION: Trigger que não permite cadastrar um grau academico para um período
               letivo com a mesma descrição de um grau que já existe.

  REVISIONS:
  Ver       Date       Author             Description
  --------- ---------- ------------------ ------------------------------------
  1.0       17/07/14   ftomasini          Bloqueia inconcistencia no cadastro de
                                          graus acadêmicos de um período letivo. 
******************************************************************************/
DECLARE
    v_validate BOOLEAN;
BEGIN

    SELECT INTO v_validate CASE WHEN degreeid IS NOT NULL THEN FALSE ELSE TRUE END 
      FROM acddegree
     WHERE description ilike NEW.description
       AND learningperiodid = NEW.learningperiodid
       AND degreeid != NEW.degreeid;

    IF (TG_OP = 'INSERT' OR  TG_OP = 'UPDATE' ) AND (v_validate IS FALSE)
    THEN
        RAISE EXCEPTION 'Erro ao salvar o período letivo, provavelmente o cadastro foi aberto em mais de uma aba do navegador, feche uma das abas e refaça o processo.';
    END IF;

    RETURN NEW;
    
END;
$$;


ALTER FUNCTION public.degreelearningperiodunique() OWNER TO solis;

--
-- Name: deletetransaction(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION deletetransaction(p_transactionname text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: deleteTransaction
  DESCRIPTION: Remove uma transacao atual das tabelas relacionadas, caso ela exista.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       03/02/2011 Moises Heberle    Funcao criada.
  1.1       03/02/2011 Moises Heberle    Adicionado verificacao de dependencia.
  1.2       10/06/2011 Alex Smith        Permite exclusao quando ha mais de um transa-
                                         cao com mesmo nome.
  1.3       19/03/2012 Moises Heberle    Adaptando para nova estrutura
**************************************************************************************/
DECLARE
    v_retVal boolean;
BEGIN
    v_retVal := false;

    IF (SELECT COUNT(*) FROM miolo_transaction WHERE m_transaction = p_transactionName) <= 0 THEN
        RAISE NOTICE 'A transacao % nao foi encontrada na tabela miolo_transaction, ignorando.', p_transactionName;
    ELSIF (SELECT COUNT(*) FROM miolo_transaction WHERE parentm_transaction = p_transactionName) > 0 THEN
        RAISE NOTICE 'A transacao % possui dependencias e nao pode ser removida.', p_transactionName;
    ELSE
        DELETE FROM miolo_access WHERE idtransaction IN (SELECT idtransaction FROM miolo_transaction WHERE m_transaction = p_transactionName);
        DELETE FROM miolo_transaction WHERE m_transaction = p_transactionName;

        v_retVal := true;
    END IF;

    RETURN v_retVal;
END;
$$;


ALTER FUNCTION public.deletetransaction(p_transactionname text) OWNER TO postgres;

--
-- Name: digitacaodenotastrocaexamepormenornota(integer, integer, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION digitacaodenotastrocaexamepormenornota(p_enrollid integer, p_degreeid integer, p_nota double precision) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    
    v_tipo_exame char(1);
    v_is_exame boolean;
    v_degreeid integer;
    
    v_degreeenroll acddegreeenroll%ROWTYPE;
    
    v_executar_troca boolean;
    v_menor_nota double precision;
    v_degreeid_menor_nota integer;
    
    v_calcula_nota boolean;
    
BEGIN
    
    v_executar_troca = true;
    v_menor_nota := NULL;
    
    SELECT examcalcmethod INTO v_tipo_exame FROM acddegree WHERE degreeid = p_degreeid;
    SELECT isexam INTO v_is_exame FROM acddegree WHERE degreeid = p_degreeid;
    
    -- Verifica se a nota é de exame e o tipo de exame é 'Troca menor nota obrigatória'
    -- Se não for, não faz nada
    IF ( v_tipo_exame = 'T' AND v_is_exame AND p_nota > 0 ) THEN
    BEGIN

        FOR v_degreeid IN SELECT degreeid FROM acddegree WHERE learningperiodid IN (SELECT learningperiodid FROM acdgroup WHERE groupid IN (select groupid FROM acdenroll WHERE enrollid = p_enrollid)) and maybenull = false and degreeid NOT IN (SELECT parentdegreeid FROM acddegree WHERE  learningperiodid IN (SELECT learningperiodid FROM acdgroup WHERE groupid IN (select groupid FROM acdenroll WHERE enrollid = p_enrollid)) and parentdegreeid is not null) LOOP
        
           
            SELECT * INTO v_degreeenroll FROM acddegreeenroll WHERE degreeid = v_degreeid AND enrollid = p_enrollid order by recorddate desc limit 1;
            
            IF ( v_degreeenroll.degreeenrollid > 0 ) THEN
            BEGIN
                
                IF ( v_menor_nota IS NULL ) THEN
                BEGIN
                    v_menor_nota = v_degreeenroll.note;
                    v_degreeid_menor_nota = v_degreeenroll.degreeid;
                END;
                ELSE
                BEGIN
                    IF ( v_degreeenroll.note < v_menor_nota ) THEN
                    BEGIN
                        v_menor_nota = v_degreeenroll.note;
                        v_degreeid_menor_nota = v_degreeenroll.degreeid;
                    END;
                    END IF;
                END;
                END IF;
            END;
            ELSE
            BEGIN
                v_executar_troca := false;
            END;
            END IF;
        
        END LOOP;
        
        IF ( v_executar_troca AND ( p_nota > v_menor_nota) ) THEN
        BEGIN
            INSERT INTO acddegreeenroll ( degreeid, enrollid, note, description ) VALUES ( v_degreeid_menor_nota, p_enrollid, p_nota, 'NOTA SUBSTITUÍDA PELO EXAME' );
            SELECT INTO v_calcula_nota calculaNota(p_enrollid);
        END;
        END IF;
    END;
    END IF;
        
    RETURN 1;
    
END;
$$;


ALTER FUNCTION public.digitacaodenotastrocaexamepormenornota(p_enrollid integer, p_degreeid integer, p_nota double precision) OWNER TO postgres;

--
-- Name: drop_function_if_exists(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION drop_function_if_exists(name character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
            DECLARE
            v_sql varchar;
            BEGIN
                FOR v_sql IN SELECT 'DROP FUNCTION '|| proname || '(' ||
                    (
                    SELECT array_to_string( array_agg(coalesce(varname,'') || ' ' ||
                                        ( SELECT coalesce(typname,'') 
                                            FROM pg_type
                                            WHERE oid::varchar = type::varchar 
                                        ) ) , ' , ' )
                                        FROM (    SELECT  unnest( coalesce(proargnames,ARRAY[''] ) ) as varname,
                                                        regexp_split_to_table( proargtypes::varchar , E'\ +') as type
                                                FROM  pg_proc A
                                                WHERE pronamespace = 2200
                                                and lower(A.proname) = lower(name)
                                                and pg_proc.oid = oid                                               
                                        ) as foo ) || ');'                                              
            FROM pg_proc                                                                                             
            WHERE lower(proname) = lower( name )
            LOOP
                    EXECUTE v_sql;
                END LOOP;
            END
            $$;


ALTER FUNCTION public.drop_function_if_exists(name character varying) OWNER TO postgres;

--
-- Name: drop_function_if_exists(character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION drop_function_if_exists(name character varying, param character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
            BEGIN
                PERFORM drop_function_if_exists(lower(name));
            END
            $$;


ALTER FUNCTION public.drop_function_if_exists(name character varying, param character varying) OWNER TO postgres;

--
-- Name: escrevenumeroporextenso(character); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION escrevenumeroporextenso(num character) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
/*************************************************************************************
  NAME: escreveNumeroPorExtenso
  PURPOSE: É chamada pela função numeroPorExtenso para concatenar os números.
  AUTOR: Nataniel
**************************************************************************************/
DECLARE
    w_cen integer ;
    w_dez integer ;
    w_dez2 integer ;
    w_uni integer ;
    w_tcen text ;
    w_tdez text ;
    w_tuni text ;
    w_ext text ;
    m_cen text[] := array['','cento','duzentos','trezentos','quatrocentos','quinhentos','seiscentos','setecentos','oitocentos','novecentos'];
    m_dez text[] := array['','dez','vinte','trinta','quarenta','cinquenta','sessenta','setenta','oitenta','noventa'] ;
    m_uni text[] := array['','um','dois','três','quatro','cinco','seis','sete','oito','nove','dez','onze','doze','treze','quatorze','quinze','dezesseis','dezessete','dezoito','dezenove'] ;
BEGIN
    w_cen := cast(substr(num,1,1) as integer) ;
    w_dez := cast(substr(num,2,1) as integer) ;
    w_dez2 := cast(substr(num,2,2) as integer) ;
    w_uni := cast(substr(num,3,1) as integer) ;
    if w_cen = 1 and w_dez2 = 0 then
        w_tcen := 'Cem' ;
        w_tdez := '' ;
        w_tuni := '' ;
        else
        if w_dez2 < 20 then 
            w_tcen := m_cen[w_cen + 1] ;
            w_tdez := m_uni[w_dez2 + 1] ; 
            w_tuni := '' ;
        else
            w_tcen := m_cen[w_cen + 1] ;
            w_tdez := m_dez[w_dez + 1] ; 
            w_tuni := m_uni[w_uni + 1] ;
        end if ;    
    end if ; 
    w_ext := w_tcen ;
    if w_tdez <> '' then  
        if w_ext = '' then 
            w_ext := w_tdez ;
        else
            w_ext := w_ext || ' e ' || w_tdez ;
        end if ;      
    end if ;   
    if w_tuni <> '' then  
        if w_ext = '' then 
            w_ext := w_tuni ;
        else
            w_ext := w_ext || ' e ' || w_tuni ;
        end if ;
    end if ;
    return w_ext ;  
end ;
$$;


ALTER FUNCTION public.escrevenumeroporextenso(num character) OWNER TO postgres;

--
-- Name: exclui_fininfotitulo(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION exclui_fininfotitulo() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
                BEGIN
                    DELETE FROM fininfotitulo WHERE titulo = OLD.invoiceid;

                    RETURN OLD;
                END;
                $$;


ALTER FUNCTION public.exclui_fininfotitulo() OWNER TO postgres;

--
-- Name: existcontract(bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION existcontract(person bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    result boolean;
BEGIN

   IF ( select count(*) > 0 personid from acdcontract where personid = person )
   THEN
   result = true; 
    ELSE
    result = false;
   END IF; 
    RETURN result;
 END;
$$;


ALTER FUNCTION public.existcontract(person bigint) OWNER TO postgres;

--
-- Name: existematricula(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION existematricula(p_contractid integer, p_learningperiodid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: existematricula
  PURPOSE: Função que verifica se existe matrícula para um contrato em um determinado
           período letivo, evitando processamento desnecessário.

  REVISIONS:
  Ver       Date       Author             Description
  --------- ---------- ------------------ ------------------------------------
  1.0       17/07/2014 Samuel Koch        1. Criação da função
**************************************************************************************/
DECLARE
    result boolean;
BEGIN

   IF ( SELECT count(A.enrollId) > 0
          FROM acdEnroll A
    INNER JOIN acdGroup B
            ON A.groupId = B.groupId
         WHERE A.contractId = p_contractId
           AND B.learningPeriodId = p_learningPeriodId
           AND B.regimenId != getParameter('ACADEMIC', 'REGIME_DE_FERIAS')::int ) THEN
        result = true; 
    ELSE
        result = false;
    END IF; 

    RETURN result;
 END;
$$;


ALTER FUNCTION public.existematricula(p_contractid integer, p_learningperiodid integer) OWNER TO postgres;

--
-- Name: existematriculacursoferias(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION existematriculacursoferias(p_contractid integer, p_learningperiodid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: existematricula
  PURPOSE: Função que verifica se existe matrícula em curso de férias para um contrato 
           em um determinado período letivo, evitando processamento desnecessário.

  REVISIONS:
  Ver       Date       Author             Description
  --------- ---------- ------------------ ------------------------------------
  1.0       17/07/2014 Samuel Koch        1. Criação da função
**************************************************************************************/
DECLARE
    result boolean;
BEGIN

   IF ( SELECT count(A.enrollId) > 0
          FROM acdEnroll A
    INNER JOIN acdGroup B
            ON A.groupId = B.groupId
         WHERE A.contractId = p_contractId
           AND B.learningPeriodId = p_learningPeriodId
           AND B.regimenId = getParameter('ACADEMIC', 'REGIME_DE_FERIAS')::int ) THEN
        result = true; 
    ELSE
        result = false;
    END IF; 

    RETURN result;
 END;
$$;


ALTER FUNCTION public.existematriculacursoferias(p_contractid integer, p_learningperiodid integer) OWNER TO postgres;

--
-- Name: existtable(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION existtable(nometabela character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    result boolean;
BEGIN
    result = false;             
   IF ( select count(*) > 0 from pg_catalog.pg_tables  WHERE tablename = nomeTabela )
   THEN
   result = true; 
   END IF; 
    RETURN result;
 END;
$$;


ALTER FUNCTION public.existtable(nometabela character varying) OWNER TO postgres;

--
-- Name: explode_array(anyarray); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION explode_array(p_array anyarray) RETURNS SETOF anyelement
    LANGUAGE sql
    AS $_$
/*********************************************************************************************
  NAME: explode_array
  PURPOSE: Recebe um array linear e retorna uma linha para cada item deste array.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       30/08/2011 Arthur Lehdermann 1. Função criada.
*********************************************************************************************/

    SELECT ($1)[s] FROM generate_series(1, array_upper($1, 1)) AS s;
$_$;


ALTER FUNCTION public.explode_array(p_array anyarray) OWNER TO postgres;

--
-- Name: findpreviouslearningperiodid(date, character varying, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION findpreviouslearningperiodid(p_begindate date, p_courseid character varying, p_courseversion integer, p_unitid integer, p_turnid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_learningPeriodId acdlearningperiod.learningperiodid%TYPE;
BEGIN
    SELECT INTO v_learningPeriodId learningperiodid
           FROM acdlearningperiod
          WHERE enddate < p_beginDate
            AND courseid = p_courseId
            AND courseversion = p_courseVersion
            AND unitid = p_unitId
            AND turnid = p_turnId
       ORDER BY enddate DESC LIMIT 1;

    RETURN v_learningPeriodId;
END
$$;


ALTER FUNCTION public.findpreviouslearningperiodid(p_begindate date, p_courseid character varying, p_courseversion integer, p_unitid integer, p_turnid integer) OWNER TO postgres;

--
-- Name: formatarvalormonetario(numeric); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION formatarvalormonetario(valor numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_valor numeric;
BEGIN
    SELECT INTO v_valor round(valor, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::int);
    RETURN trim(to_char(v_valor, '999999999990D00'));
END;
$$;


ALTER FUNCTION public.formatarvalormonetario(valor numeric) OWNER TO postgres;

--
-- Name: generateacademiccalendar(date, date, character varying[], character varying[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION generateacademiccalendar(p_begindate date, p_enddate date, p_opts character varying[], p_values character varying[]) RETURNS TABLE(referencedate date, dayevents text)
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: generateAcademicCalendar
  PURPOSE: Gera a lista de atividades em cada dia do peréodo especificado, conforme os
           parémetros.
  DESCRIPTION: Lista de parémetros posséveis e suas funçães:
    - separator Indicando o separador de eventos. Padréo: <br />;

    - courseId Filtra por curso
    - courseVersion Filtra por versão de curso
    - turnId Filtra por turno
    - unitId Filtra por unidade

    - showCurricularComponents Indica se deve retornar as oferecidas do dia.
    - showEvents Indica se deve retornar eventos que ocorrem no dia.
    - showEnrollPeriods Indica se deve exibir períodos de matrícula.
    - showAcademicCalendar Indica se deve exibir eventos do calendário acadêmico.
    - showResidencyPreceptor Indica se deve exibir unidades temáticas da pessoa.
    - showResidencyOfUser Indica se deve exibir unidades tematicas em que pessoa é residente.
    - showScheduledActivity Indica se deve exibir as atividades programadas.

    - personId Filtra pela pessoa, trazendo apenas atividades nas quais a pessoa esté envolvida.

  USAGE:

    SELECT *
      FROM generateAcademicCalendar(
              '2010-01-01', -- beginDate
              '2010-12-31', -- endDate
              ARRAY['separator', 'showCurricularComponents', 'showEvents', 'showAcademicCalendar', 'showEnrollPeriods', 'courseId', 'personId'],
              ARRAY['<br />',    'f',                        't',          't',                    'f',                 'ENF01N',   '4130']
           );

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       20/05/2011 Alex Smith        1. FUNÇÃO criada.
  1.1       26/05/2011 Alex Smith        1. FUNÇÃO alterada para trazer também o(s)
                                            professor(es) de cada disciplina.
                                         2. Alterada checagem de parémetros, para
                                            permitir que não seja informada nenhuma
                                            opção.
  1.2       25/06/2011 Alex Smith        1. Possibilidade de filtrar por pessoa.
  1.3       20/07/2011 Moises Heberle    1. Adicionado showResidencyPreceptor e showResidencyOfUser.
  1.4       01/09/2011 Arthur Lehderman  1. Adicionado showScheduledActivity.
  1.5       29/11/2011 Moises Heberle    1. Estava obtendo sempre uma data a mais pois
                                             somava endDate+1 no GENERATE_SERIES() da tabela
                                             acdEvent. Removido o "+1" para pegar corretamente.
**************************************************************************************/
DECLARE
    v_sql text;
    v_where text;

    v_index integer;

    -- Opcao 'separator', indicando o separador de eventos
    v_separator text;

    -- Opcao 'courseId', especificando filtro por curso
    v_courseId varchar;
    -- Opcao 'courseVersion', especificando filtro por versao de curso
    v_courseVersion varchar;
    -- Opcao 'turnId', especificando filtro por turno
    v_turnId varchar;
    -- Opcao 'unitId', especificando filtro por unidade
    v_unitId varchar;

    -- Opao para exibir ou nao disciplinas que ocorrem na data
    v_showCurricularComponents boolean;
    -- Opcao para exibir ou nao registros de eventos (acdEvent)
    v_showEvents boolean;
    -- Opcao para exibir ou nao periodos de matricula (acdPeriodEnrollDate)
    v_showEnrollPeriods boolean;
    -- Opcao para exibir ou nao calendario academico (acdAcademicCalendar)
    v_showAcademicCalendar boolean;
    -- Opcao para exibir ou nao unidades temáticas da pessoa.
    v_showResidencyPreceptor boolean;
    -- Opcao para exibir ou nao unidades tematicas em que pessoa é residente.
    v_showResidencyOfUser boolean;
    -- Opcao para exibir ou nao as atividades programadas
    v_showScheduledActivity boolean;

    -- Opcao 'personId', especificando a pessoa cuja agenda seré montada
    v_personId bigint;

BEGIN
    -- abortar em caso de erro na especificacao de parametros
    IF p_opts IS NOT NULL OR p_values IS NOT NULL THEN
        IF COALESCE(array_length(p_opts, 1) != array_length(p_values, 1), TRUE) THEN
            RAISE EXCEPTION 'Quantidade de opçães e valores incompatéveis.';
        END IF;
    END IF;

    -- inicializar opcoes

    -- separador
    v_separator := '<br />';
    -- ocorrencia de curso
    v_courseId := NULL;
    v_courseVersion := NULL;
    v_turnId := NULL;
    v_unitId := NULL;
    -- o que sera listado
    v_showCurricularComponents := TRUE;
    v_showEvents := TRUE;
    v_showEnrollPeriods := TRUE;
    v_showAcademicCalendar := TRUE;
    v_showResidencyPreceptor := TRUE;
    v_showResidencyOfUser := TRUE;
    v_showScheduledActivity := TRUE;

    -- personId
    v_personId := NULL;

    -- processar opcoes
    v_index := 1;
    WHILE v_index <= array_length(p_opts, 1) LOOP
        CASE p_opts[v_index]
            WHEN 'separator' THEN
                v_separator := p_values[v_index];
            WHEN 'courseId' THEN
                v_courseId := p_values[v_index];
            WHEN 'courseVersion' THEN
                v_courseVersion := p_values[v_index];
            WHEN 'turnId' THEN
                v_turnId := p_values[v_index];
            WHEN 'unitId' THEN
                v_unitId := p_values[v_index];
            WHEN 'showCurricularComponents' THEN
                v_showCurricularComponents := p_values[v_index] = 't';
            WHEN 'showEvents' THEN
                v_showEvents := p_values[v_index] = 't';
            WHEN 'showEnrollPeriods' THEN
                v_showEnrollPeriods := p_values[v_index] = 't';
            WHEN 'showAcademicCalendar' THEN
                v_showAcademicCalendar := p_values[v_index] = 't';
            WHEN 'showResidencyPreceptor' THEN
                v_showResidencyPreceptor := p_values[v_index] = 't';
            WHEN 'showResidencyOfUser' THEN
                v_showResidencyOfUser := p_values[v_index] = 't';
            WHEN 'showScheduledActivity' THEN
                v_showScheduledActivity := p_values[v_index] = 't';

            WHEN 'personId' THEN
                v_personId := p_values[v_index]::bigint;
            ELSE
                RAISE EXCEPTION 'Opção não reconhecida: %', p_opts[v_index];
        END CASE;
        v_index := v_index + 1;
    END LOOP;

    -- gera a lista de dias que serao pesquisados
    v_sql := 'SELECT A.referenceDate::date,
                     ARRAY_TO_STRING(ARRAY_AGG(B.eventDescription), ''' || v_separator || ''')::text AS dayEvents
                FROM (SELECT GENERATE_SERIES(''' || p_beginDate || '''::date,
                                             ''' || p_endDate || '''::date+1,
                                             ''1 day'') AS referenceDate) A
          INNER JOIN (';

    -- se configurado para exibir disciplinas
    IF v_showCurricularComponents THEN
        v_sql := v_sql || '
                      -- Disciplinas oferecidas por data
                      SELECT DISTINCT UNNEST(D.occurrenceDates) AS occurrenceDate,
                             1 AS appearanceOrder,
                             -- obtem dados do curso
                             B.courseId || ''/'' || B.courseVersion || '' '' || E.shortName || '' - '' ||
                             -- obtem dados da disciplina
                             A.curricularComponentId || ''/'' || A.curricularComponentVersion || '' '' || A.shortName ||
                             -- obtem professores separados por virgula
                             COALESCE((SELECT '' ('' || ARRAY_TO_STRING(ARRAY_AGG(M.name), '', '') || '')''
                                         FROM (SELECT DISTINCT R.name
                                                 FROM acdSchedule P
                                           INNER JOIN acdScheduleProfessor Q
                                                   ON Q.scheduleId = P.scheduleId
                                           INNER JOIN ONLY basPerson R
                                                   ON R.personId = Q.professorId
                                                WHERE P.groupId = C.groupId
                                             ORDER BY R.name) M), '''')
                             AS eventDescription
                        FROM acdCurricularComponent A
                  INNER JOIN acdCurriculum B
                          ON B.curricularComponentId = A.curricularComponentId
                         AND B.curricularComponentVersion = A.curricularComponentVersion
                  INNER JOIN acdGroup C
                          ON C.curriculumId = B.curriculumId
                  INNER JOIN acdSchedule D
                          ON D.groupId = C.groupId
                  INNER JOIN acdCourse E
                          ON E.courseId = B.courseId';

        v_where := '';
        IF v_courseId IS NOT NULL THEN
            v_where := v_where || ' AND B.courseId = ''' || v_courseId || '''';
        END IF;
        IF v_courseVersion IS NOT NULL THEN
            v_where := v_where || ' AND B.courseVersion = ' || v_courseVersion;
        END IF;
        IF v_turnId IS NOT NULL THEN
            v_where := v_where || ' AND B.turnId = ' || v_turnId;
        END IF;
        IF v_unitId IS NOT NULL THEN
            v_where := v_where || ' AND B.unitId = ' || v_unitId;
        END IF;
        IF v_personId IS NOT NULL THEN
            -- obter tanto disciplinas nas quais a pessoa esté
            -- matriculada quanto disciplinas das quais a pessoa
            -- é profesor.
            v_where := v_where || ' AND (EXISTS (SELECT 1
                                                   FROM acdEnroll X
                                             INNER JOIN acdContract Y
                                                     ON Y.contractId = X.contractId
                                                  WHERE X.groupId = C.groupId
                                                    AND Y.personId = ' || v_personId || ')
                                         OR
                                         EXISTS (SELECT 1
                                                   FROM acdScheduleProfessor X
                                                  WHERE X.scheduleId = D.scheduleId
                                                    AND X.professorId = ' || v_personId || ')
                                        )';
        END IF;

        v_sql := v_sql || CASE WHEN LENGTH(v_where) > 0 THEN ' WHERE ' || SUBSTR(v_where, 6) ELSE '' END || ' UNION';
    END IF;

    -- se configurado para exibir eventos
    IF v_showEvents THEN
        v_sql := v_sql || '
                      -- Eventos (acdEvent)
                      SELECT GENERATE_SERIES(A.beginDate, A.endDate, ''1 day'') AS occurrenceDate,
                             2 AS appearanceOrder,
                             A.description AS eventDescription
                        FROM acdEvent A';
        -- se especificada pessoa, verificar se ela participa do evento
        IF v_personId IS NOT NULL THEN
            v_sql := v_sql || ' WHERE EXISTS (SELECT 1
                                                FROM acdEventParticipation X
                                               WHERE X.eventId = A.eventId
                                                 AND X.personId = ' || v_personId || ')';
        END IF;

        v_sql := v_sql || ' UNION';
    END IF;

    -- se configurado para exibir períodos de matrícula
    IF v_showEnrollPeriods THEN
        v_sql := v_sql || '
                      -- períodos de matrícula (acdPeriodEnrollDate)
                      SELECT GENERATE_SERIES(A.beginDate, A.endDate+1, ''1 day'') AS occurrenceDate,
                             3 AS appearanceOrder,
                             A.description AS eventDescription
                        FROM acdPeriodEnrollDate A
                  INNER JOIN acdLearningPeriod B
                          ON A.learningPeriodId = B.learningPeriodId';

        v_where := '';
        IF v_courseId IS NOT NULL THEN
            v_where := v_where || ' AND B.courseId = ''' || v_courseId || '''';
        END IF;
        IF v_courseVersion IS NOT NULL THEN
            v_where := v_where || ' AND B.courseVersion = ' || v_courseVersion;
        END IF;
        IF v_turnId IS NOT NULL THEN
            v_where := v_where || ' AND B.turnId = ' || v_turnId;
        END IF;
        IF v_unitId IS NOT NULL THEN
            v_where := v_where || ' AND B.unitId = ' || v_unitId;
        END IF;
        IF v_personId IS NOT NULL THEN
            v_where := v_where || ' AND EXISTS (SELECT 1
                                                  FROM acdContract X
                                                 WHERE X.courseId = B.courseId
                                                   AND X.courseVersion = B.courseVersion
                                                   AND X.unitId = B.unitId
                                                   AND X.turnId = B.turnId
                                                   AND X.personId = ' || v_personId || ')';
        END IF;

        v_sql := v_sql || CASE WHEN LENGTH(v_where) > 0 THEN ' WHERE ' || SUBSTR(v_where, 6) ELSE '' END || ' UNION';
    END IF;

    -- se configurado para exibir entradas do calendário acadêmico
    IF v_showAcademicCalendar THEN
        v_sql := v_sql || '
                      -- Calendario academico (acdAcademicCalendar)
                      SELECT A.eventDate AS occurrenceDate,
                             4 AS appearanceOrder,
                             A.description AS eventDescription
                        FROM acdAcademicCalendarEvent A';

        v_where := '';
        IF v_courseId IS NOT NULL THEN
            v_where := v_where || ' AND (A.courseId = ''' || v_courseId || ''' OR A.courseId IS NULL)';
        END IF;
        IF v_courseVersion IS NOT NULL THEN
            v_where := v_where || ' AND (A.courseVersion = ' || v_courseVersion || ' OR A.courseVersion IS NULL)';
        END IF;
        IF v_turnId IS NOT NULL THEN
            v_where := v_where || ' AND (A.turnId = ' || v_turnId || ' OR A.turnId IS NULL)';
        END IF;
        IF v_unitId IS NOT NULL THEN
            v_where := v_where || ' AND (A.unitId = ' || v_unitId || ' OR A.unitId IS NULL)';
        END IF;
        IF v_personId IS NOT NULL THEN
            -- nao ha curso definido ou eh um curso
            -- no qual a pessoa tenha contrato
            v_where := v_where || ' AND ((A.courseId IS NULL
                                          AND A.courseVersion IS NULL
                                          AND A.unitId IS NULL
                                          AND A.turnId IS NULL)
                                         OR
                                         (EXISTS (SELECT 1
                                                    FROM acdContract X
                                                   WHERE X.personId = ' || v_personId || '
                                                     AND X.courseId = A.courseId
                                                     AND X.courseVersion = A.courseVersion
                                                     AND X.unitId = A.unitId
                                                     AND X.turnId = A.turnId)))';
        END IF;

        v_sql := v_sql || CASE WHEN LENGTH(v_where) > 0 THEN ' WHERE ' || SUBSTR(v_where, 6) ELSE '' END || ' UNION';
    END IF;

    -- se configurado para exibir unidades temáticas das quais o usuário é preceptor
    IF v_showResidencyPreceptor THEN
        v_sql := v_sql || '
                      SELECT GENERATE_SERIES(OUT.inicio, OUT.fim+1, ''1 day'') AS occurrenceDate,
                             5 AS appearanceOrder,
                             ''Resid: '' || UT.descricao AS eventDescription
                        FROM res.unidadeTematica UT
                  INNER JOIN res.ofertaDeUnidadeTematica OUT
                          ON OUT.unidadeTematicaId = UT.unidadeTematicaId';

        IF v_personId IS NOT NULL THEN
            v_sql := v_sql || ' WHERE OUT.personId = ' || v_personId;
        END IF;

            --RAISE NOTICE '%', v_sql;


        v_sql := v_sql || ' UNION';
    END IF;

    -- se configurado para exibir unidades temáticas das quais o usuário é residente
    IF v_showResidencyOfUser THEN
        v_sql := v_sql || '
                      SELECT GENERATE_SERIES(OUT.inicio, OUT.fim+1, ''1 day'') AS occurrenceDate,
                             6 AS appearanceOrder,
                             ''Resid: '' || UT.descricao AS eventDescription
                        FROM res.unidadeTematica UT
                  INNER JOIN res.ofertaDeUnidadeTematica OUT
                          ON OUT.unidadeTematicaId = UT.unidadeTematicaId';

        IF v_personId IS NOT NULL THEN
            v_sql := v_sql || ' WHERE OUT.ofertadeunidadetematicaid IN (
                  SELECT ODR.ofertadeunidadetematicaid
                    FROM res.ofertaDoResidente ODR
              INNER JOIN res.residente R
                      ON R.residenteId = ODR.residenteId
                   WHERE R.personId = ' || v_personId || ')';
        END IF;

            --RAISE NOTICE '%', v_sql;


        v_sql := v_sql || ' UNION';
    END IF;

    -- se configurado para exibir atividades programadas da pessoa
    IF v_showScheduledActivity THEN
        v_sql := v_sql || '
                      SELECT GENERATE_SERIES(SA.startDate::date, SA.endDate::date, ''1 day'') AS occurrenceDate,
                             7 AS appearanceOrder,
                             ''Atividade programada: '' || TO_CHAR(SA.startDate, getParameter(''BASIC'', ''MASK_TIMESTAMP_DEFAULT'')) || '' - '' || TO_CHAR(SA.endDate, getParameter(''BASIC'', ''MASK_TIMESTAMP_DEFAULT''))  || '' : '' || SA.description AS eventDescription
                        FROM hur.scheduledactivity SA
                  INNER JOIN hur.scheduledactivityparticipant SAP
                          ON SA.scheduledActivityId = SAP.scheduledActivityId';

        IF v_personId IS NOT NULL THEN
            v_sql := v_sql || ' WHERE SAP.personId = ' || v_personId;
        END IF;
            
            --RAISE NOTICE '%', v_sql;

        v_sql := v_sql || ' UNION';
    END IF;

    v_sql := SUBSTR(v_sql, 1, LENGTH(v_sql)-5) || ') B
                  ON B.occurrenceDate = A.referenceDate::date
            GROUP BY A.referenceDate,
                     B.appearanceOrder
            ORDER BY A.referenceDate,
                     B.appearanceOrder';

    RETURN QUERY EXECUTE v_sql;
END;
$$;


ALTER FUNCTION public.generateacademiccalendar(p_begindate date, p_enddate date, p_opts character varying[], p_values character varying[]) OWNER TO postgres;

--
-- Name: generateacademiccalendarreport(date, date, character varying[], character varying[]); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION generateacademiccalendarreport(p_begindate date, p_enddate date, p_opts character varying[], p_values character varying[]) RETURNS SETOF academiccalendarreporttype
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: generateAcademicCalendarReport
  
  PURPOSE: Retorna eventos agrupados quando estao em dias seguidos
           
  DESCRIPTION:
   - Retorna eventos agrupados quando estao em dias seguidos (muda a forma
    de retorno em comparacao com a FUNÇÃO generateAcademicCalendar()).
    
   - Foi feito especificamente para o relatório academico (localizado
    em Academico -> Documento)
   
  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       12/04/2012 moises            1. FUNÇÃO criada.
**************************************************************************************/
DECLARE
    v_row record;
    v_out academicCalendarReportType;
    v_evt academicCalendarReportEvt;
    v_evts academicCalendarReportEvt[];
    v_tmpEvts academicCalendarReportEvt[];
    v_datas date[];
    v_index int;
    v_dayIndex int;
    v_found boolean;
    v_evento text;
    v_eventos text[];
BEGIN
    v_evts = null;

    FOR v_row IN (SELECT * FROM generateAcademicCalendar( p_beginDate, p_endDate, p_opts, p_values) ORDER BY referenceDate)
    LOOP    
        v_eventos := STRING_TO_ARRAY(v_row.dayEvents, E'\n');
        v_dayIndex := 1;
        
        WHILE v_dayIndex <= array_length(v_eventos, 1)
        LOOP
            v_evento := v_eventos[v_dayIndex];
            v_dayIndex := v_dayIndex + 1;

            v_found := false;
            v_tmpEvts := null;
            v_index := 1;

            WHILE v_index <= array_length(v_evts, 1)
            LOOP
                v_evt := v_evts[v_index];
                v_index := v_index + 1;

                -- Se evento encontrado no array, adiciona data a mais
                IF ( md5(v_evt.evento) = md5(v_evento) AND EXTRACT(month FROM v_row.referenceDate) = EXTRACT(month FROM p_beginDate) )
                THEN
                    -- Se data anterior for igual data atual - 1 dia, significa que evento esta em sequencia
                    IF v_evt.datas[ array_length(v_evt.datas, 1) ] = (v_row.referenceDate - interval '1day')::date
                    THEN
                        v_evt.datas := array_append( v_evt.datas, v_row.referenceDate );
                        v_found := true;
                    END IF;
                END IF;

                v_tmpEvts := array_append(v_tmpEvts, v_evt);
            END LOOP;

            IF v_found IS FALSE
            THEN
                v_evt.evento := v_evento;
                v_evt.datas := ARRAY[v_row.referenceDate];
                v_tmpEvts := array_append(v_tmpEvts, v_evt);
            END IF;

            v_evts := v_tmpEvts;
        END LOOP;
    END LOOP;

    v_index := 1;
    WHILE v_index <= array_length(v_evts, 1)
    LOOP
        v_evt = v_evts[v_index];
        v_index := v_index + 1;

        IF (EXTRACT(month FROM (SELECT MIN(x) FROM UNNEST(v_evt.datas) AS x)) = EXTRACT(month FROM p_beginDate))
        THEN
            -- Prepara retorno formatado
            v_out.datas := CASE WHEN array_length(v_evt.datas, 1) > 1
                        THEN
                            EXTRACT(day FROM (SELECT MIN(x) FROM UNNEST(v_evt.datas) AS x)) || ' é ' || EXTRACT(day FROM (SELECT MAX(x) FROM UNNEST(v_evt.datas) AS x))
                        ELSE
                            EXTRACT(day FROM (SELECT MIN(x) FROM UNNEST(v_evt.datas) AS x)) || ''
                        END;
            v_out.eventos := v_evt.evento;

            RETURN NEXT v_out;
        END IF;
    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION public.generateacademiccalendarreport(p_begindate date, p_enddate date, p_opts character varying[], p_values character varying[]) OWNER TO solis;

--
-- Name: generatecontractincentivesbyperiod(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION generatecontractincentivesbyperiod(p_contractid integer, p_learningperiodid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    -- Objetos
    v_incentives record;
    v_learningPeriod record;
    v_contract record;
    v_invoice record;

    -- Operaçães
    v_incentiveOperationId integer; -- Desconto do incentivo
    v_paymentIncentiveOperationId int; -- Estorno do incentivo
    v_repaymentIncentiveOperationId int; -- Reembolso do incentivo

    -- variáveis
    V_PRECO FLOAT; -- Valor de contrato
    V_VI FLOAT; --Valor de incentivo
    V_NPCL INT; -- número de parcelas
    V_BPCL INT; -- número de parcelas bloqueadas
    V_APCL INT; -- número de parcelas abertas
    V_VIB FLOAT; -- Valor de incentivo bloqueado
    V_AJT FLOAT; -- Valor de ajuste no valor do incentivo
    V_VPI FLOAT; -- Valor da parcela de incentivo

    V_SUMVALUE FLOAT;
    V_SUBVALUE FLOAT;
    V_IVALUE FLOAT;
    V_INL FLOAT; -- Valor de incentivo não lanéado por falta de saldo no tétulo
    V_ANL FLOAT; -- Valor de ajuste não lanéado por falta de saldo no tétulo  
BEGIN
    V_PRECO = 0;
    V_VI = 0;
    V_NPCL = 0;
    V_BPCL = 0;
    V_APCL = 0;
    V_VIB = 0;
    V_AJT = 0;
    V_VPI = 0;

    V_SUMVALUE = 0;
    V_SUBVALUE = 0;
    V_IVALUE = 0;
    V_INL = 0;
    V_ANL = 0;
 
    --Obtem o peréodo letivo
    SELECT * INTO v_learningPeriod FROM acdLearningPeriod WHERE learningPeriodId = p_learningPeriodId;

    --Obtem o contrato
    SELECT * INTO v_contract FROM acdContract WHERE contractId = p_contractId;

    FOR v_incentives IN SELECT * FROM finincentive WHERE contractid = p_contractid AND (v_learningPeriod.beginDate, v_learningPeriod.endDate) OVERLAPS (startDate, endDate)
    LOOP
        --Código da operação do incentivo
        v_incentiveOperationId := operationId FROM ONLY finincentivetype WHERE incentivetypeid = v_incentives.incentivetypeid;
        --Código da operação de acréscimo de incentivo



        v_paymentIncentiveOperationId := paymentoperation FROM ONLY finincentivetype WHERE incentivetypeid = v_incentives.incentivetypeid;
        --Código da operação de reembolso de incentivo
        v_repaymentIncentiveOperationId := repaymentoperation FROM ONLY finincentivetype WHERE incentivetypeid = v_incentives.incentivetypeid;

        --
        -- OBTENçãO DE variáveis
        --
        -- número de parcelas (número de tétulos a receber o incentivo)
        V_NPCL := COUNT(*) FROM finreceivableinvoice A 
                          WHERE A.referenceMaturityDate BETWEEN v_incentives.startDate AND v_incentives.endDate                        
                            AND iscanceled = 'f'
                            AND EXISTS (SELECT 1
                                          FROM finEntry X
                                         WHERE X.invoiceId = A.invoiceId
                                           AND X.learningPeriodId = p_learningPeriodId)                      
                            AND EXISTS (SELECT 1
                                          FROM finEntry X
                                         WHERE X.invoiceId = A.invoiceId
                                           AND X.contractId = p_contractId);
        -- Valor contratado
        V_SUMVALUE := (SELECT SUM(E.value)
                         FROM ONLY finInvoice I
                   INNER JOIN finEntry E
                           ON E.invoiceId = I.invoiceId
                        WHERE I.isCanceled IS FALSE
                          AND I.referenceMaturityDate BETWEEN v_incentives.startDate AND v_incentives.endDate
                          AND EXISTS (SELECT 1
                                        FROM finEntry X
                                       WHERE X.invoiceId = I.invoiceId
                                         AND X.learningPeriodId = p_learningPeriodId)                      
                          AND EXISTS (SELECT 1
                                        FROM finEntry X
                                       WHERE X.invoiceId = I.invoiceId
                                         AND X.contractId = p_contractId)
                          AND E.operationId IN (SELECT UNNEST(ARRAY[monthlyfeeoperation, renewaloperation,addcurricularcomponentoperation,enrolloperation]) FROM finDefaultOperations));

        IF V_NPCL = 0 OR V_SUMVALUE = 0
        THEN
            RETURN TRUE;
        END IF;

        V_SUBVALUE := (SELECT SUM(E.value)
                         FROM ONLY finInvoice I
                   INNER JOIN finEntry E
                           ON E.invoiceId = I.invoiceId
                        WHERE I.isCanceled IS FALSE
                          AND I.referenceMaturityDate BETWEEN v_incentives.startDate AND v_incentives.endDate
                          AND EXISTS (SELECT 1
                                        FROM finEntry X
                                       WHERE X.invoiceId = I.invoiceId
                                         AND X.learningPeriodId = p_learningPeriodId)                      
                          AND EXISTS (SELECT 1
                                        FROM finEntry X
                                       WHERE X.invoiceId = I.invoiceId
                                         AND X.contractId = p_contractId)
                          AND E.operationId = (SELECT cancelcurricularcomponentoperation FROM finDefaultOperations));
        V_PRECO := COALESCE(V_SUMVALUE, 0) - COALESCE(V_SUBVALUE, 0);

        -- número de parcelas bloqueadas
        V_BPCL := COUNT(*) FROM finreceivableinvoice A 
                          WHERE A.referenceMaturityDate BETWEEN v_incentives.startDate AND v_incentives.endDate                        
                            AND iscanceled = 'f'
                            AND getblockedinvoice(p_contractId, p_learningPeriodId, A.parcelNumber, 0, 0) IS NOT NULL
                            AND EXISTS (SELECT 1
                                          FROM finEntry X
                                         WHERE X.invoiceId = A.invoiceId
                                           AND X.learningPeriodId = p_learningPeriodId)                      
                            AND EXISTS (SELECT 1
                                          FROM finEntry X
                                         WHERE X.invoiceId = A.invoiceId
                                           AND X.contractId = p_contractId);

        -- Valor de incentivo bloqueado
        V_SUMVALUE := (SELECT SUM(E.value)
                         FROM ONLY finInvoice I
                   INNER JOIN finEntry E
                           ON E.invoiceId = I.invoiceId
                        WHERE I.isCanceled IS FALSE
                          AND I.referenceMaturityDate BETWEEN v_incentives.startDate AND v_incentives.endDate
                          AND E.incentiveTypeId = v_incentives.incentivetypeid
                          AND getblockedinvoice(p_contractId, p_learningPeriodId, I.parcelNumber, 0, 0) IS NOT NULL
                          AND EXISTS (SELECT 1
                                        FROM finEntry X
                                       WHERE X.invoiceId = I.invoiceId
                                         AND X.learningPeriodId = p_learningPeriodId)                      
                          AND EXISTS (SELECT 1
                                        FROM finEntry X
                                       WHERE X.invoiceId = I.invoiceId
                                         AND X.contractId = p_contractId)
                          AND E.operationId IN (SELECT UNNEST(ARRAY[operationid, repaymentoperation]) FROM ONLY finIncentiveType WHERE incentiveTypeId = v_incentives.incentivetypeid));
        V_SUBVALUE := (SELECT SUM(E.value)
                         FROM ONLY finInvoice I
                   INNER JOIN finEntry E
                           ON E.invoiceId = I.invoiceId
                        WHERE I.isCanceled IS FALSE
                          AND I.referenceMaturityDate BETWEEN v_incentives.startDate AND v_incentives.endDate
                          AND E.incentiveTypeId = v_incentives.incentivetypeid
                          AND getblockedinvoice(p_contractId, p_learningPeriodId, I.parcelNumber, 0, 0) IS NOT NULL
                          AND EXISTS (SELECT 1
                                        FROM finEntry X
                                       WHERE X.invoiceId = I.invoiceId
                                         AND X.learningPeriodId = p_learningPeriodId)                      
                          AND EXISTS (SELECT 1
                                        FROM finEntry X
                                       WHERE X.invoiceId = I.invoiceId
                                         AND X.contractId = p_contractId)
                          AND E.operationId = (SELECT paymentOperation FROM ONLY finIncentiveType WHERE incentiveTypeId = v_incentives.incentivetypeid));
        V_VIB := COALESCE(V_SUMVALUE, 0) - COALESCE(V_SUBVALUE, 0);

        -- Valor de incentivo
        IF v_incentives.valueispercent IS TRUE THEN
            V_VI := ( v_incentives.value / 100 ) * V_PRECO;
        ELSE
            V_VI := v_incentives.value;
        END IF;

        -- Parcela de incentivo
        V_VPI := V_VI / V_NPCL;

        -- nÃºmero de parcelas abertas (nÃ£o bloqueadas)
        V_APCL := V_NPCL - V_BPCL;

        --Calcula valor de ajuste somente se exisitirem parcelas em aberto
        IF V_APCL > 0 
        THEN 
            -- Valor do ajuste de cada parcela
            V_AJT := ((V_VPI * V_BPCL) - V_VIB) / V_APCL;
        ELSE
            V_AJT := 0;
        END IF;


        --
        -- Percorre os tÃ©tulos abertos para lanÃ©ar o valor de incentivo
        --
        FOR v_invoice IN SELECT * FROM finreceivableinvoice A 
                          WHERE A.referenceMaturityDate BETWEEN v_incentives.startDate AND v_incentives.endDate                        
                            AND iscanceled = 'f'
                            AND getblockedinvoice(p_contractId, p_learningPeriodId, A.parcelNumber, 0, 0) IS NULL
                            AND EXISTS (SELECT 1
                                          FROM finEntry X
                                         WHERE X.invoiceId = A.invoiceId
                                           AND X.learningPeriodId = p_learningPeriodId)                      
                            AND EXISTS (SELECT 1
                                          FROM finEntry X
                                         WHERE X.invoiceId = A.invoiceId
                                           AND X.contractId = p_contractId)
        LOOP
            IF v_paymentIncentiveOperationId IS NOT NULL 
            THEN
                DELETE FROM finentry 
                      WHERE invoiceid = v_invoice.invoiceid
                        AND incentiveTypeId = v_incentives.incentivetypeid
                        AND operationid IN (SELECT UNNEST(ARRAY[operationid, repaymentoperation, paymentoperation]) FROM ONLY finIncentiveType WHERE incentiveTypeId = v_incentives.incentivetypeid);

                IF (V_VPI + V_INL) > 0 THEN
                    V_IVALUE := balance(v_invoice.invoiceid);
                    -- Verifica se existe saldo no tÃ©tulo para o lanÃ©amento do incentivo
                    IF (V_VPI + V_INL) <= V_IVALUE THEN
                        V_IVALUE := V_VPI + V_INL;
                    ELSE
                        V_INL := (V_VPI + V_INL) - V_IVALUE;
                    END IF;

                    -- Insere lanÃ©amento com o valor de incentivo
                    INSERT INTO finEntry(invoiceId, operationId, entryDate, value, costcenterid, contractid, learningperiodid, incentivetypeid) VALUES (
                        v_invoice.invoiceId,
                        v_incentiveOperationId,
                        NOW(),
                        ROUND(V_IVALUE::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer),
                        v_invoice.costCenterId,
                        V_contract.contractid,
                        V_learningperiod.learningperiodid,
                        v_incentives.incentivetypeid
                    );
                END IF;

                IF V_AJT > 0 THEN
                    V_IVALUE := balance(v_invoice.invoiceid);
                    -- Verifica se existe saldo para lanÃ©amento do ajuste
                    IF (V_AJT + V_ANL) <= V_IVALUE THEN
                        V_IVALUE := V_AJT + V_ANL;
                    ELSE
                        V_ANL := (V_AJT + V_ANL) - V_IVALUE;
                    END IF;

                    -- Insere lanÃ©amento com o valor de ajuste

                    IF V_IVALUE <> 0 THEN
                        INSERT INTO finEntry(invoiceId, operationId, entryDate, value, costcenterid, contractid, learningperiodid, incentivetypeid) VALUES (
                            v_invoice.invoiceId,
                            v_repaymentIncentiveOperationId,
                            NOW(),
                            ROUND(V_IVALUE::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer),
                            v_invoice.costCenterId,
                            V_contract.contractid,
                            V_learningperiod.learningperiodid,
                            v_incentives.incentivetypeid
                        );
                    END IF;
                ELSE
                    IF V_AJT < 0 THEN
                        -- Insere lanÃ©amento com o valor de ajuste
                        INSERT INTO finEntry(invoiceId, operationId, entryDate, value, costcenterid, contractid, learningperiodid, incentivetypeid) VALUES (
                        v_invoice.invoiceId,
                        v_paymentIncentiveOperationId,
                        NOW(),
                        ROUND((V_AJT * (-1))::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer),
                        v_invoice.costCenterId,
                        V_contract.contractid,
                        V_learningperiod.learningperiodid,
                        v_incentives.incentivetypeid );
                    END IF;
                END IF;
            ELSE
                RAISE EXCEPTION 'O código da operação não foi encontrado, verifique se as datas iniciais e finais dos incentivos da pessoa estão dentro da data inicial e final do período letivo.';
            END IF;
        END LOOP;
    END LOOP;

    RETURN TRUE;
END;
$$;


ALTER FUNCTION public.generatecontractincentivesbyperiod(p_contractid integer, p_learningperiodid integer) OWNER TO postgres;

--
-- Name: generateenrollfeebyinvoiceid(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION generateenrollfeebyinvoiceid(p_invoiceid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE    
    v_enrollFee RECORD; --Taxas de matrícula
    v_entries RECORD; --Lanéamentos
    v_parcelNumber INT; --Numero da parcela
    v_value NUMERIC; --Valor da taxa
    v_entry RECORD; --Lanéamento para aglutinar taxa   
    v_entryId INT; --Lanéamento para aglutinar taxa
BEGIN    
    --número da parcela
    v_parcelNumber := parcelNumber FROM finReceivableInvoice WHERE invoiceId = p_invoiceId;

    --Percorrer cada taxa de matrícula do peréodo letivo
    FOR v_enrollFee IN SELECT * FROM finEnrollFee WHERE learningPeriodId IN (SELECT learningPeriodId FROM finEntry WHERE invoiceid = p_invoiceId AND learningPeriodId IS NOT NULL)
    LOOP
        --Percorrer cada lanéamento do tétulo que possua contrato
        FOR v_entries IN SELECT * FROM finEntry WHERE invoiceId = p_invoiceId AND contractId IS NOT NULL
        LOOP
            IF ( v_entries.operationId IN (SELECT renewaloperation FROM findefaultOperations UNION SELECT enrolloperation FROM findefaultOperations) ) AND ( v_parcelNumber <= v_enrollFee.parcelsnumber ) AND ( (v_enrollFee.isfreshman AND isfreshman(v_entries.contractId)) OR ( v_enrollFee.isfreshman IS FALSE AND isfreshman(v_entries.contractId) IS FALSE ) )
            THEN
                -- Procurar por outro lanéamento igual. se existir, não inserir novo, pois
                --a taxa de matrícula do contrato jé teré sido gerada
                IF COUNT(*) <= 0 FROM finEntry WHERE invoiceId = p_invoiceId AND contractId = v_entries.contractId AND operationId = v_enrollFee.operationId AND learningPeriodId = v_enrollFee.learningPeriodId
                THEN
                    -- Se valor é percentual, obter a soma dos lanéamentos do tipo mensalidade
                    --para o tétulo atual e aplicar o percentual para definir o valor
                    IF v_enrollFee.valueIsPercent IS TRUE
                    THEN
                        -- aplicar percentual sobre lanéamento atual, que seré sempre de matrícula ou renovação  
                        v_value := v_entries.value * ( v_enrollFee.value /100 );
                    ELSE
                        --Se o valor é fixo, simplismente gerar o novo valor
                        v_value := v_enrollFee.value;
                    END IF;

                    --Caso ja existir um lanéamento aglutina o lanéamento
                    IF getParameter('FINANCE', 'AGGLUTINATE_INVOICE_ENTRIES') = 'YES'
                    THEN
                        SELECT INTO v_entry * FROM finEntry 
                                                WHERE invoiceId = p_invoiceId 
                                                  AND contractId = v_entries.contractId 
                                                  AND operationId = v_enrollFee.operationId
                                                  AND learningPeriodId = v_enrollFee.learningPeriodId
                                                  AND isaccounted IS FALSE
                                                  AND creationtype = v_entries.creationtype
                                                  AND costcenterid = v_entries.costcenterid;   
                        
                        v_entryId := v_entry.entryId; --Atribui o codigo para aglutinar

                    END IF;

                    --Realiza o update
                    UPDATE finEntry
                       SET invoiceId = p_invoiceId,
                           operationId = v_enrollFee.operationId,
                           entryDate = now()::date,
                           value = ROUND(v_entries.value + v_value,2),
                           costCenterId = v_entries.costCenterId,
                           comments = E'\n Aglutinada parcela '||v_parcelNumber||' de '|| v_enrollFee.parcelsNumber ||' da taxa '|| v_enrollFee.operationId ||' - '|| (SELECT description FROM finoperation WHERE operationId = v_enrollFee.operationId ) ||'.',
                           bankReturnCode = v_entries.bankReturnCode,
                           isAccounted = v_entries.isAccounted,
                           contractId = v_entries.contractId,
                           learningPeriodId = v_entries.learningPeriodId,
                           bankMovementId = v_entries.bankMovementId
                     WHERE entryId  = v_entryId;

                     --Caso lanéamento não existir insere o lanéamento da taxa
                     IF NOT FOUND THEN
                        INSERT INTO finEntry (
                                    invoiceid, 
                                    operationId, 
                                    entryDate, 
                                    value, 
                                    costcenterId, 
                                    comments, 
                                    bankreturncode, 
                                    isaccounted, 
                                    contractid, 
                                    learningPeriodId,
                                    bankMovementId )
                                    VALUES
                                  ( p_invoiceId,
                                    v_enrollFee.operationId,
                                    now()::date,
                                    ROUND(v_value,2),
                                    v_entries.costCenterId,
                                    E'\n Parcela '||v_parcelNumber||' de '|| v_enrollFee.parcelsNumber ||' da taxa '|| v_enrollFee.operationId ||' - '|| (SELECT description FROM finoperation WHERE operationId = v_enrollFee.operationId ) ||'.',
                                    v_entries.bankReturnCode,
                                    v_entries.isAccounted,
                                    v_entries.contractId,
                                    v_entries.learningPeriodId,
                                    v_entries.bankMovementId );
                     END IF;
                END IF;
            END IF;
        END LOOP;
    END LOOP;

    RETURN TRUE;
END;
$$;


ALTER FUNCTION public.generateenrollfeebyinvoiceid(p_invoiceid integer) OWNER TO postgres;

--
-- Name: generatepersonalagenda(date, date, character varying[], character varying[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION generatepersonalagenda(p_begindate date, p_enddate date, p_opts character varying[], p_values character varying[]) RETURNS TABLE(referencedate date, dayevents text)
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: generatePersonalAgenda
  PURPOSE: Gera a lista de atividades em cada dia do período especificado, conforme os
           parâmetros.
  DESCRIPTION: Lista de parâmetros possíveis e suas funções:
    - separator Indicando o separador de eventos. Padrão: <br />;

    - courseId Filtra por curso
    - courseVersion Filtra por versão de curso
    - turnId Filtra por turno
    - unitId Filtra por unidade

    - showCurricularComponents Indica se deve retornar as oferecidas do dia.
    - showEvents Indica se deve retornar eventos que ocorrem no dia.
    - showEnrollPeriods Indica se deve exibir períodos de matrícula.
    - showAcademicCalendar Indica se deve exibir eventos do calendário acadêmico.

  USAGE:

    SELECT *
      FROM generatePersonalAgenda(
              '2010-01-01', -- beginDate
              '2010-12-31', -- endDate
              ARRAY['separator', 'showCurricularComponents', 'showEvents', 'showAcademicCalendar', 'showEnrollPeriods', 'courseId'],
              ARRAY['<br />',    'f',                        't',          't',                    'f',                 'ENF01N']
           );

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       20/05/2011 Alex Smith        1. Função criada.
**************************************************************************************/
DECLARE
    v_sql text;
    v_where text;

    v_index integer;

    -- Opcao 'separator', indicando o separador de eventos
    v_separator text;

    -- Opcao 'courseId', especificando filtro por curso
    v_courseId varchar;
    -- Opcao 'courseVersion', especificando filtro por versao de curso
    v_courseVersion varchar;
    -- Opcao 'turnId', especificando filtro por turno
    v_turnId varchar;
    -- Opcao 'unitId', especificando filtro por unidade
    v_unitId varchar;

    -- Opao para exibir ou nao disciplinas que ocorrem na data
    v_showCurricularComponents boolean;
    -- Opcao para exibir ou nao registros de eventos (acdEvent)
    v_showEvents boolean;
    -- Opcao para exibir ou nao periodos de matricula (acdPeriodEnrollDate)
    v_showEnrollPeriods boolean;
    -- Opcao para exibir ou nao calendario academico (acdAcademicCalendar)
    v_showAcademicCalendar boolean;

BEGIN
    -- abortar em caso de erro na especificacao de parametros
    IF COALESCE(array_length(p_opts, 1) != array_length(p_values, 1), TRUE) THEN
        RAISE EXCEPTION 'Quantidade de opções e valores incompatíveis.';
    END IF;

    -- inicializar opcoes

    -- separador
    v_separator := '<br />';
    -- ocorrencia de curso
    v_courseId := NULL;
    v_courseVersion := NULL;
    v_turnId := NULL;
    v_unitId := NULL;
    -- o que sera listado
    v_showCurricularComponents := TRUE;
    v_showEvents := TRUE;
    v_showEnrollPeriods := TRUE;
    v_showAcademicCalendar := TRUE;

    -- processar opcoes
    v_index := 1;
    WHILE v_index <= array_length(p_opts, 1) LOOP
        CASE p_opts[v_index]
            WHEN 'separator' THEN
                v_separator := p_values[v_index];
            WHEN 'courseId' THEN
                v_courseId := p_values[v_index];
            WHEN 'courseVersion' THEN
                v_courseVersion := p_values[v_index];
            WHEN 'turnId' THEN
                v_turnId := p_values[v_index];
            WHEN 'unitId' THEN
                v_unitId := p_values[v_index];
            WHEN 'showCurricularComponents' THEN
                v_showCurricularComponents := p_values[v_index] = 't';
            WHEN 'showEvents' THEN
                v_showEvents := p_values[v_index] = 't';
            WHEN 'showEnrollPeriods' THEN
                v_showEnrollPeriods := p_values[v_index] = 't';
            WHEN 'showAcademicCalendar' THEN
                v_showAcademicCalendar := p_values[v_index] = 't';
            ELSE
                RAISE EXCEPTION 'Opção não reconhecida: %', p_opts[v_index];
        END CASE;
        v_index := v_index + 1;
    END LOOP;

    v_sql := 'SELECT A.referenceDate::date,
                     ARRAY_TO_STRING(ARRAY_AGG(B.eventDescription), ''' || v_separator || ''')::text AS dayEvents
                FROM (SELECT GENERATE_SERIES(''' || p_beginDate || '''::date,
                                             ''' || p_endDate || '''::date+1,
                                             ''1 day'') AS referenceDate) A
          INNER JOIN (';

    IF v_showCurricularComponents THEN
        v_sql := v_sql || '
                      -- Disciplinas oferecidas por data
                      SELECT DISTINCT UNNEST(D.occurrenceDates) AS occurrenceDate,
                             1 AS appearanceOrder,
                             B.courseId || ''/'' || B.courseVersion || '' '' || E.shortName || '' - '' || A.curricularComponentId || ''/'' || A.curricularComponentVersion || '' '' || A.shortName AS eventDescription
                        FROM acdCurricularComponent A
                  INNER JOIN acdCurriculum B
                          ON B.curricularComponentId = A.curricularComponentId
                         AND B.curricularComponentVersion = A.curricularComponentVersion
                  INNER JOIN acdGroup C
                          ON C.curriculumId = B.curriculumId
                  INNER JOIN acdSchedule D
                          ON D.groupId = C.groupId
                  INNER JOIN acdCourse E
                          ON E.courseId = B.courseId';

        v_where := '';
        IF v_courseId IS NOT NULL THEN
            v_where := v_where || ' AND B.courseId = ''' || v_courseId || '''';
        END IF;
        IF v_courseVersion IS NOT NULL THEN
            v_where := v_where || ' AND B.courseVersion = ' || v_courseVersion;
        END IF;
        IF v_turnId IS NOT NULL THEN
            v_where := v_where || ' AND B.turnId = ' || v_turnId;
        END IF;
        IF v_unitId IS NOT NULL THEN
            v_where := v_where || ' AND B.unitId = ' || v_unitId;
        END IF;

        v_sql := v_sql || CASE WHEN LENGTH(v_where) > 0 THEN ' WHERE ' || SUBSTR(v_where, 6) ELSE '' END || ' UNION';
    END IF;

    IF v_showEvents THEN
        v_sql := v_sql || '
                      -- Eventos (acdEvent)
                      SELECT GENERATE_SERIES(A.beginDate, A.endDate+1, ''1 day'') AS occurrenceDate,
                             2 AS appearanceOrder,
                             A.description AS eventDescription
                        FROM acdEvent A
                       UNION';
    END IF;

    IF v_showEnrollPeriods THEN
        v_sql := v_sql || '
                      -- Períodos de matrícula (acdPeriodEnrollDate)
                      SELECT GENERATE_SERIES(A.beginDate, A.endDate+1, ''1 day'') AS occurrenceDate,
                             3 AS appearanceOrder,
                             A.description AS eventDescription
                        FROM acdPeriodEnrollDate A
                  INNER JOIN acdLearningPeriod B
                          ON A.learningPeriodId = B.learningPeriodId';

        v_where := '';
        IF v_courseId IS NOT NULL THEN
            v_where := v_where || ' AND B.courseId = ''' || v_courseId || '''';
        END IF;
        IF v_courseVersion IS NOT NULL THEN
            v_where := v_where || ' AND B.courseVersion = ' || v_courseVersion;
        END IF;
        IF v_turnId IS NOT NULL THEN
            v_where := v_where || ' AND B.turnId = ' || v_turnId;
        END IF;
        IF v_unitId IS NOT NULL THEN
            v_where := v_where || ' AND B.unitId = ' || v_unitId;
        END IF;

        v_sql := v_sql || CASE WHEN LENGTH(v_where) > 0 THEN ' WHERE ' || SUBSTR(v_where, 6) ELSE '' END || ' UNION';
    END IF;

    IF v_showAcademicCalendar THEN
        v_sql := v_sql || '
                      -- Calendario academico (acdAcademicCalendar)
                      SELECT A.eventDate AS occurrenceDate,
                             4 AS appearanceOrder,
                             A.description AS eventDescription
                        FROM acdAcademicCalendarEvent A';

        v_where := '';
        IF v_courseId IS NOT NULL THEN
            v_where := v_where || ' AND (A.courseId = ''' || v_courseId || ''' OR A.courseId IS NULL)';
        END IF;
        IF v_courseVersion IS NOT NULL THEN
            v_where := v_where || ' AND (A.courseVersion = ' || v_courseVersion || ' OR A.courseVersion IS NULL)';
        END IF;
        IF v_turnId IS NOT NULL THEN
            v_where := v_where || ' AND (A.turnId = ' || v_turnId || ' OR A.turnId IS NULL)';
        END IF;
        IF v_unitId IS NOT NULL THEN
            v_where := v_where || ' AND (A.unitId = ' || v_unitId || ' OR A.unitId IS NULL)';
        END IF;

        v_sql := v_sql || CASE WHEN LENGTH(v_where) > 0 THEN ' WHERE ' || SUBSTR(v_where, 6) ELSE '' END || ' UNION';
    END IF;

    v_sql := SUBSTR(v_sql, 1, LENGTH(v_sql)-5) || '
                     ) B
                  ON B.occurrenceDate = A.referenceDate
            GROUP BY A.referenceDate,
                     B.appearanceOrder
            ORDER BY A.referenceDate,
                     B.appearanceOrder';

    RETURN QUERY EXECUTE v_sql;
END;
$$;


ALTER FUNCTION public.generatepersonalagenda(p_begindate date, p_enddate date, p_opts character varying[], p_values character varying[]) OWNER TO postgres;

--
-- Name: gerarferias(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gerarferias(p_contractid integer, p_learningperiodid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: gerarmensalidades
  PURPOSE: Gera os títulos referentes as disciplinas de férias

  REVISIONS:
  Ver       Date       Author             Description
  --------- ---------- ------------------ ------------------------------------
  1.0       XX/XX/XXXX XXXXXXXXXXX        1. FUNÇÃO criada.
  1.0       17/07/2014 Samuel Koch        1. Alterado função para não gerar parcela
                                             quando não existe matrícula.
**************************************************************************************/
DECLARE
    -- Valor a lançar, quando já existe título
    VLNC numeric;

    -- Valor do curso de férias
    p_value numeric;

    -- Código do título gerado
    v_invoiceid integer;

    -- Objeto que representa o contrato
    v_contrato acdcontract;

    -- Objeto que representa o período letivo
    v_periodo acdlearningperiod;

    -- Objeto que representa o preço de curso
    v_preco record;

    -- Numero de creditos em disciplinas de ferias
    v_creditos_ferias integer;

    -- Objeto que representa o título existente referente à parcela
    v_titulo finreceivableinvoice;

    -- Operação do lançamento
    v_operacao integer;

    -- Política para o novo título
    v_politica integer;

    -- Variáveis referentes à data de vencimento
    -- Data de vencimento
    v_data_vencimento date;

    -- Dia
    v_dia_vencimento integer;

    -- Mês
    v_mes_vencimento integer;

    -- Ano
    v_ano_vencimento integer;

    -- Dia da semana
    v_dia_da_semana integer;

    -- Variáveis referentes à data de referência
    -- Dia
    v_dia_referencia integer;

    -- Mês
    v_mes_referencia integer;

    -- Ano
    v_ano_referencia integer;

    -- Dias a serem somados/subtraídos da data de vencimento qdo esta cair em finais de semana
    v_dias_diferenca integer;

    -- Data temporária (para ajustes)
    v_tmp_data date;

    -- Centro de custo
    v_centro_de_custo varchar;
BEGIN
    SELECT INTO v_contrato * FROM acdContract WHERE contractId = p_contractId;
    SELECT INTO v_periodo * FROM acdLearningPeriod WHERE learningperiodid = p_learningPeriodId;

    v_creditos_ferias := obtemcreditoferias(p_contractId, p_learningPeriodId);

    v_politica := obtemPoliticaDoPreco(p_contractId, 0, p_learningPeriodId);

    -- Se é a primeira parcela e se a primeira deve ser à vista, o vencimento é no dia seguinte
    v_preco := obterprecoatual(v_contrato.courseid, v_contrato.courseversion, v_contrato.turnid, v_contrato.unitid, v_periodo.begindate);

    p_value := v_creditos_ferias * v_preco.valorcreditoferias;

--Validações
RAISE NOTICE 'Preço: %', v_preco.value;
RAISE NOTICE 'Política: %', v_politica;
RAISE NOTICE 'Creditos ferias: %', v_creditos_ferias;
RAISE NOTICE 'Valor: %', p_value ;

    -- Verifica se já existe um título gerado para a parcela
    SELECT INTO v_titulo * 
                       FROM finReceivableInvoice A
                      WHERE isCanceled IS FALSE
                        AND parcelNumber = 0
                        AND EXISTS (SELECT 1
                                      FROM finentry
                                     WHERE invoiceid = A.invoiceid
                                       AND contractId = p_contractId)
                        AND EXISTS (SELECT 1
                                      FROM finentry AA
                                     INNER JOIN acdlearningperiod BB USING (learningperiodid)
                                     WHERE invoiceid = A.invoiceid
                                       AND BB.periodid = v_periodo.periodid);

    -- Se já existe título, utiliza o existente, apenas atualizando o valor através dos lançamentos
    IF v_titulo.invoiceid IS NOT NULL THEN

        IF v_titulo.balance <= 0 THEN RETURN NULL; END IF;

        VLNC := p_value - v_titulo.nominalvalue;        

        IF VLNC > 0 THEN
            SELECT INTO v_operacao addcurricularcomponentoperation FROM findefaultoperations LIMIT 1;
        ELSE 
            IF VLNC < 0 THEN
                VLNC := VLNC * (-1);
                SELECT INTO v_operacao cancelcurricularcomponentoperation FROM findefaultoperations LIMIT 1;
            END IF;
        END IF;

        IF VLNC > 0 THEN
            INSERT INTO finentry 
                        (invoiceid, 
                         operationid, 
                         entrydate, 
                         value, 
                         costcenterid, 
                         contractid, 
                         learningperiodid)
                 VALUES (v_titulo.invoiceid,
                         v_operacao,
                         now()::date,
                         ROUND(VLNC::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer),
                         v_titulo.costcenterid,
                         v_contrato.contractid,
                         v_periodo.learningperiodid);
        END IF;

        v_invoiceid := v_titulo.invoiceid;

        UPDATE fininvoice SET value = balance(v_invoiceid) WHERE invoiceid = v_invoiceid;
    -- Senao deve-se criar um novo título
    ELSE
        IF p_value > 0 THEN

            v_data_vencimento := now()::date + 1;            

            IF getParameter('FINANCE', 'VENCIMENTO_EM_FINAIS_DE_SEMANA') = 'NO'
            THEN
                -- Se a data de vencimento cair num final de semana deve-se alterar o dia de vencimento
                IF EXTRACT(DOW FROM v_data_vencimento) = 0 THEN
                    v_dias_diferenca := 1;
                ELSE 
                    IF EXTRACT(DOW FROM v_data_vencimento) = 6 THEN
                        v_dias_diferenca := 2;
                    ELSE
                        v_dias_diferenca := 0;
                    END IF;
                END IF;
            ELSE
                v_dias_diferenca := 0;
            END IF;

            IF v_dias_diferenca > 0 THEN
                -- Se a primeira parcela for à vista ou se estiver configurado para adiar, o vencimento cai na próxima segunda-feira
                v_data_vencimento := v_data_vencimento + v_dias_diferenca;
            END IF;

            -- Obtem atributos do título
            -- Centro de custo
            -- Centro de custo
            SELECT INTO v_centro_de_custo costcenterid
                                     FROM acccourseaccount
                                    WHERE courseid = v_contrato.courseid
                                      AND courseversion = v_contrato.courseversion
                                      AND unitid = v_contrato.unitid;

            v_invoiceid := nextval('seq_invoiceid');

            -- Insere o título na fininvoice
            INSERT INTO fininvoice (invoiceid,
                                    personid,
                                    costcenterid,
                                    parcelnumber,
                                    emissiondate,
                                    maturitydate,
                                    value,
                                    policyid,
                                    incomesourceid,
                                    bankaccountid,
                                    emissiontypeid,
                                    referencematuritydate)
                            VALUES (v_invoiceid,
                                    v_contrato.personid,
                                    v_centro_de_custo,
                                    0,
                                    now()::date,
                                    v_data_vencimento,
                                    0,
                                    v_politica,
                                    getParameter('FINANCE', 'INCOME_SOURCE_ID')::integer,
                                    v_preco.bankaccountid,
                                    getParameter('BASIC', 'DEFAULT_EMISSION_TYPE_ID')::integer,
                                    v_data_vencimento);

            -- Insere o título na finreceivableinvoice (redundância por causa das heranças do Sagu)
            INSERT INTO finreceivableinvoice 
                                   (invoiceid,
                                    personid,
                                    costcenterid,
                                    parcelnumber,
                                    emissiondate,
                                    maturitydate,
                                    value,
                                    policyid,
                                    incomesourceid,
                                    bankaccountid,
                                    emissiontypeid,
                                    referencematuritydate,
                                    sem_descontos)
                            VALUES (v_invoiceid,
                                    v_contrato.personid,
                                    v_centro_de_custo,
                                    0,
                                    now()::date,
                                    v_data_vencimento,
                                    0,
                                    v_politica,
                                    getParameter('FINANCE', 'INCOME_SOURCE_ID')::integer,
                                    v_preco.bankaccountid,
                                    getParameter('BASIC', 'DEFAULT_EMISSION_TYPE_ID')::integer,
                                    v_data_vencimento,
                                    true);

            -- Obter a operação padrão de mensalidades
            SELECT INTO v_operacao monthlyfeeoperation FROM findefaultoperations LIMIT 1;

            -- Insere um lançamento no valor da parcela       
            INSERT INTO finentry 
                            (invoiceid, 
                             operationid, 
                             entrydate, 
                             value, 
                             costcenterid, 
                             contractid, 
                             learningperiodid)
                     VALUES (v_invoiceid,
                             v_operacao,
                             now()::date,
                             ROUND(p_value::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer),
                             v_centro_de_custo,
                             v_contrato.contractid,
                             v_periodo.learningperiodid);

            -- Atualiza o atributo valor
            UPDATE fininvoice SET value = ROUND(balance(v_invoiceid)::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer) WHERE invoiceid = v_invoiceid;
        END IF;
    END IF;

    RETURN v_invoiceid;
END;
$$;


ALTER FUNCTION public.gerarferias(p_contractid integer, p_learningperiodid integer) OWNER TO postgres;

--
-- Name: gerarincentivos(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gerarincentivos(p_contractid integer, p_learningperiodid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: gerarincentivos
  PURPOSE: gera os incentivos de um contrato em determinado periodo letivo

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       06/03/2013 Leovan Tavares    1. Funcao criada.
**************************************************************************************/
DECLARE
    -- Valor nominal dos titulos que devem receber incentivo
    PRECO numeric;
    -- Valor de incentivo a conceder
    VINC numeric;
    -- Valor de incentivo bloqueado
    VBLK numeric;
    -- Valor de incentivo a lancar
    VALC numeric;
    -- Valor por parcela
    VPCL numeric;
    -- Valor do lancamento
    VLNC numeric;
    -- Valor nao lancado por falta de saldo
    VNLC numeric;
    -- Numero de parcelas a conceder o incentivo (nao bloqueadas)
    NPCL integer;
    
    -- Objeto para representar um incentivo
    v_incentivo finincentive;
    -- Objeto para representar um tipo de incentivo
    v_tipo_incentivo finincentivetype;
    -- Objeto para representar o contrato
    v_contrato acdcontract;
    -- Objeto para representar o peri­odo letivo
    v_periodo acdlearningperiod;
    
    -- Variaveis para receber informacoes dos ti­tulos que devem receber incentivo
    v_titulos_npcl integer;
    v_titulos_preco numeric;
    
    -- Variaveis para receber informacoes dos titulos bloqueados
    v_bloqueados_bpcl integer;
    v_bloqueados_pblk numeric;
    v_bloqueados_vblk numeric;
    
    -- Objeto para representar um ti­tulo
    v_titulo finreceivableinvoice;

    --Informa se titulos bloqueados podem ou não receber incentivos
    v_somenteTitulosEmDia boolean;

    --Saldo nao bloqueado
    v_saldo numeric;
BEGIN
    -- Obter contrato
    SELECT INTO v_contrato * FROM acdcontract WHERE contractid = p_contractId;
    
    -- Obter peri­odo letivo
    SELECT INTO v_periodo * FROM acdlearningperiod WHERE learningperiodid = p_learningPeriodId;

    -- Verificar incentivos ativos no periodo letivo
    FOR v_incentivo IN SELECT * 
                         FROM finincentive 
                        WHERE contractid = p_contractId 
                          AND (v_periodo.beginDate, v_periodo.endDate) OVERLAPS (startDate, endDate)
    LOOP
        -- Obter o tipo de incentivo
        SELECT INTO v_tipo_incentivo * FROM ONLY finincentivetype WHERE incentivetypeid = v_incentivo.incentivetypeid;
        
        -- Obtem o numero de ti­tulos sobre o qual aplicar o incentivo
        SELECT INTO v_titulos_npcl, v_titulos_preco 
                              COUNT(*), SUM(nominalvalue)
                         FROM finreceivableinvoice A
                        WHERE referencematuritydate BETWEEN v_incentivo.startdate AND v_incentivo.enddate
                          AND iscanceled IS FALSE
                          AND EXISTS (SELECT 1 FROM finentry
                                       WHERE invoiceid = A.invoiceid
                                         AND contractid = p_contractId)
                          AND EXISTS (SELECT 1 FROM finentry AA INNER JOIN acdlearningperiod BB USING (learningperiodid)
                                       WHERE AA.invoiceid = A.invoiceid
                                         AND BB.periodid = v_periodo.periodid) ;

        -- Obtem informacoes sobre os titulos bloqueados
        SELECT INTO v_bloqueados_bpcl, v_bloqueados_pblk, v_bloqueados_vblk 
                    COUNT(*), 
                    SUM(nominalvalue), 
                    SUM(incentivevalue)
          FROM obtertitulosbloqueadosparaincentivos(p_contractId, p_learningPeriodId, v_incentivo.incentivetypeid);

        -- Alimentando variaveis
        PRECO := COALESCE(v_titulos_preco, 0);
        VBLK := COALESCE(v_bloqueados_vblk, 0);
        NPCL := COALESCE(v_titulos_npcl, 0) - COALESCE(v_bloqueados_bpcl, 0);

        -- Obtencao do valor de incentivo a conceder (VINC)
        -- Se o valor e em percentual
        IF v_incentivo.valueispercent IS TRUE THEN
            VINC := PRECO * (v_incentivo.value / 100);
        ELSE
            VINC := v_incentivo.value;
        END IF;

        -- Valor a conceder
        VALC := VINC - VBLK;
        
        CONTINUE WHEN VALC <= 0 OR NPCL <= 0;
        
        --Alterado o código abaixo, pois devido a essa validação
        --não estava considerando se havia mais incentivos lançados para a pessoa.        
        --IF VALC <= 0 OR NPCL <= 0 THEN
        --    RETURN TRUE;
        --END IF;
        
        -- Valor a ser lancado em cada ti­tulo aberto
        VPCL := VALC / NPCL;

        -- Inicializa o valor nao lancado
        VNLC := 0;

        -- Percorre os titulos abertos fazendo os lancamentos
        FOR v_titulo IN SELECT *
                          FROM finreceivableinvoice A
                         WHERE iscanceled IS FALSE
                           AND titulobloqueado(invoiceid, true) IS FALSE
                           AND referencematuritydate BETWEEN v_incentivo.startdate AND v_incentivo.enddate
                           AND EXISTS (SELECT 1 FROM finentry
                                       WHERE invoiceid = A.invoiceid
                                         AND contractid = p_contractId)
                           AND EXISTS (SELECT 1 FROM finentry AA INNER JOIN acdlearningperiod BB USING (learningperiodid)
                                       WHERE AA.invoiceid = A.invoiceid
                                         AND BB.periodid = v_periodo.periodid)
        LOOP
            -- Primeiramente exclui todos os lancamentos referentes ao incentivo
            DELETE FROM finentry 
             WHERE invoiceid = v_titulo.invoiceid 
               AND operationid IN (v_tipo_incentivo.operationid, v_tipo_incentivo.paymentoperation, v_tipo_incentivo.repaymentoperation);

            -- Se esta-se utilizando a primeira parcela integral, pode haver diferença no valor
            -- das parcelas (nao sao todas iguais). Neste caso, lanca-se o incentivo proporcionalmente
            IF (getParameter('FINANCE', 'PRIMEIRA_PARCELA_INTEGRAL') = 'YES') THEN
                v_saldo = PRECO - COALESCE(v_bloqueados_pblk, 0);

                IF v_saldo > 0 THEN
                    VPCL := VALC * (COALESCE(v_titulo.nominalvalue, 0)/v_saldo);
                END IF;
            END IF;
               
            -- O valor a lancar e o valor programado mais o que ficou 'para tras' dos outros ti­tulos
            VLNC := VPCL + VNLC;
            VNLC := 0;            
      
            -- Verifica se ha saldo no ti­tulo para lancar o incentivo
            IF VLNC > balance(v_titulo.invoiceid) THEN
                -- Se valor e maior que o saldo do ti­tulo, lanca o valor disponivel e atualiza VNLC
                VNLC := VLNC - balance(v_titulo.invoiceid);
                VLNC := balance(v_titulo.invoiceid);
            END IF;
            
            IF ( VLNC > 0) THEN
                -- Insere o lancamento do incentivo
                INSERT INTO  finentry
                            (invoiceid,
                             operationid,
                             entrydate,
                             value,
                             costcenterid,
                             contractid,
                             learningperiodid,
                             incentivetypeid)
                     VALUES (v_titulo.invoiceid,
                             v_tipo_incentivo.operationid,
                             now()::date,
                             ROUND(VLNC::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer),
                             v_titulo.costcenterid,
                             p_contractId,
                             p_learningPeriodId,
                             v_incentivo.incentivetypeid);

                -- Atualiza saldo do titulo
                UPDATE fininvoice SET value = ROUND(balance(v_titulo.invoiceid)::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer) WHERE invoiceid = v_titulo.invoiceid;
            END IF;
        END LOOP;
    END LOOP;
    
    RETURN TRUE;
END;
$$;


ALTER FUNCTION public.gerarincentivos(p_contractid integer, p_learningperiodid integer) OWNER TO postgres;

--
-- Name: gerarmensalidades(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gerarmensalidades(p_contractid integer, p_learningperiodid integer) RETURNS SETOF integer
    LANGUAGE plpgsql
    AS $$
/*********************************************************************************************
  NAME: gerarMensalidades
  PURPOSE: Algoritmo de geracao de mensalidades.
*********************************************************************************************/
DECLARE
    V_CONTRATO RECORD;
    V_PLETIVO RECORD;
    V_OBJPRICE RECORD;
    V_OBJCOURSEACCOUNT RECORD;
    V_CONTRACTCLASS RECORD;
    V_CLASSPERIOD INT;
    V_ENROLL RECORD;
    V_SEMESTER INT;
    V_CURRICULUMID INT;
    V_NUMHOURS RECORD;
    V_GROUP RECORD;
    V_POLICY RECORD;
    V_PROFACTIVITY INT[];
    V_PARCELNUMBER INT;
    
    V_PRECO FLOAT;
    V_NPCL INT;
    V_BPCL INT;
    V_CFIXO FLOAT;
    V_CHTOTAL FLOAT;
    V_CHPREV FLOAT;
    V_CHCONT FLOAT;
    V_CHPRAT FLOAT;
    V_CHESP FLOAT;
    V_CHDPRAT FLOAT;
    V_CHDTEOR FLOAT;
    V_CHMED FLOAT;
    V_MULT_PRAT FLOAT;
    V_MULT_TEOR FLOAT;
    V_MULT_ESP FLOAT;
    V_MULT_MED FLOAT;
    V_PER_ESP FLOAT;
    V_SEMESTRES INT;
    V_APCL INT;
    V_PENDINGCURRICULUM RECORD;
    V_SUMVALUE FLOAT;
    V_SUBVALUE FLOAT;
    V_BLOCKINVOICEID INT;
    V_INVOICEID INT;
    
    V_MENS FLOAT;
    V_VCONT FLOAT;
    V_DPPRAT FLOAT;
    V_DPTEOR FLOAT;
    V_DPESP FLOAT;
    V_DPMED FLOAT;
    V_DP FLOAT;
    v_DPVALUE FLOAT;
    V_AJT FLOAT;
    V_VB FLOAT;

    V_ISBLOCKED BOOLEAN;

    V_MATURITYDAY INTEGER;
    V_MATURITYMONTH INTEGER;
    V_MATURITYYEAR INTEGER;
    V_MATURITYDATE DATE;
    V_REFERENCEMATURITYDATE DATE;

    V_INVOICEIDDEPENDENCE INTEGER;

    V_OPERATIONID INTEGER;
BEGIN
    V_CHCONT := 0;
    V_CHPRAT := 0;
    V_CHESP := 0;
    V_CHDPRAT := 0;
    V_CHDTEOR := 0;
    V_CHMED := 0;
    V_MULT_PRAT := 2.5;
    V_MULT_TEOR := 2;
    V_MULT_ESP := 40;
    V_MULT_MED := 85;
    V_PER_ESP := 0.8543;
    
    SELECT INTO V_CONTRATO * FROM acdContract WHERE contractId = p_contractId;
    SELECT INTO V_PLETIVO * FROM acdLearningPeriod WHERE learningPeriodId = p_learningPeriodId;
    SELECT INTO V_OBJPRICE * FROM obterPrecoAtual(V_CONTRATO.courseId, V_CONTRATO.courseVersion, V_CONTRATO.turnId, V_CONTRATO.unitId, V_PLETIVO.beginDate);
    SELECT INTO V_OBJCOURSEACCOUNT * FROM getCourseAccount(V_CONTRATO.courseid, V_CONTRATO.courseversion, V_CONTRATO.unitid);
    SELECT INTO V_CONTRACTCLASS * FROM getcontractcurrentclass(V_CONTRATO.contractid);
    SELECT INTO V_CHTOTAL hourtotal FROM acdcourseversion WHERE courseid = V_CONTRATO.courseid AND courseversion = V_CONTRATO.courseversion;
    SELECT INTO V_SEMESTRES periodtotal FROM acdcourseversion WHERE courseid = V_CONTRATO.courseid AND courseversion = V_CONTRATO.courseversion;
    V_CLASSPERIOD := getClassPeriod(V_CONTRACTCLASS.classid, p_learningperiodid);

    IF V_OBJCOURSEACCOUNT.costcenterid IS NULL
    THEN
        RAISE EXCEPTION 'Nenhum centro de custo registrado para o curso, turno e unidade. Verifique o formulário de cadastro de plano de contas e centro de custo para um curso.';
    END IF;

    V_PRECO := V_OBJPRICE.value;
    V_NPCL := obternumeroparcelasprioridade(V_CONTRATO.parcelsnumber, V_PLETIVO.parcelsnumber, V_OBJPRICE.parcelsnumber);
    V_CFIXO := V_OBJPRICE.fixedValue / V_NPCL;
    V_SEMESTER := (V_CLASSPERIOD - 1);
    SELECT INTO V_PENDINGCURRICULUM * FROM getPendingCurriculumIds(V_CONTRATO.contractid, V_SEMESTER);
    
    -- Obtem carga horaria
    IF ( GETPARAMETER('ACADEMIC', 'ENROLL_BASED_ON_CURRICULUM') = 't' )
    THEN
        V_CHPREV := getperiodhours(V_CONTRATO.courseId, V_CONTRATO.courseversion, V_CONTRATO.turnid, V_CONTRATO.unitid, V_CLASSPERIOD);
    ELSE
        V_CHPREV := getHoursAvailableForEnroll(V_CONTRATO.contractid, V_CONTRACTCLASS.classid, p_learningperiodid);
    END IF;

    -- Percorre matriculas
    FOR V_ENROLL IN (SELECT A.enrollId, A.contractId, B.groupId, A.curriculumId
                       FROM acdEnroll A
                      INNER JOIN acdGroup B ON (A.groupId = B.groupId)
                      INNER JOIN acdLearningPeriod C ON (B.learningPeriodId = C.learningPeriodId)
                      WHERE A.contractId = V_CONTRATO.contractId
                        AND C.periodId = V_PLETIVO.periodid
                        AND (statusId = getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED')::int OR
                             statusId = getParameter('ACADEMIC', 'ENROLL_STATUS_APPROVED')::int OR
                             statusId = getParameter('ACADEMIC', 'ENROLL_STATUS_DISAPPROVED')::int OR
                             statusId = getParameter('ACADEMIC', 'ENROLL_STATUS_DISAPPROVED_FOR_LACKS')::int OR
                             statusId = getParameter('ACADEMIC', 'ENROLL_STATUS_DISAPPROVED_BY_PERIOD')::int OR
                             statusId = getParameter('ACADEMIC', 'ENROLL_STATUS_DEPENDENT')::int)
                        )
    LOOP
        --RAISE NOTICE '%',V_ENROLL.enrollid;
        V_NUMHOURS := getCurriculumNumberHours(V_ENROLL.curriculumId);
        V_CHCONT := V_CHCONT + V_NUMHOURS.academicnumberhours;

        -- Obtem semestres pendentes
        FOR V_CURRICULUMID IN (SELECT getPendingCurriculumIds(V_CONTRATO.contractid, V_SEMESTER))
        LOOP
            -- Caso o curriculum id pendente seja o atual
            IF V_ENROLL.curriculumId = V_CURRICULUMID
            THEN
                -- Verifica se existe codigo da turma
                IF V_ENROLL.groupId IS NULL
                THEN
                    RAISE EXCEPTION 'Erro ao obter código da turma.';
                END IF;

                SELECT INTO V_GROUP * FROM acdGroup WHERE groupId = V_ENROLL.groupId;

                IF V_GROUP.regimenId = GETPARAMETER('BASIC', 'SPECIAL_REGIMEN')::int
                THEN
                    -- FIXME: Verificar esta funcao , no SAGU na versao 2.9 nao existia mais , so na versao antiga FACIMED
                    -- V_PROFACTIVITY := getProfessionalActivityOfProfessorsByGroup(V_ENROLL.groupid);
                    IF ARRAY_LENGTH(V_PROFACTIVITY, 1) > 0
                    THEN
                        -- Soma cargas...
                    ELSE
                        V_CHESP := V_CHESP + V_NUMHOURS.academicNumberHours;
                    END IF;
                ELSE
                    IF V_NUMHOURS.praticalNumberHours > 0
                    THEN
                        V_CHPRAT := V_CHPRAT + V_NUMHOURS.academicNumberHours;
                    ELSE
                        V_CHDTEOR := V_CHDTEOR + V_NUMHOURS.academicNumberHours;
                    END IF;
                END IF;

                -- Desconta das contagens de horas da carga horaria
                V_CHCONT := V_CHCONT - V_NUMHOURS.academicNumberHours;
            END IF;
        END LOOP;
    END LOOP;
RAISE NOTICE 'V_CFIXO: %', V_CFIXO;
RAISE NOTICE 'V_CHPREV: %', V_CHPREV;
RAISE NOTICE 'V_CHCONT: %', V_CHCONT;
    -- Calcular variaveis
    V_MENS := V_PRECO / V_NPCL;
    V_VCONT := (((V_MENS - V_CFIXO) / V_CHPREV) * V_CHCONT) + V_CFIXO;
    V_DPPRAT := (V_MENS / (V_CHTOTAL / V_SEMESTRES)) * V_CHDPRAT * V_MULT_PRAT;
    V_DPTEOR := (V_MENS / (V_CHTOTAL / V_SEMESTRES)) * V_CHDTEOR * V_MULT_TEOR;
    V_DPESP := V_CHESP * V_MULT_ESP * V_PER_ESP;
    V_DPMED := V_CHMED * V_MULT_MED * V_PER_ESP;
    V_DP := V_DPPRAT + V_DPTEOR + V_DPESP + V_DPMED;

RAISE NOTICE 'V_MENS: %', V_MENS;
RAISE NOTICE 'V_VCONT: %', V_VCONT;
RAISE NOTICE 'V_DPPRAT: %', V_DPPRAT;
RAISE NOTICE 'V_DPESP: %', V_DPESP;
RAISE NOTICE 'V_DPTEOR: %', V_DPTEOR;
RAISE NOTICE 'V_DPMED: %', V_DPMED;
RAISE NOTICE 'V_DP: %', V_DP;

    -- Valor da parcela
    V_SUMVALUE := (SELECT SUM(E.value)
                         FROM ONLY finInvoice I
                   INNER JOIN finEntry E
                           ON E.invoiceId = I.invoiceId
                        WHERE I.isCanceled IS FALSE
                          AND EXISTS(SELECT 1 FROM finEntry E1 WHERE E1.invoiceID = I.invoiceId AND E1.contractId = p_contractId AND E1.learningPeriodId = p_learningPeriodId)
                          AND E.operationId IN (SELECT UNNEST(ARRAY[monthlyfeeoperation, renewaloperation,addcurricularcomponentoperation,enrolloperation]) FROM finDefaultOperations)
                          AND getblockedinvoice(p_contractId, p_learningPeriodId, I.parcelNumber, V_VCONT, V_MENS) IS NOT NULL);
    V_SUBVALUE := (SELECT SUM(E.value)
                         FROM ONLY finInvoice I
                   INNER JOIN finEntry E
                           ON E.invoiceId = I.invoiceId
                        WHERE I.isCanceled IS FALSE
                          AND EXISTS(SELECT 1 FROM finEntry E1 WHERE E1.invoiceID = I.invoiceId AND E1.contractId = p_contractId AND E1.learningPeriodId = p_learningPeriodId)
                          AND E.operationId = (SELECT cancelcurricularcomponentoperation FROM finDefaultOperations)
                          AND getblockedinvoice(p_contractId, p_learningPeriodId, I.parcelNumber, V_VCONT, V_MENS) IS NOT NULL);
RAISE NOTICE 'V_SUMVALUE: %', V_SUMVALUE;
RAISE NOTICE 'V_SUBVALUE: %', V_SUBVALUE;
    V_VB := COALESCE(V_SUMVALUE, 0) - COALESCE(V_SUBVALUE, 0);
                          
    -- Numero de parcelas bloqueadas
    V_BPCL := (SELECT COUNT(*)
                 FROM ONLY finInvoice  I
                WHERE EXISTS(SELECT 1 FROM finEntry E WHERE E.invoiceId = I.invoiceId AND E.learningPeriodId = p_learningPeriodId AND E.contractId = p_contractId)
                  AND getblockedinvoice(p_contractId, p_learningPeriodId, I.parcelNumber, V_VCONT, V_MENS) IS NOT NULL
                  );
    -- Numero de parcelas que podem sofrer alteracao
    V_APCL := V_NPCL - V_BPCL;
RAISE NOTICE 'V_BPCL: %', V_BPCL;
RAISE NOTICE 'V_APCL: %', V_APCL;
RAISE NOTICE 'V_VB : %', V_VB;
    IF V_APCL > 0
    THEN
        V_AJT := ((V_VCONT * V_BPCL) - V_VB) / V_APCL;
    ELSE
        V_AJT := 0;
    END IF;

RAISE NOTICE 'V_AJT: %', V_AJT;
    -- Percorre parcelas que podem sofrer alteracao
    V_PARCELNUMBER := 0;
    WHILE V_PARCELNUMBER < V_NPCL
    LOOP
        V_PARCELNUMBER := V_PARCELNUMBER + 1;

        -- Definir data de vencimento da parcela
        V_MATURITYDAY := COALESCE(V_CONTRATO.maturityday, V_OBJPRICE.maturityday);
        V_MATURITYMONTH := EXTRACT('MONTH' FROM V_PLETIVO.begindate);
        V_MATURITYYEAR := EXTRACT('YEAR' FROM V_PLETIVO.begindate);

        V_MATURITYDATE := (V_MATURITYYEAR || '-' || V_MATURITYMONTH || '-' || V_MATURITYDAY)::DATE;

        V_MATURITYDATE := V_MATURITYDATE + ((V_PARCELNUMBER - 1) || ' months')::interval;

        V_MATURITYMONTH := EXTRACT('MONTH' FROM V_MATURITYDATE);

        WHILE V_MATURITYMONTH <> EXTRACT('MONTH' FROM V_MATURITYDATE)
        LOOP
            V_MATURITYDATE := V_MATURITYDATE - '1 DAY'::interval;
        END LOOP;

        V_REFERENCEMATURITYDATE := V_MATURITYDATE;

        -- Verifica se a primeira parcela deve ser a vista
        IF ( (V_PARCELNUMBER = 1 AND V_OBJPRICE.firstparcelatsight IS TRUE AND isfreshman(p_contractId) IS FALSE) OR (V_PARCELNUMBER = 1 AND V_OBJPRICE.firstParcelatsightfreshman IS TRUE AND isfreshman(p_contractId) IS TRUE)) THEN
            V_MATURITYDATE := NOW()::DATE + '1 DAY'::interval;

            -- Se cair num sábado ou domingo deve assumir a data da segunda-feira
            IF (EXTRACT('DOW' FROM V_MATURITYDATE) = 0) THEN
                V_MATURITYDATE := V_MATURITYDATE + '1 DAY'::interval;
            ELSEIF (EXTRACT('DOW' FROM V_MATURITYDATE) = 6) THEN
                V_MATURITYDATE := V_MATURITYDATE + '2 DAYS'::interval;
            END IF;
        END IF;

        -- Obtem politica
        SELECT INTO V_POLICY *
               FROM finPricePolicy
              WHERE courseId = V_CONTRATO.courseId AND courseVersion = V_CONTRATO.courseVersion AND turnid = V_CONTRATO.turnid AND unitid = V_CONTRATO.unitid
                AND startdate = V_OBJPRICE.startdate
                AND parcelNumber = V_PARCELNUMBER AND semester = V_CLASSPERIOD;
                   
        IF V_POLICY IS NULL THEN
            SELECT INTO V_POLICY *
                   FROM finPricePolicy
                  WHERE courseId = V_CONTRATO.courseId AND courseVersion = V_CONTRATO.courseVersion AND turnid = V_CONTRATO.turnid AND unitid = V_CONTRATO.unitid
                    AND startdate = V_OBJPRICE.startdate
                    AND parcelNumber IS NULL AND semester = V_CLASSPERIOD;
        END IF;
        
        IF V_POLICY IS NULL THEN
            SELECT INTO V_POLICY *
                   FROM finPricePolicy
                  WHERE courseId = V_CONTRATO.courseId AND courseVersion = V_CONTRATO.courseVersion AND turnid = V_CONTRATO.turnid AND unitid = V_CONTRATO.unitid
                    AND startdate = V_OBJPRICE.startdate
                    AND parcelNumber = V_PARCELNUMBER AND semester IS NULL;
        END IF;
        
        IF V_POLICY IS NULL THEN
            SELECT INTO V_POLICY *
                   FROM finPricePolicy
                  WHERE courseId = V_CONTRATO.courseId AND courseVersion = V_CONTRATO.courseVersion AND turnid = V_CONTRATO.turnid AND unitid = V_CONTRATO.unitid
                    AND startdate = V_OBJPRICE.startdate
                    AND parcelNumber IS NULL AND semester IS NULL;
        END IF;
        
        IF V_POLICY.policyId IS NULL
        THEN
            RAISE EXCEPTION 'Não foi possível obter a política de cobrança. Verifique o cadastro de preço.';
        END IF;

        -- Obtem o invoiceId bloqueado (caso exista) desta parcela
        V_BLOCKINVOICEID := getblockedinvoice(p_contractId, p_learningPeriodId, V_PARCELNUMBER, V_VCONT, V_MENS);

        -- Se titulo existe e eh bloqueado
        IF V_BLOCKINVOICEID IS NOT NULL
        THEN
            -- Nao faz nada, pula para proxima parcela
RAISE NOTICE '% está bloqueado', V_PARCELNUMBER;
        ELSE
            -- Se titulo existe e eh aberto
            V_INVOICEID := (SELECT getopeninvoicebyparcel(p_contractId, p_learningPeriodId, V_PARCELNUMBER, V_VCONT, V_MENS));
            
            -- Atualiza valor do titulo com V_VCONT
            IF V_INVOICEID IS NOT NULL
            THEN
RAISE NOTICE 'Título % encontrado', V_INVOICEID;
                -- Apaga todos os lançamentos referentes a mensalidade
                DELETE FROM finEntry 
                 WHERE invoiceId = V_INVOICEID 
                   AND operationId IN (SELECT UNNEST(ARRAY[monthlyfeeoperation,renewaloperation,addcurricularcomponentoperation,enrolloperation,cancelcurricularcomponentoperation]) 
                                         FROM finDefaultOperations);

                UPDATE fininvoice SET value = ROUND(V_VCONT::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer), policyId = V_POLICY.policyId WHERE invoiceId = V_INVOICEID;               
            ELSE
                --
                -- Se titulo NAO existe, insere titulo + lancamento
                --
                V_INVOICEID := nextval('seq_invoiceid'::regclass);
                -- Insere titulo
                INSERT INTO fininvoice ( invoiceid, personid, costcenterid, accountschemeid, parcelnumber,  maturitydate, value, referencematuritydate, emissiondate, policyId, incomesourceid, bankAccountId, invoiceiddependence ) VALUES (
                    V_INVOICEID,
                    V_CONTRATO.personid,
                    V_OBJCOURSEACCOUNT.costCenterId,
                    V_OBJCOURSEACCOUNT.accountSchemeId,
                    V_PARCELNUMBER,
                    V_MATURITYDATE,
                    ROUND(V_VCONT::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer),
                    V_REFERENCEMATURITYDATE,
                    now(),
                    V_POLICY.policyid,
                    GETPARAMETER('FINANCE', 'INCOME_SOURCE_ID')::int,
                    V_OBJPRICE.bankAccountId,
                    V_INVOICEIDDEPENDENCE );

                INSERT INTO finreceivableinvoice ( invoiceid, personid, costcenterid, accountschemeid, parcelnumber,  maturitydate, value, referencematuritydate, emissiondate, policyId, incomesourceid, bankAccountId, invoiceiddependence ) VALUES (
                    V_INVOICEID,
                    V_CONTRATO.personid,
                    V_OBJCOURSEACCOUNT.costCenterId,
                    V_OBJCOURSEACCOUNT.accountSchemeId,
                    V_PARCELNUMBER,
                    V_MATURITYDATE,
                    ROUND(V_VCONT::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer),
                    V_REFERENCEMATURITYDATE,
                    now(),
                    V_POLICY.policyid,
                    GETPARAMETER('FINANCE', 'INCOME_SOURCE_ID')::int,
                    V_OBJPRICE.bankAccountId,
                    V_INVOICEIDDEPENDENCE );
                    
                IF ( V_PARCELNUMBER = 1 AND GETPARAMETER('FINANCE', 'DEPENDENCE_INVOICE_ENABLED')::boolean IS TRUE) THEN
                    V_INVOICEIDDEPENDENCE := V_INVOICEID;
                END IF;
RAISE NOTICE 'Título % inserido', V_INVOICEID;
            END IF;

            -- Faz o lançamento do novo valor
            IF V_INVOICEID IS NOT NULL THEN
                IF V_PARCELNUMBER = 1 THEN
                    IF isfreshman(p_contractid) THEN
                        V_OPERATIONID := enrollOperation FROM findefaultoperations LIMIT 1;
                    ELSE
                        V_OPERATIONID := renewalOperation FROM findefaultoperations LIMIT 1;
                    END IF;
                ELSE
                    V_OPERATIONID := monthlyFeeOperation FROM findefaultoperations LIMIT 1;
                END IF;

                INSERT INTO finEntry(invoiceId, operationId, entryDate, value, costcenterid, contractid, learningperiodid) VALUES (
                    V_INVOICEID,
                    V_OPERATIONID,
                    NOW(),
                    ROUND(V_VCONT::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer),
                    V_OBJCOURSEACCOUNT.costCenterId,
                    V_CONTRATO.contractid,
                    V_PLETIVO.learningperiodid
                );
RAISE NOTICE 'Lançamento de % inserido no título %', V_VCONT, V_INVOICEID;
            END IF;

            -- Verifica se há ajuste a ser inserido
            IF V_AJT > 0
            THEN
                -- Insere lancamento com operacao de acrescimo de disciplina
                INSERT INTO finEntry(invoiceId, operationId, entryDate, value, costcenterid, contractid, learningperiodid) VALUES (
                    V_INVOICEID,
                    (SELECT addcurricularcomponentoperation FROM finDefaultOperations),
                    NOW(),
                    ROUND(V_AJT::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer),
                    V_OBJCOURSEACCOUNT.costCenterId,
                    V_CONTRATO.contractid,
                    V_PLETIVO.learningperiodid
                );
RAISE NOTICE '3: Lançamento de % inserido no título %', V_AJT, V_INVOICEID;                
            ELSE
                IF V_AJT < 0
                THEN
                    -- Insere lancamento com operacao de cancelamento de disciplina
                    INSERT INTO finEntry(invoiceId, operationId, entryDate, value, costcenterid, contractid, learningperiodid) VALUES (
                        V_INVOICEID,
                        (SELECT cancelcurricularcomponentoperation FROM finDefaultOperations),
                        NOW(),
                        ROUND((V_AJT * (-1))::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer),
                        V_OBJCOURSEACCOUNT.costCenterId,
                        V_CONTRATO.contractid,
                        V_PLETIVO.learningperiodid
                        );
RAISE NOTICE '4: Lançamento de % inserido no título %', V_AJT, V_INVOICEID;
                END IF;
            END IF;
        END IF;
        
        RAISE NOTICE 'Processando parcela %', V_PARCELNUMBER;
    END LOOP;

    -- Dependências
    IF V_DP > 0 THEN
        IF V_DPPRAT > 0 THEN
            V_DPVALUE := V_DPVALUE + ((V_VCONT / (V_CHTOTAL / V_SEMESTRES)) * V_DPPRAT * 2.5);
        END IF;

        IF V_DPTEOR > 0 THEN
            V_DPVALUE := V_DPVALUE + ((V_VCONT / (V_CHTOTAL / V_SEMESTRES)) * V_DPTEOR * 2);
        END IF;

        IF V_DPESP > 0 THEN
            V_DPVALUE := V_DPVALUE + (V_DPESP * 40 * 0,8543);
        END IF;

        IF V_DPMED > 0 THEN
            V_DPVALUE := V_DPVALUE + (V_DPMED * 85 * 0,8543);
        END IF;

        IF V_DPVALUE > 0 THEN
            SELECT INTO V_POLICY * FROM finPolicy WHERE policyId = getParameter('FINANCE', 'DEPENDENCY_POLICY_ID');

            IF V_POLICY IS NULL THEN
                RAISE EXCEPTION 'Não foi possível obter a política de cobrança para dependências. Verifique o parâmetro DEPENDENCY_POLICY_ID';
            END IF;
            
            SELECT INTO V_INVOICEID invoiceId
              FROM ONLY finInvoice A
             WHERE isCanceled IS FALSE
               AND policyId = V_POLICY.policyId
               AND EXISTS(SELECT 1 FROM finEntry E WHERE E.invoiceId = A.invoiceId AND E.learningPeriodId = p_learningPeriodId AND E.contractId = p_contractId);

            IF V_INVOICEID IS NULL THEN
                V_INVOICEID := nextval('seq_invoiceid'::regclass);
                -- Insere titulo
                INSERT INTO fininvoice ( invoiceid, personid, costcenterid, accountschemeid, parcelnumber,  maturitydate, value, referencematuritydate, emissiondate, policyId, incomesourceid, bankAccountId ) VALUES (
                V_INVOICEID,
                V_CONTRATO.personid,
                V_OBJCOURSEACCOUNT.costCenterId,
                V_OBJCOURSEACCOUNT.accountSchemeId,
                1,
                now(),
                ROUND(V_DPVALUE::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer),
                now(),
                now(),
                V_POLICY.policyid,
                GETPARAMETER('FINANCE', 'INCOME_SOURCE_ID')::int,
                V_OBJPRICE.bankAccountId );

                INSERT INTO finreceivableinvoice ( invoiceid, personid, costcenterid, accountschemeid, parcelnumber,  maturitydate, value, referencematuritydate, emissiondate, policyId, incomesourceid, bankAccountId ) VALUES (
                V_INVOICEID,
                V_CONTRATO.personid,
                V_OBJCOURSEACCOUNT.costCenterId,
                V_OBJCOURSEACCOUNT.accountSchemeId,
                1,
                now(),
                ROUND(V_DPVALUE::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer),
                now(),
                now(),
                V_POLICY.policyid,
                GETPARAMETER('FINANCE', 'INCOME_SOURCE_ID')::int,
                V_OBJPRICE.bankAccountId );
            ELSE
                DELETE FROM finEntry WHERE invoiceId = V_INVOICEID AND operationId = V_POLICY.operationId;
                UPDATE fininvoice 
                   SET value = ROUND(V_DPVALUE, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer),
                       policyId = V_POLICY.policyId
                 WHERE invoiceId = V_INVOICEID;
            END IF;

            IF V_INVOICEID IS NOT NULL THEN
                INSERT INTO finEntry(invoiceId, operationId, entryDate, value, costcenterid, contractid, learningperiodid) VALUES (
                V_INVOICEID,
                V_POLICY.operationId,
                NOW(),
                ROUND(V_DPVALUE::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer),
                V_OBJCOURSEACCOUNT.costCenterId,
                V_CONTRATO.contractid,
                V_PLETIVO.learningperiodid
                );
            ELSE
                RAISE EXCEPTION 'Não foi possível gerar título de dependências.';
            END IF;
        END IF;
    END IF;

    -- Taxas

    -- Incentivos
    PERFORM generatecontractincentivesbyperiod(V_CONTRATO.contractid, V_PLETIVO.learningperiodid);

    FOR V_INVOICEID IN SELECT invoiceId
                         FROM ONLY finInvoice A
                        WHERE isCanceled = FALSE
                          AND EXISTS (SELECT 1
                                        FROM finEntry X
                                       WHERE X.invoiceId = A.invoiceId
                                         AND X.learningPeriodId = p_learningPeriodId)                      
                          AND EXISTS (SELECT 1
                                        FROM finEntry X
                                       WHERE X.invoiceId = A.invoiceId
                                         AND X.contractId = p_contractId) ORDER BY referenceMaturityDate
    LOOP
        RETURN NEXT V_INVOICEID;
    END LOOP;

    RETURN;
END
$$;


ALTER FUNCTION public.gerarmensalidades(p_contractid integer, p_learningperiodid integer) OWNER TO postgres;

--
-- Name: gerarmensalidades(integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gerarmensalidades(p_contractid integer, p_learningperiodid integer, p_ecalouro boolean) RETURNS SETOF integer
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: gerarmensalidades
  PURPOSE: Gera os títulos referentes às mensalidades

  REVISIONS:
  Ver       Date       Author             Description
  --------- ---------- ------------------ ------------------------------------
  1.0       05/03/13   Leovan T. da Silva 1. FUNÇÃO criada.
  1.0       27/02/2014 Samuel Koch        1. Alterado função para gerar a primeira
                                             parcela sempre cheia.
  1.0       17/07/2014 Samuel Koch        1. Alterado função para não gerar parcela
                                             quando não existe matrícula.
**************************************************************************************/
DECLARE
    -- Número de parcelas nas quais o valor do semestre deve ser dividido
    NPCL integer;
    -- Número de parcelas bloqueadas
    BPCL integer;
    -- Valor a pagar pelo semestre
    VPRG numeric;
    -- Valor bloqueado
    VBLK numeric;
    -- Valor restante a pagar
    VAPG numeric;
    -- Valor da parcela
    VPCL numeric;
    -- Valor nominal do título já existente
    VTIT numeric;
    -- Valor a lançar no título já existente
    VLNC numeric;
    -- Valor previsto de parcela
    VPCLPREV numeric;
    -- Preco do curso
    PRECO record;

    -- Objeto que representa o contrato
    v_contrato acdcontract;

    -- Objeto que representa o período letivo
    v_periodo acdlearningperiod;

    -- Titulo que está sendo processado
    v_invoiceid integer;

    --Valor a ser descontado dos títulos bloqueados
    v_valor_desconto numeric;

    --Recebe o invoiceid dos titulos bloqueados 
    v_titulos record;

    --Recebe informações do titulo
    v_info_titulo RECORD;

    --Recebe o status que o título irá ser salvo na finstatusdotitulolog
    v_status_titulo INTEGER;

BEGIN

    IF existematricula(p_contractId, p_learningPeriodId) THEN
        SELECT INTO v_contrato * FROM acdcontract WHERE contractid = p_contractId;

        SELECT INTO v_periodo * FROM acdlearningperiod WHERE learningperiodid = p_learningPeriodId;

        --Obtem o numero de parcelas
        NPCL := COALESCE(obterNumeroDeParcelas(p_contractId, p_learningPeriodId), 0);
        --Obtem o valor total a pagar
        VPRG := COALESCE(obterValorAPagar(p_contractId, p_learningPeriodId), 0);

        BPCL := COALESCE(count(invoiceid),0) FROM obterTitulosBloqueados(p_contractId, p_learningPeriodId);

        VBLK := COALESCE(sum(nominalvalue),0) FROM obterTitulosBloqueados(p_contractId, p_learningPeriodId);    

        VPCLPREV := 0;

        -- Verifica se a primeira parcela deve ser integral para atualizar o valor programado de acordo
        IF (getParameter('FINANCE', 'PRIMEIRA_PARCELA_INTEGRAL') = 'YES') THEN
            PRECO := obterprecoatual(v_contrato.courseid, v_contrato.courseversion, v_contrato.turnid, v_contrato.unitid, v_periodo.begindate);

            -- Só executa alguma coisa se o preco for fixo
            IF PRECO.valueisfixed = 't' AND VPRG < PRECO.value THEN        
                VPCLPREV := (PRECO.value / getParameter('BASIC', 'DEFAULT_PARCELS_NUMBER')::int);

                --Verifica se a primeira parcela está bloqueada, caso não esteja, atribui valor cheio nessa parcela  
                IF ( SELECT invoiceid FROM obtertitulosbloqueados(p_contractId, p_learningPeriodId) WHERE parcelnumber = 1) IS NULL
                THEN
                     VPRG := VPCLPREV + ( ( VPRG / getParameter('BASIC', 'DEFAULT_PARCELS_NUMBER')::int ) * 5);
                END IF;
            END IF;
        END IF;

        v_valor_desconto := 0;

        --Obtém os títulos bloqueados
        FOR v_titulos IN 
        ( SELECT invoiceid 
            FROM obterTitulosBloqueados(p_contractId, p_learningPeriodId) )
        LOOP
            v_status_titulo = 2;
        --Função que retorna o valor total a ser descontado dos títulos bloqueados
            v_valor_desconto := v_valor_desconto + valorbloqueadoadesconsiderar(v_titulos.invoiceid);  

            SELECT INTO v_info_titulo * FROM fininfotitulo WHERE titulo = v_titulos.invoiceid;

            IF v_info_titulo.vencimento < now()::DATE AND (SELECT balance(v_titulos.invoiceid)) != 0.00 THEN
                --Status do titulo como vencido
                v_status_titulo = 4;
            ELSEIF v_info_titulo.envionaremessa = 't' AND (SELECT balance(v_titulos.invoiceid)) != 0.00 THEN
                --Status do titulo como enviado para remessa
                v_status_titulo = 5;
            ELSEIF (SELECT balance(v_titulos.invoiceid)) = 0.00 THEN
                --Status do titulo como pago
                v_status_titulo = 3;
            END IF;

            --Insere registro do título na tabela finstatusdotitulolog com status de v_status_titulo
            INSERT INTO finStatusDoTituloLog
                        (invoiceId, 
                         statusDoTituloId)
                  VALUES (v_titulos.invoiceid,
                         v_status_titulo);    

            RAISE NOTICE 'STATUS DO TITULO BLOQUEIADO %', v_status_titulo;     

        END LOOP;

        -- Calcula VAPG
        VAPG := VPRG - (VBLK - v_valor_desconto);

        -- Se o valor bloqueado é maior que o valor a pagar, então VAPG é 0, pois não há mais nada a cobrar
        IF VAPG < 0 THEN VAPG := 0; END IF;

        -- Se o número de parcelas bloqueadas for maior ou igual que o número de parcelas 
        -- ou se VAPG for 0 VPCL é 0, pois significa que não há mais nada para cobrar
        -- Este teste é para evitar erros por divisão com 0
        IF BPCL >= NPCL OR VAPG = 0 THEN
            VPCL := 0;
        ELSE
            VPCL := ROUND((VAPG / (NPCL - BPCL)),2);
        END IF;

        -- Gera as parcelas
        FOR CNT IN 1..NPCL LOOP
            IF CNT NOT IN (SELECT parcelnumber FROM obterTitulosBloqueados(p_contractId, p_learningPeriodId)) THEN
                IF ( getParameter('FINANCE', 'PRIMEIRA_PARCELA_INTEGRAL') = 'YES' AND
                     CNT = 1 AND
                     VPCL < VPCLPREV ) THEN
                    v_invoiceid := gerarparcela(p_contractId, p_learningperiodid, CNT, VPCLPREV, p_ecalouro);

                    VPCL := (VAPG - VPCLPREV) / (NPCL - BPCL - 1);
                ELSE
                    v_invoiceid := gerarparcela(p_contractId, p_learningperiodid, CNT, VPCL, p_ecalouro);
                END IF;
            END IF;
        END LOOP;

        /**
         * Verifica se o número de parcelas pagas é igual ao número de parcela bloqueadas e
         * se o valor a pagar é diferente do valor dos titulos bloqueados
         * então gera um novo único título com o valor restante #27294
         */
        VAPG := ROUND(VAPG, 2);
        IF VPRG > VBLK AND BPCL = NPCL THEN
            v_invoiceid := gerarparcela(p_contractId, p_learningperiodid, NPCL+1, VAPG, p_ecalouro);
        END IF;

        PERFORM gerarincentivos(p_contractId, p_learningPeriodId);
    END IF;

    IF existematriculacursoferias(p_contractId, p_learningPeriodId) THEN
        PERFORM gerarferias(p_contractId, p_learningPeriodId);
    END IF;

    -- Retorna os títulos
    RETURN QUERY ( SELECT obterTitulosDaMatricula(p_contractId, p_learningperiodid) );
END;
$$;


ALTER FUNCTION public.gerarmensalidades(p_contractid integer, p_learningperiodid integer, p_ecalouro boolean) OWNER TO postgres;

--
-- Name: gerarmensalidadesadaptacao(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gerarmensalidadesadaptacao(p_contractid integer, p_learningperiodid integer) RETURNS SETOF integer
    LANGUAGE plpgsql
    AS $$
/*********************************************************************************************
   NAME: gerarMensalidadesAdaptacao
   PURPOSE: Algoritmo de geracao de mensalidades em adaptaç?o.

REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       07/03/2013 Augusto           1. FUNÇÃO criada.
*********************************************************************************************/
DECLARE
    --Variáveis do tipo registro
    V_CONTRATO RECORD;
    V_PLETIVO RECORD;
    V_OBJPRICE RECORD;
    V_OBJCOURSEACCOUNT RECORD;
    V_CONTRACTCLASS RECORD;
    V_NUMHOURS RECORD;
    V_GROUP RECORD;
    V_POLICY RECORD;    
    V_ENROLL RECORD;
    V_PENDINGCURRICULUM RECORD;
    V_ADAPTACAO RECORD;

    --Variáveis inteiras
    V_AUX INT;
    V_NPCL INT; --Número de parcelas do curso.
    V_BPCL INT; --Número de parcelas que n?o podem sofrer alteraç?es.
    V_APCL INT; --Número de parcelas que podem sofrer alteraç?es.
    V_CURRICULUMID INT;
    V_PROFACTIVITY INT[];
    V_PARCELNUMBER INT;
    V_SEMESTRES INT;
    V_BLOCKINVOICEID INT;
    V_INVOICEID INT;
    V_INVOICEIDDEPENDENCE INT;
    V_OPERATIONID INT;

    --Variáveis do tipo flutuante
    V_PRECO FLOAT; --Preço vigente do curso
    V_CFIXO FLOAT; --Custo fixo do curso
    V_CHTOTAL FLOAT; --Carga horária total do curso
    V_CHPREV FLOAT; --Carga hprária do período do curso
    V_CHCONT FLOAT; --Carga horária contratada
    V_CHPRAT FLOAT; --Carga horária prática
    V_CHADAP FLOAT; --Carga horária adaptaç?o
    V_CHESP FLOAT; --Carga horária especial
    V_CHDPRAT FLOAT; --Carga horária depend?ncia prática
    V_CHDTEOR FLOAT; --Carga horária depend?ncia teórica
    V_CHMED FLOAT;  --Carga horária professor médico
    V_MULT_PRAT FLOAT; --Fator de multiplicaç?o para hora prática
    V_MULT_TEOR FLOAT; --Fator de multiplicaç?o para hora teórica
    V_MULT_ESP FLOAT; --Fator de multiplicaç?o para hora especial
    V_MULT_MED FLOAT; --Fator de multiplicaç?o para hora médico
    V_PER_ESP FLOAT; --Percentual deo valor no regime especial
    V_SUMVALUE FLOAT;
    V_SUBVALUE FLOAT;
    V_MENS FLOAT; --Mensalidade do curso
    V_VCONT FLOAT; --Parcela a pagar
    V_DPPRAT FLOAT; --Valor de depend?ncia prática
    V_DPTEOR FLOAT; --Valor de depend?ncia teórica
    V_VADAPT FLOAT; --Valor da adaptaç?o
    V_DPESP FLOAT; --Valor de depend?ncia especial
    V_DPMED FLOAT; --Valor de depend?ncia médico
    V_DP FLOAT; --Valor de depend?ncia
    v_DPVALUE FLOAT;
    V_AJT FLOAT; --Valor de ajuste
    V_VB FLOAT; --Valor de parcela bloqueada

    --Variáveis lógicas
    V_ISBLOCKED BOOLEAN;
    V_DP_REST   FLOAT;
    V_ADAP_REST   FLOAT;
    V_NUMERO_PARCELAS_REST INT;
    V_NUMERO_PARCELAS INT;
    V_NUMERO_PERIODO_MATRICULA INT;
    V_SEMESTRE_DISCIPLINA INT;

    --Variáveis que armazenam datas
    V_MATURITYDAY INTEGER;
    V_MATURITYMONTH INTEGER;
    V_MATURITYYEAR INTEGER;
    V_MATURITYDATE DATE;
    V_REFERENCEMATURITYDATE DATE;
    V_TESTE INT;

BEGIN
    V_CHCONT := 0;
    V_CHPRAT := 0;
    V_CHADAP :=0;
    V_CHESP := 0;
    V_VADAPT := 0;
    V_CHDPRAT := 0;
    V_CHDTEOR := 0;
    V_CHMED := 0;
    V_MULT_PRAT := 2.5;
    V_MULT_TEOR := 2;
    V_MULT_ESP := 40;
    V_MULT_MED := 85;
    V_PER_ESP := 0.8543;

    --Obtem os dados do contrato
    SELECT INTO V_CONTRATO * 
           FROM acdContract
           WHERE contractId = p_contractId;

    --Obtem os dados do período letivo
    SELECT INTO V_PLETIVO *
           FROM acdLearningPeriod
          WHERE learningPeriodId = p_learningPeriodId;

    --Obtem o preço vigente para o cálculo da mensalidade
    SELECT INTO V_OBJPRICE *
           FROM obterPrecoAtual(V_CONTRATO.courseId, 
                                V_CONTRATO.courseVersion,
                                V_CONTRATO.turnId,
                                V_CONTRATO.unitId, 
                                V_PLETIVO.beginDate);

    --Obtem informaç?es contábeis
    SELECT INTO V_OBJCOURSEACCOUNT *
           FROM getCourseAccount(V_CONTRATO.courseid,
                                 V_CONTRATO.courseversion,
                                 V_CONTRATO.unitid);

    --Obtem a turma
    SELECT INTO V_CONTRACTCLASS *
           FROM getcontractcurrentclass(V_CONTRATO.contractid);

    --Obtem a carga horária da vers?o do curso.
    SELECT INTO V_CHTOTAL hourtotal
           FROM acdcourseversion
          WHERE courseid = V_CONTRATO.courseid
            AND courseversion = V_CONTRATO.courseversion;

    --Obtem o total de semestres do curso
    SELECT INTO V_SEMESTRES periodtotal
           FROM acdcourseversion
          WHERE courseid = V_CONTRATO.courseid
            AND courseversion = V_CONTRATO.courseversion;

    --Valida a exist?ncia de um centro de custo 
    IF V_OBJCOURSEACCOUNT.costcenterid IS NULL THEN
        RAISE EXCEPTION 'Nenhum centro de custo registrado para o 
                         curso, turno e unidade. Verifique o formulário
                         de cadastro de plano de contas e centro de 
                         custo para um curso.';
    END IF;

    V_PRECO := V_OBJPRICE.value;
    V_NPCL := obternumeroparcelasprioridade(V_CONTRATO.parcelsnumber, 
                                            V_PLETIVO.parcelsnumber,
                                            V_OBJPRICE.parcelsnumber);

    --Cálculo do valor fixo
    V_CFIXO := V_OBJPRICE.fixedValue / V_NPCL;

    SELECT INTO V_PENDINGCURRICULUM *
           FROM getdisaprovedcurriculumids(V_CONTRATO.contractid);

    --Define se a matrícula se baseará nas disciplinas da matriz curricular
    --ou nas oferecidas para calcular as diferenças de matrícula.
    IF ( GETPARAMETER('ACADEMIC', 'ENROLL_BASED_ON_CURRICULUM') = 't' ) THEN
        V_CHPREV := getperiodhours(V_CONTRATO.courseId, 
                                   V_CONTRATO.courseversion,
                                   V_CONTRATO.turnid,
                                   V_CONTRATO.unitid, 
                                   V_CLASSPERIOD);
    ELSE
        V_CHPREV := getHoursAvailableForEnroll(V_CONTRATO.contractid, 
                                               V_CONTRACTCLASS.classid,
                                               p_learningperiodid);
    END IF;
	
    -- Percorre matriculas
    FOR V_ENROLL IN ( SELECT A.enrollId,
                             A.contractId,
                             B.groupId,
                             A.curriculumId
                        FROM acdEnroll A
                  INNER JOIN acdGroup B
                          ON (A.groupId = B.groupId)
                  INNER JOIN acdLearningPeriod C
                          ON (B.learningPeriodId = C.learningPeriodId)
                  INNER JOIN acdCurriculum D
                          ON (B.curriculumId = D.curriculumId)
                       WHERE A.contractId = V_CONTRATO.contractId
                         AND C.periodId = V_PLETIVO.periodid
                         AND statusId NOT IN (SELECT getdisaprovedcurriculumids(V_CONTRATO.contractid) )
                         AND D.semester < ( SELECT obtemPeriodosMatriculado(V_CONTRATO.contractid) ) )
    LOOP
        V_NUMHOURS := getCurriculumNumberHours(V_ENROLL.curriculumId);
        V_CHCONT := V_CHCONT + V_NUMHOURS.academicnumberhours;       

    END LOOP;

RAISE NOTICE 'V_CHPREV: %', V_CHPREV;
RAISE NOTICE 'V_CHCONT: %', V_CHCONT;

    -- Calcular variaveis
    V_MENS := V_PRECO / V_NPCL;
    V_VCONT := (((V_MENS - V_CFIXO) / V_CHPREV) * V_CHCONT) + V_CFIXO;


     -- adaptaç?es
    IF V_VCONT > 0 THEN
    SELECT INTO V_POLICY *
               FROM finPolicy
              WHERE policyId = getParameter('FINANCE', 'ADAPTATION_POLICY_ID')::INT;

        IF V_POLICY IS NULL THEN
             RAISE EXCEPTION 'N?o foi possível obter a política de cobrança para
                              depend?ncias. Verifique o parâmetro DEPENDENCY_POLICY_ID';
        END IF;

        V_NUMERO_PARCELAS:= 1;
        SELECT EXTRACT(MONTH FROM AGE(V_PLETIVO.enddate,now()::date)) + (EXTRACT(YEAR FROM AGE(V_PLETIVO.enddate,now()::date)) * 12) +1 INTO V_NUMERO_PARCELAS_REST;
        V_ADAP_REST := V_VCONT / V_NUMERO_PARCELAS_REST;

        WHILE V_NUMERO_PARCELAS <= V_NUMERO_PARCELAS_REST LOOP
            IF V_NUMERO_PARCELAS = 1 THEN
                V_MATURITYDATE := NOW()::DATE + '1 DAY'::interval;

                -- Se cair num sábado ou domingo deve assumir a data da segunda-feira
                IF ( EXTRACT('DOW' FROM V_MATURITYDATE) = 0 ) THEN
                    V_MATURITYDATE := V_MATURITYDATE + '1 DAY'::interval;
                ELSEIF ( EXTRACT('DOW' FROM V_MATURITYDATE) = 6 ) THEN
                    V_MATURITYDATE := V_MATURITYDATE + '2 DAYS'::interval;
                END IF;
            ELSE
                -- Definir data de vencimento da parcela
                V_MATURITYDAY := COALESCE(V_CONTRATO.maturityday,
                                          V_OBJPRICE.maturityday);

                V_MATURITYMONTH := EXTRACT('MONTH' FROM( NOW()::DATE + (V_NUMERO_PARCELAS-1 || ' months')::interval));
                V_MATURITYYEAR := EXTRACT('YEAR' FROM V_PLETIVO.begindate);
                V_MATURITYDATE := (V_MATURITYYEAR || '-' || V_MATURITYMONTH || '-' || V_MATURITYDAY)::DATE;
            END IF;

            SELECT INTO V_INVOICEID invoiceId
              FROM ONLY finInvoice A
                  WHERE isCanceled IS FALSE
                    AND policyId = V_POLICY.policyId
                    AND A.parcelNumber = V_NUMERO_PARCELAS
                    AND EXISTS ( SELECT 1
                                   FROM finEntry E
                                  WHERE E.invoiceId = A.invoiceId
                                    AND E.learningPeriodId = p_learningPeriodId
                                    AND E.contractId = p_contractId );

            IF V_INVOICEID IS NULL THEN
                V_INVOICEID := nextval('seq_invoiceid'::regclass);

                -- Insere titulo
                INSERT INTO fininvoice ( invoiceid,
                                         personid,
                                         costcenterid,
                                         accountschemeid,
                                         parcelnumber,
                                         maturitydate,
                                         value,
                                         referencematuritydate,
                                         emissiondate,
                                         policyId,
                                         incomesourceid,
                                         bankAccountId )
                                VALUES ( V_INVOICEID,
                                         V_CONTRATO.personid,
                                         V_OBJCOURSEACCOUNT.costCenterId,
                                         V_OBJCOURSEACCOUNT.accountSchemeId,
                                         V_NUMERO_PARCELAS,
                                         V_MATURITYDATE,
                                         ROUND(V_ADAP_REST::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer),
                                         V_MATURITYDATE,
                                         now(),
                                         V_POLICY.policyid,
                                         GETPARAMETER('FINANCE', 'INCOME_SOURCE_ID')::int,
                                         V_OBJPRICE.bankAccountId );

                INSERT INTO finreceivableinvoice ( invoiceid,
                                                   personid,
                                                   costcenterid,
                                                   accountschemeid,
                                                   parcelnumber,
                                                   maturitydate,
                                                   value,
                                                   referencematuritydate,
                                                   emissiondate,
                                                   policyId,
                                                   incomesourceid,
                                                   bankAccountId )
                                          VALUES ( V_INVOICEID,
                                                   V_CONTRATO.personid,
                                                   V_OBJCOURSEACCOUNT.costCenterId,
                                                   V_OBJCOURSEACCOUNT.accountSchemeId,
                                                   V_NUMERO_PARCELAS,
                                                   V_MATURITYDATE,
                                                   ROUND(V_ADAP_REST::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer),
                                                   V_MATURITYDATE,
                                                   now(),
                                                   V_POLICY.policyid,
                                                   GETPARAMETER('FINANCE', 'INCOME_SOURCE_ID')::int,
                                                   V_OBJPRICE.bankAccountId );
            ELSE
                DELETE FROM finEntry
                      WHERE invoiceId = V_INVOICEID
                        AND operationId = V_POLICY.operationId;

                UPDATE fininvoice SET value = ROUND(V_ADAP_REST::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer),
                                              policyId = V_POLICY.policyId
                 WHERE invoiceId = V_INVOICEID;
            END IF;

            IF V_INVOICEID IS NOT NULL THEN
                INSERT INTO finEntry ( invoiceId,
                                       operationId,
                                       entryDate,
                                       value,
                                       costcenterid,
                                       contractid,
                                       learningperiodid )
                              VALUES ( V_INVOICEID,
                                       V_POLICY.operationId,
                                       NOW(),
                                       ROUND(V_ADAP_REST::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer),
                                       V_OBJCOURSEACCOUNT.costCenterId,
                                       V_CONTRATO.contractid,
                                       V_PLETIVO.learningperiodid );
            ELSE
                RAISE EXCEPTION 'N?o foi possível gerar título de depend?ncias.';
            END IF;

            V_NUMERO_PARCELAS:= V_NUMERO_PARCELAS +1;
        END LOOP;
    END IF;
    
    FOR V_INVOICEID IN SELECT A.invoiceId
                    FROM ONLY finInvoice A
                        WHERE isCanceled = FALSE
                          AND EXISTS (SELECT 1
                                        FROM finEntry X
                                       WHERE X.invoiceId = A.invoiceId
                                         AND X.learningPeriodId = p_learningPeriodId)
                          AND EXISTS (SELECT 1
                                        FROM finEntry X
                                       WHERE X.invoiceId = A.invoiceId
                                         AND X.contractId = p_contractId)
                          AND A.policyId = getParameter('FINANCE', 'ADAPTATION_POLICY_ID')::INT
                     ORDER BY referenceMaturityDate, parcelnumber
    LOOP
        RETURN NEXT V_INVOICEID;
    END LOOP;   

    RETURN;
END
$$;


ALTER FUNCTION public.gerarmensalidadesadaptacao(p_contractid integer, p_learningperiodid integer) OWNER TO postgres;

--
-- Name: gerarmensalidadesdependencia(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gerarmensalidadesdependencia(p_contractid integer, p_learningperiodid integer) RETURNS SETOF integer
    LANGUAGE plpgsql
    AS $$
/*********************************************************************************************
   NAME: gerarMensalidades
   PURPOSE: Algoritmo de geracao de mensalidades.

REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       xx/xx/xxxx xxxxxxxxx         1. FUNÇÃO criada.
  1.1       04/02/2013 Samuel Koch       1. Correç?o na lógica que verifica se o contrato é
                                            de um calouro ou veterano.
  1.2       05/02/2013 Samuel Koch       1. Correç?o no recálculo das mensalidades.
  1.3       26/02/2013 Samuel Koch       1. Alteraç?o na regra quando o aluno se matricula em
                                            depend?ncia do tipo prática. Caso a disciplina tenha
                                            alguma hora prática considerar 100% prática.
  1.4       02/03/2013 Samuel Koch       1. Alteraç?o para separar as disciplinas que o aluno
                                            irá cursar em outros semestres
*********************************************************************************************/
DECLARE
    --Variáveis do tipo registro
    V_CONTRATO RECORD;
    V_PLETIVO RECORD;
    V_OBJPRICE RECORD;
    V_OBJCOURSEACCOUNT RECORD;
    V_CONTRACTCLASS RECORD;
    V_NUMHOURS RECORD;
    V_GROUP RECORD;
    V_POLICY RECORD;    
    V_ENROLL RECORD;
    V_PENDINGCURRICULUM RECORD;
    V_ADAPTACAO RECORD;

    --Variáveis inteiras
    V_AUX INT;
    V_NPCL INT; --Número de parcelas do curso.
    V_BPCL INT; --Número de parcelas que n?o podem sofrer alteraç?es.
    V_APCL INT; --Número de parcelas que podem sofrer alteraç?es.
    V_CLASSPERIOD INT;
    V_SEMESTER INT;
    V_CURRICULUMID INT;
    V_PROFACTIVITY INT[];
    V_PARCELNUMBER INT;
    V_SEMESTRES INT;
    V_BLOCKINVOICEID INT;
    V_INVOICEID INT;
    V_INVOICEIDDEPENDENCE INT;
    V_OPERATIONID INT;

    --Variáveis do tipo flutuante
    V_PRECO FLOAT; --Preço vigente do curso
    V_CFIXO FLOAT; --Custo fixo do curso
    V_CHTOTAL FLOAT; --Carga horária total do curso
    V_CHPREV FLOAT; --Carga hprária do período do curso
    V_CHCONT FLOAT; --Carga horária contratada
    V_CHPRAT FLOAT; --Carga horária prática
    V_CHADAP FLOAT; --Carga horária adaptaç?o
    V_CHESP FLOAT; --Carga horária especial
    V_CHDPRAT FLOAT; --Carga horária depend?ncia prática
    V_CHDTEOR FLOAT; --Carga horária depend?ncia teórica
    V_CHMED FLOAT;  --Carga horária professor médico
    V_MULT_PRAT FLOAT; --Fator de multiplicaç?o para hora prática
    V_MULT_TEOR FLOAT; --Fator de multiplicaç?o para hora teórica
    V_MULT_ESP FLOAT; --Fator de multiplicaç?o para hora especial
    V_MULT_MED FLOAT; --Fator de multiplicaç?o para hora médico
    V_PER_ESP FLOAT; --Percentual deo valor no regime especial
    V_SUMVALUE FLOAT;
    V_SUBVALUE FLOAT;
    V_MENS FLOAT; --Mensalidade do curso
    V_VCONT FLOAT; --Parcela a pagar
    V_DPPRAT FLOAT; --Valor de depend?ncia prática
    V_DPTEOR FLOAT; --Valor de depend?ncia teórica
    V_VADAPT FLOAT; --Valor da adaptaç?o
    V_DPESP FLOAT; --Valor de depend?ncia especial
    V_DPMED FLOAT; --Valor de depend?ncia médico
    V_DP FLOAT; --Valor de depend?ncia
    v_DPVALUE FLOAT;
    V_AJT FLOAT; --Valor de ajuste
    V_VB FLOAT; --Valor de parcela bloqueada

    --Variáveis lógicas
    V_ISBLOCKED BOOLEAN;
    V_DP_REST   FLOAT;
    V_ADAP_REST   FLOAT;
    V_NUMERO_PARCELAS_REST INT;
    V_NUMERO_PARCELAS INT;
    V_NUMERO_PERIODO_MATRICULA INT;
    V_SEMESTRE_DISCIPLINA INT;

    --Variáveis que armazenam datas
    V_MATURITYDAY INTEGER;
    V_MATURITYMONTH INTEGER;
    V_MATURITYYEAR INTEGER;
    V_MATURITYDATE DATE;
    V_REFERENCEMATURITYDATE DATE;
    V_TESTE INT;

BEGIN
    V_CHCONT := 0;
    V_CHPRAT := 0;
    V_CHADAP :=0;
    V_CHESP := 0;
    V_VADAPT := 0;
    V_CHDPRAT := 0;
    V_CHDTEOR := 0;
    V_CHMED := 0;
    V_MULT_PRAT := 2.5;
    V_MULT_TEOR := 2;
    V_MULT_ESP := 40;
    V_MULT_MED := 85;
    V_PER_ESP := 0.8543;

    --Obtem os dados do contrato
    SELECT INTO V_CONTRATO * 
           FROM acdContract
           WHERE contractId = p_contractId;

    --Obtem os dados do período letivo
    SELECT INTO V_PLETIVO *
           FROM acdLearningPeriod
          WHERE learningPeriodId = p_learningPeriodId;

    --Obtem o preço vigente para o cálculo da mensalidade
    SELECT INTO V_OBJPRICE *
           FROM obterPrecoAtual(V_CONTRATO.courseId, 
                                V_CONTRATO.courseVersion,
                                V_CONTRATO.turnId,
                                V_CONTRATO.unitId, 
                                V_PLETIVO.beginDate);

    --Obtem informaç?es contábeis
    SELECT INTO V_OBJCOURSEACCOUNT *
           FROM getCourseAccount(V_CONTRATO.courseid,
                                 V_CONTRATO.courseversion,
                                 V_CONTRATO.unitid);

    --Obtem a turma
    SELECT INTO V_CONTRACTCLASS *
           FROM getcontractcurrentclass(V_CONTRATO.contractid);

    --Obtem a carga horária da vers?o do curso.
    SELECT INTO V_CHTOTAL hourtotal
           FROM acdcourseversion
          WHERE courseid = V_CONTRATO.courseid
            AND courseversion = V_CONTRATO.courseversion;

    --Obtem o total de semestres do curso
    SELECT INTO V_SEMESTRES periodtotal
           FROM acdcourseversion
          WHERE courseid = V_CONTRATO.courseid
            AND courseversion = V_CONTRATO.courseversion;

     --Verifica o período em que a turma se encontra.
     V_CLASSPERIOD := getClassPeriod(V_CONTRACTCLASS.classid, 
                                     p_learningperiodid);

    --Valida a exist?ncia de um centro de custo 
    IF V_OBJCOURSEACCOUNT.costcenterid IS NULL THEN
        RAISE EXCEPTION 'Nenhum centro de custo registrado para o 
                         curso, turno e unidade. Verifique o formulário
                         de cadastro de plano de contas e centro de 
                         custo para um curso.';
    END IF;

    V_PRECO := V_OBJPRICE.value;
    V_NPCL := obternumeroparcelasprioridade(V_CONTRATO.parcelsnumber, 
                                            V_PLETIVO.parcelsnumber,
                                            V_OBJPRICE.parcelsnumber);

    --Cálculo do valor fixo
    V_CFIXO := V_OBJPRICE.fixedValue / V_NPCL;
    V_SEMESTER := (V_CLASSPERIOD - 1);

    SELECT INTO V_PENDINGCURRICULUM *
           FROM getdisaprovedcurriculumids(V_CONTRATO.contractid);

    --Define se a matrícula se baseará nas disciplinas da matriz curricular
    --ou nas oferecidas para calcular as diferenças de matrícula.
    IF ( GETPARAMETER('ACADEMIC', 'ENROLL_BASED_ON_CURRICULUM') = 't' ) THEN
        V_CHPREV := getperiodhours(V_CONTRATO.courseId, 
                                   V_CONTRATO.courseversion,
                                   V_CONTRATO.turnid,
                                   V_CONTRATO.unitid, 
                                   V_CLASSPERIOD);
    ELSE
        V_CHPREV := getHoursAvailableForEnroll(V_CONTRATO.contractid, 
                                               V_CONTRACTCLASS.classid,
                                               p_learningperiodid);
    END IF;
	
    SELECT INTO V_NUMERO_PERIODO_MATRICULA COUNT(periodId)
           FROM acdPeriod
          WHERE periodId IN ( SELECT A.periodId
                       FROM acdLearningPeriod A
                  INNER JOIN acdGroup B
                      ON (A.learningPeriodId = B.learningPeriodId)
                  INNER JOIN acdEnroll C
                      ON (B.groupId = C.groupId)
                   WHERE C.contractId = V_CONTRATO.contractId );

    -- Percorre matriculas
    FOR V_ENROLL IN ( SELECT A.enrollId,
                             A.contractId,
                             B.groupId,
                             A.curriculumId
                        FROM acdEnroll A
                  INNER JOIN acdGroup B
                          ON (A.groupId = B.groupId)
                  INNER JOIN acdLearningPeriod C
                          ON (B.learningPeriodId = C.learningPeriodId)
                       WHERE A.contractId = V_CONTRATO.contractId
                         AND C.periodId = V_PLETIVO.periodid
                         AND (statusId = getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED')::int OR
                              statusId = getParameter('ACADEMIC', 'ENROLL_STATUS_APPROVED')::int OR
                              statusId = getParameter('ACADEMIC', 'ENROLL_STATUS_DISAPPROVED')::int OR
                              statusId = getParameter('ACADEMIC', 'ENROLL_STATUS_DISAPPROVED_FOR_LACKS')::int OR
                              statusId = getParameter('ACADEMIC', 'ENROLL_STATUS_DISAPPROVED_BY_PERIOD')::int OR
                              statusId = getParameter('ACADEMIC', 'ENROLL_STATUS_DEPENDENT')::int) ) 
    LOOP

        
        -- Obtem semestres pendentes
        FOR V_CURRICULUMID IN (SELECT getdisaprovedcurriculumids(V_CONTRATO.contractId) ) LOOP

            -- Caso o curriculum id pendente seja o atual
            IF V_ENROLL.curriculumId = V_CURRICULUMID THEN

                V_NUMHOURS := getCurriculumNumberHours(V_ENROLL.curriculumId);

                -- Verifica se existe codigo da turma
                IF V_ENROLL.groupId IS NULL THEN
                    RAISE EXCEPTION 'Erro ao obter código da turma.';
                END IF;
                SELECT INTO V_GROUP *
                       FROM acdGroup
                      WHERE groupId = V_ENROLL.groupId;

                IF V_GROUP.regimenId = GETPARAMETER('BASIC', 'SPECIAL_REGIMEN')::int THEN
                    -- FIXME: Verificar esta FUNÇÃO , no SAGU na versao2.9 nao existia mais , so na versao antiga FACIMED
                    -- V_PROFACTIVITY :=getProfessionalActivityOfProfessorsByGroup(V_ENROLL.groupid);
                    IF ARRAY_LENGTH(V_PROFACTIVITY, 1) > 0 THEN
                        -- Soma cargas...
                    ELSE
                        V_CHESP := V_CHESP + V_NUMHOURS.academicNumberHours;
                    END IF;
                ELSE 

                    IF V_NUMHOURS.practicalNumberHours > 0 AND V_NUMHOURS.practicalNumberHours IS NOT NULL THEN
                        V_CHDPRAT := V_CHPRAT +  V_NUMHOURS.academicNumberHours;
                    ELSE
                        IF V_NUMHOURS.theoreticalNumberHours > 0 AND V_NUMHOURS.theoreticalNumberHours IS NOT NULL THEN
                            V_CHDTEOR := V_CHDTEOR + V_NUMHOURS.theoreticalNumberHours;
                        ELSE
                            V_CHDTEOR := V_CHDTEOR + V_NUMHOURS.academicNumberHours;
                        END IF;
                     END IF;
                END IF;
            END IF;

        END LOOP;
    END LOOP;

    -- Calcular variaveis
    V_MENS := V_PRECO / V_NPCL;

    IF V_CHDPRAT > 0 THEN
       V_DPTEOR := 0; 
       V_DPPRAT := (V_MENS / (V_CHTOTAL / V_SEMESTRES)) * (V_CHDPRAT) * V_MULT_PRAT;
    ELSE
        V_DPPRAT :=  0;
        V_DPTEOR := (V_MENS / (V_CHTOTAL / V_SEMESTRES)) * V_CHDTEOR * V_MULT_TEOR;
    END IF;

    V_DPESP := V_CHESP * V_MULT_ESP * V_PER_ESP;
    V_DPMED := V_CHMED * V_MULT_MED * V_PER_ESP;
    V_DP := V_DPPRAT + V_DPTEOR + V_DPESP + V_DPMED;

RAISE NOTICE 'V_DPPRAT: %', V_DPPRAT;
RAISE NOTICE 'V_DPESP: %', V_DPESP;
--RAISE exception 'V_DPTEOR: %', V_DPTEOR;
--RAISE exception 'V_DPPRAT % V_DPTEOR % V_DPESP %  V_DPMED: %', V_DPPRAT, V_DPTEOR, V_DPESP, V_DPMED;
--RAISE exception 'V_DP: %', V_DP;


    
    -- Depend?ncias
    IF V_DP > 0 THEN
        SELECT INTO V_POLICY *
               FROM finPolicy
              WHERE policyId = getParameter('FINANCE', 'DEPENDENCY_POLICY_ID')::INT;

        IF V_POLICY IS NULL THEN
             RAISE EXCEPTION 'N?o foi possível obter a política de cobrança para
                              depend?ncias. Verifique o parâmetro DEPENDENCY_POLICY_ID';
        END IF;

        V_NUMERO_PARCELAS:= 1;
        SELECT EXTRACT(MONTH FROM AGE(V_PLETIVO.enddate,now()::date)) + (EXTRACT(YEAR FROM AGE(V_PLETIVO.enddate,now()::date)) * 12) +1 INTO V_NUMERO_PARCELAS_REST;
        V_DP_REST := V_DP / V_NUMERO_PARCELAS_REST;

        WHILE V_NUMERO_PARCELAS <= V_NUMERO_PARCELAS_REST LOOP
            IF V_NUMERO_PARCELAS = 1 THEN
                V_MATURITYDATE := NOW()::DATE + '1 DAY'::interval;

                -- Se cair num sábado ou domingo deve assumir a data da segunda-feira
                IF ( EXTRACT('DOW' FROM V_MATURITYDATE) = 0 ) THEN
                    V_MATURITYDATE := V_MATURITYDATE + '1 DAY'::interval;
                ELSEIF ( EXTRACT('DOW' FROM V_MATURITYDATE) = 6 ) THEN
                    V_MATURITYDATE := V_MATURITYDATE + '2 DAYS'::interval;
                END IF;
            ELSE
                -- Definir data de vencimento da parcela
                V_MATURITYDAY := COALESCE(V_CONTRATO.maturityday,
                                          V_OBJPRICE.maturityday);

                V_MATURITYMONTH := EXTRACT('MONTH' FROM( NOW()::DATE + (V_NUMERO_PARCELAS-1 || ' months')::interval));
                V_MATURITYYEAR := EXTRACT('YEAR' FROM V_PLETIVO.begindate);
                V_MATURITYDATE := (V_MATURITYYEAR || '-' || V_MATURITYMONTH || '-' || V_MATURITYDAY)::DATE;
            END IF;

            SELECT INTO V_INVOICEID invoiceId
              FROM ONLY finInvoice A
                  WHERE isCanceled IS FALSE
                    AND policyId = V_POLICY.policyId
                    AND A.parcelNumber = V_NUMERO_PARCELAS
                    AND EXISTS ( SELECT 1
                                   FROM finEntry E
                                  WHERE E.invoiceId = A.invoiceId
                                    AND E.learningPeriodId = p_learningPeriodId
                                    AND E.contractId = p_contractId );

            IF V_INVOICEID IS NULL THEN
                V_INVOICEID := nextval('seq_invoiceid'::regclass);

                -- Insere titulo
                INSERT INTO fininvoice ( invoiceid,
                                         personid,
                                         costcenterid,
                                         accountschemeid,
                                         parcelnumber,
                                         maturitydate,
                                         value,
                                         referencematuritydate,
                                         emissiondate,
                                         policyId,
                                         incomesourceid,
                                         bankAccountId )
                                VALUES ( V_INVOICEID,
                                         V_CONTRATO.personid,
                                         V_OBJCOURSEACCOUNT.costCenterId,
                                         V_OBJCOURSEACCOUNT.accountSchemeId,
                                         V_NUMERO_PARCELAS,
                                         V_MATURITYDATE,
                                         ROUND(V_DP_REST::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer),
                                         V_MATURITYDATE,
                                         now(),
                                         V_POLICY.policyid,
                                         GETPARAMETER('FINANCE', 'INCOME_SOURCE_ID')::int,
                                         V_OBJPRICE.bankAccountId );

                INSERT INTO finreceivableinvoice ( invoiceid,
                                                   personid,
                                                   costcenterid,
                                                   accountschemeid,
                                                   parcelnumber,
                                                   maturitydate,
                                                   value,
                                                   referencematuritydate,
                                                   emissiondate,
                                                   policyId,
                                                   incomesourceid,
                                                   bankAccountId )
                                          VALUES ( V_INVOICEID,
                                                   V_CONTRATO.personid,
                                                   V_OBJCOURSEACCOUNT.costCenterId,
                                                   V_OBJCOURSEACCOUNT.accountSchemeId,
                                                   V_NUMERO_PARCELAS,
                                                   V_MATURITYDATE,
                                                   ROUND(V_DP_REST::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer),
                                                   V_MATURITYDATE,
                                                   now(),
                                                   V_POLICY.policyid,
                                                   GETPARAMETER('FINANCE', 'INCOME_SOURCE_ID')::int,
                                                   V_OBJPRICE.bankAccountId );
            ELSE
                DELETE FROM finEntry
                      WHERE invoiceId = V_INVOICEID
                        AND operationId = V_POLICY.operationId;

                UPDATE fininvoice SET value = ROUND(V_DP_REST::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer),
                                              policyId = V_POLICY.policyId
                 WHERE invoiceId = V_INVOICEID;
            END IF;

            IF V_INVOICEID IS NOT NULL THEN
                INSERT INTO finEntry ( invoiceId,
                                       operationId,
                                       entryDate,
                                       value,
                                       costcenterid,
                                       contractid,
                                       learningperiodid )
                              VALUES ( V_INVOICEID,
                                       V_POLICY.operationId,
                                       NOW(),
                                       ROUND(V_DP_REST::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer),
                                       V_OBJCOURSEACCOUNT.costCenterId,
                                       V_CONTRATO.contractid,
                                       V_PLETIVO.learningperiodid );
            ELSE
                RAISE EXCEPTION 'N?o foi possível gerar título de depend?ncias.';
            END IF;

            V_NUMERO_PARCELAS:= V_NUMERO_PARCELAS +1;
        END LOOP;
    END IF;

    -- Incentivos
    PERFORM generatecontractincentivesbyperiod(V_CONTRATO.contractid, 
                                               V_PLETIVO.learningperiodid);

    FOR V_INVOICEID IN SELECT invoiceId
                    FROM ONLY finInvoice A
                        WHERE isCanceled = FALSE
                          AND EXISTS (SELECT 1
                                        FROM finEntry X
                                       WHERE X.invoiceId = A.invoiceId
                                         AND X.learningPeriodId = p_learningPeriodId)
                          AND EXISTS (SELECT 1
                                        FROM finEntry X
                                       WHERE X.invoiceId = A.invoiceId
                                         AND X.contractId = p_contractId)
                          AND A.policyId =  getParameter('FINANCE', 'DEPENDENCY_POLICY_ID')::INT
                     ORDER BY referenceMaturityDate, parcelnumber
    LOOP
        RETURN NEXT V_INVOICEID;
    END LOOP;

    RETURN;
END
$$;


ALTER FUNCTION public.gerarmensalidadesdependencia(p_contractid integer, p_learningperiodid integer) OWNER TO postgres;

--
-- Name: gerarparcela(integer, integer, integer, numeric, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gerarparcela(p_contractid integer, p_learningperiodid integer, p_parcelnumber integer, p_value numeric, p_ecalouro boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: gerarparcela
  PURPOSE: Gera uma parcela (título) específica

  REVISIONS:
  Ver       Date       Author             Description
  --------- ---------- ------------------ ------------------------------------
  1.0       05/03/13   Leovan T. da Silva 1. FUNÇÃO criada.
  1.0       24/02/2014 Samuel Koch        1. Alterado função para atualizar
                                             a política.
**************************************************************************************/
DECLARE
    -- Valor a lançar, quando já existe título
    VLNC numeric;

    -- Código do título gerado
    v_invoiceid integer;
    
    -- Objeto que representa o contrato
    v_contrato acdcontract;
    -- Objeto que representa o período letivo
    v_periodo acdlearningperiod;
    -- Objeto que representa o título existente referente à parcela
    v_titulo finreceivableinvoice;
    -- Objeto que representa o preço de curso
    v_preco record;

    -- Data de referência - é a data de emissão do primeiro título ou a data atual
    v_data_referencia date;
    -- Operação do lançamento
    v_operacao integer;
    -- Política para o novo título
    v_politica integer;

    -- Variáveis referentes à data de vencimento
    -- Data de vencimento
    v_data_vencimento date;
    -- Dia
    v_dia_vencimento integer;
    -- Mês
    v_mes_vencimento integer;
    -- Ano
    v_ano_vencimento integer;
    -- Dia da semana
    v_dia_da_semana integer;

    -- Variáveis referentes à data de referência
    -- Dia
    v_dia_referencia integer;
    -- Mês
    v_mes_referencia integer;
    -- Ano
    v_ano_referencia integer;

    -- Dias a serem somados/subtraídos da data de vencimento qdo esta cair em finais de semana
    v_dias_diferenca integer;

    -- Data temporária (para ajustes)
    v_tmp_data date;

    -- Centro de custo
    v_centro_de_custo varchar;
BEGIN
    SELECT INTO v_contrato * FROM acdContract WHERE contractId = p_contractId;
    SELECT INTO v_periodo * FROM acdLearningPeriod WHERE learningperiodid = p_learningPeriodId;

    -- Verifica se já existe um título gerado para a parcela
    SELECT INTO v_titulo * 
                       FROM finReceivableInvoice A
                      WHERE isCanceled IS FALSE
                        AND parcelNumber = p_parcelnumber
                        AND EXISTS (SELECT 1
                                      FROM finentry
                                     WHERE invoiceid = A.invoiceid
                                       AND contractId = p_contractId)
                        AND EXISTS (SELECT 1
                                      FROM finentry AA
                                     INNER JOIN acdlearningperiod BB USING (learningperiodid)
                                     WHERE invoiceid = A.invoiceid
                                       AND BB.periodid = v_periodo.periodid);
    
    -- Se já existe título, utiliza o existente, apenas atualizando o valor através dos lançamentos
    IF v_titulo.invoiceid IS NOT NULL THEN
    
        VLNC := p_value - v_titulo.nominalvalue;        

        IF VLNC > 0 THEN
            SELECT INTO v_operacao addcurricularcomponentoperation FROM findefaultoperations LIMIT 1;
        ELSE 
            IF VLNC < 0 THEN
                VLNC := VLNC * (-1);
                SELECT INTO v_operacao cancelcurricularcomponentoperation FROM findefaultoperations LIMIT 1;
            END IF;
        END IF;
        
        IF VLNC > 0 THEN
            INSERT INTO finentry 
                        (invoiceid, 
                         operationid, 
                         entrydate, 
                         value, 
                         costcenterid, 
                         contractid, 
                         learningperiodid)
                 VALUES (v_titulo.invoiceid,
                         v_operacao,
                         now()::date,
                         ROUND(VLNC::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer),
                         v_titulo.costcenterid,
                         v_contrato.contractid,
                         v_periodo.learningperiodid);
        END IF;

        v_invoiceid := v_titulo.invoiceid;
        SELECT INTO v_politica policyid FROM fininvoice WHERE invoiceid = v_invoiceid;
        IF ( v_politica IS NULL ) THEN
            v_politica := obtempoliticadopreco(p_contractId, p_parcelnumber, p_learningPeriodId);            
        END IF;
        
        UPDATE fininvoice SET value = balance(v_invoiceid), policyid = v_politica WHERE invoiceid = v_invoiceid;

        --Insere registro do título na tabela finstatusdotitulolog com status de ajustado
        INSERT INTO finStatusDoTituloLog
                    (invoiceId, 
                     statusDoTituloId)
              VALUES (v_titulo.invoiceid,
                     2);

    -- Senao deve-se criar um novo título
    ELSE
        v_politica := obtempoliticadopreco(p_contractId, p_parcelnumber, p_learningPeriodId);
        v_data_referencia := obterDataReferenciaTitulos(p_contractId, p_learningPeriodId);
        
        IF (getParameter('FINANCE', 'GERAR_TITULOS_RETROATIVOS') = 'YES' OR
            v_data_referencia < v_periodo.begindate)
        THEN
            v_data_referencia := v_periodo.begindate;
        END IF;

        -- Se é a primeira parcela e se a primeira deve ser à vista, o vencimento é no dia seguinte
        v_preco := obterprecoatual(v_contrato.courseid, v_contrato.courseversion, v_contrato.turnid, v_contrato.unitid, v_periodo.begindate);
        
        -- Se é a primeira parcela e se a primeira deve ser à vista, o vencimento é no dia seguinte ou
        -- todos os títulos estão fehado e gera um novo título com o vencimento para o dia seguinte 
        IF (p_parcelnumber = 1 AND v_preco.firstParcelatsightfreshman IS TRUE) OR (p_parcelnumber > COALESCE(obterNumeroDeParcelas(p_contractid, p_learningperiodid), 0) AND p_parcelnumber != 0) THEN
            v_data_vencimento := now()::date + 1;            
        ELSE    
            -- Caso o dia de vencimento for configurado como o dia da matricula obtém o dia da matricula, caso contrário utiliza o dia de vencimento do preço
            IF v_preco.parceltype = 'D' THEN
                --Obtém o dia de vencimento da primeira movimentação contratual de matricula ou pré-matricula
                SELECT INTO     v_dia_vencimento EXTRACT('DAY' FROM statetime) FROM acdmovementcontract WHERE contractid = p_contractid AND learningperiodid = p_learningperiodid  AND statecontractid IN ( getparameter('BASIC', 'STATE_CONTRACT_ID_ENROLLED')::int, getparameter('ACADEMIC', 'STATE_CONTRACT_ID_PRE_ENROLL')::int ) ORDER BY statetime ASC LIMIT 1;
                v_mes_referencia := EXTRACT(month FROM v_data_referencia + ((p_parcelnumber - 2) || ' month')::interval);
            ELSE
                --O dia de vencimento é definido pelo contrato
                v_dia_vencimento := v_contrato.maturityday;
                v_mes_referencia := EXTRACT(month FROM v_data_referencia + ((p_parcelnumber - 1) || ' month')::interval);
            END IF;
            
            v_ano_referencia := EXTRACT(year FROM v_data_referencia + ((p_parcelnumber - 1) || ' month')::interval);

            v_tmp_data := TO_DATE(v_dia_vencimento || '/' || v_mes_referencia || '/' || v_ano_referencia, 'dd/mm/yyyy');

            --Caso a data passar do mes de referencia antecipa até o último dia do mes
            WHILE (EXTRACT (MONTH FROM v_tmp_data) <> v_mes_referencia) LOOP
                v_dia_vencimento := v_dia_vencimento - 1;

                v_tmp_data := TO_DATE(v_dia_vencimento || '/' || v_mes_referencia || '/' || v_ano_referencia, 'dd/mm/yyyy');
            END LOOP;
            
            v_data_vencimento := TO_DATE(v_dia_vencimento || '/' || v_mes_referencia || '/' || v_ano_referencia, 'dd/mm/yyyy');
            
        END IF;

        IF getParameter('FINANCE', 'VENCIMENTO_EM_FINAIS_DE_SEMANA') = 'NO'
        THEN
            -- Se a data de vencimento cair num final de semana deve-se alterar o dia de vencimento
            IF EXTRACT(DOW FROM v_data_vencimento) = 0 THEN
                v_dias_diferenca := 1;
            ELSE 
                IF EXTRACT(DOW FROM v_data_vencimento) = 6 THEN
                    v_dias_diferenca := 2;
                ELSE
                    v_dias_diferenca := 0;
                END IF;
            END IF;
        ELSE
            v_dias_diferenca := 0;
        END IF;

        IF v_dias_diferenca > 0 THEN
            -- Se a primeira parcela for à vista ou se estiver configurado para adiar, o vencimento cai na próxima segunda-feira
            IF (p_parcelnumber = 1 AND v_preco.firstparcelatsight IS TRUE) OR GETPARAMETER('FINANCE', 'ANTECIPATED_MATURITY_DATE') = 'f' THEN
                v_data_vencimento := v_data_vencimento + v_dias_diferenca;
            -- Senão adianta para a sexta-feira
            ELSE
                v_data_vencimento := v_data_vencimento - (3 - v_dias_diferenca);
            END IF;
        END IF;


        -- Obtem atributos do título
        -- Centro de custo
        -- Centro de custo
        SELECT INTO v_centro_de_custo costcenterid
                                 FROM acccourseaccount
                                WHERE courseid = v_contrato.courseid
                                  AND courseversion = v_contrato.courseversion
                                  AND unitid = v_contrato.unitid;

        v_invoiceid := nextval('seq_invoiceid');
 
        -- Insere o título na fininvoice
        INSERT INTO fininvoice (invoiceid,
                                personid,
                                costcenterid,
                                parcelnumber,
                                emissiondate,
                                maturitydate,
                                value,
                                policyid,
                                incomesourceid,
                                bankaccountid,
                                emissiontypeid,
                                referencematuritydate)
                        VALUES (v_invoiceid,
                                v_contrato.personid,
                                v_centro_de_custo,
                                p_parcelnumber,
                                now()::date,
                                v_data_vencimento,
                                0,
                                v_politica,
                                getParameter('FINANCE', 'INCOME_SOURCE_ID')::integer,
                                v_preco.bankaccountid,
                                getParameter('BASIC', 'DEFAULT_EMISSION_TYPE_ID')::integer,
                                v_data_vencimento);

        -- Insere o título na finreceivableinvoice (redundância por causa das heranças do Sagu)
        INSERT INTO finreceivableinvoice 
                               (invoiceid,
                                personid,
                                costcenterid,
                                parcelnumber,
                                emissiondate,
                                maturitydate,
                                value,
                                policyid,
                                incomesourceid,
                                bankaccountid,
                                emissiontypeid,
                                referencematuritydate)
                        VALUES (v_invoiceid,
                                v_contrato.personid,
                                v_centro_de_custo,
                                p_parcelnumber,
                                now()::date,
                                v_data_vencimento,
                                0,
                                v_politica,
                                getParameter('FINANCE', 'INCOME_SOURCE_ID')::integer,
                                v_preco.bankaccountid,
                                getParameter('BASIC', 'DEFAULT_EMISSION_TYPE_ID')::integer,
                                v_data_vencimento);
        
        --Insere registro do título na tabela finstatusdotitulolog com status de novo
        INSERT INTO finStatusDoTituloLog
                    (invoiceId, 
                     statusDoTituloId)
              VALUES (v_invoiceid,
                     1);
         
        -- Casos especias para primeira parcela
	IF ( p_parcelnumber = 1 )
	THEN
            -- Operação da primeira parcela para calouros
            IF ( p_ecalouro )
            THEN
                v_operacao := ( SELECT enrollOperation
				  FROM finDefaultOperations );
            ELSE
                -- Verifica se para o período existe uma movimentação contratual de reingresso, caso sim a operação da primeira parcela deve ser de reingresso e não de renovação.
		IF ( verificaSeAlunoEReingressanteNoPeriodo(p_contractid, p_learningperiodId) )
		THEN
		    v_operacao := ( SELECT reentryOperation
				      FROM finDefaultOperations );
		ELSE
		    v_operacao := ( SELECT renewalOperation
				      FROM finDefaultOperations );
		END IF;
            END IF;
	ELSE
            v_operacao := ( SELECT operationId
	 		      FROM finPolicy
			     WHERE policyId = v_politica );
	END IF;
 
        -- Insere um lançamento no valor da parcela       
        INSERT INTO finentry 
                        (invoiceid, 
                         operationid, 
                         entrydate, 
                         value, 
                         costcenterid, 
                         contractid, 
                         learningperiodid)
                 VALUES (v_invoiceid,
                         v_operacao,
                         now()::date,
                         ROUND(p_value::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer),
                         v_centro_de_custo,
                         v_contrato.contractid,
                         v_periodo.learningperiodid);

        -- Atualiza o atributo valor
        UPDATE fininvoice SET value = ROUND(balance(v_invoiceid)::numeric, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::integer) WHERE invoiceid = v_invoiceid;
    END IF;

    --Insere taxa de matrícula
    PERFORM (SELECT gerartaxadematricula(v_invoiceid));

    RETURN v_invoiceid;
END;
$$;


ALTER FUNCTION public.gerarparcela(p_contractid integer, p_learningperiodid integer, p_parcelnumber integer, p_value numeric, p_ecalouro boolean) OWNER TO postgres;

--
-- Name: gerartaxadematricula(integer); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION gerartaxadematricula(p_invoiceid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: gerartaxadematricula
  PURPOSE: Verifica se o título deve receber taxa de matricula
  **************************************************************************************/
DECLARE
    -- Recebe todas as taxas referente ao período letivo do título
    v_taxas RECORD;
    
    -- Obtém informações da tabela fininfotitulo
    v_info_titulo RECORD;

    -- Obtém informações da tabela finreceivableinvoice
    v_titulo RECORD;

    -- Recebe o valor da taxa da mensalidade
    v_valor_taxa NUMERIC;

    -- Verifica se o aluno é calouro
    v_isfreshman BOOLEAN;
    
    
BEGIN
    -- Obtém informações do título
    SELECT INTO v_info_titulo *
           FROM fininfotitulo
          WHERE titulo = p_invoiceid;

    SELECT INTO v_titulo * 
      FROM ONLY finreceivableinvoice
          WHERE invoiceid = p_invoiceid;

    --Verifica se o aluno é calouro
    SELECT INTO v_isfreshman isFreshMan(v_info_titulo.contrato);

    --Obtém todas as taxas referentes ao período letivo do título
    FOR v_taxas IN ( SELECT * 
		       FROM finenrollfee 
                      WHERE learningperiodid = v_info_titulo.periodo_letivo )
    LOOP
        v_valor_taxa := 0;
        
	--Verifica em quantas parcelas deve inserir a taxa
	IF v_titulo.parcelnumber <= v_taxas.parcelsnumber THEN

	    -- Obtém as taxas de calouro
	    IF v_taxas.isfreshman = TRUE AND v_isfreshman = TRUE THEN
	        IF v_taxas.valueispercent = TRUE THEN
		    v_valor_taxa := (v_info_titulo.valor_nominal * v_taxas.value/100);
	        ELSE
		    v_valor_taxa := v_taxas.value;
	        END IF;
	     END IF;

	    -- Obtém as taxas de veterano
	    IF v_taxas.isfreshman = FALSE AND v_isfreshman = FALSE THEN
	        IF v_taxas.valueispercent = TRUE THEN
		    v_valor_taxa := (v_info_titulo.valor_nominal * v_taxas.value/100);
	        ELSE
		    v_valor_taxa := v_taxas.value;
	        END IF;
	    END IF; 

            v_valor_taxa := ROUND(v_valor_taxa, GETPARAMETER('BASIC', 'REAL_ROUND_VALUE')::INTEGER);
		
            IF v_valor_taxa > 0 THEN
		    
		    -- Insere um lançamento para o título com o valor da taxa
		    INSERT INTO finentry
				(invoiceid, 
				 operationid, 
				 entrydate, 
				 value, 
				 costcenterid, 
				 contractid, 
				 learningperiodid)
			  VALUES (p_invoiceid,
				  v_taxas.operationid,
				  now()::DATE,
				  v_valor_taxa,
				  v_titulo.costcenterid,
				  v_info_titulo.contrato,
				  v_info_titulo.periodo_letivo);
	    END IF;
	     RAISE NOTICE 'VALOR DA TAXA DE MENSALIDADE % PARA O TÍTULO %', v_valor_taxa, p_invoiceid;
	END IF;
    END LOOP;
    RETURN TRUE;
END;
$$;


ALTER FUNCTION public.gerartaxadematricula(p_invoiceid integer) OWNER TO solis;

--
-- Name: get_atributo(integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION get_atributo(integer, text) RETURNS text
    LANGUAGE sql
    AS $_$ SELECT valor FROM ava_atributos WHERE ref_resposta = $1 AND chave = $2 $_$;


ALTER FUNCTION public.get_atributo(integer, text) OWNER TO postgres;

--
-- Name: get_atributo_totalizador(integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION get_atributo_totalizador(integer, text) RETURNS text
    LANGUAGE sql
    AS $_$ SELECT valor FROM ava_totalizadores_atributos WHERE ref_totalizador = $1 AND chave = $2 $_$;


ALTER FUNCTION public.get_atributo_totalizador(integer, text) OWNER TO postgres;

--
-- Name: get_multa(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION get_multa(p_fineid integer) RETURNS SETOF type_multa
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_line TYPE_MULTA;
    v_select text;
    
BEGIN
    
    v_select := 'SELECT C.personid, 
                        B.loanid, 
                        A.begindate, 
                        A.value, 
                        A.observation, 
                        (CASE WHEN finestatusid = 2
                        THEN
                            true
                        ELSE
                            false
                        END) AS waspaid, --foi paga
                        A.fineid,
                        B.loanoperator as operator,
                        (CASE WHEN finestatusid = 4 
                        THEN
                            true
                        ELSE
                            false
                        END) AS allowance, --foi abonada
                        '''' as allowancejustify, 
                        A.enddate,
                        B.returnoperator,
                        (CASE WHEN finestatusid = 3
                        THEN
                            true
                        ELSE
                        false
                        END) AS slipthrough --via boleto
                FROM gtcfine A 
            LEFT JOIN gtcloan B 
                    ON (A.loanid = B.loanid) 
            LEFT JOIN basPerson C 
                    ON (B.personid = C.personid)
                WHERE A.fineid = ' || p_fineid;


    FOR v_line IN EXECUTE v_select
    LOOP
        RETURN NEXT v_line;
    END LOOP;
    
    RETURN;
        
END;
$$;


ALTER FUNCTION public.get_multa(p_fineid integer) OWNER TO postgres;

--
-- Name: get_semester_contract(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION get_semester_contract(p_contractid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: get_v_semester_contract
  PURPOSE: Obtém o semestre em que o aluno está.
  AUTOR: ftomasini
**************************************************************************************/
DECLARE
    v_ch_semester RECORD;
    v_ch_contract FLOAT;
    v_semester_contract INT;
    v_ch_begin FLOAT;
    v_ch_semester_total FLOAT;
    
    v_enroll_status_approved INT := getParameter('ACADEMIC', 'ENROLL_STATUS_APPROVED')::INT;
    v_enroll_status_excused INT := getParameter('ACADEMIC', 'ENROLL_STATUS_EXCUSED')::INT;
    v_enroll_status_enrolled INT := getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED')::INT;
    v_enroll_status_pre_enrolled INT := getParameter('ACADEMIC', 'ENROLL_STATUS_PRE_ENROLLED')::INT;

    v_gordura_de_horas NUMERIC := getparameter('ACADEMIC', 'DEFINE_GORDURA_DE_HORAS_PARA_SEMESTRE_POR_CARGA_HORARIA');
BEGIN
    v_semester_contract:= 1;
    v_ch_begin:= 0;
    v_ch_semester_total:= 0;

    --carga horária já efetuada pelo aluno no contrato.
    SELECT INTO v_ch_contract COALESCE(sum(academicnumberhours),0)
           FROM acdcurricularcomponent A
     INNER JOIN acdcurriculum B
             ON (A.curricularcomponentid = B.curricularcomponentid
            AND A.curricularcomponentversion = B.curricularcomponentversion)
     INNER JOIN acdenroll C
             ON (B.curriculumid = C.curriculumid)
     INNER JOIN acdcontract D
             ON (D.contractid = C.contractid
            AND B.courseid =  D.courseid
            AND B.courseversion = D.courseversion
            AND B.turnid = D.turnid
            AND B.unitid = D.unitid)
          --Filtra somente pelas disciplinas pré-matriculadas, matriculadas, aprovadas e dispensadas.
          WHERE C.statusid IN (v_enroll_status_approved, v_enroll_status_excused, v_enroll_status_enrolled, v_enroll_status_pre_enrolled)
            AND D.contractid = p_contractid;

    --Percorre os semestres do curso do aluno
    FOR v_ch_semester IN 
	( SELECT B.semester, 
                 COALESCE(SUM(academicnumberhours),0) AS academicnumberhours
	    FROM acdcurricularcomponent A
      INNER JOIN acdcurriculum B
	      ON (A.curricularcomponentid = B.curricularcomponentid
	     AND A.curricularcomponentversion = B.curricularcomponentversion)
      INNER JOIN acdcontract D
	      ON (B.courseid =  D.courseid
	     AND B.courseversion = D.courseversion
	     AND B.turnid = D.turnid
	     AND B.unitid = D.unitid)
	   WHERE D.contractid = p_contractid
	     -- desconsidera disciplinas que não são da matriz do curso (opcoes de eletiva)
	     AND semester != 0
        GROUP BY B.semester 
        ORDER BY B.semester )
    LOOP
        v_ch_semester_total := v_ch_semester_total + v_ch_semester.academicnumberhours;        

	--Gordura de horas para atingir o semestre.
        IF v_gordura_de_horas IS NOT NULL
        THEN
            v_ch_semester_total := v_ch_semester_total + v_gordura_de_horas;
	END IF;

        --RAISE NOTICE 'v_ch_begin % < v_ch_contract % AND v_ch_contract % <= v_ch_semester_total %', v_ch_begin, v_ch_contract, v_ch_contract,v_ch_semester_total;
        --Verifica se a ch do contrato se encaixa na faixa do semestre
        IF ( ( v_ch_begin < v_ch_contract ) AND ( v_ch_contract <= v_ch_semester_total ) )
        THEN
            v_semester_contract:= v_ch_semester.semester;
        END IF;
        
        v_ch_begin:= v_ch_semester_total + 1;
    END LOOP;

    RETURN v_semester_contract;
END;
$$;


ALTER FUNCTION public.get_semester_contract(p_contractid integer) OWNER TO postgres;

--
-- Name: getbalancediscounts(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getbalancediscounts(p_invoiceid integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$
BEGIN
   return (SELECT SUM( 
                CASE WHEN A.operationTypeId = 'D' THEN ( 1 * B.value ) 
                WHEN A.operationTypeId = 'C' THEN ( -1 * B.value )    
                END 
               )    
               FROM finOperation A,                                                 
                    finEntry B                                                      
               WHERE A.operationId = B.operationId 
                    AND A.useInDiscounts is true
                    AND B.invoiceId = $1)::FLOAT;
END;
$_$;


ALTER FUNCTION public.getbalancediscounts(p_invoiceid integer) OWNER TO postgres;

--
-- Name: getbalancefines(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getbalancefines(p_invoiceid integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$
BEGIN
   return (SELECT SUM( 
                CASE WHEN A.operationTypeId = 'D' THEN ( 1 * B.value ) 
                WHEN A.operationTypeId = 'C' THEN ( -1 * B.value )    
                END 
               )    
               FROM finOperation A,                                                 
                    finEntry B                                                      
               WHERE A.operationId = B.operationId 
                    AND A.useInFines is true
                    AND B.invoiceId = $1)::FLOAT;
END;
$_$;


ALTER FUNCTION public.getbalancefines(p_invoiceid integer) OWNER TO postgres;

--
-- Name: getbalanceinterests(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getbalanceinterests(p_invoiceid integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$
BEGIN
   return (SELECT SUM( 
                CASE WHEN A.operationTypeId = 'D' THEN ( 1 * B.value ) 
                WHEN A.operationTypeId = 'C' THEN ( -1 * B.value )    
                END 
               )    
               FROM finOperation A,                                                 
                    finEntry B                                                      
               WHERE A.operationId = B.operationId 
                    AND A.useInInterests is true
                    AND B.invoiceId = $1)::FLOAT;
END;
$_$;


ALTER FUNCTION public.getbalanceinterests(p_invoiceid integer) OWNER TO postgres;

--
-- Name: getbanktaxvalue(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getbanktaxvalue(integer) RETURNS numeric
    LANGUAGE sql
    AS $_$
SELECT A.banktaxvalue
  FROM finPolicy A
 INNER JOIN acdLearningPeriod AS B
    ON (A.policyId = B.policyId)
 WHERE B.learningPeriodId = $1 $_$;


ALTER FUNCTION public.getbanktaxvalue(integer) OWNER TO postgres;

--
-- Name: getblockedinvoice(integer, integer, integer, double precision, double precision); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION getblockedinvoice(p_contractid integer, p_learningperiodid integer, p_parcelnumber integer, v_vcont double precision, v_mens double precision) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/*********************************************************************************************
  NAME: getblockedinvoice
  PURPOSE: Obtem titulo bloqueado para o contrato + periodo letivo + numero parcela passados
*********************************************************************************************/
DECLARE
BEGIN
    RETURN  (SELECT MIN(I.invoiceId)
               FROM finInvoice I
         INNER JOIN finEntry E
                 ON (I.invoiceId = E.invoiceId)
              WHERE I.isCanceled IS FALSE
                AND I.parcelNumber = p_parcelnumber
              
                AND EXISTS(SELECT 1 FROM finEntry E1 WHERE E1.invoiceID = I.invoiceId AND E1.contractId = p_contractid AND E1.learningPeriodId = p_learningperiodid)
                
                -- Deve existir uma operacao de pagamento
                AND EXISTS(SELECT 1 FROM finEntry E2 WHERE E2.invoiceId = I.invoiceId AND E2.operationId = (SELECT paymentOperation FROM findefaultoperations))

                AND (
                   BALANCE(I.invoiceId) <= 0
                   OR (
                        -- Caso seja PRIMEIRA parcela e aluno for CALOURO e "V_VCONT < V_MENS", conta como bloqueado.
                        ( CASE WHEN I.parcelNumber = 1
                          THEN
                              ( V_VCONT < V_MENS AND isFreshMan(p_contractId) )
                          ELSE
                              TRUE
                          END )
                   ) )
                );
END
$$;


ALTER FUNCTION public.getblockedinvoice(p_contractid integer, p_learningperiodid integer, p_parcelnumber integer, v_vcont double precision, v_mens double precision) OWNER TO solis;

--
-- Name: getbusinessdates(date, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getbusinessdates(p_begindate date, p_enddate date) RETURNS SETOF date
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: getbusinessdays
  DESCRIPTION: Obtem dias éteis validos (datas) nos periodos passados.
**************************************************************************************/
DECLARE
BEGIN
    RETURN QUERY (SELECT dt::date
              FROM GENERATE_SERIES(p_beginDate, p_endDate, '1 day') dt
             WHERE EXTRACT(DOW FROM dt)::varchar = ANY (
                STRING_TO_ARRAY(GETPARAMETER('BASIC', 'INSTITUTION_BUSINESS_DAYS'), ',')
             )
    );
END
$$;


ALTER FUNCTION public.getbusinessdates(p_begindate date, p_enddate date) OWNER TO postgres;

--
-- Name: getcargahorariacursada(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcargahorariacursada(p_residenteid integer, p_unidadetematicaid integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: getCargaHorariaCursada
  PURPOSE: Retorna carga horaria já cursada pelo residente na unidade temática passada
  DESCRIPTION: Retorna carga horaria já cursada pelo residente na unidade temática passada

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       18/07/2011 Moises Heberle    1. Função criada.
**************************************************************************************/
DECLARE
    v_row RECORD;
BEGIN
    RETURN 11.2;
END;
$$;


ALTER FUNCTION public.getcargahorariacursada(p_residenteid integer, p_unidadetematicaid integer) OWNER TO postgres;

--
-- Name: getcellphone(bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcellphone(bigint) RETURNS character varying
    LANGUAGE sql
    AS $_$
    SELECT phone FROM basphone WHERE type = 'CEL' AND personId = $1
$_$;


ALTER FUNCTION public.getcellphone(bigint) OWNER TO postgres;

--
-- Name: getcity(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcity(integer) RETURNS character varying
    LANGUAGE sql
    AS $_$
SELECT name 
  FROM basCity 
 WHERE cityId = $1 
$_$;


ALTER FUNCTION public.getcity(integer) OWNER TO postgres;

--
-- Name: getclassname(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getclassname(p_classid character varying) RETURNS text
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: getClassName
  DESCRIPTION: Obtem o nome da turma 

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       17/03/2011 Moises Heberle    1. Função alterada
******************************************************************************/
DECLARE
    v_className varchar;
BEGIN
    SELECT INTO v_className
           A.name
      FROM acdClass A
     WHERE A.classId = p_classId;

     RETURN v_className;
END;
$$;


ALTER FUNCTION public.getclassname(p_classid character varying) OWNER TO postgres;

--
-- Name: getclassperiod(character varying, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getclassperiod(p_classid character varying, p_learningperiodid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: getClassPeriod
  PURPOSE: Retorna o período em que a turma se encontra no período letivo informado
  DESCRIPTION:
  A partir do período inicial da turma informada, percorre a lista de períodos
  letivos até encontrar (ou não) o período informado, mantendo um contador que é
  incrementado e será o valor de retorno. Se atingir o fim da lista de períodos
  letivos sem encontrar o período informado, aborta a função com um erro.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       12/11/2010 Alexandre Schmidt 1. Função criada.
  1.1       04/02/2011 Alexandre Schmidt 1. Tratamento de inconsistências, tais
                                            como informação de períodos letivos
                                            faltando ou de turmas inexistentes.
******************************************************************************/
DECLARE
    v_currentLearningPeriodId acdLearningPeriod.learningPeriodId%TYPE;
    v_classPeriod integer;
    v_found boolean;
BEGIN
    -- obriga informação da turma e do período letivo
    IF ( p_classId IS NULL OR p_learningPeriodId IS NULL )
    THEN
        RETURN NULL;
    END IF;

    -- obter período letivo inicial da turma
    SELECT initialLearningPeriodId INTO v_currentLearningPeriodId
      FROM acdClass
     WHERE classId = p_classId;

    IF ( v_currentLearningPeriodId IS NULL )
    THEN
        RAISE WARNING 'Não foi possível obter período letivo inicial da turma %.', p_classId;
        RETURN NULL;
    END IF;

    v_classPeriod := 1;

    -- if initial learning period is the learning period being searched
    v_found := (p_learningPeriodId = v_currentLearningPeriodId);
    WHILE NOT v_found LOOP
        -- look for a period with previous learning period = current learning period
        SELECT learningPeriodId INTO v_currentLearningPeriodId
          FROM acdLearningPeriod
         WHERE previousLearningPeriodId = v_currentLearningPeriodId;

        -- if no learning period found, raise an error
        IF v_currentLearningPeriodId IS NULL THEN
            RAISE WARNING 'Período letivo % não pertence à lista de períodos letivos da turma %.', p_learningPeriodId, p_classId;
            RETURN NULL;
        ELSE
           -- increment class current period and check if we found
           -- what we've been looking for
           v_classPeriod := v_classPeriod + 1;
           v_found = p_learningPeriodId = v_currentLearningPeriodId;
        END IF;
    END LOOP;

    RETURN v_classPeriod;
END;
$$;


ALTER FUNCTION public.getclassperiod(p_classid character varying, p_learningperiodid integer) OWNER TO postgres;

--
-- Name: getcollectiontypedescription(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcollectiontypedescription(integer) RETURNS character varying
    LANGUAGE sql
    AS $_$
 SELECT description
   FROM finCollectionType
  WHERE collectionTypeId = $1$_$;


ALTER FUNCTION public.getcollectiontypedescription(integer) OWNER TO postgres;

--
-- Name: getcontractactivationdate(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcontractactivationdate(_contractid integer) RETURNS timestamp without time zone
    LANGUAGE plpgsql STABLE
    AS $$

DECLARE
    result acdMovementContract.stateTime%TYPE;

BEGIN

    SELECT INTO result A.stateTime
           FROM acdMovementContract A,
                acdStateContract B 
          WHERE A.contractId = _contractId
            AND A.stateContractId = B.stateContractId 
       ORDER BY A.stateTime
          LIMIT 1;

    RETURN result;
END;
$$;


ALTER FUNCTION public.getcontractactivationdate(_contractid integer) OWNER TO postgres;

--
-- Name: getcontractactivationstatecontract(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcontractactivationstatecontract(_contractid integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$

DECLARE
    result acdMovementContract.stateContractId%TYPE;

BEGIN

    SELECT INTO result A.stateContractId
           FROM acdMovementContract A,
                acdStateContract B 
          WHERE A.contractId = _contractId
            AND A.stateContractId = B.stateContractId 
       ORDER BY A.stateTime
          LIMIT 1;

    RETURN result;
END;
$$;


ALTER FUNCTION public.getcontractactivationstatecontract(_contractid integer) OWNER TO postgres;

--
-- Name: getcontractclassid(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcontractclassid(p_contractid integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: getContractClassId
  DESCRIPTION: Função que retorna a turma em que determinado contrato se encontra.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       03/02/2011 Moises Heberle    1. Função alterada.
******************************************************************************/
DECLARE
    v_classId acdClass.classId%TYPE;
BEGIN
    SELECT INTO v_classId
           A.classId
      FROM acdClassPupil A
     WHERE A.contractId = p_contractId
       AND (A.endDate IS NULL OR A.endDate > now()::date)
  ORDER BY A.beginDate DESC
     LIMIT 1;

     RETURN v_classId;
END;
$$;


ALTER FUNCTION public.getcontractclassid(p_contractid integer) OWNER TO postgres;

--
-- Name: getcontractcourseid(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcontractcourseid("contractId" integer) RETURNS character varying
    LANGUAGE sql
    AS $_$
  SELECT courseId FROM acdContract WHERE contractId = $1 
$_$;


ALTER FUNCTION public.getcontractcourseid("contractId" integer) OWNER TO postgres;

--
-- Name: getcontractcourseversion(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcontractcourseversion("contractId" integer) RETURNS integer
    LANGUAGE sql
    AS $_$
  SELECT courseVersion FROM acdContract WHERE contractId = $1 
$_$;


ALTER FUNCTION public.getcontractcourseversion("contractId" integer) OWNER TO postgres;

--
-- Name: getcontractcurrentclass(integer); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION getcontractcurrentclass(p_contractid integer) RETURNS SETOF getcontractcurrentclasstype
    LANGUAGE plpgsql
    AS $$
/*********************************************************************************************
  NAME: getContractCurrentClass
  PURPOSE: Obtem a turma atual do contrato..
*********************************************************************************************/
DECLARE
BEGIN
    RETURN QUERY (SELECT DISTINCT A.classId,
                                B.name,
                                A.contractId,
                                A.beginDate
                  FROM acdClassPupil A
            INNER JOIN acdClass B
                    ON B.classId = A.classId
                 WHERE A.contractId = p_contractid
                   AND (A.endDate IS NULL OR A.endDate > now()::date )
                   AND A.classId = getContractClassId(p_contractId)
              ORDER BY A.begindate DESC
                 LIMIT 1);
END
$$;


ALTER FUNCTION public.getcontractcurrentclass(p_contractid integer) OWNER TO solis;

--
-- Name: getcontractcurricularcomponents(integer, integer[], integer[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcontractcurricularcomponents(_contractid integer, _curriculumtypeid integer[], _statusid integer[]) RETURNS integer
    LANGUAGE plpgsql
    AS $$

DECLARE
    result1 int;

BEGIN
    SELECT INTO result1 count(*) 
           FROM acdEnroll A
     INNER JOIN acdCurriculum B
             ON (B.curriculumId = A.curriculumId)
     INNER JOIN acdContract C
             ON (C.contractId = A.contractId)
          WHERE C.contractId = _contractId
            AND C.courseId = B.courseId
            AND C.courseVersion = B.courseVersion
            AND C.unitId = B.unitId
            AND C.turnId = B.turnId
            AND B.curriculumTypeId = ANY (_curriculumTypeId)
            AND A.statusId = ANY (_statusId);

    RETURN result1;
END;
$$;


ALTER FUNCTION public.getcontractcurricularcomponents(_contractid integer, _curriculumtypeid integer[], _statusid integer[]) OWNER TO postgres;

--
-- Name: getcontractdisactivationdate(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcontractdisactivationdate(_contractid integer) RETURNS timestamp without time zone
    LANGUAGE plpgsql STABLE
    AS $$

DECLARE
    result1 RECORD;
    result2 boolean;

BEGIN
    SELECT INTO result1 stateContractId, stateTime
           FROM acdMovementContract 
          WHERE contractId = _contractId
       ORDER BY acdMovementContract.stateTime DESC
          LIMIT 1;

    IF result1.stateContractId > 0
        THEN
            SELECT INTO result2 isCloseContract
                   FROM acdStateContract
                  WHERE inOutTransition <> 'I'
                    AND stateContractId NOT IN (4, 6, 8, 10)
                    AND stateContractid = result1.stateContractId;
            IF result2 = true
            THEN
                RETURN result1.stateTime;
            END IF;
        END IF;

    RETURN NULL;
END;
$$;


ALTER FUNCTION public.getcontractdisactivationdate(_contractid integer) OWNER TO postgres;

--
-- Name: getcontractdisactivationreasonid(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcontractdisactivationreasonid(_contractid integer) RETURNS character varying
    LANGUAGE plpgsql STABLE
    AS $$

DECLARE
    result1 RECORD;
    result2 boolean;
    result3 varchar;

BEGIN
    SELECT INTO result1 stateContractId, reasonId 
           FROM acdMovementContract 
          WHERE contractId = _contractId
       ORDER BY acdMovementContract.stateTime DESC
          LIMIT 1;

    IF result1.stateContractId > 0
        THEN
            SELECT INTO result2 isCloseContract
                   FROM acdStateContract
                  WHERE inOutTransition <> 'I'
                    AND stateContractId NOT IN (4, 6, 8, 10)
                    AND stateContractid = result1.stateContractId;
            
            IF result2 = true
                THEN
                    RETURN result1.reasonId;
            END IF;
        END IF;

    RETURN '';
END;
$$;


ALTER FUNCTION public.getcontractdisactivationreasonid(_contractid integer) OWNER TO postgres;

--
-- Name: getcontractpersonid(integer); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION getcontractpersonid("contractId" integer) RETURNS bigint
    LANGUAGE sql
    AS $_$
  SELECT personId::bigint FROM acdContract WHERE contractId = $1 
$_$;


ALTER FUNCTION public.getcontractpersonid("contractId" integer) OWNER TO solis;

--
-- Name: getcontractstate(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcontractstate(_contractid integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    result1 int;
BEGIN
    SELECT INTO result1 stateContractId 
           FROM acdMovementContract 
          WHERE contractId = _contractId
       ORDER BY stateTime DESC
          LIMIT 1;

    RETURN result1;
END;
$$;


ALTER FUNCTION public.getcontractstate(_contractid integer) OWNER TO postgres;

--
-- Name: getcontractstatebetweendates(integer, date, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcontractstatebetweendates(_contractid integer, begindate date, enddate date) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$

DECLARE
    result1 int;

BEGIN

    SELECT INTO result1 stateContractId 
           FROM acdMovementContract 
          WHERE contractId = _contractId
            AND stateTime >= beginDate
            AND stateTime <= endDate
       ORDER BY stateTime DESC
          LIMIT 1;

    RETURN result1;
END;
$$;


ALTER FUNCTION public.getcontractstatebetweendates(_contractid integer, begindate date, enddate date) OWNER TO postgres;

--
-- Name: getcontractstatebyperiod(integer, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcontractstatebyperiod(v_contractid integer, v_periodid character varying) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    result1 int;
BEGIN
    SELECT INTO result1 MC.stateContractId 
           FROM acdMovementContract MC
     INNER JOIN acdLearningPeriod LP
             ON LP.learningPeriodId = MC.learningperiodid
          WHERE MC.contractId = v_contractId
            AND LP.periodId = v_periodid
       ORDER BY MC.stateTime DESC
          LIMIT 1;

    RETURN result1;
END;
$$;


ALTER FUNCTION public.getcontractstatebyperiod(v_contractid integer, v_periodid character varying) OWNER TO postgres;

--
-- Name: getcontractunitid(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcontractunitid("contractId" integer) RETURNS integer
    LANGUAGE sql
    AS $_$
  SELECT unitId FROM acdContract WHERE contractId = $1 
$_$;


ALTER FUNCTION public.getcontractunitid("contractId" integer) OWNER TO postgres;

--
-- Name: getcourseaccount(character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION getcourseaccount(p_courseid character varying, p_courseversion integer, p_unitid integer) RETURNS SETOF getcourseaccounttype
    LANGUAGE plpgsql
    AS $$
/*********************************************************************************************
  NAME: getCourseAccount
  PURPOSE: Get course account
*********************************************************************************************/
DECLARE
BEGIN
    RETURN QUERY   (SELECT A.courseId,
                           A.courseVersion,
                           B.name AS courseName,
                           A.unitId,
                           A.accountSchemeId,
                           C.description AS accountSchemeDescription,
                           A.costCenterId,
                           D.description AS costCenterDescription
                     FROM accCourseAccount A
               INNER JOIN acdCourse B
                       ON B.courseId = A.courseId
               INNER JOIN accAccountScheme C
                       ON C.accountSchemeId = A.accountSchemeId
               INNER JOIN accCostCenter D
                       ON D.costCenterId = A.costCenterId
                    WHERE A.courseId = p_courseid
                      AND A.courseVersion = p_courseversion
                      AND A.unitId = p_unitid );
END
$$;


ALTER FUNCTION public.getcourseaccount(p_courseid character varying, p_courseversion integer, p_unitid integer) OWNER TO solis;

--
-- Name: getcoursedefaultnumber(character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcoursedefaultnumber(character varying, integer, character varying) RETURNS integer
    LANGUAGE sql
    AS $_$
-- Função getcoursedefaultnumber
-- Obtém o número total de inadimplentes para um curso em um período
-- Parâmetros: courseid varchar, turnid integer, periodid varchar
-- Retorno: número de inadimplentes
    SELECT count(*)::int 
      FROM (
            SELECT DISTINCT A.personId
              FROM finreceivableinvoice A
             INNER JOIN finentry B USING (invoiceId)
             INNER JOIN acdContract C USING (contractId)
             INNER JOIN acdLearningPeriod D USING (learningPeriodId)
             WHERE EXISTS (SELECT AAA.operationId 
                             FROM finOperation AAA
                            WHERE AAA.operationId = B.operationId
                              AND AAA.operationGroupId = (SELECT value 
                                                            FROM basconfig 
                                                           WHERE parameter = 'MONTHLY_FEE_OPERATION_GROUP_ID') )
               AND EXISTS (SELECT AAAA.contractId
                             FROM acdEnroll AAAA
                            INNER JOIN acdGroup BBBB USING (groupId)
                            WHERE BBBB.learningPeriodId IN (SELECT learningPeriodId FROM acdLearningPeriod WHERE periodId = $3)
                              AND AAAA.contractId = B.contractId)
               AND A.referenceMaturityDate < now()::date
               AND balance(A.invoiceId) > 0
               AND C.courseId = $1
               AND C.turnId = $2
               AND D.periodId = $3
           ) AS sel
$_$;


ALTER FUNCTION public.getcoursedefaultnumber(character varying, integer, character varying) OWNER TO postgres;

--
-- Name: getcoursedefaultvalue(character varying, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcoursedefaultvalue(character varying, integer, integer, character varying) RETURNS numeric
    LANGUAGE sql
    AS $_$
-- Função getcoursedefaultvalue
-- Obtém o valor de inadimplência de determinada parcela para um curso em um período
-- Parâmetros: courseid varchar, turnid integer , parcelnumber integer, periodid integer
-- Retorno: valor de inadimplência
    SELECT ROUND(COALESCE(sum(valor_nominal), 0), (SELECT value FROM basconfig WHERE parameter LIKE 'REAL_ROUND_VALUE')::int )
      FROM (
            SELECT DISTINCT A.personid as matricula,
                            getpersonname(A.personid) as nome,
                            getcontractclassid(C.contractid) as turma,
                            A.invoiceid as titulo,
                            A.parcelnumber as parcela,
                            TO_CHAR(A.referencematuritydate, (SELECT value FROM basconfig WHERE parameter LIKE 'MASK_DATE')) as vencimento,
                            ROUND(balance(A.invoiceid), (SELECT value FROM basconfig WHERE parameter LIKE 'REAL_ROUND_VALUE')::int) as valor_nominal,
                            balanceWithPoliciesDated(A.invoiceId, now()::date) as valor_atualizado,
                            COALESCE((SELECT ROUND(sum(X.value), (SELECT value FROM basconfig WHERE parameter LIKE 'REAL_ROUND_VALUE')::int) FROM finentry X INNER JOIN finoperation Y USING (operationid) WHERE X.invoiceid = A.invoiceid AND Y.operationtypeid = 'C' AND NOT EXISTS (SELECT * FROM findefaultoperations XX WHERE XX.paymentoperation = X.operationid)), 0) as descontos
              FROM finreceivableinvoice A
        INNER JOIN finentry B USING (invoiceId)
        INNER JOIN acdContract C USING (contractId)
        INNER JOIN acdLearningPeriod D USING (learningPeriodId)
             WHERE EXISTS (SELECT AAA.operationId 
                             FROM finOperation AAA
                            WHERE AAA.operationId = B.operationId
                              AND AAA.operationGroupId = (SELECT value 
                                                            FROM basconfig 
                                                           WHERE parameter = 'MONTHLY_FEE_OPERATION_GROUP_ID') )
               AND A.referenceMaturityDate < now()::date
               AND balance(A.invoiceId) > 0
               AND C.courseId = $1
               AND C.turnId = $2
               AND A.parcelNumber = $3
               AND D.periodId = $4
    ) as sel
$_$;


ALTER FUNCTION public.getcoursedefaultvalue(character varying, integer, integer, character varying) OWNER TO postgres;

--
-- Name: getcourseenrollcancellednumber(character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcourseenrollcancellednumber(character varying, integer, character varying) RETURNS integer
    LANGUAGE sql
    AS $_$
-- Função getcourseenrollcancellednumber
-- Obtém o número total de alunos que se matricularam e cancelaram (trancamento ou transferência) para um curso em um período
-- Parâmetros: courseid varchar, turnid integer, periodid varchar
-- Retorno: número de alunos que se matricularam e cancelaram
    SELECT count(*)::int 
      FROM (
            SELECT DISTINCT A.contractId
              FROM acdEnroll A
             INNER JOIN acdGroup B
                ON (B.groupId = A.groupId)
             WHERE EXISTS (SELECT AA.learningPeriodId
                             FROM acdLearningPeriod AA
                            WHERE AA.learningPeriodId = B.learningPeriodId
                              AND AA.periodId = $3)
               AND EXISTS (SELECT BB.contractId 
                             FROM acdContract BB
                            WHERE BB.contractId = A.contractId
                              AND BB.courseId = $1
                              AND BB.turnId = $2)
               AND A.statusId = (SELECT value::int FROM basConfig WHERE parameter = 'ENROLL_STATUS_CANCELLED')
               AND NOT EXISTS (SELECT CC.contractId 
                                 FROM acdEnroll CC
                                INNER JOIN acdGroup DD
                                   ON (DD.groupId = CC.groupId)
                                WHERE CC.contractId = A.contractId 
                                  AND EXISTS (SELECT EE.learningPeriodId
                                                FROM acdLearningPeriod EE
                                               WHERE EE.learningPeriodId = B.learningPeriodId
                                                 AND EE.periodId = $3)
                                  AND CC.statusId = (SELECT value::int FROM basConfig WHERE parameter = 'ENROLL_STATUS_ENROLLED'))
           ) AS sel
$_$;


ALTER FUNCTION public.getcourseenrollcancellednumber(character varying, integer, character varying) OWNER TO postgres;

--
-- Name: getcourseenrollednumber(character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcourseenrollednumber(character varying, integer, character varying) RETURNS integer
    LANGUAGE sql
    AS $_$
-- Função getcourseenrollednumber
-- Obtém o número total de alunos matriculados para um curso em um período
-- Parâmetros: courseid varchar, turnid integer, periodid varchar
-- Retorno: número de alunos matriculados
    SELECT count(*)::int 
      FROM (
            SELECT DISTINCT A.contractId
              FROM acdEnroll A
             INNER JOIN acdGroup B
                ON (B.groupId = A.groupId)
             WHERE EXISTS (SELECT AA.learningPeriodId
                             FROM acdLearningPeriod AA
                            WHERE AA.learningPeriodId = B.learningPeriodId
                              AND AA.periodId = $3)
               AND EXISTS (SELECT BB.contractId 
                             FROM acdContract BB
                            WHERE BB.contractId = A.contractId
                              AND BB.courseId = $1
                              AND BB.turnId = $2)
               AND A.statusId = (SELECT value::int FROM basConfig WHERE parameter = 'ENROLL_STATUS_ENROLLED')
           ) AS sel
$_$;


ALTER FUNCTION public.getcourseenrollednumber(character varying, integer, character varying) OWNER TO postgres;

--
-- Name: getcoursename(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcoursename(character varying) RETURNS character varying
    LANGUAGE sql
    AS $_$
SELECT name
  FROM acdCourse
 WHERE courseId = $1$_$;


ALTER FUNCTION public.getcoursename(character varying) OWNER TO postgres;

--
-- Name: getcoursename(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcoursename(integer) RETURNS character varying
    LANGUAGE sql
    AS $_$
SELECT name
  FROM acdCourse
 WHERE courseId = $1$_$;


ALTER FUNCTION public.getcoursename(integer) OWNER TO postgres;

--
-- Name: getcourseoccurrencedescription(character varying, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcourseoccurrencedescription(p_courseid character varying, p_courseversion integer, p_unitid integer, p_turnid integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: getCourseOccurrenceDescription
  PURPOSE: Retorna um varchar contendo as informações de uma ocorrência de curso.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       04/08/2011 Alexandre Schmidt 1. Função criada.
**************************************************************************************/
DECLARE
    v_retVal varchar;
BEGIN
    SELECT A.courseId || '/' || A.courseVersion || ' ' || B.name ||
           ' - ' || A.unitId || ' ' || C.description ||
           ' - ' || A.turnId || ' ' || D.description INTO v_retVal
      FROM acdCourseOccurrence A
INNER JOIN acdCourse B
        ON B.courseId = A.courseId
INNER JOIN basUnit C
        ON C.unitId = A.unitId
INNER JOIN basTurn D
        ON D.turnId = A.turnId
     WHERE A.courseId = p_courseId
       AND A.courseVersion = p_courseVersion
       AND A.unitId = p_unitId
       AND A.turnId = p_turnId;

    RETURN v_retVal;
END;
$$;


ALTER FUNCTION public.getcourseoccurrencedescription(p_courseid character varying, p_courseversion integer, p_unitid integer, p_turnid integer) OWNER TO postgres;

--
-- Name: getcourseshortname(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcourseshortname(character varying) RETURNS character varying
    LANGUAGE sql
    AS $_$
SELECT shortName
  FROM acdCourse
 WHERE courseId = $1$_$;


ALTER FUNCTION public.getcourseshortname(character varying) OWNER TO postgres;

--
-- Name: getcourseshortname(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcourseshortname(integer) RETURNS character varying
    LANGUAGE sql
    AS $_$
SELECT shortName
  FROM acdCourse
 WHERE courseId = $1$_$;


ALTER FUNCTION public.getcourseshortname(integer) OWNER TO postgres;

--
-- Name: getcurrentenrollid(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcurrentenrollid(p_contractid integer, p_groupid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: getCurrentEnrollId
  DESCRIPTION: Obtem o codigo da ultima matricula (enrollId)
    a partir de uma disciplina e contrato passado. Util para casos onde aluno
    possui varias matriculas em uma disciplina, sendo que anteriores estao como
    CANCELADAS ou outro estado.
**************************************************************************************/
DECLARE
BEGIN
    RETURN    (SELECT enrollId
                 FROM acdEnroll
                WHERE contractId = p_contractId
                  AND groupId = p_groupId
             ORDER BY dateTime DESC
                LIMIT 1);
END;
$$;


ALTER FUNCTION public.getcurrentenrollid(p_contractid integer, p_groupid integer) OWNER TO postgres;

--
-- Name: getcurricularcomponentname(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcurricularcomponentname(character varying) RETURNS character varying
    LANGUAGE sql
    AS $_$
SELECT name
  FROM acdCurricularComponent
 WHERE curricularComponentId = $1$_$;


ALTER FUNCTION public.getcurricularcomponentname(character varying) OWNER TO postgres;

--
-- Name: getcurricularcomponentname(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcurricularcomponentname(integer) RETURNS character varying
    LANGUAGE sql
    AS $_$
SELECT name
  FROM acdCurricularComponent
 WHERE curricularComponentId = $1$_$;


ALTER FUNCTION public.getcurricularcomponentname(integer) OWNER TO postgres;

--
-- Name: getcurricularcomponentshortname(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcurricularcomponentshortname(character varying) RETURNS character varying
    LANGUAGE sql
    AS $_$
SELECT shortName
  FROM acdCurricularComponent
 WHERE curricularComponentId = $1$_$;


ALTER FUNCTION public.getcurricularcomponentshortname(character varying) OWNER TO postgres;

--
-- Name: getcurricularcomponentshortname(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcurricularcomponentshortname(integer) RETURNS character varying
    LANGUAGE sql
    AS $_$
SELECT shortName
  FROM acdCurricularComponent
 WHERE curricularComponentId = $1$_$;


ALTER FUNCTION public.getcurricularcomponentshortname(integer) OWNER TO postgres;

--
-- Name: getcurriculumnumberhours(integer); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION getcurriculumnumberhours(p_curriculumid integer) RETURNS SETOF getcurriculumnumberhours
    LANGUAGE plpgsql
    AS $$
/*********************************************************************************************
  NAME: getCurriculumNumberHours
  PURPOSE: Gets the different number hours of a curriculum
*********************************************************************************************/
DECLARE
BEGIN
    RETURN QUERY (SELECT B.academicNumberHours,
                         B.practicalNumberHours,
                         B.theoreticalNumberHours
                   FROM acdCurriculum A
             INNER JOIN acdCurricularComponent B
                     ON (B.curricularComponentId = A.curricularComponentId AND
                         B.curricularComponentVersion = A.curricularComponentVersion)
                  WHERE A.curriculumId = p_curriculumid );
END
$$;


ALTER FUNCTION public.getcurriculumnumberhours(p_curriculumid integer) OWNER TO solis;

--
-- Name: getcustomvalue(character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getcustomvalue(p_fieldname character varying, p_customizedid character varying) RETURNS text
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: getcustomvalue
  PURPOSE: Returna o valor customizado, de acordo com id do registro e campo passados.
**************************************************************************************/
BEGIN
     RETURN (   SELECT value
                  FROM miolo_custom_field F
            INNER JOIN miolo_custom_value V ON V.custom_field_id = F.id
                 WHERE F.name = p_fieldname
                   AND customized_id = p_customizedId );
END;
$$;


ALTER FUNCTION public.getcustomvalue(p_fieldname character varying, p_customizedid character varying) OWNER TO postgres;

--
-- Name: getdateinterval(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getdateinterval(begindate character varying, enddate character varying, maskdate character varying) RETURNS SETOF character varying
    LANGUAGE plpgsql STABLE
    AS $$

DECLARE
    count integer;

BEGIN
    count:= TO_DATE(endDate,maskDate) - TO_DATE(beginDate,maskDate);

    WHILE (count>=0)
    LOOP
          RETURN NEXT (TO_CHAR(( TO_DATE(endDate,maskDate) - count ),
maskDate));
          count:=count-1;
    END LOOP;
    RETURN;
END;
$$;


ALTER FUNCTION public.getdateinterval(begindate character varying, enddate character varying, maskdate character varying) OWNER TO postgres;

--
-- Name: getdateintervalweek(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getdateintervalweek(begindate character varying, enddate character varying, datemask character varying) RETURNS SETOF character varying
    LANGUAGE plpgsql STABLE
    AS $$

DECLARE
    count integer;

BEGIN
    count:= TO_DATE(endDate,dateMask) - TO_DATE(beginDate,dateMask);

    WHILE (count>=0)
    LOOP
          RETURN NEXT (TO_CHAR((TO_DATE(endDate,dateMask) - count),dateMask) || ';' || extract ( DOW FROM TO_DATE(endDate,dateMask) - count ) );
          count:=count-1;
    END LOOP;
    RETURN;
END;
$$;


ALTER FUNCTION public.getdateintervalweek(begindate character varying, enddate character varying, datemask character varying) OWNER TO postgres;

--
-- Name: getdaystoconvenant(integer, integer); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION getdaystoconvenant(p_invoiceid integer, v_convenantid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$

/*********************************************************************************************
  NAME: getDaysToConvenant
  PURPOSE: obtém o número de dias a conceder desconto de um título.
  DESCRIPTION: A função obtém o número para conceder desconto levando em consideração
  os parâmetros DESCARTAR_DIA_31 e EXTENDER_DESCONTOS_NA_SEGUNDA

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       07/04/2014 Fabiano Tomasini        1. Função criada
*********************************************************************************************/

DECLARE
     v_calcNumberDays INTEGER;
     v_invoiceInfo RECORD;
     v_convenantinfo RECORD;
     v_numberDays INTEGER;
     v_maturityMonth INTEGER;
     v_maturityYear INTEGER;
     v_nowMonth INTEGER;
     v_to_date DATE;
     v_to_dateMonth INTEGER;
BEGIN

    -- Invoice data
    SELECT INTO v_invoiceInfo *
      FROM ONLY finReceivableInvoice
     WHERE invoiceId = p_invoiceid;

    -- Policy's invoice data
    SELECT INTO v_convenantinfo *
      FROM finConvenant
     WHERE convenantid = v_convenantid;
     
    v_numberDays := v_convenantinfo.daysToDiscount;

    IF v_convenantinfo.beforeAfter = 'A' THEN --Depois
    
        IF getParameter('FINANCE', 'DESCARTAR_DIA_31') = 'YES' 
        THEN		
            v_maturityMonth := EXTRACT(MONTH FROM v_invoiceInfo.referenceMaturityDate);
            v_maturityYear := EXTRACT(YEAR FROM v_invoiceInfo.referenceMaturityDate);
            v_nowMonth := EXTRACT(MONTH FROM v_invoiceInfo.referenceMaturityDate + v_numberDays);
            v_to_date := TO_DATE('31/' || v_maturityMonth || '/' || v_maturityYear, 'dd/mm/yyyy');
            v_to_dateMonth := EXTRACT(MONTH FROM v_to_date);

            IF ( (v_maturityMonth <> v_nowMonth) AND (v_maturityMonth = v_to_dateMonth) ) THEN
                v_numberDays := v_numberDays + 1;
            END IF;		
        END IF;

        --Caso for segunda feira desconta 1 dia extendendo o desconto de domingo
        IF getParameter('FINANCE', 'EXTENDER_DESCONTOS_NA_SEGUNDA') = 'YES'
        THEN
            IF ( EXTRACT('DOW' FROM (v_invoiceInfo.referenceMaturityDate::date+v_numberDays)) = 0 ) THEN
                v_numberDays := v_numberDays+1;
                RAISE NOTICE 'CONDICAO 1, NUMERO DE DIAS %', v_numberDays;
            END IF;
            IF ( EXTRACT('DOW' FROM (v_invoiceInfo.referenceMaturityDate::date+v_numberDays)) = 6 ) THEN
                v_numberDays := v_numberDays+2;
                RAISE NOTICE 'CONDICAO 2, NUMERO DE DIAS %', v_numberDays;
            END IF;
        END IF;
 END IF;

    RETURN v_numberDays;
END;
$$;


ALTER FUNCTION public.getdaystoconvenant(p_invoiceid integer, v_convenantid integer) OWNER TO solis;

--
-- Name: getdaystodiscount(integer, integer); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION getdaystodiscount(p_invoiceid integer, v_discountid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/**
* Obtém o número de dias a conceder desconto de um título.
**/
DECLARE
     v_calcNumberDays INTEGER;
     v_invoiceInfo RECORD;
     v_policyDiscountInfo RECORD;
     v_numberDays INTEGER;
     v_maturityMonth INTEGER;
     v_maturityYear INTEGER;
     v_nowMonth INTEGER;
     v_to_date DATE;
     v_to_dateMonth INTEGER;
BEGIN

    -- Invoice data
    SELECT INTO v_invoiceInfo *
      FROM ONLY finReceivableInvoice
     WHERE invoiceId = p_invoiceid;

    -- Policy's invoice data
    SELECT INTO v_policyDiscountInfo *
      FROM finPolicyDiscount
     WHERE discountid = v_discountid;
     
    v_numberDays := v_policyDiscountInfo.daysToDiscount;

    IF v_policyDiscountInfo.beforeAfter = 'A' THEN --Depois
    
        IF getParameter('FINANCE', 'DESCARTAR_DIA_31') = 'YES' 
        THEN		
            v_maturityMonth := EXTRACT(MONTH FROM v_invoiceInfo.referenceMaturityDate);
            v_maturityYear := EXTRACT(YEAR FROM v_invoiceInfo.referenceMaturityDate);
            v_nowMonth := EXTRACT(MONTH FROM v_invoiceInfo.referenceMaturityDate + v_numberDays);
            v_to_date := TO_DATE('31/' || v_maturityMonth || '/' || v_maturityYear, 'dd/mm/yyyy');
            v_to_dateMonth := EXTRACT(MONTH FROM v_to_date);

            IF ( (v_maturityMonth <> v_nowMonth) AND (v_maturityMonth = v_to_dateMonth) ) THEN
                v_numberDays := v_numberDays + 1;
            END IF;		
        END IF;

        --Caso for segunda feira desconta 1 dia extendendo o desconto de domingo
        IF getParameter('FINANCE', 'EXTENDER_DESCONTOS_NA_SEGUNDA') = 'YES'
        THEN
            IF ( EXTRACT('DOW' FROM (v_invoiceInfo.referenceMaturityDate::date+v_numberDays)) = 0 ) THEN
                v_numberDays := v_numberDays+1;
                RAISE NOTICE 'CONDICAO 1, NUMERO DE DIAS %', v_numberDays;
            END IF;
            IF ( EXTRACT('DOW' FROM (v_invoiceInfo.referenceMaturityDate::date+v_numberDays)) = 6 ) THEN
                v_numberDays := v_numberDays+2;
                RAISE NOTICE 'CONDICAO 2, NUMERO DE DIAS %', v_numberDays;
            END IF;
        END IF;
 END IF;

    RETURN v_numberDays;
END;
$$;


ALTER FUNCTION public.getdaystodiscount(p_invoiceid integer, v_discountid integer) OWNER TO solis;

--
-- Name: getdaystofines(integer); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION getdaystofines(p_invoiceid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$

/*********************************************************************************************
  NAME: getDaysToConvenant
  PURPOSE: Obtém o número de dias para aplicar multa de um título.
  DESCRIPTION: A função obtém o número de dias para aplicar multa levando em consideração
  os parâmetros DESCARTAR_DIA_31 e EXTENDER_DESCONTOS_NA_SEGUNDA

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       07/04/2014 Fabiano Tomasini        1. Função criada
*********************************************************************************************/


DECLARE
     v_calcNumberDays INTEGER;
     v_invoiceInfo RECORD;
     v_policy RECORD;
     v_numberDays INTEGER;
     v_maturityMonth INTEGER;
     v_maturityYear INTEGER;
     v_nowMonth INTEGER;
     v_to_date DATE;
     v_to_dateMonth INTEGER;
BEGIN

    -- Invoice data
    SELECT INTO v_invoiceInfo *
      FROM ONLY finReceivableInvoice
     WHERE invoiceId = p_invoiceid;

    -- Policy's invoice data
    SELECT INTO v_policy *
      FROM finPolicy
     WHERE policyid = v_invoiceInfo.policyid;
     
    v_numberDays := v_policy.daystofine;

    IF getParameter('FINANCE', 'DESCARTAR_DIA_31') = 'YES' 
    THEN		
        v_maturityMonth := EXTRACT(MONTH FROM v_invoiceInfo.referenceMaturityDate);
        v_maturityYear := EXTRACT(YEAR FROM v_invoiceInfo.referenceMaturityDate);
        v_nowMonth := EXTRACT(MONTH FROM v_invoiceInfo.referenceMaturityDate + v_numberDays);
        v_to_date := TO_DATE('31/' || v_maturityMonth || '/' || v_maturityYear, 'dd/mm/yyyy');
        v_to_dateMonth := EXTRACT(MONTH FROM v_to_date);

        IF ( (v_maturityMonth <> v_nowMonth) AND (v_maturityMonth = v_to_dateMonth) ) THEN
            v_numberDays := v_numberDays + 1;
        END IF;
    END IF;		

    --Caso for segunda feira desconta 1 dia extendendo o desconto de domingo
    IF getParameter('FINANCE', 'EXTENDER_DESCONTOS_NA_SEGUNDA') = 'YES'
    THEN
        IF ( EXTRACT('DOW' FROM (v_invoiceInfo.referenceMaturityDate::date+v_numberDays)) = 0 ) THEN
            v_numberDays := v_numberDays+1;
            RAISE NOTICE 'CONDICAO 1, NUMERO DE DIAS %', v_numberDays;
        END IF;
        IF ( EXTRACT('DOW' FROM (v_invoiceInfo.referenceMaturityDate::date+v_numberDays)) = 6 ) THEN
            v_numberDays := v_numberDays+2;
            RAISE NOTICE 'CONDICAO 2, NUMERO DE DIAS %', v_numberDays;
        END IF;
    END IF;
    RETURN v_numberDays;
END;
$$;


ALTER FUNCTION public.getdaystofines(p_invoiceid integer) OWNER TO solis;

--
-- Name: getdegreeenrollcurrentgrade(integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION getdegreeenrollcurrentgrade(p_degreeid integer, p_enrollid integer, p_ishistory boolean) RETURNS SETOF typedegreeenrollcurrentgrade
    LANGUAGE plpgsql
    AS $$
DECLARE
v_row RECORD;
v_sql TEXT;
v_orderby TEXT;
v_limitsql TEXT;
BEGIN
v_limitsql := '';

IF p_ishistory IS TRUE
THEN
v_orderby = ' ORDER BY DE.recorddate DESC ';
ELSE
-- Se parametro estiver ativado, ordena pela nota mais alta, senao, pela ultima
IF GETPARAMETER('ACADEMIC', 'CONSIDER_HIGHER_PUNCTUATION_DEGREE') = 't'
THEN
    v_orderby := ' AND recorddate > (SELECT CASE WHEN (
                                         SELECT recorddate FROM acddegreeenroll 
                                         WHERE enrollid = DE.enrollid AND degreeid = DE.degreeid AND note IS NULL 
                                         ORDER BY recorddate DESC LIMIT 1) IS NULL THEN ''2000-01-01''::timestamp ELSE
                                         (SELECT recorddate FROM acddegreeenroll 
                                         WHERE enrollid = DE.enrollid AND degreeid = DE.degreeid AND note IS NULL 
                                         ORDER BY recorddate DESC LIMIT 1)
                                         END) ORDER BY DE.note DESC ';
ELSE
    v_orderby := ' ORDER BY DE.recordDate DESC ';
END IF;

v_limitsql := ' LIMIT 1 ';
END IF;

v_sql := 'SELECT (CASE WHEN (SELECT G.useConcept
                    FROM acdEnroll E
            INNER JOIN acdgroup G
                    ON E.groupId = G.groupId
                    WHERE E.enrollId = DE.enrollId) IS TRUE
            THEN
                DE.concept
            ELSE
                ROUND(DE.note::numeric, GETPARAMETER(''BASIC'', ''GRADE_ROUND_VALUE'')::int)::varchar
            END) AS nota,

            DE.description,                    
            timestamptouser(DE.recordDate) AS recorddate,
            DE.username
    FROM acdDegreeEnroll DE
    WHERE DE.degreeId = ' || p_degreeId || '
        AND DE.enrollId = ' || p_enrollId || v_orderby || v_limitsql;

-- Prevencao de erros
IF p_degreeId IS NULL OR p_enrollId IS NULL
THEN
RETURN;
END IF;

RETURN QUERY EXECUTE v_sql;
END; 
$$;


ALTER FUNCTION public.getdegreeenrollcurrentgrade(p_degreeid integer, p_enrollid integer, p_ishistory boolean) OWNER TO solis;

--
-- Name: getdirectionhours(bigint, date, date, character varying, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getdirectionhours(p_professorid bigint, p_begindate date, p_enddate date, p_courseid character varying, p_courseversion integer, p_turnid integer, p_unitid integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: getDirectionHours
  PURPOSE: Obtém o total de horas de orientação do professor no peréodo especificado.
  A ocorréncia de curso pode ser nula.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       24/06/2011 Alexandre Schmidt 1. FUNÇÃO criada.
  1.1       10/08/2011 Alex Smith        1. Ajuste para permitir orientação de mais de
                                         uma disciplina.
**************************************************************************************/
DECLARE
    v_retVal float;
BEGIN
    SELECT SUM(A.directionWorkLoad) INTO v_retVal
      FROM acdFinalExaminationDirectors A
INNER JOIN acdEnroll B
        ON B.enrollId = A.enrollId
INNER JOIN acdGroup C
        ON C.groupId = B.groupId
INNER JOIN acdCurriculum D
        ON D.curriculumId = C.curriculumId
INNER JOIN acdLearningPeriod E
        ON E.learningPeriodId = C.learningPeriodId
     WHERE A.personId = p_professorId
       AND E.beginDate <= p_endDate
       AND E.endDate >= p_beginDate
       AND D.courseId = COALESCE(p_courseId, D.courseId)
       AND D.courseVersion = COALESCE(p_courseVersion, D.courseVersion)
       AND D.turnId = COALESCE(p_turnId, D.turnId)
       AND D.unitId = COALESCE(p_unitId, D.unitId);

    RETURN COALESCE(v_retVal, 0);
END;
$$;


ALTER FUNCTION public.getdirectionhours(p_professorid bigint, p_begindate date, p_enddate date, p_courseid character varying, p_courseversion integer, p_turnid integer, p_unitid integer) OWNER TO postgres;

--
-- Name: getdisaprovedcurriculumids(integer); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION getdisaprovedcurriculumids(p_contractid integer) RETURNS SETOF integer
    LANGUAGE plpgsql
    AS $$
/*********************************************************************************************
   NAME: getdisaprovedcurriculumids
   PURPOSE: Busca todas discplinas reprovadas do contrato.

REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       xx/xx/xxxx xxxxxxxxx         1. FUNÇÂO criada.
  1.1       04/02/2013 Samuel Koch       1. Correção na lógica que verifica se o contrato é
                                            de um calouro ou veterano.
  1.2       05/02/2013 Samuel Koch       1. Correção no recálculo das mensalidades.
  1.3       26/02/2013 Samuel Koch       1. Alteração na regra quando o aluno se matricula em
                                            dependência do tipo prática. Caso a disciplina tenha
                                            alguma hora prática considerar 100% prática.
  1.4       02/03/2013 Samuel Koch       1. Alteração para separar as disciplinas que o aluno
                                            irá cursar em outros semestres
*********************************************************************************************/
DECLARE
BEGIN
    RETURN QUERY ( SELECT A.curriculumId
                     FROM acdCurriculum A
               INNER JOIN acdCurricularComponent C
                       ON (C.curricularComponentId = A.curricularComponentId
                      AND C.curricularComponentVersion = A.curricularComponentVersion)
                    WHERE A.curriculumid IN ( SELECT curriculumid
                                                FROM acdEnroll X
                                               WHERE X.contractId = p_contractid
                                                 AND X.curriculumId = A.curriculumId
                                                 AND X.statusId::varchar = ANY(STRING_TO_ARRAY(GETPARAMETER('ACADEMIC', 'ENROLL_STATUS_DISAPPROVED'), ',')))
                 ORDER BY A.curricularComponentId || '' || A.curricularComponentVersion || '' || C.name );
END
$$;


ALTER FUNCTION public.getdisaprovedcurriculumids(p_contractid integer) OWNER TO solis;

--
-- Name: getemail(bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getemail(personid bigint) RETURNS character varying
    LANGUAGE sql
    AS $_$
  SELECT lower(email) FROM ONLY basPerson WHERE personId = $1 
$_$;


ALTER FUNCTION public.getemail(personid bigint) OWNER TO postgres;

--
-- Name: getexamnote(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getexamnote(integer, integer) RETURNS double precision
    LANGUAGE sql
    AS $_$
   SELECT note 
FROM ONLY sprNote
    WHERE inscriptionId = $1
      AND examOccurrenceId = $2
$_$;


ALTER FUNCTION public.getexamnote(integer, integer) OWNER TO postgres;

--
-- Name: getfatherid(bigint); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION getfatherid(bigint) RETURNS bigint
    LANGUAGE sql
    AS $_$
    SELECT X.relativePersonId::bigint
      FROM basPhysicalPersonKinship X
     WHERE X.personId = $1
       AND X.kinshipId = (SELECT value::integer
                            FROM basConfig
                           WHERE parameter = 'FATHER_KINSHIP_ID'
                             AND moduleConfig = 'BASIC');
$_$;


ALTER FUNCTION public.getfatherid(bigint) OWNER TO solis;

--
-- Name: gethoursavailableforenroll(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gethoursavailableforenroll(p_contractid integer, p_learningperiodid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: getTotalCredits
  PURPOSE: Obtém o valor total de horas disponíveis para o aluno se matricular

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       04/03/2013 Jonas Diel    1. FUNÇÂO criada.
**************************************************************************************/
DECLARE

BEGIN
    RETURN sum(C.academicnumberhours)
                      FROM acdcurriculum A
                INNER JOIN acdContract B
                        ON (B.courseId = A.courseId
                            AND B.courseVersion = A.courseVersion)
                INNER JOIN acdCurricularComponent C
                        ON (C.curricularComponentId = A.curricularComponentId
                            AND C.curricularComponentVersion = A.curricularComponentVersion)
                INNER JOIN acdGroup D
                        ON (D.curriculumId = A.curriculumId)
                INNER JOIN acdlearningperiod E
                        ON E.learningPeriodId = D.learningPeriodId
                INNER JOIN basTurn F
                        ON F.turnId = B.turnId
                INNER JOIN basUnit G
                        ON G.unitId = B.unitId
                INNER JOIN acdRegimen H
                        ON H.regimenId = D.regimenId
                INNER JOIN acdclass K
                        ON K.classId = D.classId
                     WHERE B.contractId = p_contractId
                       AND D.classId = getContractClassId(p_contractId)
                       AND NOT E.isClosed
                       AND E.periodId IN (SELECT periodId FROM acdlearningperiod WHERE learningPeriodId = p_learningPeriodId)
                       AND D.regimenId <> GETPARAMETER('ACADEMIC', 'REGIME_DE_FERIAS')::INTEGER;
END
$$;


ALTER FUNCTION public.gethoursavailableforenroll(p_contractid integer, p_learningperiodid integer) OWNER TO postgres;

--
-- Name: gethoursavailableforenroll(integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION gethoursavailableforenroll(p_contractid integer, p_classid character varying, p_learningperiodid integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
/*********************************************************************************************
  NAME: getHoursAvailableForEnroll
  PURPOSE: Obtem carga horaria do periodo
*********************************************************************************************/
DECLARE
BEGIN
    RETURN (SELECT SUM(C.academicNumberHours)
                      FROM acdCurriculum A
                INNER JOIN acdContract B
                        ON (B.courseId = A.courseId
                            AND B.courseVersion = A.courseVersion)
                INNER JOIN acdCurricularComponent C
                        ON (C.curricularComponentId = A.curricularComponentId
                            AND C.curricularComponentVersion = A.curricularComponentVersion)
                INNER JOIN acdGroup D
                        ON (D.curriculumId = A.curriculumId)
                INNER JOIN acdLearningPeriod E
                        ON E.learningPeriodId = D.learningPeriodId
                INNER JOIN basTurn F
                        ON F.turnId = B.turnId
                INNER JOIN basUnit G
                        ON G.unitId = B.unitId
                INNER JOIN acdRegimen H
                        ON H.regimenId = D.regimenId
                INNER JOIN acdClass K
                        ON K.classId = D.classId
                     WHERE B.contractId = p_contractid
                       AND D.classId = p_classid
                       AND NOT E.isClosed
                       AND E.periodId IN (SELECT periodId FROM acdLearningPeriod WHERE learningPeriodId = p_learningperiodid)
                       AND D.regimenId != GETPARAMETER('ACADEMIC', 'REGIME_DE_FERIAS')::integer
    );
END
$$;


ALTER FUNCTION public.gethoursavailableforenroll(p_contractid integer, p_classid character varying, p_learningperiodid integer) OWNER TO solis;

--
-- Name: getincomesourcedescription(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getincomesourcedescription(integer) RETURNS character varying
    LANGUAGE sql
    AS $_$
 SELECT description 
   FROM finIncomeSource
  WHERE incomeSourceId = $1 $_$;


ALTER FUNCTION public.getincomesourcedescription(integer) OWNER TO postgres;

--
-- Name: getinternalexternalactivitiesprogrammedhours(bigint, date, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getinternalexternalactivitiesprogrammedhours(p_professorid bigint, p_begindate date, p_enddate date) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: getInternalExternalActivitiesProgrammedHours
  PURPOSE: Obtém o total de horas alocadas para atividades internas ou externas no
  peréodo especificado

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       24/06/2011 Alexandre Schmidt 1. FUNÇÃO criada.
**************************************************************************************/
DECLARE
    v_retVal float;
BEGIN
    SELECT EXTRACT(DAY FROM totalTime) * 24 +
           EXTRACT(HOUR FROM totalTime) +
           EXTRACT(MINUTE FROM totalTime) / 60 +
           EXTRACT(SECOND FROM totalTime) / (60 * 60) INTO v_retVal
      FROM (SELECT SUM(A.endDate - A.startDate) AS totalTime
              FROM hur.scheduledActivity A
             WHERE (A.startDate BETWEEN p_beginDate
                                    AND p_endDate
                    OR A.endDate BETWEEN p_beginDate
                                    AND p_endDate)
               AND EXISTS (SELECT 'x'
                             FROM hur.scheduledActivityParticipant X
                            WHERE X.scheduledActivityId = A.scheduledActivityId
                              AND X.personId = p_professorId)) A;

    RETURN COALESCE(v_retVal, 0);
END;
$$;


ALTER FUNCTION public.getinternalexternalactivitiesprogrammedhours(p_professorid bigint, p_begindate date, p_enddate date) OWNER TO postgres;

--
-- Name: getinternalexternalactivitiesrealizedhours(bigint, date, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getinternalexternalactivitiesrealizedhours(p_professorid bigint, p_begindate date, p_enddate date) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: getInternalExternalActivitiesRealizedHours
  PURPOSE: Obtém o total de horas alocadas realizadas em atividades internas ou
  externas no peréodo especificado

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       24/06/2011 Alexandre Schmidt 1. FUNÇÃO criada.
**************************************************************************************/
DECLARE
    v_retVal float;
BEGIN
    SELECT EXTRACT(DAY FROM totalTime) * 24 +
           EXTRACT(HOUR FROM totalTime) +
           EXTRACT(MINUTE FROM totalTime) / 60 +
           EXTRACT(SECOND FROM totalTime) / (60 * 60) INTO v_retVal
      FROM (SELECT SUM(A.endDate - A.startDate) AS totalTime
              FROM hur.realizedActivity A
             WHERE (A.startDate BETWEEN p_beginDate
                                    AND p_endDate
                    OR A.endDate BETWEEN p_beginDate
                                    AND p_endDate)
               AND EXISTS (SELECT 'x'
                             FROM hur.realizedActivityParticipant X
                            WHERE X.realizedActivityId = A.realizedActivityId
                              AND X.personId = p_professorId)) A;

    RETURN COALESCE(v_retVal, 0);
END;
$$;


ALTER FUNCTION public.getinternalexternalactivitiesrealizedhours(p_professorid bigint, p_begindate date, p_enddate date) OWNER TO postgres;

--
-- Name: getinvoicecontract(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getinvoicecontract(p_invoiceid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: getInvoiceContract
  PURPOSE: Obtem o contrato de um titulo
**************************************************************************************/
BEGIN
    RETURN (SELECT contractId
              FROM finEntry
             WHERE invoiceId = p_invoiceId
               AND contractId IS NOT NULL
          ORDER BY entryId
        DESC LIMIT 1);
END;
$$;


ALTER FUNCTION public.getinvoicecontract(p_invoiceid integer) OWNER TO postgres;

--
-- Name: getinvoiceconvenants(integer, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getinvoiceconvenants(p_invoiceid integer, p_date date) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: getInvoiceConvenants
  PURPOSE: Obtém os convênios a serem aplicados em um título
  DESCRIPTION: vide "PURPOSE".

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       07/12/2010 Leovan            1. FUNÇÃO criada.
  1.1       16/04/2012 Moises            1. Alterado calculo de convenios
  1.2       04/06/2012 Jonas Diel        1. Altera calculo de convenios no balance
  1.3       07/11/2012 Jonas Diel        1. Adicionada regra da data de ocorrencia
                                            para finais de semana (ENABLE_BUSINESS_USER = 1)
  1.4       23/11/2012 Jonas Diel        1. Ajustes para calcular convênios somente
                                         para lançamentos com opção 
                                         'Considerar em descontos' habilitada
**************************************************************************************/
DECLARE
    v_invoice RECORD;
    v_release RECORD;
    v_convenant RECORD;
    v_convenantCursor refcursor;
    v_numberDays INTEGER;
    v_select TEXT;
    v_applyConvenant BOOLEAN;
    v_balanceValue NUMERIC;
    v_decimals INTEGER;
    v_maturityMonth INTEGER;
    v_maturityYear INTEGER;
    v_nowMonth INTEGER;
    v_to_date DATE;
    v_to_dateMonth INTEGER;
    v_referenceMaturityDate DATE;
    v_calcNumberDays INTEGER;
    v_date DATE;
BEGIN
    v_date := p_date;
    v_applyConvenant := FALSE;
    IF getParameter('BASIC', 'ENABLE_BUSINESS_USER') = '1'
    THEN
        --Se a data de pagamento for numa segunda-feira é sinal que pode ter sido pago no final de semana no boleto
        IF ( EXTRACT('DOW' FROM p_date::date) = 1 ) THEN 
            v_date := p_date - interval '2 day';
        END IF;
    END IF;

    v_balanceValue := getBalanceDiscounts(p_invoiceid) - getinvoicediscountvalue(p_invoiceid, v_date);

    SELECT INTO v_decimals value::integer FROM basConfig WHERE parameter LIKE 'REAL_ROUND_VALUE';
    
    -- Dados do título
    SELECT INTO v_invoice * FROM ONLY finReceivableInvoice WHERE invoiceId = p_invoiceId;

    -- Verifica se há liberação de convênios - finRelease
    FOR v_release IN SELECT * FROM finrelease WHERE invoiceid = p_invoiceid AND v_date BETWEEN begindate AND enddate
    LOOP
        IF v_release.applyconvenant = TRUE THEN v_applyConvenant := TRUE; END IF;
    END LOOP;

    v_referenceMaturityDate := v_invoice.referenceMaturityDate::date;
    v_calcNumberDays := 0;

    IF getParameter('BASIC', 'ENABLE_BUSINESS_USER') = '1'
    THEN
        IF ( EXTRACT('DOW' FROM v_referenceMaturityDate) = 6 ) THEN
            v_referenceMaturityDate := v_referenceMaturityDate + '2 days'::interval;
            v_calcNumberDays := 2;
        ELSEIF ( EXTRACT('DOW' FROM v_referenceMaturityDate) = 0 ) THEN
            v_referenceMaturityDate := v_referenceMaturityDate + '1 day'::interval;
            v_calcNumberDays := 1;
        END IF;
    END IF;

    -- Busca os convênios a serem aplicados
    v_select := 'SELECT B.convenantid,
                        B.description,

                        -- Trata para casos onde foi definido um contrato especifico para o convenio da pessoa
                        (CASE WHEN
                             ( E.contractId IS NOT NULL
                                AND A.contractId IS NOT NULL
                                AND A.contractId = E.contractId )
                          OR ( A.contractId IS NULL )
                         THEN
                             ROUND(B.value::numeric, ' || v_decimals || ')
                         ELSE
                             0::numeric
                         END) AS value,

                        B.ispercent,
                        B.convenantOperation
                   FROM finconvenantperson A
             INNER JOIN finconvenant B
                     ON (B.convenantid = A.convenantid)
        INNER JOIN ONLY finInvoice I
                     ON (I.invoiceId = ' || p_invoiceId || ')
              LEFT JOIN finEntry E
                     ON ( E.entryId = ( SELECT MIN(entryId) FROM finEntry WHERE invoiceId = ' || p_invoiceId || ' AND contractId IS NOT NULL ) )                     
                  WHERE A.personid = ' || v_invoice.personid || '
AND CASE WHEN A.enddate IS NOT NULL THEN ''' || v_invoice.referencematuritydate || ''' BETWEEN A.begindate AND A.enddate ELSE ''' || v_invoice.referencematuritydate || ''' >= A.begindate END';

    IF v_select IS NOT NULL THEN
    BEGIN
    -- Se há liberação, pega todos os convênios ativos
    IF v_applyConvenant = TRUE THEN
        OPEN v_convenantCursor FOR EXECUTE v_select;
    ELSE
        -- Se a data é menor que o vencimento, verifica a aplicação dos convênios que vencem antes do vencimento
        IF v_date <= v_invoice.referenceMaturityDate THEN
            v_numberDays := v_invoice.referenceMaturityDate::date - v_date::date;

            v_select := v_select || ' AND ((B.beforeafter LIKE ''B'' AND B.daystodiscount <= ' || v_numberDays || ')
                                       OR B.beforeafter LIKE ''A'')';
        ELSE
            -- Se a data é maior que o vencimento, verifica a aplicação dos convênios que vencem depois do vencimento

            IF getParameter('FINANCE', 'DESCARTAR_DIA_31') = 'YES' THEN
                v_numberDays := p_date::date - v_referenceMaturityDate;
                v_numberDays := v_numberDays - v_calcNumberDays;

                v_maturityMonth := EXTRACT(MONTH FROM v_referenceMaturityDate);
                v_maturityYear := EXTRACT(YEAR FROM v_referenceMaturityDate);
                v_nowMonth := EXTRACT(MONTH FROM p_date::date);
                v_to_date := TO_DATE('31/' || v_maturityMonth || '/' || v_maturityYear, 'dd/mm/yyyy');
                v_to_dateMonth := EXTRACT(MONTH FROM v_to_date);

                IF ( (v_maturityMonth <> v_nowMonth) AND (v_maturityMonth = v_to_dateMonth) ) THEN
                    v_numberDays := v_numberDays - 1;
                END IF;
            ELSE
                v_numberDays := v_date::date - v_invoice.referenceMaturityDate::date;
            END IF;

            --Caso for segunda feira desconta 1 dia extendendo o desconto de domingo
            IF getParameter('FINANCE', 'EXTENDER_DESCONTOS_NA_SEGUNDA') = 'YES'
            THEN
                IF ( EXTRACT('DOW' FROM (v_referenceMaturityDate+v_numberDays)) = 1 ) THEN
                    v_numberDays := v_numberDays-1;
                END IF;
            END IF;

            v_select := v_select || ' AND B.beforeafter LIKE ''A'' AND B.daystodiscount >= ' || v_numberDays;
        END IF;

        OPEN v_convenantCursor FOR EXECUTE v_select;
    END IF;

    LOOP
        FETCH v_convenantCursor INTO v_convenant;

        IF NOT FOUND THEN
            EXIT;
        END IF;

        IF v_convenant.ispercent = TRUE THEN
            v_convenant.value := v_balanceValue * v_convenant.value/100;
        END IF;

        v_convenant.value := ROUND(v_convenant.value, v_decimals);

        RETURN NEXT v_convenant;
    END LOOP;

    CLOSE v_convenantCursor;
    END;
    END IF;

    RETURN;
END;
$$;


ALTER FUNCTION public.getinvoiceconvenants(p_invoiceid integer, p_date date) OWNER TO postgres;

--
-- Name: getinvoiceconvenantvalue(integer, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getinvoiceconvenantvalue(p_invoiceid integer, p_date date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: getInvoiceConvenantValue
  PURPOSE: Obtém o valor total de convê­nios a ser descontado de um título
  DESCRIPTION: vide "PURPOSE".

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       07/12/2010 Leovan            1. FUNÇÃO criada.
  1.1       23/11/2012 Jonas Diel        1. Ajustes para calcular convê­nios somente
                                         para lançamentos com opção 
                                         'Considerar em descontos' habilitada
  1.2       01/11/2013 Nataniel          1. Verifica se a pessoa está inadimplente e
                                         se o convênio está no paramêtro de verificação 
                                         e cancelamento do convênio.
**************************************************************************************/
DECLARE
    v_convenant RECORD;
    v_convenantValue NUMERIC;
    v_balance NUMERIC;
    v_personid INT;
    v_parcel_number NUMERIC;
BEGIN
    v_convenantValue := 0;
    v_balance := getBalanceDiscounts(p_invoiceId);

    SELECT INTO v_personid
		personid
      FROM ONLY finInvoice
          WHERE invoiceid = p_invoiceId;

    FOR v_convenant IN SELECT * FROM getinvoiceconvenants(p_invoiceid, p_date) AS convenant(convenantid integer, description text, value numeric, ispercent boolean, convenantoperation int)
    LOOP
        IF ( ( SELECT isDefaulter(v_personid)) = 't' AND
	       v_convenant.convenantId::TEXT IN ( select regexp_split_to_table(getParameter('FINANCE','CODIGO_CONVENIO_PARA_VERIFICACAO_DE_INADIMPLENCIA'), E'\\,')) )
        THEN
           UPDATE finconvenantperson SET observacao = 'CONVÊNIO CANCELADO POR INADIMPLÊNCIA', enddate = now()::date WHERE convenantId = v_convenant.convenantId; 
        ELSE
            v_convenantValue := v_convenantValue + v_convenant.value;
        END IF;
    END LOOP;

    IF v_convenantValue > v_balance THEN v_convenantValue := v_balance; END IF;
    
    SELECT INTO v_parcel_number
		parcelnumber
      FROM ONLY finInvoice
          WHERE invoiceid = p_invoiceId;

    IF v_parcel_number = 0 THEN
        RETURN 0;
    END IF;

    RETURN v_convenantValue;
END;
$$;


ALTER FUNCTION public.getinvoiceconvenantvalue(p_invoiceid integer, p_date date) OWNER TO postgres;

--
-- Name: getinvoicediscountvalue(integer, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getinvoicediscountvalue(p_invoiceid integer, p_date date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: getInvoiceDiscountValue
  PURPOSE: Calcula os descontos que um título teria, se baixado na data p_date.
  DESCRIPTION: vide "PURPOSE".

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       30/11/2010 AlexSmith         1. FUNÇÃO criada.
  1.1       06/12/2010 Leovan            1. Considerar descontos avulsos concedidos para o aluno
  1.2       14/06/2012 Jonas e Leovan    1. Alteração no balance.
  1.3       17/10/2012 Samuel Koch       1. Se o saldo for 0 (zero) retorna 0 (zero) não
                                            calculando a existência de descontos
**************************************************************************************/
DECLARE
    v_policyInfo RECORD;
    v_invoiceInfo RECORD;
    v_policyDiscountInfo finPolicyDiscount%ROWTYPE;
    v_release RECORD;
    v_releaseValue NUMERIC;
    v_discountValue NUMERIC;
    v_balanceValue NUMERIC;
    v_balance NUMERIC;
    v_numberDays INTEGER;   
    v_applyDiscounts BOOLEAN;
    v_date DATE;
    v_maturityMonth INTEGER;
    v_maturityYear INTEGER;
    v_maturityDay INTEGER;
    v_nowMonth INTEGER;  
    v_to_date DATE;
    v_to_dateMonth INTEGER;
    v_hasFinancialAid BOOLEAN;
    v_referenceMaturityDate DATE;
    v_calcNumberDays INTEGER;
BEGIN
    v_discountValue := 0;
    v_releaseValue := 0;

    v_balance := balance(p_invoiceid);
    IF v_balance = 0 THEN
        RETURN 0;
    END IF;

    v_balanceValue := getBalanceDiscounts(p_invoiceid);
    v_date := p_date;
    --Caso o título possuir um lançamento que seu tipo de incentivo (incentivetypeid) nao aplique descontos (finincentivetype.applydiscounts) retorna o desconto como 0
    v_applyDiscounts := FALSE;
    SELECT INTO v_applyDiscounts COUNT(*) > 0
      FROM finEntry E
INNER JOIN finIncentiveType I
        ON E.incentivetypeid = I.incentivetypeid
     WHERE E.invoiceId = p_invoiceid AND I.applydiscounts = 'f';

    IF v_applyDiscounts THEN
    RETURN 0;
    END IF;

    -- Invoice data
    SELECT INTO v_invoiceInfo *
      FROM ONLY finReceivableInvoice
     WHERE invoiceId = p_invoiceid;

    IF v_invoiceInfo.parcelnumber = 0 THEN
        RETURN 0;
    END IF;

    -- Policy's invoice data
    SELECT INTO v_policyInfo *
      FROM finPolicy
     WHERE policyId = v_invoiceInfo.policyId;

    v_referenceMaturityDate := v_invoiceInfo.referenceMaturityDate::date;
    v_calcNumberDays := 0;

    --Antes do vencimento
    IF v_date <= v_invoiceInfo.referenceMaturityDate::date THEN
        v_numberDays := v_invoiceInfo.referenceMaturityDate::date - v_date::date;

        --Obtem o primeiro desconto para dias antes do vencimento que seja menor que o numero de dias
        SELECT INTO v_policyDiscountInfo *
          FROM finPolicyDiscount
         WHERE beforeafter LIKE 'B'
           AND daystodiscount <= v_numberDays
           AND policyId = v_policyInfo.policyId
      ORDER BY daystodiscount DESC
         LIMIT 1;

        --Se nao ha configuracao para descontos antes do vencimento, obtem o primeiro desconto depois do vencimento
        IF v_policyDiscountInfo IS NULL THEN
            SELECT INTO v_policyDiscountInfo *
              FROM finPolicyDiscount
             WHERE beforeafter LIKE 'A'
               AND policyId = v_policyInfo.policyId
          ORDER BY daystodiscount
             LIMIT 1;
        END IF;
    --Depois do vencimento

    ELSE
        IF v_date > v_invoiceInfo.maturityDate THEN

            IF getParameter('FINANCE', 'DESCARTAR_DIA_31') = 'YES' THEN
                v_numberDays := p_date::date - v_referenceMaturityDate;
                --v_numberDays := v_numberDays - v_calcNumberDays;

                v_maturityMonth := EXTRACT(MONTH FROM v_referenceMaturityDate);
                v_maturityYear := EXTRACT(YEAR FROM v_referenceMaturityDate);
                v_nowMonth := EXTRACT(MONTH FROM p_date::date);
                v_to_date := TO_DATE('31/' || v_maturityMonth || '/' || v_maturityYear, 'dd/mm/yyyy');
                v_to_dateMonth := EXTRACT(MONTH FROM v_to_date);

                IF ( (v_maturityMonth <> v_nowMonth) AND (v_maturityMonth = v_to_dateMonth) ) THEN
                    v_numberDays := v_numberDays - 1;
                    RAISE NOTICE 'É DIA 31, NUMERO DE DIAS %', v_numberDays;

                END IF;
            ELSE
                v_numberDays := v_date::date - v_invoiceInfo.referenceMaturityDate::date;
            END IF;

            --Caso for segunda feira desconta 1 dia extendendo o desconto de domingo
            IF getParameter('FINANCE', 'EXTENDER_DESCONTOS_NA_SEGUNDA') = 'YES'
            THEN
                IF ( EXTRACT('DOW' FROM (v_invoiceInfo.referenceMaturityDate::date+v_numberDays)) = 0 ) THEN
                    v_numberDays := v_numberDays - 1;
                    RAISE NOTICE 'CONDICAO 1, NUMERO DE DIAS %', v_numberDays;
                END IF;
                IF ( EXTRACT('DOW' FROM (v_invoiceInfo.referenceMaturityDate::date+v_numberDays)) = 6 ) THEN
                    v_numberDays := v_numberDays - 2;
                    RAISE NOTICE 'CONDICAO 2, NUMERO DE DIAS %', v_numberDays;
                END IF;
            END IF;

            --Obtem o primeiro desconto para depois do vencimento
            SELECT INTO v_policyDiscountInfo *
              FROM finPolicyDiscount
             WHERE beforeafter = 'A'
               AND getDaysToDiscount(p_invoiceid, discountId) >= v_numberDays
               AND policyId = v_policyInfo.policyId
          ORDER BY daystodiscount
             LIMIT 1;
        END IF;
    END IF;
    
    IF v_policyDiscountInfo.discountValue > 0 THEN
        IF v_policyDiscountInfo.isPercent = TRUE THEN
            v_discountValue := v_balanceValue*(v_policyDiscountInfo.discountValue/100);
        ELSE
            v_discountValue := v_policyDiscountInfo.discountValue;
        END IF;
    END IF;

    --Descontos concedidos - finRelease
    FOR v_release IN SELECT discountValue, isPercent
                       FROM finRelease
                      WHERE invoiceid = p_invoiceId
                        AND v_date BETWEEN beginDate AND endDate
    LOOP
        IF v_release.discountValue > 0 THEN
            IF v_release.isPercent = TRUE THEN
                v_releaseValue := v_releaseValue + (v_balanceValue - v_discountValue) * (v_release.discountValue/100);
            ELSE
                v_releaseValue := v_releaseValue + v_release.discountValue;
            END IF;
        END IF;
    END LOOP;

    IF (v_discountValue + v_releaseValue) > v_balanceValue THEN
        RETURN v_balanceValue;
    ELSE
        RETURN (v_discountValue + v_releaseValue);
    END IF;
END;
$$;


ALTER FUNCTION public.getinvoicediscountvalue(p_invoiceid integer, p_date date) OWNER TO postgres;

--
-- Name: getinvoicefinevalue(integer, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getinvoicefinevalue(p_invoiceid integer, p_date date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: getInvoiceFineValue
  PURPOSE: Calcula o valor referente a multas para um título, se fosse baixado em p_date.
  DESCRIPTION: vide "PURPOSE".

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       30/11/2010 AlexSmith         1. FUNÇÃO criada.
  1.1       06/12/2010 Leovan            1. Considerar liberações de juro e multa
  1.2       14/06/2012 Jonas e Leovan    1. Alteração no balance.
  1.3       07/11/2012 Jonas Diel        1. Adicionada regra da data de ocorrencia
                                            para finais de semana (ENABLE_BUSINESS_USER = 1)
**************************************************************************************/
DECLARE
    v_policyInfo RECORD;
    v_invoiceInfo RECORD;
    v_release BOOLEAN;
    v_fineValue NUMERIC;
    v_balanceValue NUMERIC;
    v_date DATE;
    v_maturityMonth INTEGER;
    v_maturityYear INTEGER;
    v_nowMonth INTEGER;  
    v_to_date DATE;
    v_to_dateMonth INTEGER;
    v_index INTEGER;
    v_referenceDate DATE;
BEGIN
    v_fineValue = 0;
    v_date := p_date;

    -- Invoice data
    SELECT INTO v_invoiceInfo *
      FROM ONLY finReceivableInvoice
     WHERE invoiceId = p_invoiceId;

    --Release data
    FOR v_release IN SELECT releaseInterest
                       FROM finRelease
                      WHERE invoiceid = p_invoiceId
                        AND v_date BETWEEN beginDate AND endDate
    LOOP
        IF v_release = true THEN RETURN 0; END IF;
    END LOOP;

    -- Policy's invoice data
    SELECT INTO v_policyInfo *
      FROM finPolicy
     WHERE policyId = v_invoiceInfo.policyId;

    SELECT INTO v_balanceValue *
      FROM getBalanceFines(p_invoiceId);

    IF getParameter('FINANCE', 'DESCARTAR_DIA_31') = 'YES' THEN
        v_maturityMonth := EXTRACT(MONTH FROM v_invoiceInfo.referenceMaturityDate::date);
        v_maturityYear := EXTRACT(YEAR FROM v_invoiceInfo.referenceMaturityDate::date);
        v_nowMonth := EXTRACT(MONTH FROM p_date::date);
        v_to_date := TO_DATE('31/' || v_maturityMonth || '/' || v_maturityYear, 'dd/mm/yyyy');
        v_to_dateMonth := EXTRACT(MONTH FROM v_to_date);

        v_index = 0;

        IF ( (v_maturityMonth <> v_nowMonth) AND (v_maturityMonth = v_to_dateMonth) ) THEN
            v_index := 1;
        END IF;

        v_referenceDate := ((v_index||' days')::interval+v_invoiceInfo.referenceMaturityDate+(v_policyInfo.daysToFine||' days')::interval)::date;

    ELSE
        v_referenceDate := (v_invoiceInfo.referenceMaturityDate+(v_policyInfo.daysToFine||' days')::interval)::date;
    END IF;

    IF getParameter('BASIC', 'ENABLE_BUSINESS_USER') = '1'
    THEN
        IF ( EXTRACT('DOW' FROM v_referenceDate) = 6 ) THEN
            v_referenceDate := v_referenceDate+'2 DAYS'::interval;
        ELSEIF ( EXTRACT('DOW' FROM v_referenceDate) = 0 ) THEN    
            v_referenceDate := v_referenceDate+'1 DAY'::interval;
        END IF;
    END IF;

    --Caso for segunda feira desconta 1 dia extendendo o desconto de domingo
    IF getParameter('FINANCE', 'EXTENDER_DESCONTOS_NA_SEGUNDA') = 'YES'
    THEN
        --Verifica se ira cobrar multa
        IF v_date > v_referenceDate THEN
            --Se A data de referencia for uma segunda
            IF ( EXTRACT('DOW' FROM v_date) = 1 ) THEN
                --Caso não cobrou a multa no dia anterior (domingo) então não cobra na segunda
                IF ( v_date-('1 days')::interval <= v_referenceDate ) THEN
                    RETURN 0;
                END IF;               
            END IF;
        END IF;
    END IF;

    IF v_policyInfo.applyFine = TRUE THEN
    -- Check if maturity date is in fine period (sum interest and fine days if have interest period)
        IF v_date > v_referenceDate THEN
            v_fineValue := v_balanceValue * ( ((v_policyInfo.finePercent)/100));
        END IF;
    END IF;

    RETURN v_fineValue;
END
$$;


ALTER FUNCTION public.getinvoicefinevalue(p_invoiceid integer, p_date date) OWNER TO postgres;

--
-- Name: getinvoiceinterestvalue(integer, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getinvoiceinterestvalue(p_invoiceid integer, p_date date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: getInvoiceInterestValue
  PURPOSE: Calcula os juros que um título teria, se baixado em p_date.
  DESCRIPTION: vide "PURPOSE".

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       30/11/2010 AlexSmith         1. FUNÇÃO criada.
  1.1       06/12/2010 Leovan            1. Considerar liberações de juro e multa
  1.2       14/06/2012 Jonas e Leovan    1. Alteração no balance.
  1.3       07/11/2012 Jonas Diel        1. Adicionada regra da data de ocorrencia
                                            para finais de semana (ENABLE_BUSINESS_USER = 1)
**************************************************************************************/
DECLARE
    v_policyInfo RECORD;
    v_invoiceInfo RECORD;
    v_release BOOLEAN;
    v_interestValue NUMERIC;
    v_balanceValue NUMERIC;
    v_interestPercent NUMERIC;
    v_numDays NUMERIC;
    v_date DATE;
    v_maturityMonth INTEGER;
    v_maturityYear INTEGER;
    v_nowMonth INTEGER;  
    v_to_date DATE;
    v_to_dateMonth INTEGER;
    v_index INTEGER;
    v_referenceDate DATE;
BEGIN
    v_interestValue = 0;
    v_date := p_date;

    -- Invoice data
    SELECT INTO v_invoiceInfo *
      FROM ONLY finReceivableInvoice
     WHERE invoiceId = p_invoiceId;

    FOR v_release IN SELECT releaseInterest
                       FROM finRelease
                      WHERE invoiceid = p_invoiceId
                        AND v_date BETWEEN beginDate AND endDate
    LOOP
        IF v_release = true THEN RETURN 0; END IF;
    END LOOP;

    -- Policy's invoice data
    SELECT INTO v_policyInfo *
      FROM finPolicy
     WHERE policyId = v_invoiceInfo.policyId;

    SELECT INTO v_balanceValue *
      FROM getBalanceInterests(p_invoiceId);

    IF getParameter('FINANCE', 'DESCARTAR_DIA_31') = 'YES' THEN
        v_maturityMonth := EXTRACT(MONTH FROM v_invoiceInfo.referenceMaturityDate::date);
        v_maturityYear := EXTRACT(YEAR FROM v_invoiceInfo.referenceMaturityDate::date);
        v_nowMonth := EXTRACT(MONTH FROM p_date::date);
        v_to_date := TO_DATE('31/' || v_maturityMonth || '/' || v_maturityYear, 'dd/mm/yyyy');
        v_to_dateMonth := EXTRACT(MONTH FROM v_to_date);

        v_index = 0;

        IF ( (v_maturityMonth <> v_nowMonth) AND (v_maturityMonth = v_to_dateMonth) ) THEN
            v_index := 1;
        END IF;

        v_referenceDate := ((v_index||' days')::interval+v_invoiceInfo.referenceMaturityDate+(v_policyInfo.daysToFine||' days')::interval)::date;
    ELSE
            v_referenceDate := (v_invoiceInfo.referenceMaturityDate+(v_policyInfo.daysToInterest||' days')::interval)::date;
    END IF;

    IF getParameter('BASIC', 'ENABLE_BUSINESS_USER') = '1'
        THEN
            IF ( EXTRACT('DOW' FROM v_referenceDate) = 6 ) THEN
                v_referenceDate := v_referenceDate+'2 DAYS'::interval;
            ELSEIF ( EXTRACT('DOW' FROM v_referenceDate) = 0 ) THEN    
                v_referenceDate := v_referenceDate+'1 DAY'::interval;
            END IF;
        END IF;

    IF v_policyInfo.applyInterest = TRUE THEN
        -- Check if maturity date is in interest period
        IF v_date > v_referenceDate THEN
            -- function that returns the difference in months of 2 dates
            v_numDays := v_date::date - v_invoiceInfo.referenceMaturityDate::date;
            v_interestPercent := (v_policyInfo.monthlyInterestPercent/30)/100;
            IF v_policyInfo.interestType = 'S' THEN
                -- Apply simple interest formula
                v_interestValue := (v_balanceValue * v_interestPercent) * v_numDays;
            ELSE
                -- Apply compound interest formula
                v_interestValue := (v_balanceValue * ( POWER(1 + (v_interestPercent) , v_numDays) ) - v_balanceValue);
            END IF;
        END IF;
    END IF;

    --Caso for segunda feira desconta 1 dia extendendo o desconto de domingo
    IF getParameter('FINANCE', 'EXTENDER_DESCONTOS_NA_SEGUNDA') = 'YES'
    THEN
        --Verifica se ira cobrar multa
        IF v_date > v_referenceDate THEN
            --Se A data de referencia for uma segunda
            IF ( EXTRACT('DOW' FROM v_date) = 1 ) THEN
                --Caso não cobrou a multa no dia anterior (domingo) então não cobra na segunda
                IF ( v_date-('1 days')::interval <= v_referenceDate ) THEN
                    v_interestValue := 0;
                END IF;               
            END IF;
        END IF;
    END IF;

    RETURN v_interestValue;
END
$$;


ALTER FUNCTION public.getinvoiceinterestvalue(p_invoiceid integer, p_date date) OWNER TO postgres;

--
-- Name: getinvoicelearningperiod(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getinvoicelearningperiod(integer) RETURNS integer
    LANGUAGE sql
    AS $_$
  SELECT B.learningPeriodId
    FROM acdLearningPeriod B,
         finInvoice A
   WHERE A.maturityDate
 BETWEEN B.beginDate
     AND B.endDate
     AND A.courseId = B.courseId
     AND A.courseVersion = B.courseVersion
     AND A.policyId = B.policyId
     AND A.unitId = B.unitId
     AND A.invoiceId = $1
$_$;


ALTER FUNCTION public.getinvoicelearningperiod(integer) OWNER TO postgres;

--
-- Name: getinvoiceperiod(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getinvoiceperiod(integer) RETURNS character varying
    LANGUAGE sql
    AS $_$
  SELECT B.periodId
    FROM acdLearningPeriod B,
         finInvoice A
   WHERE A.maturityDate
 BETWEEN B.beginDate
     AND B.endDate
     AND A.courseId = B.courseId
     AND A.courseVersion = B.courseVersion
     AND A.policyId = B.policyId
     AND A.unitId = B.unitId
     AND A.invoiceId = $1
GROUP BY B.periodId
   LIMIT 1 
$_$;


ALTER FUNCTION public.getinvoiceperiod(integer) OWNER TO postgres;

--
-- Name: getlanguage(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getlanguage(integer) RETURNS character varying
    LANGUAGE sql
    AS $_$
SELECT description 
  FROM sprLanguage 
 WHERE languageId = $1 
$_$;


ALTER FUNCTION public.getlanguage(integer) OWNER TO postgres;

--
-- Name: getlearningperiodbegindate(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getlearningperiodbegindate("learningPeriodId" integer) RETURNS date
    LANGUAGE sql
    AS $_$
  SELECT beginDate FROM acdLearningPeriod WHERE learningPeriodId = $1 
$_$;


ALTER FUNCTION public.getlearningperiodbegindate("learningPeriodId" integer) OWNER TO postgres;

--
-- Name: getmessagephone(bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getmessagephone(bigint) RETURNS character varying
    LANGUAGE sql
    AS $_$
    SELECT phone FROM basphone WHERE type = 'REC' AND personId = $1
$_$;


ALTER FUNCTION public.getmessagephone(bigint) OWNER TO postgres;

--
-- Name: getmonthsforinterest(date, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getmonthsforinterest(date, date) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE
    numMonths    NUMERIC;
    actualDate   DATE;
    maturityDate DATE;

BEGIN
    actualDate   = $1;
    maturityDate = $2;

    numMonths := (extract(year from age(actualDate, maturityDate)) * 12) + (extract(month from age(actualDate, maturityDate)));

    RETURN numMonths;
END
$_$;


ALTER FUNCTION public.getmonthsforinterest(date, date) OWNER TO postgres;

--
-- Name: getmotherid(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getmotherid(integer) RETURNS integer
    LANGUAGE sql
    AS $_$
    SELECT X.relativePersonId
      FROM basPhysicalPersonKinship X
     WHERE X.personId = $1
       AND X.kinshipId = (SELECT value::integer
                            FROM basConfig
                           WHERE parameter = 'MOTHER_KINSHIP_ID'
                             AND moduleConfig = 'BASIC');
$_$;


ALTER FUNCTION public.getmotherid(integer) OWNER TO postgres;

--
-- Name: getmotherid(bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getmotherid(bigint) RETURNS bigint
    LANGUAGE sql
    AS $_$
    SELECT X.relativePersonId
      FROM basPhysicalPersonKinship X
     WHERE X.personId = $1
       AND X.kinshipId = (SELECT value::integer
                            FROM basConfig
                           WHERE parameter = 'MOTHER_KINSHIP_ID'
                             AND moduleConfig = 'BASIC');
$_$;


ALTER FUNCTION public.getmotherid(bigint) OWNER TO postgres;

--
-- Name: getnextournumber(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getnextournumber(p_bankaccountid integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_ourNumber text;
    v_last_ourNumber text;
    v_query varchar;
BEGIN
/**
* FUNÇÃO chamada na geração do título
* Gera o nosso número com a utitlização de uma sequência
**/
    --Obtém o nosso numero definido na conta bancária
    v_last_ourNumber := ourNumber FROM finbankaccount WHERE bankaccountid = p_bankAccountId;

    IF v_last_ourNumber IS NULL 
    THEN
        RAISE EXCEPTION 'Deve ser registrado ''Nosso número'' para a conta bancária %', p_bankAccountId;
    END IF;
    
    -- Verifica se existe sequencia e pega o nextval, caso nao exista ainda, cria
    BEGIN
        v_ourNumber := nextval('seq_ourNumber_bankAccountId_' || p_bankAccountId)::text;
    EXCEPTION
        WHEN OTHERS THEN
            -- cai no erro se a sequencia ainda nao existir e cria a sequencia
            v_query := 'CREATE SEQUENCE seq_ourNumber_bankAccountId_' || p_bankAccountId || ' START ' || v_last_ourNumber::numeric + 1;
            EXECUTE v_query;
            v_ourNumber := nextval('seq_ourNumber_bankAccountId_' || p_bankAccountId)::text;
    END;

    -- Corrige a sequencia caso esteja incorreta.
    WHILE ( SELECT ( SELECT COUNT(ourNumber) FROM finBankInvoiceInfo WHERE ourNumber = lpad(v_ourNumber, length(v_last_ourNumber), '0') ) > 0 )
    LOOP 
	v_ourNumber := v_ourNumber::INTEGER + 1;
	PERFORM setval('seq_ourNumber_bankAccountId_' || p_bankAccountId, v_ourNumber::INTEGER);
    END LOOP;

    --Obtém o nosso numero original e converte o novo nosso numero para o mesmo numero de caracteres    
    v_ourNumber := lpad(v_ourNumber, length(v_last_ourNumber), '0');

RAISE NOTICE 'v_ourNumber %', v_ourNumber;
    --Atualiza o nosso numero
    UPDATE finbankaccount SET ourNumber = v_ourNumber WHERE bankaccountid = p_bankAccountId;

    RETURN v_ourNumber;
END;
$$;


ALTER FUNCTION public.getnextournumber(p_bankaccountid integer) OWNER TO postgres;

--
-- Name: getopeninvoicebyparcel(integer, integer, integer, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getopeninvoicebyparcel(p_contractid integer, p_learningperiodid integer, p_parcelnumber integer, v_vcont double precision, v_mens double precision) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/*********************************************************************************************
  NAME: getopeninvoicebyparcel
  PURPOSE: Obtem titulo aberto para o contrato + periodo letivo + numero parcela passados
*********************************************************************************************/
DECLARE
BEGIN
    RETURN  (SELECT MIN(I.invoiceId)
               FROM finInvoice I
         INNER JOIN finEntry E
                 ON (I.invoiceId = E.invoiceId)
              WHERE I.isCanceled IS FALSE
                AND I.parcelNumber = p_parcelnumber
                AND EXISTS(SELECT 1 FROM finEntry E1 WHERE E1.invoiceID = I.invoiceId AND E1.contractId = p_contractid AND E1.learningPeriodId = p_learningperiodid)
                AND (SELECT * FROM getblockedinvoice(p_contractid, p_learningperiodid, p_parcelnumber, V_VCONT, V_MENS)) IS NULL
                );
END
$$;


ALTER FUNCTION public.getopeninvoicebyparcel(p_contractid integer, p_learningperiodid integer, p_parcelnumber integer, v_vcont double precision, v_mens double precision) OWNER TO postgres;

--
-- Name: getparameter(character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getparameter(p_moduleconfig character varying, p_parameter character varying) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE
    AS $$
/*************************************************************************************
  NAME: getParameter
  PURPOSE: Retorna um varchar contendo o valor de um parÃ©metro.
**************************************************************************************/
DECLARE
    v_retVal varchar;
    
    v_validationSql varchar;
    v_validationVal boolean;
    v_validationMsg varchar;
BEGIN
    --Caso o parâmetro não exista, retorna mostrando o erro.
    IF checkValidParameter(p_moduleConfig, p_parameter) = 'f' THEN
        RAISE EXCEPTION 'O parâmetro % não existe no módulo %.', p_parameter, p_moduleConfig;
    END IF;

    -- Se nÃ£o tiver passado o mÃ©dulo
    IF ( p_moduleConfig IS NULL )
    THEN
        RAISE EXCEPTION 'Você deve informar um módulo.';
    -- Se nÃ£o tiver passado o parÃ©metro
    ELSIF ( p_parameter IS NULL )
    THEN
        RAISE EXCEPTION 'Você deve informar um parâmetro.';
    END IF;

    -- Busca o valor do parÃ©metro, priorizando da unidade logada, caso existir
    SELECT COALESCE(UC.value, C.value) INTO v_retVal
      FROM basConfig C
 LEFT JOIN basUnitConfig UC ON UC.unitid = obterUnidadeLogada()
       AND (UC.moduleConfig, UC.parameter) = (C.moduleConfig, C.parameter)
     WHERE (C.moduleConfig, C.parameter) = (UPPER(p_moduleConfig), UPPER(p_parameter));
     
    -- Validar o valor, caso exista um comando para validação. 
    SELECT COALESCE(UC.validatevalue, C.validatevalue) INTO v_validationSql
      FROM basConfig C
 LEFT JOIN basUnitConfig UC ON UC.unitid = obterUnidadeLogada()
       AND (UC.moduleConfig, UC.parameter) = (C.moduleConfig, C.parameter)
     WHERE (C.moduleConfig, C.parameter) = (UPPER(p_moduleConfig), UPPER(p_parameter));
     
     IF ( char_length(v_validationSql) > 0 ) THEN
         BEGIN
            v_validationSql := replace(v_validationSql, '?', '''' || v_retVal || '''');
            EXECUTE v_validationSql INTO v_validationVal;
            
            IF ( v_validationVal ) IS NOT TRUE THEN
                BEGIN
                    SELECT COALESCE(UC.validatemsg, C.validatemsg) INTO v_validationMsg
                      FROM basConfig C
                 LEFT JOIN basUnitConfig UC ON UC.unitid = obterUnidadeLogada()
                       AND (UC.moduleConfig, UC.parameter) = (C.moduleConfig, C.parameter)
                     WHERE (C.moduleConfig, C.parameter) = (UPPER(p_moduleConfig), UPPER(p_parameter));
                     
                     RAISE EXCEPTION 'O valor % não é um valor válido para o parâmetro %. %', v_retVal, p_parameter, v_validationMsg;
                END;
            END IF;
         
         END;
     END IF;

    RETURN v_retVal;
END;
$$;


ALTER FUNCTION public.getparameter(p_moduleconfig character varying, p_parameter character varying) OWNER TO postgres;

--
-- Name: getparcelopenvalue(bigint, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getparcelopenvalue(bigint, integer, integer) RETURNS numeric
    LANGUAGE sql
    AS $_$
-- FUNÇÃO getparcelpayedvalue
-- Obtém o valor em aberto de uma parcela de uma pessoa de um peréodo letivo
-- Parémetros: personid bigint, parcelnumber integer, learningperiodid integer
-- Retorno: valor em aberto
    SELECT ROUND( (SELECT sum(balanceWithPoliciesDated(AA.invoiceId, now()::date))
                                 FROM finReceivableInvoice AA 
                                WHERE AA.personId = $1 
                                  AND AA.parcelnumber = $2 
                                  AND EXISTS (SELECT BB.entryid 
                                                FROM finEntry BB
                                          INNER JOIN finOperation CC
                                                  ON (CC.operationId = BB.operationId) 
                                               WHERE BB.invoiceId = AA.invoiceId 
                                                 AND BB.learningperiodid = $3 
                                                 AND CC.operationgroupid = (SELECT value 
                                                                              FROM basconfig 
                                                                             WHERE parameter LIKE 'MONTHLY_FEE_OPERATION_GROUP_ID') ) 
                  ), 
                   (SELECT value FROM basconfig WHERE parameter LIKE 'REAL_ROUND_VALUE')::int )
$_$;


ALTER FUNCTION public.getparcelopenvalue(bigint, integer, integer) OWNER TO postgres;

--
-- Name: getparcelpayedvalue(bigint, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getparcelpayedvalue(bigint, integer, integer) RETURNS numeric
    LANGUAGE sql
    AS $_$
-- FUNÇÃO getparcelpayedvalue
-- Obtém o valor pago de uma parcela de uma pessoa de um peréodo letivo
-- Parémetros: personid bigint, parcelnumber integer, learningperiodid integer
-- Retorno: valor pago
    SELECT ROUND( (SELECT sum(X.value) 
                   FROM finentry X 
                   WHERE X.operationid = (SELECT paymentoperation FROM findefaultoperations LIMIT 1)
                   AND EXISTS (SELECT AA.invoiceid 
                                 FROM finReceivableInvoice AA 
                                WHERE AA.invoiceId = X.invoiceId
                                  AND AA.personId = $1 
                                  AND AA.parcelnumber = $2 
                                  AND EXISTS (SELECT BB.entryid 
                                                FROM finEntry BB
                                          INNER JOIN finOperation CC
                                                  ON (CC.operationId = BB.operationId) 
                                               WHERE BB.invoiceId = AA.invoiceId 
                                                 AND BB.learningperiodid = $3 
                                                 AND CC.operationgroupid = (SELECT value 
                                                                              FROM basconfig 
                                                                             WHERE parameter LIKE 'MONTHLY_FEE_OPERATION_GROUP_ID') ) ) 
                  ), 
                   (SELECT value FROM basconfig WHERE parameter LIKE 'REAL_ROUND_VALUE')::int )
$_$;


ALTER FUNCTION public.getparcelpayedvalue(bigint, integer, integer) OWNER TO postgres;

--
-- Name: getparcelsdates(character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getparcelsdates(begindate character varying, months integer, datemask character varying) RETURNS SETOF character varying
    LANGUAGE plpgsql STABLE
    AS $$

DECLARE
    count integer;
    plus interval;

BEGIN
    count:= 0;
    WHILE (count<months)
    LOOP  
          plus:= '' || count || ' month';
          RETURN NEXT  TO_CHAR((TO_DATE(beginDate,dateMask) + plus)::DATE, dateMask);
          count:=count+1;
    END LOOP;
    RETURN;
END;
$$;


ALTER FUNCTION public.getparcelsdates(begindate character varying, months integer, datemask character varying) OWNER TO postgres;

--
-- Name: getpendingcurriculumids(integer, integer); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION getpendingcurriculumids(p_contractid integer, p_semesterlimit integer) RETURNS SETOF integer
    LANGUAGE plpgsql
    AS $$
/*********************************************************************************************
  NAME: getPendingCurriculumIds
  PURPOSE: Obtem as disciplinas pendentes, que nao foram cursadas no semestre
*********************************************************************************************/
DECLARE
BEGIN
    RETURN QUERY (SELECT A.curriculumId
                  FROM acdCurriculum A
            INNER JOIN acdContract B
                    ON (B.courseId = A.courseId
                    AND B.courseVersion = A.courseVersion
                    AND B.turnId = A.turnId
                    AND B.unitId = A.unitId)
            INNER JOIN acdCurricularComponent C
                    ON (C.curricularComponentId = A.curricularComponentId
                    AND C.curricularComponentVersion = A.curricularComponentVersion)
                 WHERE B.contractId = p_contractid
                   AND A.semester BETWEEN 1 AND p_semesterlimit
                   AND NOT EXISTS (SELECT 'x'
                                     FROM acdEnroll X
                                    WHERE X.contractId = B.contractId
                                      AND X.curriculumId = A.curriculumId
                                      AND X.statusId::varchar = ANY(STRING_TO_ARRAY(GETPARAMETER('ACADEMIC', 'ENROLL_STATUS_APPR_OR_EXC'), ',')))
              ORDER BY A.curricularComponentId || '' || A.curricularComponentVersion || '' || C.name);
END
$$;


ALTER FUNCTION public.getpendingcurriculumids(p_contractid integer, p_semesterlimit integer) OWNER TO solis;

--
-- Name: getperiodhours(character varying, integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION getperiodhours(p_courseid character varying, p_courseversion integer, p_turnid integer, p_unitid integer, p_semester integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
/*********************************************************************************************
  NAME: getperiodhours
  PURPOSE: Obtem carga horaria do periodo
*********************************************************************************************/
DECLARE
BEGIN
    RETURN (SELECT SUM(B.academicNumberHours)
                  FROM acdCurriculum A
            INNER JOIN acdCurricularComponent B
                    ON (B.curricularComponentId = A.curricularComponentId
                   AND  B.curricularComponentVersion = A.curricularComponentVersion)
                 WHERE A.courseId = p_courseid
                   AND A.courseVersion = p_courseversion
                   AND A.turnId = p_turnid
                   AND A.unitId = p_unitid
                   AND A.semester = p_semester
                   AND A.curriculumTypeId::varchar = ANY(STRING_TO_ARRAY(GETPARAMETER('ACADEMIC', 'CURRICULUM_TYPE_NON_OPTIONAL'), ','))
                   );
END
$$;


ALTER FUNCTION public.getperiodhours(p_courseid character varying, p_courseversion integer, p_turnid integer, p_unitid integer, p_semester integer) OWNER TO solis;

--
-- Name: getpersonaddress(bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getpersonaddress(bigint) RETURNS character varying
    LANGUAGE sql
    AS $_$
   SELECT COALESCE(A.location||' - ', '')||COALESCE(A.complement||' - ', '')||COALESCE(A.neighborhood||' - ', '')||COALESCE(B.name||' - ', '')|| B.stateId 
      FROM ONLY basPerson A 
LEFT JOIN basCity B 
          ON A.cityId = B.cityId 
    WHERE personId = $1
$_$;


ALTER FUNCTION public.getpersonaddress(bigint) OWNER TO postgres;

--
-- Name: getpersondocument(bigint, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getpersondocument(bigint, integer) RETURNS character varying
    LANGUAGE sql
    AS $_$
SELECT content 
  FROM basDocument
 WHERE personId = $1
   AND documentTypeId = $2
$_$;


ALTER FUNCTION public.getpersondocument(bigint, integer) OWNER TO postgres;

--
-- Name: getpersondocumentcity(bigint, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getpersondocumentcity(bigint, integer) RETURNS integer
    LANGUAGE sql
    AS $_$
SELECT cityId
  FROM basDocument
 WHERE personId = $1
   AND documentTypeId = $2 
$_$;


ALTER FUNCTION public.getpersondocumentcity(bigint, integer) OWNER TO postgres;

--
-- Name: getpersondocumentdateexpedition(bigint, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getpersondocumentdateexpedition(bigint, integer) RETURNS date
    LANGUAGE sql
    AS $_$
SELECT dateExpedition
  FROM basDocument
 WHERE personId = $1
   AND documentTypeId = $2 
$_$;


ALTER FUNCTION public.getpersondocumentdateexpedition(bigint, integer) OWNER TO postgres;

--
-- Name: getpersondocumentorgan(bigint, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getpersondocumentorgan(bigint, integer) RETURNS character varying
    LANGUAGE sql
    AS $_$
SELECT organ
  FROM basDocument
 WHERE personId = $1
   AND documentTypeId = $2 
$_$;


ALTER FUNCTION public.getpersondocumentorgan(bigint, integer) OWNER TO postgres;

--
-- Name: getpersonname(bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getpersonname(bigint) RETURNS character varying
    LANGUAGE sql
    AS $_$
   SELECT name 
FROM ONLY basPerson
    WHERE personId = $1 
$_$;


ALTER FUNCTION public.getpersonname(bigint) OWNER TO postgres;

--
-- Name: getphysicalpersonage(bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getphysicalpersonage(bigint) RETURNS integer
    LANGUAGE sql
    AS $_$
     SELECT extract(year FROM age(date(now()), dateBirth))::INT
  FROM ONLY basPhysicalPerson
      WHERE personId = $1
$_$;


ALTER FUNCTION public.getphysicalpersonage(bigint) OWNER TO postgres;

--
-- Name: getpreviouslearningperiodid(integer, integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getpreviouslearningperiodid(integer, integer, integer, integer, character varying) RETURNS character varying
    LANGUAGE sql
    AS $_$
SELECT periodId
  FROM acdLearningPeriod
 WHERE learningPeriodId = ( SELECT previousLearningPeriodId
                              FROM acdLearningPeriod
                             WHERE courseId = $1
                               AND courseVersion = $2
                               AND turnId = $3
                               AND unitId = $4
                               AND periodId = '$5'
                             LIMIT 1 );
$_$;


ALTER FUNCTION public.getpreviouslearningperiodid(integer, integer, integer, integer, character varying) OWNER TO postgres;

--
-- Name: getpreviousperiodid(integer, integer, integer, integer, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getpreviousperiodid(integer, integer, integer, integer, character varying) RETURNS character varying
    LANGUAGE sql
    AS $_$
SELECT A.periodId
  FROM acdLearningPeriod A,
       acdPeriod B
 WHERE A.periodId = B.periodId
   AND A.learningPeriodId = ( SELECT previousLearningPeriodId
                              FROM acdLearningPeriod
                             WHERE courseId = $1
                               AND courseVersion = $2
                               AND turnId = $3
                               AND unitId = $4
                               AND periodId = '$5'
                             LIMIT 1 );
$_$;


ALTER FUNCTION public.getpreviousperiodid(integer, integer, integer, integer, character varying) OWNER TO postgres;

--
-- Name: getprofessionalactivityofprofessorsbygroup(integer); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION getprofessionalactivityofprofessorsbygroup(p_groupid integer) RETURNS SETOF integer
    LANGUAGE plpgsql
    AS $$
/*********************************************************************************************
  NAME: getProfessionalActivityOfProfessorsByGroup
  PURPOSE: Obtém atividade profissional de cada professor, da disciplina especificada.
           Obs: Professores com horério definido e professor responsável.
*********************************************************************************************/
DECLARE
BEGIN
    RETURN QUERY (SELECT DISTINCT C.professionalactivityid
                  FROM acdScheduleProfessor A
            INNER JOIN acdSchedule B
                    ON (B.scheduleId = A.scheduleId)
            INNER JOIN basProfessionalActivityPeople C
                    ON (C.personId = A.professorId)
                 WHERE B.groupId = p_groupId
                 UNION
                SELECT B.professionalactivityid
                  FROM acdGroup A
            INNER JOIN basProfessionalActivityPeople B
                    ON (A.professorresponsible = B.personId)
                 WHERE A.groupId = p_groupId
                 );
END
$$;


ALTER FUNCTION public.getprofessionalactivityofprofessorsbygroup(p_groupid integer) OWNER TO solis;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: baslog; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE baslog (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet
);


ALTER TABLE public.baslog OWNER TO postgres;

--
-- Name: TABLE baslog; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE baslog IS 'Registro de acessos e modificações aos registros.';


--
-- Name: COLUMN baslog.username; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baslog.username IS 'nome do usuário';


--
-- Name: COLUMN baslog.datetime; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baslog.datetime IS 'Data do registo';


--
-- Name: COLUMN baslog.ipaddress; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baslog.ipaddress IS 'IP do usuario';


--
-- Name: basprofessorcommitment; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basprofessorcommitment (
    personid bigint NOT NULL,
    begindate date NOT NULL,
    enddate date,
    workload double precision NOT NULL,
    schedule text,
    tasks text,
    teachworkload double precision,
    timesheet character varying(30),
    unitid integer,
    sectorid integer
)
INHERITS (baslog);


ALTER TABLE public.basprofessorcommitment OWNER TO postgres;

--
-- Name: TABLE basprofessorcommitment; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basprofessorcommitment IS 'Armazena a duração do contrato e a carga horária contratada do professor.';


--
-- Name: COLUMN basprofessorcommitment.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basprofessorcommitment.personid IS 'Código da pessoa física';


--
-- Name: COLUMN basprofessorcommitment.begindate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basprofessorcommitment.begindate IS 'Data inicial';


--
-- Name: COLUMN basprofessorcommitment.enddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basprofessorcommitment.enddate IS 'Data final';


--
-- Name: COLUMN basprofessorcommitment.workload; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basprofessorcommitment.workload IS 'Carga horária';


--
-- Name: getprofessorcurrentcommitment(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getprofessorcurrentcommitment(p_professorid integer) RETURNS basprofessorcommitment
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: getProfessorCurrentCommitment
  PURPOSE: Obtém os dados atuais do vínculo do professor com a instituição.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       29/06/2011 Alexandre Schmidt 1. Função criada.
**************************************************************************************/
DECLARE
    v_row RECORD;
BEGIN
    SELECT * INTO v_row
      FROM basProfessorCommitment
     WHERE personId = p_professorId
       AND now()::date BETWEEN beginDate
       AND COALESCE(endDate, now()::date);

    RETURN v_row;
END;
$$;


ALTER FUNCTION public.getprofessorcurrentcommitment(p_professorid integer) OWNER TO postgres;

--
-- Name: getprofessorstext(integer, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getprofessorstext(_groupid integer, _separator character varying) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE 
    resultStr text;
    scheduleData RECORD;
BEGIN
    FOR scheduleData IN SELECT DISTINCT C.name AS name
                          FROM acdSchedule A 
                    INNER JOIN acdScheduleProfessor B
                            ON (B.scheduleId = A.scheduleId)
                    INNER JOIN basPhysicalPersonProfessor C
                            ON (C.personId = B.professorId)
                         WHERE A.groupId = _groupId
                      ORDER BY C.name 
    LOOP
        IF resultStr IS NULL THEN
            resultStr := scheduleData.name;
        ELSE
            resultStr := resultStr || _separator || scheduleData.name;
        END IF;
    END LOOP;
    
    RETURN resultStr;
END;
$$;


ALTER FUNCTION public.getprofessorstext(_groupid integer, _separator character varying) OWNER TO postgres;

--
-- Name: getprogrammedteachhours(integer, date, date, character varying, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getprogrammedteachhours(p_professorid integer, p_begindate date, p_enddate date, p_courseid character varying, p_courseversion integer, p_turnid integer, p_unitid integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: getProgrammedTeachHours
  PURPOSE: Obtém o total de horas programadas para o professor no período
  especificado. A ocorrência de curso pode ser nula.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       24/06/2011 Alexandre Schmidt 1. Função criada.
**************************************************************************************/
DECLARE
    v_retVal float;
BEGIN
    SELECT EXTRACT(HOUR FROM SUM(B.endHour - B.beginHour)) +
           EXTRACT(MINUTE FROM SUM(B.endHour - B.beginHour)) / 60 +
           EXTRACT(SECOND FROM SUM(B.endHour - B.beginHour)) / 60 / 60 AS duration INTO v_retVal
      FROM (SELECT UNNEST(B.occurrenceDates) AS occurrenceDate,
                   UNNEST(C.timeIds) AS timeId
              FROM acdScheduleProfessor A
        INNER JOIN acdSchedule B
                ON B.scheduleId = A.scheduleId
        INNER JOIN acdSchedule C
                ON C.scheduleId = A.scheduleId
        INNER JOIN acdGroup D
                ON D.groupId = C.groupId
        INNER JOIN acdCurriculum E
                ON E.curriculumId = D.curriculumId
             WHERE A.professorId = p_professorId
               AND E.courseId = COALESCE(p_courseId, E.courseId)
               AND E.courseVersion = COALESCE(p_courseVersion, E.courseVersion)
               AND E.turnId = COALESCE(p_turnId, E.turnId)
               AND E.unitId = COALESCE(p_unitId, E.unitId)) A
INNER JOIN acdTime B
        ON B.timeId = A.timeId
     WHERE A.occurrenceDate BETWEEN p_beginDate
                                AND p_endDate;

    RETURN COALESCE(v_retVal, 0);
END;
$$;


ALTER FUNCTION public.getprogrammedteachhours(p_professorid integer, p_begindate date, p_enddate date, p_courseid character varying, p_courseversion integer, p_turnid integer, p_unitid integer) OWNER TO postgres;

--
-- Name: getrealizedteachhours(integer, date, date, character varying, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getrealizedteachhours(p_professorid integer, p_begindate date, p_enddate date, p_courseid character varying, p_courseversion integer, p_turnid integer, p_unitid integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
/***gfr**********************************************************************************
  NAME: getRealizedTeachHours
  PgURPOSE: Obtém o total de horas realizadas pelo professor no período especificado.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       24/06/2011 Alexandre Schmidt 1. Função criada.
  1.1       27/02/2012 Jonas Guilherme Dahmer 1. Ajuste para o professor substituto
**************************************************************************************/
DECLARE
    v_retVal float;
BEGIN
    SELECT EXTRACT(HOUR FROM duration) +
           EXTRACT(MINUTE FROM duration) / 60 +
           EXTRACT(SECOND FROM duration) / (60 * 60) INTO v_retVal
      FROM (SELECT SUM(COALESCE(A.realEndDate - A.realStartDate, C.endHour - C.beginHour)) AS duration
              FROM acdScheduleProfessorContent A
        INNER JOIN acdScheduleProfessor B
                ON B.scheduleProfessorId = A.scheduleProfessorId
        INNER JOIN acdTime C
                ON C.timeId = A.timeId
        INNER JOIN acdSchedule D
                ON D.scheduleId = B.scheduleId
        INNER JOIN acdGroup E
                ON E.groupId = D.groupId
        INNER JOIN acdCurriculum F
                ON F.curriculumId = E.curriculumId
             WHERE  A.substituteprofessorid = p_professorId OR
                    (B.professorId = p_professorId AND A.substituteprofessorid is null)
               AND A.date BETWEEN p_beginDate
                              AND p_endDate
               AND F.courseId = COALESCE(p_courseId, F.courseId)
               AND F.courseVersion = COALESCE(p_courseVersion, F.courseVersion)
               AND F.turnId = COALESCE(p_turnId, F.turnId)
               AND F.unitId = COALESCE(p_unitId, F.unitId)) A;

    RETURN COALESCE(v_retVal, 0);
END;
$$;


ALTER FUNCTION public.getrealizedteachhours(p_professorid integer, p_begindate date, p_enddate date, p_courseid character varying, p_courseversion integer, p_turnid integer, p_unitid integer) OWNER TO postgres;

--
-- Name: getrelated(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getrelated(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
    DECLARE

        text_output TEXT;
        row_data RECORD;

        BEGIN

            text_output := '';

            FOR row_data IN SELECT DISTINCT relatedcontent FROM gtcdictionaryrelatedcontent
                            WHERE dictionarycontentid = $1 LOOP
                text_output := text_output || row_data.relatedcontent || '<br>';
            END LOOP;

            RETURN text_output;

        END;

$_$;


ALTER FUNCTION public.getrelated(integer) OWNER TO postgres;

--
-- Name: getresidentialphone(bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getresidentialphone(bigint) RETURNS character varying
    LANGUAGE sql
    AS $_$
    SELECT phone FROM basphone WHERE type = 'RES' AND personId = $1
$_$;


ALTER FUNCTION public.getresidentialphone(bigint) OWNER TO postgres;

--
-- Name: getrestantparcels(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getrestantparcels(integer) RETURNS bigint
    LANGUAGE sql
    AS $_$
   SELECT count(months) 
     FROM (SELECT DISTINCT EXTRACT(MONTH FROM maturitydate) as months 
                      FROM finincomeforecast 
                     WHERE contractid = $1 
                       AND isprocessed = 'f') AS sel 
$_$;


ALTER FUNCTION public.getrestantparcels(integer) OWNER TO postgres;

--
-- Name: getsearchcontenttoyearcompare(character varying, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getsearchcontenttoyearcompare(character varying, boolean) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
    DECLARE

        text_output TEXT;

        BEGIN

            text_output := $1;

            IF char_length(text_output) = 0 AND $2 THEN
                text_output := date_part('year', now());
            END IF;

            text_output := replace(text_output, '?', '0');
            text_output := regexp_replace(text_output, '[^0-9]', '', 'g');

            IF char_length(text_output) = 0 THEN
                RETURN '0';
            END IF;

            RETURN text_output;

        END;

$_$;


ALTER FUNCTION public.getsearchcontenttoyearcompare(character varying, boolean) OWNER TO postgres;

--
-- Name: getsectordescription(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getsectordescription(integer) RETURNS character varying
    LANGUAGE sql
    AS $_$
SELECT description
  FROM basSector
 WHERE sectorId = $1
$_$;


ALTER FUNCTION public.getsectordescription(integer) OWNER TO postgres;

--
-- Name: getstatescontractfromcontracttoenrollbookrules(integer, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getstatescontractfromcontracttoenrollbookrules(integer, character varying) RETURNS integer[]
    LANGUAGE plpgsql STABLE
    AS $_$

DECLARE
    result1 RECORD;
    result2 integer[];
    --str     text;
    --str_aux text;
    x       integer;

BEGIN
    x = 0;
    --str     := '';
    --str_aux := '{';
    --str_aux := '';


    FOR result1 IN SELECT A.stateContractId 
                     FROM acdMovementContract A
               INNER JOIN acdContract B
                       ON (A.contractId = B.contractId)
               INNER JOIN acdLearningPeriod C
                       ON (C.courseId      = B.courseId AND
                           C.courseVersion = B.courseVersion AND
                           C.unitId        = B.unitId AND
                           C.turnId        = B.turnId)
                    WHERE A.contractId = $1--152373--$1
                      AND C.periodId   = $2--'2006B'--$2
                      AND A.stateTime BETWEEN C.beginDate AND C.endDate
                 ORDER BY A.stateTime DESC

    LOOP  
          result2[x] = result1.stateContractID;
	  x = x + 1;
          --result2 := result1.stateContractId;

          --str     := str_aux || result1.stateContractId;
          --str_aux := str     || ',';

    END LOOP;

     --     str_aux := str;
     --     str     := str || '}';

     --str := str || '}';


    --RETURN result2;
    --str := str || '}';

    RETURN result2[0:x];

END;
$_$;


ALTER FUNCTION public.getstatescontractfromcontracttoenrollbookrules(integer, character varying) OWNER TO postgres;

--
-- Name: getstatescontractfromcontracttoenrollbookrules(integer, timestamp without time zone, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getstatescontractfromcontracttoenrollbookrules(integer, timestamp without time zone, character varying) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $_$

DECLARE
    result1 RECORD;
    str     text;
    str_aux text;

BEGIN
    str     := '';
    str_aux := '';

    FOR result1 IN SELECT A.stateContractId 
                     FROM acdMovementContract A
               INNER JOIN acdContract B
                       ON (A.contractId = B.contractId)
               INNER JOIN acdLearningPeriod C
                       ON (C.courseId      = B.courseId AND
                           C.courseVersion = B.courseVersion AND
                           C.unitId        = B.unitId AND
                           C.turnId        = B.turnId)
                    WHERE A.stateTime  = $2
                      AND A.contractId = $1
                      AND C.periodId   = $3
                 ORDER BY A.stateTime DESC

    LOOP  
          str     := str_aux || result1.stateContractId;
          str_aux := str     || ',';
    END LOOP;

    RETURN str;

END;
$_$;


ALTER FUNCTION public.getstatescontractfromcontracttoenrollbookrules(integer, timestamp without time zone, character varying) OWNER TO postgres;

--
-- Name: getsuggestionmaterial(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getsuggestionmaterial() RETURNS SETOF type_suggestion_material
    LANGUAGE plpgsql
    AS $$
DECLARE
    vclassification RECORD;
    vcontrolNumber RECORD;
BEGIN
    CREATE TEMP TABLE gtcPersonMaterial (personid bigint, controlnumber int); --tabela temporária para relacionar pessoa a número de controle
    
    FOR vclassification IN SELECT A.personId, 
                                A.classificationareaid, 
                                regexp_split_to_table(B.classification, ', ') as classification, 
                                regexp_split_to_table( regexp_split_to_table(coalesce(B.ignoreclassification,''), ', '), ' ,')  as ignoreclassification
                            FROM gtcinterestsarea A
                    INNER JOIN gtcclassificationarea B
                            USING (classificationareaid)
    LOOP
        FOR vcontrolNumber IN SELECT distinct(A.controlNumber) as controlNumber, 
                                            count(B.*) as max 
                                        FROM gtcexemplarycontrol A 
                                INNER JOIN gtcloan B 
                                    USING (itemnumber) 
                                LEFT JOIN gtcMyLibrary C
                                        ON (C.tableid = 'gtcMaterial')  
                                INNER JOIN gtcMaterial D
                                        USING (controlNumber)
                                    WHERE A.controlNumber NOT IN (SELECT controlnumber 
                                                                    FROM gtcloan 
                                                                INNER JOIN gtcExemplaryControl 
                                                                    USING (itemnumber) 
                                                                    WHERE personid = vclassification.personId)
                                        AND (D.fieldid = '090' AND D.subfieldid = 'a')
                                        AND D.content LIKE (vclassification.classification) 
                                        AND D.content NOT LIKE (vclassification.ignoreclassification)
                                        AND controlNumber NOT IN (SELECT tableid::int FROM gtcMyLibrary WHERE tablename = 'gtcMaterial' AND personId = vclassification.personId)                      
                                    GROUP BY 1 ORDER BY 2 DESC LIMIT 1
        LOOP                    
            INSERT INTO gtcPersonMaterial VALUES ( vclassification.personId, vcontrolNumber.controlnumber );

        END LOOP;            
    END LOOP;

    RETURN QUERY SELECT DISTINCT personId, controlNumber FROM gtcPersonMaterial;

    DROP TABLE gtcPersonMaterial;
    
END;
$$;


ALTER FUNCTION public.getsuggestionmaterial() OWNER TO postgres;

--
-- Name: gettotalbusinessdays(date, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gettotalbusinessdays(p_begindate date, p_enddate date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: gettotalbusinessdays
  DESCRIPTION: Obtem o total de dias úteis entre um período de datas (total de
    dias - dias que nao sao considerados dias uteis pela instituicao).
**************************************************************************************/
DECLARE
BEGIN
    RETURN (SELECT COUNT(*) FROM getbusinessdates(p_beginDate, p_endDate));
END
$$;


ALTER FUNCTION public.gettotalbusinessdays(p_begindate date, p_enddate date) OWNER TO postgres;

--
-- Name: gettotalhours(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gettotalhours(p_contractid integer, p_learningperiodid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: getTotalCredits
  PURPOSE: Obtém o valor total de horas academicos em que o aluno estão matriculado

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       04/03/2013 Jonas Diel    1. FUNÇÂO criada.
**************************************************************************************/
DECLARE

BEGIN
    RETURN SUM(E.academicnumberhours)
                  FROM unit_acdEnroll A
            INNER JOIN unit_acdcurriculum C
                    ON C.curriculumId = A.curriculumId
            INNER JOIN acdCurricularComponent E
                    ON (E.curricularComponentId = C.curricularComponentId AND
                        E.curricularComponentVersion = C.curricularComponentVersion)
            INNER JOIN acdGroup B
		    ON A.groupId = B.groupId 
            INNER JOIN unit_acdlearningperiod D
                    ON D.learningPeriodId = B.learningPeriodId
                 WHERE A.contractId = p_contractId
                   AND D.periodId = (SELECT periodId
                                       FROM unit_acdlearningperiod
                                      WHERE learningPeriodId = p_learningPeriodId)
                   AND A.statusId NOT IN (getParameter('ACADEMIC', 'ENROLL_STATUS_CANCELLED')::INT, getParameter('ACADEMIC', 'ENROLL_STATUS_EXCUSED')::INT, getParameter('ACADEMIC', 'ENROLL_STATUS_DESISTING')::INT ) 
                   AND B.regimenId <> GETPARAMETER('ACADEMIC', 'REGIME_DE_FERIAS')::integer;
END
$$;


ALTER FUNCTION public.gettotalhours(p_contractid integer, p_learningperiodid integer) OWNER TO postgres;

--
-- Name: gettotallearningperioddays(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gettotallearningperioddays(p_learningperiodid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: gettotallearningperioddays
  DESCRIPTION: Obtem o total de dias úteis de um periodo letivo.
**************************************************************************************/
DECLARE
    v_learningPeriod RECORD;
BEGIN
    SELECT INTO v_learningPeriod * FROM acdLearningPeriod WHERE learningPeriodId = p_learningperiodid;

    RETURN (SELECT COUNT(*)
              FROM getbusinessdates(v_learningPeriod.beginDate, v_learningPeriod.endDate) dt
             WHERE

                -- Desconta dias em que nao havera aula
                NOT EXISTS(
                    SELECT 1
                      FROM acdacademiccalendarevent
                     WHERE courseId = v_learningPeriod.courseId
                       AND courseversion = v_learningPeriod.courseVersion
                       AND turnId = v_learningPeriod.turnId
                       AND unitId = v_learningPeriod.unitId
                       AND haveClass IS FALSE
                       AND eventDate = dt
                )
    );
END
$$;


ALTER FUNCTION public.gettotallearningperioddays(p_learningperiodid integer) OWNER TO postgres;

--
-- Name: gettotalmovementstatus(integer, date); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION gettotalmovementstatus(p_contractid integer, v_limitdate date) RETURNS TABLE(intervalcursed interval, intervalclosed interval)
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: getTotalMovementStatus
  DESCRIPTION: Retorna o tempo cursado e de trancamento de determinado período

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       20/08/2013 Jonas Diel        Função Criada
******************************************************************************/
DECLARE
    v_counterMovement RECORD;    
    v_intervalCursed INTERVAL; --Intervalo de tempo cursado
    v_intervalClosed INTERVAL; --Intervalo de tempo trancado

    v_beforeMovement RECORD;
    v_firstMovement BOOLEAN;
BEGIN
    v_intervalCursed := 0;
    v_intervalClosed := 0;

    v_firstMovement := TRUE;

    FOR v_counterMovement IN 
                  SELECT A.stateContractId,
                         A.stateTime,
                         A.learningPeriodId,
                         B.inouttransition,
                         B.isclosecontract
                    FROM acdMovementContract A
              INNER JOIN acdStateContract B
                      ON B.stateContractId = A.stateContractId
                   WHERE contractId = p_contractId 
                ORDER BY A.statetime
    LOOP

        v_counterMovement.stateTime := COALESCE(v_limitDate::timestamp, v_counterMovement.stateTime);
    
        IF v_firstMovement IS FALSE THEN --Não for a primeira linha

            IF v_counterMovement.isclosecontract IS TRUE THEN --A movimentação tranca o contrato
                            
                IF v_beforeMovement.isclosecontract IS FALSE THEN --Verifica a anterior
                    v_intervalCursed := v_intervalCursed + (v_counterMovement.stateTime - v_beforeMovement.stateTime)::interval;
                ELSE --Calcula tempo de trancamento                    
                    v_intervalClosed := v_intervalClosed + (v_counterMovement.stateTime - v_beforeMovement.stateTime)::interval;
                END IF;

            ELSE --A movimentação nao tranca o contrato       

                IF v_beforeMovement.isclosecontract IS TRUE THEN --Verifica a anterior
                    v_intervalCursed := v_intervalCursed + (now() - v_counterMovement.stateTime)::interval;
                ELSE --soma intervalo cursado                    
                    v_intervalCursed := v_intervalCursed + (v_counterMovement.stateTime - v_beforeMovement.stateTime)::interval;
                END IF;

            END IF;          
        END IF;       

        v_beforeMovement := v_counterMovement;
        v_firstMovement := FALSE;
    END LOOP;

    RETURN QUERY SELECT v_intervalCursed, v_intervalClosed;
    
    END;
$$;


ALTER FUNCTION public.gettotalmovementstatus(p_contractid integer, v_limitdate date) OWNER TO solis;

--
-- Name: gettotalteachedhours(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gettotalteachedhours(p_groupid integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: getTotalTeachedHours
  PURPOSE: Obtém a quantidade de horas já ministradas da oferecida.
  DESCRIPTION:
  Pesquisa a tabela acdScheduleProfessorContent, somando os timeIds de todas as aulas
  jÃ© ministradas. Utilizado para determinar o percentual de frequência do aluno frente
  ao total de aulas ministradas.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       10/06/2011 Alex Smith        1. FUNÇÃO criada.
**************************************************************************************/
DECLARE
    v_totalHours float;
BEGIN
    SELECT COALESCE(SUM((EXTRACT(HOUR   FROM (B.endHour - B.beginHour)) +
                         EXTRACT(MINUTE FROM (B.endHour - B.beginHour)) / 60 +
                         EXTRACT(SECOND FROM (B.endHour - B.beginHour)) / 60 / 60)::float), 0) INTO v_totalHours
      FROM acdScheduleProfessorContent A
INNER JOIN acdTime B
        ON B.timeId = A.timeId
INNER JOIN acdScheduleProfessor C
        ON C.scheduleProfessorId = A.scheduleProfessorId
INNER JOIN acdSchedule D
        ON D.scheduleId = C.scheduleId
     WHERE A.classOccurred
       AND D.groupId = p_groupId;

    RETURN v_totalHours;
END;
$$;


ALTER FUNCTION public.gettotalteachedhours(p_groupid integer) OWNER TO postgres;

--
-- Name: getturncharid(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getturncharid(integer) RETURNS character
    LANGUAGE sql
    AS $_$ SELECT charid
  FROM basTurn
 WHERE turnId = $1$_$;


ALTER FUNCTION public.getturncharid(integer) OWNER TO postgres;

--
-- Name: getturndescription(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getturndescription(integer) RETURNS character varying
    LANGUAGE sql
    AS $_$
SELECT description
  FROM basTurn
 WHERE turnId = $1$_$;


ALTER FUNCTION public.getturndescription(integer) OWNER TO postgres;

--
-- Name: getunitdescription(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getunitdescription(integer) RETURNS character varying
    LANGUAGE sql
    AS $_$
SELECT description
  FROM basUnit
 WHERE unitId = $1$_$;


ALTER FUNCTION public.getunitdescription(integer) OWNER TO postgres;

--
-- Name: getunitparameter(character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION getunitparameter(p_moduleconfig character varying, p_parameter character varying, p_unitid integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: getUnitParameter
  PURPOSE: Retorna um varchar contendo o valor de um parÃ©metro para a unidade desejada.
**************************************************************************************/
DECLARE
    v_retVal varchar;
BEGIN
    -- Se nÃ£o tiver passado o mÃ©dulo
    IF ( p_moduleConfig IS NULL )
    THEN
        RAISE EXCEPTION 'VocÃ© deve informar um mÃ©dulo.';
    -- Se nÃ£o tiver passado o parÃ©metro
    ELSIF ( p_parameter IS NULL )
    THEN
        RAISE EXCEPTION 'VocÃ© deve informar um parÃ©metro.';
    -- Se nÃ£o tiver passado a unidade
    ELSIF ( p_unitid IS NULL )
    THEN
        RAISE EXCEPTION 'VocÃ© deve informar uma unidade.';
    END IF;
    

    -- Busca o valor do parÃ©metro para a unidade desejada
    SELECT COALESCE(UC.value, C.value) INTO v_retVal
      FROM basConfig C
 LEFT JOIN basUnitConfig UC ON UC.unitid = p_unitid
       AND (UC.moduleConfig, UC.parameter) = (C.moduleConfig, C.parameter)
     WHERE (C.moduleConfig, C.parameter) = (UPPER(p_moduleConfig), UPPER(p_parameter));

    -- Caso nÃ£o consiga obter o valor, erro:
    IF ( v_retVal IS NULL )
    THEN
        RAISE EXCEPTION 'O parÃ©metro % nÃ£o existe no mÃ©dulo % para a unidade selecionada.', p_parameter, p_moduleConfig;
    END IF;

    RETURN v_retVal;
END;
$$;


ALTER FUNCTION public.getunitparameter(p_moduleconfig character varying, p_parameter character varying, p_unitid integer) OWNER TO solis;

--
-- Name: getworkphone(bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getworkphone(bigint) RETURNS character varying
    LANGUAGE sql
    AS $_$
    SELECT phone FROM basphone WHERE type = 'PRO' AND personId = $1
$_$;


ALTER FUNCTION public.getworkphone(bigint) OWNER TO postgres;

--
-- Name: gtc_chk_domain(character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gtc_chk_domain(p_domain character varying, p_key character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_result boolean;
BEGIN

    --Se o valor do dominio for nulo permite inserir pois, em alguns casos, o campo da tabela em questão pode aceitar NULL.
    IF p_key iS NULL
    THEN
        RETURN TRUE;
    END IF;

    PERFORM * FROM basDomain LIMIT 1;
    IF NOT FOUND
    THEN
        RETURN TRUE; --Caso não haja nenhum dado na basDomain retorna como true. Isso é para resolver o bug do postgres que não ignora os check no dump
    END IF;

    SELECT INTO v_result count(*) > 0
        FROM basDomain
        WHERE domainId = p_domain
            AND key = p_key;

    RETURN v_result;

END;
$$;


ALTER FUNCTION public.gtc_chk_domain(p_domain character varying, p_key character varying) OWNER TO postgres;

--
-- Name: gtc_chk_parameter(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gtc_chk_parameter(p_parameter text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_result boolean;
BEGIN
        SELECT INTO v_result count(*) > 0 FROM basConfig WHERE parameter = p_parameter;
        
        RETURN v_result;
END;
$$;


ALTER FUNCTION public.gtc_chk_parameter(p_parameter text) OWNER TO postgres;

--
-- Name: gtcfnc_updatesearchmaterialviewtable(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gtcfnc_updatesearchmaterialviewtable() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
            BEGIN

                DELETE FROM gtcSearchMaterialView;
                INSERT INTO gtcSearchMaterialView SELECT * FROM searchMaterialView;

                DELETE FROM gtcSearchTableUpdateControl;
                INSERT INTO gtcSearchTableUpdateControl (lastUpdate) values (now());

                RETURN OLD;
            END;
        $$;


ALTER FUNCTION public.gtcfnc_updatesearchmaterialviewtable() OWNER TO postgres;

--
-- Name: gtcfnc_updatesearchmaterialviewtablebool(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gtcfnc_updatesearchmaterialviewtablebool() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    lastUpdate_ BOOLEAN;
BEGIN
    --Havia problemas de corromper o indice. Então sempre exclui o indice e recria
    DROP INDEX index_gtcsearchmaterialview_controlnumber;

    DELETE FROM gtcSearchMaterialView;

    CREATE INDEX index_gtcsearchmaterialview_controlnumber ON gtcSearchMaterialView(controlnumber);

    INSERT INTO gtcSearchMaterialView SELECT * FROM searchMaterialView;

    DELETE FROM gtcSearchTableUpdateControl;
    INSERT INTO gtcSearchTableUpdateControl (lastUpdate) values (now());

    RETURN TRUE;
END;
$$;


ALTER FUNCTION public.gtcfnc_updatesearchmaterialviewtablebool() OWNER TO postgres;

--
-- Name: gtcfncupdatematerialson(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gtcfncupdatematerialson() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE

        row_data    RECORD;
        row_data1   RECORD;

        fatherCategory  char(2);
        fatherLevel     char(1);

        loopX       int;
        tag         char(5);
        fieldS      char(3);
        subFieldS   char(1);

        currentControlNumber    int;
        currentFieldId          char(3);
        currentSubFieldId       char(1);
        currentContent          text;
        currentSearchContent    text;
        currentLine             int;

    BEGIN

        IF (TG_OP != 'DELETE') THEN

            currentControlNumber    := NEW.controlnumber;
            currentFieldId          := NEW.fieldid;
            currentSubFieldId       := NEW.subfieldid;
            currentContent          := NEW.content;
            currentSearchContent    := NEW.searchcontent;
            currentLine             := NEW.line;

        ELSE

            currentControlNumber    := OLD.controlnumber;
            currentFieldId          := OLD.fieldid;
            currentSubFieldId       := OLD.subfieldid;
            currentContent          := OLD.content;
            currentSearchContent    := OLD.searchcontent;
            currentLine             := OLD.line;

        END IF;

        /**
        * BUSCA CATEGORIA E LEVEL DO PAI
        */
        FOR row_data IN (SELECT  category, level FROM  gtcMaterialControl WHERE  controlnumber = currentControlNumber)
        LOOP
            fatherCategory  := row_data.category;
            fatherLevel     := row_data.level;
        END LOOP;

        FOR row_data1 IN
        (
            SELECT  LK.tag, LK.tagson, MC.controlnumber
            FROM  gtcmaterialcontrol MC
        INNER JOIN  gtclinkoffieldsbetweenspreadsheets LK
                ON  (MC.category = LK.categoryson AND MC.level = LK.levelson )
            WHERE  LK.category         = fatherCategory
            AND  LK.level            = fatherLevel
            AND  LK.tag      like    ('%' || currentFieldId || '.' || currentSubFieldId || '%')
            AND  MC.controlnumberfather = currentControlNumber
            AND  LK.type = '2'
        )
        LOOP

            IF (strpos(row_data1.tagson, ',') = 0) THEN
                row_data1.tagson = row_data1.tagson || ',';
            END IF;

            loopX := 1;

            LOOP

                tag = split_part(row_data1.tagson, ',', loopX);

                IF char_length(tag) = 0 THEN
                    EXIT;
                END IF;

                fieldS      := split_part(tag, '.', 1);
                subFieldS   := split_part(tag, '.', 2);

                IF (TG_OP = 'DELETE') THEN

                    DELETE FROM gtcMaterial
                    WHERE controlnumber    = row_data1.controlnumber
                    AND fieldid          = fieldS
                    AND subfieldid       = subFieldS
                    AND line             = currentLine;

                ELSIF (TG_OP = 'UPDATE') THEN

                    UPDATE gtcMaterial
                    SET content          = currentContent,
                        searchcontent    = currentSearchContent
                    WHERE controlnumber    = row_data1.controlnumber
                    AND fieldid          = fieldS
                    AND subfieldid       = subFieldS
                    AND line             = currentLine;

                ELSIF (TG_OP = 'INSERT') THEN
                    --Deleta para garantir que nao tera nenhuma informacao que va gerar erro de chave duplicada ao tentar inserir o material
                    DELETE FROM gtcMaterial WHERE controlnumber =  row_data1.controlnumber AND fieldid = fieldS AND subfieldid = subFieldS AND line = currentLine;

                    INSERT INTO gtcMaterial
                        (content, searchcontent, controlnumber, fieldid, subfieldid, line)
                    VALUES
                        (currentContent, currentSearchContent, row_data1.controlnumber, fieldS, subFieldS, currentLine);

                END IF;

                loopX := loopX + 1;

            END LOOP;

        END LOOP;

        RETURN NULL;
    END;
$$;


ALTER FUNCTION public.gtcfncupdatematerialson() OWNER TO postgres;

--
-- Name: gtcgnccheckhelp(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gtcgnccheckhelp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_result boolean;
BEGIN

    IF ( TG_OP = 'UPDATE' )
    THEN
        IF ( (NEW.form = OLD.form) )
        THEN
            IF ( NEW.subform IS NOT NULL )
            THEN
                IF ( NEW.subform = OLD.subform )
                THEN
                    RETURN NEW;
                END IF;
            ELSE
                RETURN NEW;
            END IF; 
        END IF;
        
        RAISE EXCEPTION 'Não é possível alterar o formulário deste registro.';    
    ELSE
        IF (NEW.subform IS NULL )
        THEN
            SELECT into v_result count(*) = 0
            FROM gtcHelp
            WHERE form = NEW.form
                AND subform IS NULL;
        ELSE
        
            SELECT into v_result count(*) = 0 
            FROM gtcHelp
            WHERE form = NEW.form
                AND subform = NEW.subform;
        END IF;
        
        IF ( v_result )
        THEN
            RETURN NEW;
        END IF;
        
        RAISE EXCEPTION 'Já existe um registo para este formulário.';
    END IF;
    
    RETURN NULL;    

END;
$$;


ALTER FUNCTION public.gtcgnccheckhelp() OWNER TO postgres;

--
-- Name: gtcnadaconsta(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gtcnadaconsta(person integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_result boolean;
BEGIN
    SELECT into v_result SUM(quantidade) = 0 FROM gtcObterRestricoes(person);
    
    RETURN v_result;
END; 
$$;


ALTER FUNCTION public.gtcnadaconsta(person integer) OWNER TO postgres;

--
-- Name: gtcobterrestricoes(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gtcobterrestricoes(p_personid integer) RETURNS SETOF type_obter_restricoes
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY 
        SELECT 'Penalidade' AS "tipo",
               obterQuantPenalidades(p_personid) AS "quantidade"

         UNION
        SELECT 'Multas' AS "tipo",
               obterQuantMultas(p_personid) AS "quantidade"

         UNION
        SELECT 'Empréstimos atrasados' AS "tipo",
               obterQuantEmprestimos(p_personid) AS "quantidade";
END;
$$;


ALTER FUNCTION public.gtcobterrestricoes(p_personid integer) OWNER TO postgres;

--
-- Name: gtcobterrestricoesparasagu(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gtcobterrestricoesparasagu(person integer) RETURNS SETOF type_obter_restricoes
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
	RETURN QUERY
	SELECT
		'Penalidade' AS tipo,
		( SELECT COUNT()
		  FROM gtcpenalty
		  WHERE coalesce( penaltyEndDate > now(), penaltyEndDate IS NULL )
		  AND personid = person ) as quantidade
	UNION
	(
		SELECT 'Multas' AS tipo,
		( SELECT COUNT()
		  FROM gtcfine f
		  LEFT JOIN gtcloan l
		  ON f.loanid = l.loanid
		  WHERE finestatusid = ( SELECT value FROM basconfig WHERE parameter ='ID_FINESTATUS_OPEN' )::int
		  AND personid = person ) as quantidade
	)
	UNION
	(
		SELECT 'Total de Empréstimos' AS tipo,
		( SELECT count()
		  FROM gtcloan
		  WHERE personid = person
		  AND returndate is null ) as quantidade
	)
	UNION
	(
		SELECT 'Empréstimos atrasados' AS tipo,
		( SELECT count()
		  FROM gtcloan
		  WHERE personid = person
		  AND returndate is null
		  AND returnforecastdate < NOW ) as quantidade
	);
END;
$$;


ALTER FUNCTION public.gtcobterrestricoesparasagu(person integer) OWNER TO postgres;

--
-- Name: gtcpersonunion(bigint, bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION gtcpersonunion(stayperson bigint, outperson bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_supporterId INTEGER;
BEGIN
        PERFORM * FROM basPerson WHERE personId = stayPerson LIMIT 1;
        IF NOT FOUND
        THEN
            RAISE EXCEPTION 'Pessoa % não existe.' , stayPerson;
        END IF;
        PERFORM * FROM basPerson WHERE personId = outPerson;
        IF NOT FOUND
        THEN
            RAISE EXCEPTION 'Pessoa % não existe.' , outPerson;
        END IF;
        IF stayPerson = outPerson 
        THEN
            RAISE EXCEPTION 'é necessário escolher duas pessoas diferentes.';
        END IF;

        --UNIÃO.
        -- empréstimos
        UPDATE gtcLoan SET personId = stayPerson WHERE personId = outPerson;
        -- emprésimos entre biblioteca
        UPDATE gtcLoanBetweenLibrary SET personId = stayPerson WHERE personId = outPerson; 
        -- avaliação
        UPDATE gtcMaterialEvaluation SET personId = stayPerson WHERE personId = outPerson;
        -- mINha biblioteca
        UPDATE gtcMylibrary SET personId = stayPerson WHERE personId = outPerson;
        -- penalidades
        UPDATE gtcPenalty SET personId = stayPerson WHERE personId = outPerson;
        -- solicitação de compras
        UPDATE gtcPurchaseRequest SET personId = stayPerson WHERE personId = outPerson;
        -- solicitação de alteração de estado do exempla (congelamento)
        UPDATE gtcRequestChangeExemplaryStatus SET personId = stayPerson WHERE personId = outPerson;
        -- reservas
        UPDATE gtcReserve SET personId = stayPerson WHERE personId = outPerson;
        --CONTROLE DE NOTIFICAçãO DE E-MAIL DE REQUISIçãO.
        UPDATE gtcEmailControlNotifyAquisition SET personId = stayPerson WHERE personId = outPerson;
        --MANTER A DA PESSOA SELECIONADA, REMOVER AS OUTRAS.
        DELETE FROM gtcPersonConfig WHERE personId = outPerson;

        --TELEFONES
        INSERT INTO basPhone 
                    (personId, 
                    type ,phone)    
            (SELECT stayPerson,     
                    type, 
                    phone 
               FROM basPhone 
              WHERE personId = outPerson 
                AND type 
                 IN ( SELECT type 
               FROM basPhone 
              WHERE personId = outPerson EXCEPT
             SELECT type 
               FROM basPhone 
              WHERE personId = stayPerson)
            );

         DELETE FROM basPhone where personId = outPerson;

        --AREAS DE INTERESSE.
        INSERT INTO gtcInterestsArea
                    (personId,
                    classificationAreaId )
            (SELECT stayPerson,
                    classificationAreaId
               FROM gtcINterestsarea
              WHERE personId = outPerson
                AND classificationAreaId
             NOT IN ( SELECT classificationAreaId
               FROM gtcInterestsArea
              WHERE personId = stayPerson)
             );

        DELETE FROM gtcInterestsarea WHERE personId = outPerson;

        --LIGAçãO ENTRE PESSOAS
        INSERT INTO baspersonlink
                    (personId, 
                    linkId, 
                    dateValidate ) 
            (SELECT stayPerson, 
                    linkId, 
                    dateValidate 
               FROM baspersonLink               
              WHERE personId = outPerson 
                AND linkId NOT IN 
           ( SELECT linkId 
               FROM basPersonLink 
              WHERE personId = stayPerson)
           );

        DELETE FROM basPersonLink WHERE personId = outPerson;

        --ANALéTICA

        UPDATE gtcAnalytics set personId = stayPerson where personId = outPerson;

        DELETE FROM gtcAnalytics WHERE personId = outPerson;

        --FAVORITOS
       INSERT INTO gtcFavorite 
                   (personId, 
                   controlNumber) 
           (select stayPerson, 
                   controlNumber 
              from gtcFavorite 
             where personId = outPerson 
               and controlNumber not in 
           (select controlNumber 
              from gtcFavorite 
             where personId = stayPerson)
           );

       DELETE FROM gtcFavorite where personId = outPerson;

       --PESSOAS NAS UNIDADES DE BIBLOTECA
       INSERT INTO gtcPersonLibraryUnit
                   (personId, 
                   libraryUnitId)    
                (SELECT stayPerson,     
                        libraryUnitId
                   FROM gtcPersonLibraryUnit
                  WHERE personId = outPerson 
                    AND libraryUnitId
                 NOT IN ( SELECT libraryUnitId
                   FROM gtcPersonLibraryUnit
                  WHERE personId = stayPerson)
                );

       DELETE FROM gtcPersonLibraryUnit where personId = outPerson;

        --DOCUMENTOS
        INSERT INTO basDocument 
                    (personId, 
                    documentTypeId) 
            (SELECT stayPerson, documentTypeId 
               FROM basDocument 
              WHERE personId = outPerson 
                AND documentTypeId  
             NOT IN (SELECT documentTypeId 
               FROM basDocument  
              WHERE personId = stayPerson)
            );

        DELETE FROM basDocument where personId = outPerson;

        IF (existTable( 'basphysicalperson' ))
        THEN
            IF (existContract( outperson ))
            THEN
                UPDATE acdContract SET personId = stayperson WHERE personId = outperson;
            END IF;

        INSERT INTO basphysicalpersonkinship
                    (personid,
                     relativepersonid,
                     kinshipid,
                     datetime
                    ) 
            (SELECT stayPerson , 
                    relativepersonid, 
                    kinshipid,
                    datetime
               FROM basphysicalpersonkinship            
              WHERE personId = outPerson 
                AND kinshipid NOT IN 
           ( SELECT kinshipid
               FROM basphysicalpersonkinship
              WHERE personId = stayPerson )
           );
        DELETE FROM basphysicalpersonkinship WHERE personid = outPerson;
        UPDATE basphysicalpersonkinship SET relativepersonid = stayPerson WHERE relativepersonid = outPerson;

        INSERT INTO basbadgeloan
                    (personid,
                     datetime,
                     loanid, 
                     badgeid, 
                     loandate,  
                     expectedreturndate) 
            (SELECT stayPerson,
                    datetime, 
                    loanid,
                    badgeid,
                    loandate,
                    expectedreturndate
               FROM basbadgeloan            
              WHERE personId = outPerson 
                AND badgeid NOT IN 
           ( SELECT badgeid
               FROM basbadgeloan
              WHERE personId = stayPerson)
           );
        DELETE FROM basbadgeloan WHERE personid = outPerson;

        INSERT INTO bashistoricofuncional
                    (personid,
                     datetime,
                     historicofuncionalid,
                     data, 
                     assunto, 
                     inicio,  
                     observacao) 
            (SELECT stayPerson,
                    datetime, 
                    historicofuncionalid,
                    data,
                    assunto,
                    inicio,
                    observacao
               FROM bashistoricofuncional           
              WHERE personId = outPerson 
                AND historicofuncionalid NOT IN 
           ( SELECT historicofuncionalid
               FROM bashistoricofuncional
              WHERE personId = stayPerson)
           );
        DELETE FROM bashistoricofuncional WHERE personid = outPerson;

        INSERT INTO basprofessionalactivitypeople
                    (personid,
                     datetime,
                     professionalactivitypeopleid,
                     professionalactivityid, 
                     legalpersonid, 
                     begindate,  
                     professionalactivitylinktypeid) 
            (SELECT stayPerson,
                    datetime, 
                    professionalactivitypeopleid,
                    professionalactivityid,
                    legalpersonid,
                    begindate,
                    professionalactivitylinktypeid
               FROM basprofessionalactivitypeople           
              WHERE personId = outPerson 
                AND professionalactivityid NOT IN 
           ( SELECT professionalactivityid
               FROM basprofessionalactivitypeople
              WHERE personId = stayPerson)
           );
        DELETE FROM basprofessionalactivitypeople WHERE personid = outPerson;

        INSERT INTO bassectorboss
                    (bossid,
                     sectorid,
                     issendemail, 
                     email 
                     ) 
            (SELECT stayPerson,
                    sectorid,
                    issendemail, 
                    email
               FROM bassectorboss   
              WHERE bossid = outPerson 
                AND sectorid NOT IN 
           ( SELECT sectorid 
               FROM bassectorboss
              WHERE bossid = stayPerson)
           );
        DELETE FROM bassectorboss WHERE bossid = outPerson;

        INSERT INTO basstamp
                    (personid,
                     datetime,
                     stampid,
                     functiondescription 
                     ) 
            (SELECT stayPerson,
                    datetime, 
                    stampid,
                    functiondescription
               FROM basstamp            
              WHERE personId = outPerson 
                AND stampid NOT IN 
           ( SELECT stampid
               FROM basstamp
              WHERE personId = stayPerson)
           );
        DELETE FROM basstamp WHERE personid = outPerson;

        INSERT INTO basphysicalpersonprofessor 
                    ( personid , 
                    persondv , 
                    personmask , 
                    name , 
                    shortname , 
                    cityid , 
                    zipcode , 
                    location , 
                    number , 
                    complement , 
                    neighborhood , 
                    email , 
                    emailalternative , 
                    url , 
                    datein , 
                    password , 
                    isallowpersonaldata , 
                    miolousername , 
                    locationtypeid , 
                    sentemail , 
                    photoid , 
                    login , 
                    obs , 
                    sex , 
                    maritalstatusid , 
                    residentialphone , 
                    workphone , 
                    cellphone , 
                    messagephone , 
                    messagecontact , 
                    datebirth , 
                    cityidbirth , 
                    countryidbirth , 
                    responsablelegalid , 
                    carplate , 
                    specialnecessityid , 
                    specialnecessitydescription , 
                    cityidwork , 
                    zipcodework , 
                    locationwork , 
                    complementwork , 
                    neighborhoodwork , 
                    ethnicoriginid , 
                    datedeath , 
                    persontitleid , 
                    locationtypeidwork , 
                    mothername ,    
                    fathername , 
                    workemployername , 
                    workfunction , 
                    workstartdate ,
                    workenddate , 
                    workathome , 
                    ethnicorigin , 
                    identifier ) 
          ( SELECT  stayperson, 
                    persondv , 
                    personmask , 
                    name , 
                    shortname , 
                    cityid , 
                    zipcode , 
                    location , 
                    number , 
                    complement , 
                    neighborhood , 
                    email , 
                    emailalternative , 
                    url , 
                    datein , 
                    password , 
                    isallowpersonaldata , 
                    miolousername ,         
                    locationtypeid , 
                    sentemail , 
                    photoid , 
                    login , 
                    obs , 
                    sex , 
                    maritalstatusid , 
                    residentialphone , 
                    workphone ,         
                    cellphone  , 
                    messagephone , 
                    messagecontact ,    
                    datebirth , 
                    cityidbirth , 
                    countryidbirth , 
                    responsablelegalid , 
                    carplate , 
                    specialnecessityid , 
                    specialnecessitydescription , 
                    cityidwork , 
                    zipcodework , 
                    locationwork , 
                    complementwork , 
                    neighborhoodwork , 
                    ethnicoriginid , 
                    datedeath , 
                    persontitleid , 
                    locationtypeidwork , 
                    mothername , 
                    fathername , 
                    workemployername , 
                    workfunction , 
                    workstartdate , 
                    workenddate , 
                    workathome , 
                    ethnicorigin , 
                    identifier 
               FROM basphysicalpersonprofessor 
              WHERE personid = outperson);

        INSERT INTO basprofessorcommitment
                    (personid,
                     datetime,
                     begindate,
                     workload 
                     ) 
            (SELECT stayPerson,
                    datetime, 
                    begindate,
                    workload
               FROM basprofessorcommitment          
              WHERE personId = outPerson 
                AND begindate NOT IN 
           ( SELECT begindate
               FROM basprofessorcommitment
              WHERE personId = stayPerson)
           );
        DELETE FROM basprofessorcommitment WHERE personid = outPerson; 

        UPDATE fininvoice SET personId = stayPerson WHERE personId = outPerson;

        INSERT INTO acdprofessorformation
                    (professorid,
                     formationlevelid,
                     externalcourseid,
                     begindate,
                     dateconclusion,
                     institutionid 
                     ) 
            (SELECT stayPerson,
                    formationlevelid,
                    externalcourseid,
                    begindate,
                    dateconclusion,
                    institutionid 
               FROM acdprofessorformation           
              WHERE professorid = outPerson 
                AND formationlevelid NOT IN 
           ( SELECT formationlevelid
               FROM acdprofessorformation
              WHERE professorid = stayPerson)
                AND externalcourseid NOT IN
           ( SELECT externalcourseid
               FROM acdprofessorformation
              WHERE professorid = stayPerson));
         DELETE FROM acdprofessorformation WHERE professorid = outPerson;

   INSERT INTO acdprofessorcenter
                    (professorid,
                     centerid,
                     begindate 
                     ) 
            (SELECT stayPerson,
                    centerid,
                    begindate
               FROM acdprofessorcenter      
              WHERE professorid = outPerson 
                AND centerid NOT IN 
           ( SELECT centerid
               FROM acdprofessorcenter
              WHERE professorid = stayPerson));
    DELETE FROM acdprofessorcenter WHERE professorid = outPerson;

    INSERT INTO basphysicalpersonemployee 
                (personid , 
                persondv , 
                personmask , 
                name , 
                shortname , 
                cityid , 
                zipcode , 
                location , 
                number , 
                complement , 
                neighborhood , 
                email , 
                emailalternative , 
                url , 
                datein , 
                password , 
                isallowpersonaldata , 
                miolousername ,     
                locationtypeid , 
                sentemail , 
                photoid , 
                login , 
                obs , 
                sex , 
                maritalstatusid , 
                residentialphone , 
                workphone , 
                cellphone , 
                messagephone , 
                messagecontact , 
                datebirth , 
                cityidbirth , 
                countryidbirth , 
                responsablelegalid , 
                carplate , 
                specialnecessityid , 
                specialnecessitydescription , 
                cityidwork , 
                zipcodework , 
                locationwork , 
                complementwork , 
                neighborhoodwork , 
                ethnicoriginid , 
                datedeath , 
                persontitleid , 
                locationtypeidwork ,    
                mothername , 
                fathername ,
                workemployername , 
                workfunction , 
                workstartdate , 
                workenddate , 
                workathome , 
                ethnicorigin ,  
                identifier) 
       ( SELECT stayperson ,   
                persondv , 
                personmask , 
                name , 
                shortname , 
                cityid , 
                zipcode , 
                location , 
                number , 
                complement , 
                neighborhood , 
                email , 
                emailalternative , 
                url , 
                datein , 
                password , 
                isallowpersonaldata , 
                miolousername , 
                locationtypeid , 
                sentemail , 
                photoid , 
                login , 
                obs , 
                sex , 
                maritalstatusid , 
                residentialphone , 
                workphone , 
                cellphone , 
                messagephone , 
                messagecontact , 
                datebirth , 
                cityidbirth , 
                countryidbirth , 
                responsablelegalid , 
                carplate , 
                specialnecessityid , 
                specialnecessitydescription , 
                cityidwork , 
                zipcodework , 
                locationwork , 
                complementwork , 
                neighborhoodwork , 
                ethnicoriginid , 
                datedeath , 
                persontitleid , 
                locationtypeidwork , 
                mothername , 
                fathername , 
                workemployername , 
                workfunction , 
                workstartdate , 
                workenddate , 
                workathome , 
                ethnicorigin , 
                identifier 
           FROM basphysicalpersonemployee 
          WHERE personid = outperson);

    INSERT INTO basemployee
                    (personid,
                     employeetypeid 
                     ) 
            (SELECT stayPerson,
                    employeetypeid
               FROM basemployee     
              WHERE personid = outPerson 
                AND employeetypeid NOT IN 
           ( SELECT employeetypeid
               FROM basemployee
              WHERE personid = stayPerson));
    DELETE FROM basemployee WHERE personid = outPerson;

    INSERT INTO  Acdmoodlesubscription
                    (personId, 
                    groupid)    
            (SELECT stayPerson,
                    groupid     

               FROM Acdmoodlesubscription
              WHERE personId = outPerson 
                AND groupid
                 IN ( SELECT groupid
               FROM Acdmoodlesubscription 
              WHERE personId = outPerson EXCEPT
             SELECT groupid 
               FROM Acdmoodlesubscription 
              WHERE personId = stayPerson)
            );

         DELETE FROM Acdmoodlesubscription  where personId = outPerson;

        DELETE FROM basphysicalperson WHERE personId = outperson; 
        DELETE FROM basphysicalpersonprofessor WHERE personId = outperson;
        DELETE FROM basphysicalpersonemployee WHERE personId = outperson; 
        DELETE FROM basphysicalpersonstudent WHERE personId = outperson; 
        UPDATE fininvoice SET personId = stayPerson WHERE personId = outPerson; 
        UPDATE basphysicalperson SET responsablelegalid = stayPerson WHERE responsablelegalid = outPerson;
    END IF;

    IF getParameter('BASIC', 'MODULE_FINANCE_INSTALLED') = 'YES' 
    THEN
	SELECT INTO v_supporterId
		    supporterId
	       FROM finincentive
	      WHERE supporterId = outPerson;

	IF v_supporterId = outPerson
	THEN
	   UPDATE finincentive
	      SET supporterid = stayPerson
	    WHERE supporterid = outPerson;
	END IF;	
    END IF;

    DELETE FROM basDocument where personId = outPerson;
    DELETE FROM gtcLibPerson WHERE personId = outPerson;
    DELETE FROM basPerson WHERE personId = outperson;

    RETURN true;

END;
$$;


ALTER FUNCTION public.gtcpersonunion(stayperson bigint, outperson bigint) OWNER TO postgres;

--
-- Name: has_subscription_status(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION has_subscription_status(p_subscriptionid integer, p_subscriptionstatusid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: HAS_SUBSCRIPTION_STATUS
  PURPOSE: Verifica se ha algum status especifico para algum subscriptionId

  DESCRIPTION: Caso haja algum status (Ex: APROVADO) (passado na funcao) na
    spr.subscriptionOption para o subscriptionId informado, retorna TRUE, senao, FALSE.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       29/04/2011 Moises Heberle    1. Funcao criada.
**************************************************************************************/
DECLARE
BEGIN
    RETURN (   SELECT COUNT(*)
                      FROM spr.subscription A
             INNER JOIN spr.subscriptionOption B
                         ON (A.subscriptionId = B.subscriptionId)
             INNER JOIN spr.subscriptionStatus C
                         ON (C.subscriptionStatusId = B.subscriptionStatusId)
                    WHERE B.subscriptionStatusId = p_subscriptionStatusId) > 0;
END;
$$;


ALTER FUNCTION public.has_subscription_status(p_subscriptionid integer, p_subscriptionstatusid integer) OWNER TO postgres;

--
-- Name: hascontractualmovement(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION hascontractualmovement(integer, integer, integer) RETURNS boolean
    LANGUAGE sql
    AS $_$
SELECT CASE WHEN ( count(*) > 0 ) THEN true ELSE false END 
  FROM acdMovementContract
 WHERE contractId = $1
   AND learningPeriodId = $2
   AND statecontractid = $3;
$_$;


ALTER FUNCTION public.hascontractualmovement(integer, integer, integer) OWNER TO postgres;

--
-- Name: hasenroll(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION hasenroll(integer, integer, integer) RETURNS boolean
    LANGUAGE sql
    AS $_$
    SELECT CASE WHEN ( count(*) > 0 ) THEN true ELSE FALSE END 
                FROM acdEnroll A
          INNER JOIN acdGroup B
               USING ( groupId )
               WHERE A.contractId = $1
                 AND B.learningPeriodId = $2
                 AND A.statusId <> $3$_$;


ALTER FUNCTION public.hasenroll(integer, integer, integer) OWNER TO postgres;

--
-- Name: inheritancehierarchy(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION inheritancehierarchy(oid integer) RETURNS SETOF integer
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
    aux integer;
    flag integer;
BEGIN
    aux:=oid;
    select into flag count(inhparent) FROM pg_inherits WHERE inhrelid = aux;
    WHILE (flag>0)
    LOOP
          RETURN NEXT aux;
          SELECT into aux inhparent FROM pg_inherits WHERE inhrelid = aux;
          select into flag count(inhparent) FROM pg_inherits WHERE inhrelid = aux;
    END LOOP;
    RETURN;
END;
$$;


ALTER FUNCTION public.inheritancehierarchy(oid integer) OWNER TO postgres;

--
-- Name: insere_data_de_competencia(); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION insere_data_de_competencia() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    
BEGIN
    IF NEW.competencydate IS NOT NULL THEN
        RETURN NEW;
    ELSE
        UPDATE fininvoice 
           SET competencydate = NEW.referencematuritydate 
         WHERE invoiceid = NEW.invoiceid;

        RETURN NEW;
    END IF;
END;
$$;


ALTER FUNCTION public.insere_data_de_competencia() OWNER TO solis;

--
-- Name: insere_fininfotitulo(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION insere_fininfotitulo() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
                  BEGIN
                      IF TG_OP = 'INSERT' THEN
                        INSERT INTO fininfotitulo (
                                    matricula,
                                    nome,
                                    titulo,
                                    vencimento,
                                    referencia,
                                    cod_origem,
                                    origem
                                    ) 
                             VALUES (NEW.personid, 
                                     getpersonname(NEW.personid), 
                                     NEW.invoiceid,
                                     NEW.maturitydate,
                                     NEW.referencematuritydate,
                                     NEW.incomesourceid,
                                     (SELECT description FROM finincomesource WHERE incomesourceid = NEW.incomesourceid)
                                    );
                      END IF;

                      IF TG_OP = 'UPDATE' THEN
                          UPDATE fininfotitulo SET
                              matricula = NEW.personid,
                              nome = getpersonname(NEW.personid), 
                              vencimento = NEW.maturitydate,
                              referencia = NEW.referencematuritydate,
                              cod_origem = NEW.incomesourceid,
                              origem = (SELECT description FROM finincomesource WHERE incomesourceid = NEW.incomesourceid)
                          WHERE titulo = NEW.invoiceid ;
                      END IF;

                      RETURN NEW;
                  END;
                  $$;


ALTER FUNCTION public.insere_fininfotitulo() OWNER TO postgres;

--
-- Name: insere_nosso_numero(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION insere_nosso_numero() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_ourNumber text;
BEGIN
    v_ourNumber := getNextOurNumber(NEW.bankaccountid);

    INSERT INTO finbankinvoiceinfo (invoiceid, bankaccountid, ournumber) VALUES (NEW.invoiceid, NEW.bankaccountid, v_ourNumber);
    UPDATE finbankaccount SET ournumber = v_ourNumber WHERE bankAccountId = NEW.bankaccountid;

    RETURN NEW;
END;
$$;


ALTER FUNCTION public.insere_nosso_numero() OWNER TO postgres;

--
-- Name: insere_semestre_atual_dos_alunos(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION insere_semestre_atual_dos_alunos() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
        DECLARE
            v_dados_semestre RECORD;
        BEGIN
            FOR v_dados_semestre IN
                ( SELECT DISTINCT A.contractId,
                         D.periodId,
                         get_semester_contract(A.contractId) AS semester
                    FROM acdContract A
              INNER JOIN acdMovementContract B
                      ON B.contractId = A.contractId
                     AND B.stateTime = ( SELECT distinct MAX(stateTime)
                                           FROM acdMovementContract
                                          WHERE contractId = A.contractId
                                            AND stateContractId = getContractState(A.contractId) )
              INNER JOIN acdStateContract C
                      ON C.stateContractId = B.stateContractId
                     AND C.isCloseContract = FALSE
              INNER JOIN ( SELECT distinct getParameter('BASIC', 'CURRENT_PERIOD_ID') AS periodId ) D
                      ON TRUE
                ORDER BY A.contractId DESC )
            LOOP
                RAISE NOTICE 'INSERIU: contrato %, periodo %, semestre %', v_dados_semestre.contractId, v_dados_semestre.periodId, v_dados_semestre.semester;
                INSERT INTO acdSemesterContractPeriod
                            ( contractId,
                              periodId,
                              semester )
                     VALUES ( v_dados_semestre.contractId,
                              v_dados_semestre.periodId,
                              v_dados_semestre.semester ); 

                v_dados_semestre.contractId := null; 
                v_dados_semestre.periodId := null; 
                v_dados_semestre.semester := null;  
            END LOOP;

            RETURN TRUE;
        END;
        $$;


ALTER FUNCTION public.insere_semestre_atual_dos_alunos() OWNER TO postgres;

--
-- Name: inserelancamentostemporariosreferenteaosconvenios(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION inserelancamentostemporariosreferenteaosconvenios() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: insereLancamentosTemporariosReferentesAosConvenios
  PURPOSE: Insere lançamentos na tabela temporária temp_bank_movement_entries, processo de retorno bancário.
**************************************************************************************/
DECLARE
    v_invoice record;
    v_convenant record;
    v_mask_date varchar := getParameter('BASIC', 'MASK_DATE');
    v_data_hoje date := ( SELECT TO_CHAR(NOW()::DATE, 'dd/mm/yyyy') )::date;
BEGIN
    -- Percorre todos os registros do retorno bancário que possuem convênios.
    FOR v_invoice IN
        ( SELECT DISTINCT A.invoiceId,
                          A.occurrenceDate,
                          B.costCenterId,
                          A.bankReturnId,
                          A.occurrenceDate
		     FROM temp_bank_movement A
	  INNER JOIN ONLY finInvoice B
		       ON B.invoiceId = A.invoiceId
	       INNER JOIN finConvenantPerson C
		       ON C.personId = B.personId
		      AND B.referenceMaturityDate BETWEEN C.beginDate AND C.endDate
		      AND A.statusId IS NULL
		      AND A.convenantValue > 0
		      AND A.valuePaid = A.balancewithpolicies )
    LOOP
	v_convenant := NULL;

	-- Percorre todos os convênios do registro
	FOR v_convenant IN
	    ( SELECT * 
		FROM getInvoiceConvenants(v_invoice.invoiceId, TO_DATE(v_invoice.occurrenceDate, v_mask_date))
	          AS convenant(convenantid integer, description text, value numeric, ispercent boolean, convenantoperation int) )
	LOOP
	    -- Insere lançamento temporário do convênio do registro.
	    INSERT INTO temp_bank_movement_entries
	                ( invoiceId, 
	                  costCenterId, 
	                  comments, 
	                  bankReturnCode, 
	                  entryDate, 
	                  operationId, 
	                  value )
	         VALUES ( v_invoice.invoiceId,
			  v_invoice.costCenterId,
			  'ARQUIVO DE RETORNO IMPORTADO EM ' || v_data_hoje,
			  v_invoice.bankReturnId,
			  COALESCE(v_invoice.occurrenceDate::DATE, v_data_hoje),
			  v_convenant.convenantoperation,
			  v_convenant.value );
	END LOOP;
    END LOOP;

    RETURN TRUE;
END;
$$;


ALTER FUNCTION public.inserelancamentostemporariosreferenteaosconvenios() OWNER TO postgres;

--
-- Name: insert_miolo_user_passwords(text, text); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION insert_miolo_user_passwords(p_user text, p_password text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    
BEGIN
    BEGIN
        
        EXECUTE 'CREATE USER "'|| p_user ||'" WITH password '''|| p_password ||''' SUPERUSER IN GROUP miolo_users';

        EXCEPTION
            WHEN OTHERS THEN
                --RAISE NOTICE 'Não foi possível inserir o usuário % no postgres. Erro: %', p_user, SQLERRM; 
                RETURN FALSE;
    END;

    RETURN TRUE;
END;
$$;


ALTER FUNCTION public.insert_miolo_user_passwords(p_user text, p_password text) OWNER TO solis;

--
-- Name: isacademicenrolledinperiod(integer, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION isacademicenrolledinperiod(p_contractid integer, p_periodid character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_enroll_status_cancelled integer;
    v_enroll_status_excused integer;
    v_enroll_status_pre_matriculado integer;
    v_count integer;
BEGIN
    SELECT INTO v_enroll_status_cancelled value::integer FROM basconfig WHERE parameter LIKE 'ENROLL_STATUS_CANCELLED';
    SELECT INTO v_enroll_status_excused value::integer FROM basconfig WHERE parameter LIKE 'ENROLL_STATUS_EXCUSED';
    SELECT INTO v_enroll_status_pre_matriculado value::integer FROM basconfig WHERE parameter LIKE 'ENROLL_STATUS_PRE_ENROLLED';
    
    SELECT INTO v_count count(AA.enrollId)
           FROM acdEnroll AA
          INNER JOIN acdGroup BB
             ON BB.groupId = AA.groupId
          WHERE BB.learningPeriodId IN (SELECT learningPeriodId FROM acdLearningPeriod WHERE periodid = p_periodid)
            AND AA.statusId NOT IN (v_enroll_status_cancelled, v_enroll_status_excused, v_enroll_status_pre_matriculado)
            AND AA.contractId = p_contractid;
    
    IF v_count > 0
    THEN
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END IF;
END;
$$;


ALTER FUNCTION public.isacademicenrolledinperiod(p_contractid integer, p_periodid character varying) OWNER TO postgres;

--
-- Name: isbetweendates(character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION isbetweendates(maindate character varying, firstdate character varying, seconddate character varying, datemask character varying) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$

DECLARE
    result1 date;
    result2 date;
    result3 date;

BEGIN
          SELECT INTO result1 TO_DATE(mainDate,  dateMask);
          SELECT INTO result2 TO_DATE(firstDate, dateMask);
          SELECT INTO result3 TO_DATE(secondDate,dateMask);
          
          IF result1 >= result2 AND result1 <= result3
          THEN
              RETURN TRUE;
          END IF;
    RETURN FALSE;
END;
$$;


ALTER FUNCTION public.isbetweendates(maindate character varying, firstdate character varying, seconddate character varying, datemask character varying) OWNER TO postgres;

--
-- Name: iscontractclosed(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION iscontractclosed(p_contractid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
NAME: isContractClosed
PURPOSE: Retorna TRUE se um contrato está fechado ou FALSE, se estiver aberto.
REVISIONS:
Ver       Date       Author            Description
--------- ---------- ----------------- ------------------------------------
1.0       21/09/2011 AlexSmith         1. Função criada.
*************************************************************************************/           
DECLARE
    v_retVal RECORD;
BEGIN
    SELECT * INTO v_retVal
      FROM acdMovementContract A
INNER JOIN acdStateContract B
        ON B.stateContractId = A.stateContractId
     WHERE A.contractId = p_contractId
  ORDER BY A.stateTime DESC
     LIMIT 1;

    RETURN (v_retVal.isCloseContract AND v_retVal.inOutTransition IN ('T', 'O'));
END;
$$;


ALTER FUNCTION public.iscontractclosed(p_contractid integer) OWNER TO postgres;

--
-- Name: iscostcenteractive(text); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION iscostcenteractive(p_costcenterid text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_active boolean;
BEGIN

    SELECT INTO v_active active FROM acccostcenter WHERE costcenterid = p_costcenterid;
    
    RETURN v_active;

END;
$$;


ALTER FUNCTION public.iscostcenteractive(p_costcenterid text) OWNER TO solis;

--
-- Name: isdefaulter(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION isdefaulter(p_personid integer) RETURNS boolean
    LANGUAGE sql
    AS $_$
/******************************************************************************
  NAME: isDefaulter
  PURPOSE: Retorna TRUE (FALSE) se a pessoa informada (não) está em débito.
  DESCRIPTION:
  Estar em débito significa ter títulos já vencidos com valor maior do que zero.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       08/12/2010 Alexandre Schmidt 1. Função criada.
******************************************************************************/
    -- verifica se a pessoa informada possui algum
    -- título com data de vencimento já passada e com
    -- saldo maior do que zero.
    SELECT COUNT(*) > 0
      FROM finInvoice X
     WHERE X.personId = $1
       AND X.maturityDate < now()
       AND balance(X.invoiceId) > 0
$_$;


ALTER FUNCTION public.isdefaulter(p_personid integer) OWNER TO postgres;

--
-- Name: isdefaulter(bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION isdefaulter(p_personid bigint) RETURNS boolean
    LANGUAGE sql
    AS $_$
/******************************************************************************
  NAME: isDefaulter
  PURPOSE: Retorna TRUE (FALSE) se a pessoa informada (não) esté em débito.
  DESCRIPTION:
  Estar em débito significa ter tétulos jé vencidos com valor maior do que zero.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       08/12/2010 Alexandre Schmidt 1. FUNÇÃO criada.
******************************************************************************/
    -- verifica se a pessoa informada possui algum
    -- tétulo com data de vencimento jé passada e com
    -- saldo maior do que zero.
    SELECT COUNT(*) > 0
      FROM finInvoice X
     WHERE X.personId = $1
       AND X.maturityDate < now()
       AND balance(X.invoiceId) > 0
$_$;


ALTER FUNCTION public.isdefaulter(p_personid bigint) OWNER TO postgres;

--
-- Name: isemployeeactive(bigint); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION isemployeeactive(p_personid bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    RETURN TRUE;
END;
$$;


ALTER FUNCTION public.isemployeeactive(p_personid bigint) OWNER TO solis;

--
-- Name: isfinanceenrolledinperiod(integer, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION isfinanceenrolledinperiod(p_contractid integer, p_periodid character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: isfinanceenrolledinperiod
  PURPOSE: Verifica se há títulos abertos em determinado período.
**************************************************************************************/
DECLARE
    v_count integer;
BEGIN
    SELECT INTO v_count count(*)
           FROM finReceivableInvoice AA
          INNER JOIN finEntry BB
             ON BB.invoiceId = AA.invoiceId
            AND BB.contractId = p_contractid
            AND EXISTS (SELECT learningPeriodId FROM acdLearningPeriod WHERE periodid = p_periodid AND learningperiodid = BB.learningperiodid)
            AND AA.balance <= 0;
    
    IF v_count > 0
    THEN
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END IF;
END;
$$;


ALTER FUNCTION public.isfinanceenrolledinperiod(p_contractid integer, p_periodid character varying) OWNER TO postgres;

--
-- Name: isfreshman(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION isfreshman(p_contractid integer) RETURNS boolean
    LANGUAGE sql
    AS $_$
/******************************************************************************
  NAME: isFreshMan
  PURPOSE: Descobrir se um determinado contrato é calouro ou não
  DESCRIPTION: A consulta é feita verificando se o contrato informado possui
  algum registro de matrícula em disciplinas que pertençam a períodos maiores
  do que 1, ou seja, se o aluno já tem ou teve matrícula em semestres posterio-
  res ao primeiro.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       25/11/2010 Alexandre Schmidt 1. Função criada.
******************************************************************************/
    SELECT COUNT(*) = 0
      FROM acdEnroll A
INNER JOIN acdGroup B
        ON B.groupId = A.groupId
INNER JOIN acdCurriculum C
        ON C.curriculumId = B.curriculumId
     WHERE A.contractId = $1
       AND C.semester > 1;
$_$;


ALTER FUNCTION public.isfreshman(p_contractid integer) OWNER TO postgres;

--
-- Name: isprofessoractive(bigint); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION isprofessoractive(p_personid bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    RETURN TRUE;
END;
$$;


ALTER FUNCTION public.isprofessoractive(p_personid bigint) OWNER TO solis;

--
-- Name: main_attendance_report(integer); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION main_attendance_report(p_group_id integer) RETURNS TABLE(groupid integer, curricularcomponent text, professor text, periodid character varying, unit text, lessonnumberhours double precision, minimumnumberhours double precision, room text, center text, classid character varying, coursename text, minimumfrequency double precision, curricularcomponentunblocks text)
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: MAIN_ATTENDANCE_REPORT
  DESCRIPTION: FUNÇÃO que retorna dados de disciplina (utilizado em relatórios jasper)

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       11/11/2010 Fabiano Tomasini  1. FUNÇÃO criada.
  1.1       06/07/2011 Moises Heberle    2. Alterado para nao duplicar registros
******************************************************************************/
DECLARE
    v_select text;
BEGIN
    v_select := 'SELECT DISTINCT B.groupId,
                                 E.curricularComponentId || '' - '' || E.name as curricularComponent,
                                 ARRAY_TO_STRING(ARRAY(SELECT DISTINCT J.personId || '' - '' || J.name as professor
                                                                  FROM acdSchedule _F
                                                            INNER JOIN acdScheduleProfessor I
                                                                    ON _F.scheduleId = I.scheduleId
                                                       INNER JOIN ONLY basPhysicalPersonProfessor J
                                                                    ON I.professorId = J.personId
                                                            INNER JOIN acdLearningPeriod C
                                                                    ON (B.learningPeriodId = C.learningPeriodId)
                                                                 WHERE B.groupId = _F.groupId), '', '') AS professor,

                                 C.periodId,
                                 K.description as unit,
                                 E.lessonNumberHours,
                                 ROUND(CAST ((C.minimumFrequency * E.lessonNumberHours / 100) AS numeric), 2)::FLOAT as minimumNumberHours,
                                 G.room || '' - '' || G.building as room,
                                 L.name as center,
                                 B.classId,
                                 M.name as coursename,
                                 C.minimumFrequency,
                                 ( SELECT array_to_string(array_agg(''('' || X.curricularComponentId || '' - '' || X.name || '')''), '', '')
				     FROM ( SELECT DISTINCT CC.curricularComponentId, CC.name
						       FROM acdCurricularComponentUnblock AA
					         INNER JOIN acdCurriculum BB
						      USING (curriculumId)
					         INNER JOIN acdCurricularComponent CC
						         ON (CC.curricularComponentId = AA.curricularComponentId 
						        AND CC.curricularComponentVersion = AA.curricularComponentVersion)
					         INNER JOIN acdCurricularComponent DD
						         ON (DD.curricularComponentId = BB.curricularComponentId 
						        AND DD.curricularComponentVersion = BB.curricularComponentVersion)
						      WHERE BB.curricularComponentId = E.curricularComponentId ) X
				    WHERE X.curricularComponentId <> E.curricularComponentId ) AS curricularComponentUnblocks
                            FROM acdGroup B
                      INNER JOIN acdLearningPeriod C
                              ON (B.learningPeriodId = C.learningPeriodId)
                      INNER JOIN acdCurriculum D
                              ON (B.curriculumId = D.curriculumId)
                      INNER JOIN acdCurricularComponent E
                              ON (D.curricularComponentId = E.curricularComponentId AND
                                 D.curricularComponentVersion = E.curricularComponentVersion)
                       LEFT JOIN acdSchedule F
                              ON (B.groupId = F.groupId)
                       LEFT JOIN insPhysicalResource G
                              ON (G.physicalResourceId = F.physicalResourceId AND
                                  G.physicalResourceVersion = F.physicalResourceVersion)
                      INNER JOIN acdCourse H
                              ON (H.courseId = D.courseId)
                      INNER JOIN basUnit K
                              ON (C.unitId = K.unitId)
                       LEFT JOIN acdCenter L
                              ON (L.centerId = H.centerId)
                      INNER JOIN acdCourse M
                              ON (M.courseId = D.courseId)
                           WHERE  B.groupId = '''||p_group_id||'''';

    RETURN QUERY EXECUTE v_select;
END;
$$;


ALTER FUNCTION public.main_attendance_report(p_group_id integer) OWNER TO solis;

--
-- Name: maskcpf(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION maskcpf(p_cpf text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_unmasked text;
BEGIN

    SELECT INTO v_unmasked unmaskCPF( p_cpf ) ;

    RETURN substring( v_unmasked from 1 for 3 ) || '.' 
        || substring( v_unmasked from 4 for 3 ) || '.' 
        || substring( v_unmasked from 7 for 3 ) || '-' 
        || substring( v_unmasked from 10 for 2 );
END;
 $$;


ALTER FUNCTION public.maskcpf(p_cpf text) OWNER TO postgres;

--
-- Name: max_date_array(date[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION max_date_array(datearray date[]) RETURNS date
    LANGUAGE plpgsql
    AS $$
DECLARE
  size_array int;
  max_date date;
BEGIN
  size_array = array_upper(dateArray,1);
  if size_array > 0 then
  		  max_date = dateArray[1];
		  for i in 1..size_array loop
		     if dateArray[i] > max_date then
		        max_date = dateArray[i];
		     end if;		       
		  end loop;
  end if;
  return max_date; 
END;
$$;


ALTER FUNCTION public.max_date_array(datearray date[]) OWNER TO postgres;

--
-- Name: miolo_audit_it(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION miolo_audit_it() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
/*************************************************************************************************************
  NAME: miolo_audit_it
  PURPOSE: Função que permite auditoria de tabelas.
  
  REVISIONS:
  Ver       Date       Author                    Description
  --------- ---------- ----------------- ------------------------------------
  1.0       -          Daniel Hartmann           1. Função criada.
  2.0     27/11/2013   Nataniel Ingor da Silva   2. Função adaptada para utilizar uma outra base
                                                    para salvar os dados de auditoria, caso esteja
                                                    configurado o parâmetro MIOLO_AUDIT_DATABASE(dblink).
  3.0     13/05/2014   Augusto A. Silva          3. Feitas automatizações no processo de auditoria.
**************************************************************************************************************/
DECLARE
    v_original_value TEXT;
    v_new_value TEXT;
    v_col TEXT;
    v_audit_id INT;
    v_do_insert BOOLEAN;
    v_ispk BOOLEAN;
    v_path_dblink TEXT;
    v_dblink TEXT;
    v_is_dblink BOOLEAN = FALSE;
    v_current_query TEXT;
    v_next_val INTEGER;
    v_dblink_extension BOOLEAN = FALSE;
    v_database TEXT;
    v_pkeys VARCHAR[];
    v_pkey TEXT;
BEGIN
    v_original_value := NULL;
    v_new_value := '-';
    v_next_val := nextval('miolo_audit_audit_id_seq');
  
    IF TG_OP = 'DELETE' OR TG_OP = 'UPDATE' THEN
        INSERT INTO miolo_audit 
                    (audit_id, schema_name, table_name, user_name, action, query)
            VALUES (v_next_val, TG_TABLE_SCHEMA::TEXT, TG_TABLE_NAME::TEXT, session_user::TEXT, TG_OP, current_query());
    END IF;
           
    -- Obtém array de chaves primárias da tabela.
    BEGIN
	EXECUTE 'SELECT miolo_audit_' || TG_TABLE_SCHEMA || '_' || TG_TABLE_NAME || '_pkeys()' 
	   INTO v_pkeys;
    EXCEPTION WHEN undefined_function
    THEN
	SELECT INTO v_pkeys array_agg(column_name::text) AS column_name FROM obtemChavesPrimariasDaTabela(TG_TABLE_NAME, TG_TABLE_SCHEMA);
    END;
   
    -- Percorre todas as colunas da tabela.
    FOR v_col IN SELECT column_name
                   FROM information_schema.columns 
                  WHERE table_name = TG_TABLE_NAME
                    AND table_schema = TG_TABLE_SCHEMA
               ORDER BY ordinal_position
    LOOP
	v_ispk := FALSE;
        v_do_insert := TRUE;

	-- Identifica se o valor da coluna foi alterado, caso sim, deverá registrar nos detalhes da auditoria.
        IF TG_OP = 'DELETE' OR TG_OP = 'UPDATE' THEN
            EXECUTE 'SELECT ' || v_col || ' FROM (SELECT $1.*) AS table_old' INTO v_original_value USING OLD;
        END IF;

        IF TG_OP = 'UPDATE' THEN
            EXECUTE 'SELECT ' || v_col || ' FROM (SELECT $1.*) AS table_new' INTO v_new_value USING NEW;

            IF TG_OP = 'UPDATE' AND (v_original_value = v_new_value OR (v_original_value IS NULL AND v_new_value IS NULL)) 
            THEN
                v_do_insert := FALSE;
            END IF;

        END IF;

	-- Aqui está sendo forçada a inserção da chave primária, independente se foi alterada ou não.
        FOR v_pkey IN ( SELECT vt FROM unnest(v_pkeys) x(vt) )
        LOOP
            IF v_pkey = v_col
            THEN
                v_ispk := TRUE;
                v_do_insert := TRUE;
            END IF;
        END LOOP;

        IF v_do_insert THEN
            INSERT INTO miolo_audit_detail
                        (audit_id, column_name, original_value, new_value, is_pkey)
                VALUES (v_next_val, v_col, v_original_value, v_new_value, v_ispk);
        END IF;
        
    END LOOP;

    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE'
    THEN
        RETURN NEW;
    ELSE
        RETURN OLD;
    END IF;
END;
$_$;


ALTER FUNCTION public.miolo_audit_it() OWNER TO postgres;

--
-- Name: miolo_audit_public_acdcontract_pkeys(); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION miolo_audit_public_acdcontract_pkeys() RETURNS character varying[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
             DECLARE
                 v_pkeys VARCHAR[] := ARRAY['contractid'];
             BEGIN
                 RETURN v_pkeys;
             END;
             $$;


ALTER FUNCTION public.miolo_audit_public_acdcontract_pkeys() OWNER TO solis;

--
-- Name: miolo_audit_upgrade(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION miolo_audit_upgrade(p_query text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/***************************************************************
  NAME: miolo_audit_upgrade
  PURPOSE: Executa um comando sql na base externa da miolo audit.
  PARAMETERS: p_query - String que recebe sql.
                
****************************************************************/
DECLARE
    --Valor configurado do parâmetro (host)
    v_hostExterno TEXT;
    --Recebe o nome da base utilizada pelo sagu
    v_database TEXT;
    -- Recebe string de conexão com o banco externo (dblink)
    v_conn TEXT;
    
BEGIN

    v_hostExterno := GETPARAMETER('BASIC', 'MIOLO_AUDIT_DATABASE');

    --Busca a base de dados atual usada pelo sagu
    SELECT INTO v_database current_database();

    --Monta o host externo para conectar ao dblink
    v_database := ' dbname=' || v_database || '_auditoria ';
    v_conn := v_database || v_hostExterno;
    
    IF LENGTH(v_hostExterno)>0 THEN

       BEGIN
       
       PERFORM (SELECT dblink_exec(''|| v_conn::TEXT ||'', '' || p_query || ''));
       EXCEPTION
           WHEN others THEN
                 --RAISE EXCEPTION 'NÃO FOI POSSÍVEL EXECUTAR ESSA QUERY NO BANCO CONFIGURADO PRA MIOLO_ADIT.'
                 RETURN FALSE;
       END;

    END IF;

    RETURN TRUE;
	 
END;
$$;


ALTER FUNCTION public.miolo_audit_upgrade(p_query text) OWNER TO postgres;

--
-- Name: numeroporextenso(numeric, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION numeroporextenso(num numeric, moeda text, moedas text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
/*************************************************************************************
  NAME: numeroPorExtenso
  PURPOSE: Obtém o número por extenso, e a moeda, caso seja passado.
  PARAMETERS: 
            num -> numero a ser convertido em extenso
            moeda -> nome da moeda no singular
            moedas -> nome da moeda no plural
  **CASO QUEIRA APENAS O NÚMERO POR EXTENSO, PASSAR OS ÚLTIMOS DOIS PARÂMETROS VAZIOS.
**************************************************************************************/
DECLARE
    w_int char(21) ;
    x integer ;
    v integer ;
    w_ret text ;
    w_ext text ;
    w_apoio text ;
    m_cen text[] := array['quatrilhão','quatrilhões','trilhão','trilhões','bilhão','bilhões','milhão','milhões','mil','mil'] ;
BEGIN
    w_ret := '' ;
    w_int := to_char(num * 100 , 'fm000000000000000000 00') ;
    for x in 1..5 loop
        v := cast(substr(w_int,(x-1)*3 + 1,3) as integer) ;    
        if v > 0 then
            if v > 1 then
                w_ext := m_cen[(x-1)*2+2] ;
            else
                w_ext := m_cen[(x-1)*2+1] ;
            end if ;   
            w_ret := w_ret || escreveNumeroPorExtenso(substr(w_int,(x-1)*3 + 1,3)) || ' ' || w_ext ||', ' ;
        end if ;  
    end loop ;
    v := cast(substr(w_int,16,3) as integer) ;    
    if v > 0 then
        if v > 1 then
            w_ext := moedas ;
        else
            if w_ret = '' then 
            w_ext := moeda ;
            else
            w_ext := moedas ;
            end if ;   
        end if ; 
        w_apoio := escreveNumeroPorExtenso(substr(w_int,16,3)) || ' ' || w_ext ;
        if w_ret = '' then 
            w_ret := w_apoio ;
        else 
            if v > 100 then 
            if w_ret = '' then 
                w_ret := w_apoio ;
                else
                w_ret := w_ret || w_apoio ;
            end if ;   
            else
            w_ret := btrim(w_ret,', ') || ' e ' || w_apoio ;
            end if ;   
        end if ;   
        else 
        if w_ret <> '' then  
            if substr(w_int,13,6) = '000000' then 
            w_ret := btrim(w_ret,', ') || ' de ' || moedas ;
            else 
            w_ret := btrim(w_ret,', ') || ' ' || moedas ;
            end if ;    
        end if ;  
    end if ;    
    v := cast(substr(w_int,20,2) as integer) ;    
    if v > 0 then
        if v > 1 then
            w_ext := 'centavos' ;
        else
            w_ext := 'centavo' ;
        end if ;   
        w_apoio := escreveNumeroPorExtenso('0'||substr(w_int,20,2)) || ' ' || w_ext ;
        if w_ret = '' then 
            w_ret := w_apoio  || ' de ' || moeda;
        else 
            w_ret := w_ret || ' e ' || w_apoio ;
        end if ;   
    end if ;    
    return w_ret ;  
end ;
$$;


ALTER FUNCTION public.numeroporextenso(num numeric, moeda text, moedas text) OWNER TO postgres;

--
-- Name: obtemcargahorariadetodasofertasdamesmaunidadetematica(integer, integer); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION obtemcargahorariadetodasofertasdamesmaunidadetematica(p_residenteid integer, p_unidadetematicaid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: obtemCargaHorariaDeTodasOfertasDaMesmaUnidadeTematica
  PURPOSE: Retorna a carga horÃ¡ria de outras ofertas da mesma unidade temÃ¡tica.
**************************************************************************************/
DECLARE
    v_retVal res.encontro.cargaHoraria%TYPE;
    v_cargahoraria res.encontro.cargaHoraria%TYPE;
    v_cargahorariacomplementar res.encontro.cargaHoraria%TYPE;

BEGIN

SELECT COALESCE (SUM(JJ2.cargaHoraria), 0) INTO v_cargahoraria
               FROM (SELECT  B.cargaHoraria,
                             D.UnidadeTematicaid,
                             A.residenteid
                       FROM res.frequencia A
                 INNER JOIN res.encontro B
                         ON B.encontroId = A.encontroId
                 INNER JOIN res.ofertaDeUnidadeTematica C
                         ON C.ofertaDeUnidadeTematicaId = B.ofertaDeUnidadeTematicaId
                 INNER JOIN res.unidadeTematica D
                         ON D.unidadeTematicaId = C.unidadeTematicaId
                 INNER JOIN res.ofertadoresidente xODR
                         ON (xODR.ofertaDeUnidadeTematicaId = b.ofertaDeUnidadeTematicaId
                        AND xODR.residenteid = A.residenteid)
                 INNER JOIN res.ocorrenciaDeoferta XE
                         ON (XE.ofertadoresidenteid = xODR.ofertadoresidenteid 
                        AND xe.ocorrenciadeofertaid = res.ultimaOcorrenciaDeOfertaId(A.residenteId, B.ofertaDeUnidadeTematicaId)
                        AND xe.status in (1,2, 4))
                         -- considerar somente presenca ou falta justificada
                      WHERE A.presenca IN ('P', 'J')
                        AND A.residenteId = p_residenteid
                        AND CASE WHEN p_unidadeTematicaId IS NOT NULL THEN D.unidadetematicaid = p_unidadeTematicaId ELSE 1=1 END) JJ2;

            -- carga horaria oriunda de outras fontes (aproveitamentos, por exemplo)
            SELECT COALESCE(SUM(A.cargaHoraria),0) INTO v_cargahorariacomplementar
              FROM res.cargaHorariaComplementar A
             WHERE A.residenteId = p_residenteId
               AND (CASE WHEN p_unidadeTematicaId IS NOT NULL THEN A.unidadeTematicaId = p_unidadeTematicaId ELSE 1=1 END);

            -- Total da carga horÃ©ria (carga horÃ©ria complementar + carga horÃ©ria total das unidades temÃ¡ticas)
	    v_retVal = ROUND(COALESCE((v_cargahorariacomplementar + v_cargahoraria),0)::numeric,2);

    RETURN v_retVal;
END;
$$;


ALTER FUNCTION public.obtemcargahorariadetodasofertasdamesmaunidadetematica(p_residenteid integer, p_unidadetematicaid integer) OWNER TO solis;

--
-- Name: obtemchavesprimariasdatabela(text, text); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION obtemchavesprimariasdatabela(p_table_name text, p_table_squema text) RETURNS TABLE(column_name information_schema.sql_identifier)
    LANGUAGE plpgsql IMMUTABLE
    AS $$
/*************************************************************************************************************
  NAME: obtemChavesPrimariasDaTabela
  PURPOSE: Obtém os nomes das colunas chaves primárias da tabela.
  
  REVISIONS:
  Ver       Date          Author               Description
  --------- ------------- -------------------- ------------------------------------
  1.0       13/05/2014    Augusto A. Silva     1. Função criada.
**************************************************************************************************************/
DECLARE
      v_select TEXT;
BEGIN
     -- Obtém todas as colunas chaves primárias da tabela.
     v_select := 'SELECT column_name AS column_name
                    FROM information_schema.constraint_column_usage U
              INNER JOIN information_schema.table_constraints CONS
                      ON CONS.table_name = U.table_name
                     AND CONS.table_schema = U.table_schema
                     AND CONS.constraint_name = U.constraint_name
                     AND CONS.constraint_type = ''PRIMARY KEY''
                   WHERE U.table_name = ''' || p_table_name || '''
                     AND U.table_schema = ''' || p_table_squema || '''';
        
     RETURN QUERY EXECUTE v_select;
END;
$$;


ALTER FUNCTION public.obtemchavesprimariasdatabela(p_table_name text, p_table_squema text) OWNER TO solis;

--
-- Name: obtemcreditoferias(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obtemcreditoferias(p_contractid integer, p_learningperiodid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$

DECLARE

BEGIN
    RETURN COALESCE (
           (SELECT CASE getParameter('ACADEMIC', 'USAR_CREDITOS_ACADEMICOS') 
                   WHEN 't' THEN SUM(D.academiccredits)
                   WHEN 'f' THEN SUM(D.lessoncredits)
                    END
                          
              FROM acdEnroll A
        INNER JOIN acdGroup B
                ON (A.groupId = B.groupId)
        INNER JOIN acdCurriculum C
                ON (B.curriculumId = C.curriculumId)
        INNER JOIN acdCurricularComponent D
                ON (C.curricularComponentId = D.curricularComponentId AND
                    C.curricularComponentVersion = D.curricularComponentVersion)
        INNER JOIN acdLearningPeriod E
                ON (E.learningPeriodId = B.learningPeriodId)
             WHERE E.periodId IN (SELECT periodId FROM acdLearningPeriod WHERE learningPeriodId = p_learningPeriodId)
               AND A.contractId = p_contractId
               AND A.statusid <> GETPARAMETER('ACADEMIC', 'ENROLL_STATUS_CANCELLED')::integer
               AND B.regimenId = GETPARAMETER('ACADEMIC', 'REGIME_DE_FERIAS')::integer)
               , 0);
END;
$$;


ALTER FUNCTION public.obtemcreditoferias(p_contractid integer, p_learningperiodid integer) OWNER TO postgres;

--
-- Name: obtemcreditomatriculado(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obtemcreditomatriculado(p_contractid integer, p_learningperiodid integer) RETURNS real
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: obtemCreditoMatriculado
  PURPOSE: Retorna o total de créditos em que o aluno está matriculado.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       12/02/2013 Samuel Koch       1. FUNÇÃO criada.
  1.0       19/02/2014 Samuel Koch       1. Alterado função para retornar valores
                                            quebrados. Ex: 19.5
**************************************************************************************/
DECLARE

BEGIN
    RETURN (SELECT CASE getParameter('ACADEMIC', 'USAR_CREDITOS_ACADEMICOS') 
                   WHEN 't' THEN SUM(D.academiccredits)
                   WHEN 'f' THEN SUM(D.lessoncredits)
                    END

              FROM acdEnroll A
        INNER JOIN acdGroup B
                ON (A.groupId = B.groupId)
        INNER JOIN acdCurriculum C
                ON (B.curriculumId = C.curriculumId)
        INNER JOIN acdCurricularComponent D
                ON (C.curricularComponentId = D.curricularComponentId AND
                    C.curricularComponentVersion = D.curricularComponentVersion)
        INNER JOIN acdLearningPeriod E
                ON (E.learningPeriodId = B.learningPeriodId)
             WHERE E.periodId IN (SELECT periodId FROM acdLearningPeriod WHERE learningPeriodId = p_learningPeriodId)
               AND A.contractId = p_contractId
               AND A.statusid <> GETPARAMETER('ACADEMIC', 'ENROLL_STATUS_CANCELLED')::integer
               AND B.regimenId <> GETPARAMETER('ACADEMIC', 'REGIME_DE_FERIAS')::integer);
END;
$$;


ALTER FUNCTION public.obtemcreditomatriculado(p_contractid integer, p_learningperiodid integer) OWNER TO postgres;

--
-- Name: obtemperiodosmatriculado(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obtemperiodosmatriculado(p_contractid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: obtemPeriodosMatriculado
  PURPOSE: Retorna o número de períodos que o aluno se matriculou
  se encontra.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ---------------------------------------------
  1.0       14/03/2013 Samuel Koch       1. FUNÇÃO criada.

**************************************************************************************/
DECLARE
BEGIN
    
    RETURN (SELECT COUNT(periodId)
             FROM acdPeriod
            WHERE periodId IN ( SELECT DISTINCT A.periodId
                                           FROM acdLearningPeriod A
                                     INNER JOIN acdGroup B
                                             ON (A.learningPeriodId = B.learningPeriodId)
                                     INNER JOIN acdEnroll C
                                             ON (B.groupId = C.groupId)
                                          WHERE C.contractId = p_contractId ));
END
$$;


ALTER FUNCTION public.obtemperiodosmatriculado(p_contractid integer) OWNER TO postgres;

--
-- Name: obtempoliticadopreco(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obtempoliticadopreco(p_contractid integer, p_parcelnumber integer, p_learningperiodid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: obtemPolíticaPreco
  PURPOSE: Retorna o código da política vigente para o período/semestre em que o aluno
  se encontra.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       11/02/2013 Samuel Koch       1. FUNÇÃO criada.
  1.1       18/07/2013 Samuel Koch       1. Alteração onde foi trocado a função 
                                            que obtem o semestre do aluno.
  1.2       13/01/2014 Samuel Koch       1. Alteração da função inserindo 
  1.3       13/01/2014 ftomasini         1. Alteração na lógica que pega a politica
                                            do preço
  1.4       24/02/2014 Samuel Koch       1. Alterado função que obtem o semestre.
**************************************************************************************/
DECLARE
    v_classId   varchar; --Armazena a turma do aluno
    v_semester  integer; --Armazena o semestre que o aluno se encontra no curso
    v_policyId  integer; --Código da política a ser aplicada no boleto
    v_controle  integer; --Variável de controle
    v_contrato  record; --Armazena as informaçÃµes de contrato
    v_select    text; --Armazena a consulta para verificar a política
    v_beginDate date; --Data base para pesquisar o preço.
    v_date      date; --Data para pesquisar o preço.
BEGIN

    --Obtem o semestre da turma
    v_semester :=  get_semester_contract(p_contractid);

    --Obtem a data inicial do período letivo para filtrar o preço
    SELECT A.beginDate INTO v_beginDate
      FROM acdLearningPeriod A
     WHERE A.learningPeriodId = p_learningPeriodId;

    --Obtem os dados do contrato do aluno
    SELECT * INTO v_contrato
      FROM acdContract
     WHERE contractId = p_contractId;

    --Obtem a data inicial do preço
    SELECT B.startDate INTO v_date
      FROM finPrice B
     WHERE B.courseId = v_contrato.courseId
       AND B.courseVersion = v_contrato.courseVersion
       AND B.turnId = v_contrato.turnId
       AND B.unitId = v_contrato.unitId
       AND v_beginDate BETWEEN B.startDate AND B.endDate;

    IF v_date IS NULL THEN
        RAISE EXCEPTION 'Não foi possível obter a data inicial cadastrada no preço desta disciplina. Verifique as datas iniciais do período letivo e do preço, cadastrados para está disciplina.';
    END IF;

       v_select := ' SELECT A.policyId
                        FROM finPricePolicy A
                       WHERE A.startDate = TO_DATE(''' || v_date || ''',''yyyy-mm-dd'')
                         AND A.courseId = ''' || v_contrato.courseId || '''
                         AND A.courseVersion = ' || v_contrato.courseVersion || '
                         AND A.turnId = ' || v_contrato.turnId || '
                         AND A.unitId = ' || v_contrato.unitId || ' ';


       --Verifica as possibilidades de configuração de preço.
       --Semestre nao nulo e parcela nao nula
       IF (v_semester IS NOT NULL AND p_parcelNumber IS NOT NULL) 
       THEN
           EXECUTE v_select || ' AND A.parcelNumber = ' || p_parcelNumber || ' AND A.semester = ' || v_semester INTO v_policyId;           
           --Semestre nao nulo e parcela nula
           IF ( v_policyId IS NULL ) 
           THEN
               EXECUTE v_select || ' AND A.semester = ' || v_semester || ' AND A.parcelNumber IS NULL ' INTO v_policyId;
           END IF;
           --Semestre nulo e parcela nao nula
           IF ( v_policyId IS NULL )
           THEN
	       EXECUTE v_select || ' AND A.parcelNumber = ' || p_parcelNumber || ' AND A.semester IS NULL ' INTO v_policyId;
           END IF;
           --Semestre e parcela nulos
           IF ( v_policyId IS NULL )
           THEN 
               EXECUTE v_select || ' AND A.parcelNumber IS NULL AND A.semester IS NULL ' INTO v_policyId;
           END IF;
       END IF;

       IF ( v_policyId IS NULL )
       THEN
           RAISE EXCEPTION 'Defina uma política para o preço do curso';
       ELSE
           RETURN v_policyId;
       END IF;
  END;
$$;


ALTER FUNCTION public.obtempoliticadopreco(p_contractid integer, p_parcelnumber integer, p_learningperiodid integer) OWNER TO postgres;

--
-- Name: obtemvalorcomdescontodecontratoquetenhaincentivo(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obtemvalorcomdescontodecontratoquetenhaincentivo(p_contractid integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$

DECLARE

BEGIN
    RETURN (SELECT 
			ROUND(SUM(CASE WHEN B.valueispercent = 't' THEN (E.nominalvalue -(E.nominalvalue*B.value/100))
			     ELSE (E.nominalvalue - B.value) END )::NUMERIC, getParameter('BASIC', 'REAL_ROUND_VALUE')::INT )AS valorcomdesconto
	        
		  FROM acdContract A
            INNER JOIN finIncentive B
                    ON A.contractId = B.contractId
       INNER JOIN ONLY finIncentiveType C
                    ON C.incentiveTypeId = B.incentiveTypeId
	    INNER JOIN finEntry D
		    ON D.contractId = A.contractId
	    INNER JOIN finreceivableinvoice E
		    ON E.invoiceId = D.invoiceId

	         WHERE A.contractId = p_contractid
	           AND E.maturitydate > B.startDate 
	           AND E.maturitydate < B.endDate
		   AND ( D.operationId IN (SELECT monthlyfeeoperation FROM findefaultoperations)
			 OR D.operationId IN (SELECT enrollOperation FROM findefaultoperations)
			 OR D.operationId IN (SELECT renewalOperation FROM findefaultoperations) ));
END;
$$;


ALTER FUNCTION public.obtemvalorcomdescontodecontratoquetenhaincentivo(p_contractid integer) OWNER TO postgres;

--
-- Name: obtemvalornominaldecontratoquetenhaincentivo(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obtemvalornominaldecontratoquetenhaincentivo(p_contractid integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$

DECLARE

BEGIN
    RETURN (SELECT ROUND(SUM(E.nominalvalue)::NUMERIC, getParameter('BASIC', 'REAL_ROUND_VALUE')::INT )
	        
		  FROM acdContract A
            INNER JOIN finIncentive B
                    ON A.contractId = B.contractId
       INNER JOIN ONLY finIncentiveType C
                    ON C.incentiveTypeId = B.incentiveTypeId
	    INNER JOIN finEntry D
		    ON D.contractId = A.contractId
	    INNER JOIN finreceivableinvoice E
		    ON E.invoiceId = D.invoiceId

	         WHERE A.contractId = p_contractid
	           AND E.maturitydate > B.startDate 
	           AND E.maturitydate < B.endDate
		   AND ( D.operationId IN (SELECT monthlyfeeoperation FROM findefaultoperations)
			 OR D.operationId IN (SELECT enrollOperation FROM findefaultoperations)
			 OR D.operationId IN (SELECT renewalOperation FROM findefaultoperations) ));
END;
$$;


ALTER FUNCTION public.obtemvalornominaldecontratoquetenhaincentivo(p_contractid integer) OWNER TO postgres;

--
-- Name: seq_personid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_personid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_personid OWNER TO postgres;

--
-- Name: basperson; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basperson (
    personid bigint DEFAULT nextval('seq_personid'::regclass) NOT NULL,
    persondv integer,
    personmask character varying(15),
    name character varying(100) NOT NULL,
    shortname character varying(30),
    cityid integer,
    zipcode character varying(9),
    location text,
    number character varying(10),
    complement character varying(60),
    neighborhood text,
    email character varying(60),
    emailalternative character varying(60),
    url text,
    datein date,
    password character varying(100),
    isallowpersonaldata boolean DEFAULT true NOT NULL,
    miolousername character varying(25),
    locationtypeid integer DEFAULT 0 NOT NULL,
    sentemail boolean DEFAULT false NOT NULL,
    photoid integer,
    login character varying,
    obs text
)
INHERITS (baslog);


ALTER TABLE public.basperson OWNER TO postgres;

--
-- Name: TABLE basperson; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basperson IS 'pessoas';


--
-- Name: COLUMN basperson.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basperson.personid IS 'Codigo da pessoa';


--
-- Name: COLUMN basperson.persondv; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basperson.persondv IS 'Digito verificador da pessoa';


--
-- Name: COLUMN basperson.personmask; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basperson.personmask IS 'Mascara para o codigo da pessoa';


--
-- Name: COLUMN basperson.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basperson.name IS 'Nome';


--
-- Name: COLUMN basperson.shortname; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basperson.shortname IS 'Apelido';


--
-- Name: COLUMN basperson.cityid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basperson.cityid IS 'Codigo da cidade';


--
-- Name: COLUMN basperson.zipcode; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basperson.zipcode IS 'CEP';


--
-- Name: COLUMN basperson.location; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basperson.location IS 'Logradouro';


--
-- Name: COLUMN basperson.number; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basperson.number IS 'Numero';


--
-- Name: COLUMN basperson.complement; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basperson.complement IS 'Complemento';


--
-- Name: COLUMN basperson.neighborhood; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basperson.neighborhood IS 'Bairro';


--
-- Name: COLUMN basperson.email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basperson.email IS 'Email';


--
-- Name: COLUMN basperson.emailalternative; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basperson.emailalternative IS 'Email alternativo';


--
-- Name: COLUMN basperson.url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basperson.url IS 'URL';


--
-- Name: COLUMN basperson.datein; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basperson.datein IS 'Data de ingresso';


--
-- Name: COLUMN basperson.password; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basperson.password IS 'Senha para acesso aos processo on-line';


--
-- Name: COLUMN basperson.isallowpersonaldata; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basperson.isallowpersonaldata IS 'Permite a divulgacao de dados pessoais';


--
-- Name: COLUMN basperson.miolousername; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basperson.miolousername IS 'nome do usuario que eh inserido automaticamente na base de dados do miolo para acesso ao modulo de servicos';


--
-- Name: COLUMN basperson.sentemail; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basperson.sentemail IS 'Flag informando se confirma ou nao o envio de informações por email';


--
-- Name: basphysicalperson; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basphysicalperson (
    sex character(1) NOT NULL,
    maritalstatusid character(1),
    residentialphone character varying(50),
    workphone character varying(50),
    cellphone character varying(50),
    messagephone character varying(50),
    messagecontact character varying(50),
    datebirth date,
    cityidbirth integer,
    countryidbirth character varying(3),
    responsablelegalid integer,
    carplate character varying(40),
    specialnecessityid integer,
    specialnecessitydescription text,
    cityidwork integer,
    zipcodework character varying(9),
    locationwork character varying(100),
    complementwork character varying(40),
    neighborhoodwork character varying(100),
    ethnicoriginid integer,
    datedeath date,
    persontitleid integer,
    locationtypeidwork integer DEFAULT 0 NOT NULL,
    mothername character varying(255),
    fathername character varying(255),
    workemployername character varying(255),
    workfunction character varying(255),
    workstartdate date,
    workenddate date,
    workathome boolean DEFAULT false NOT NULL,
    ethnicorigin character varying(255),
    identifier character varying(255),
    namesearch character varying
)
INHERITS (basperson);


ALTER TABLE public.basphysicalperson OWNER TO postgres;

--
-- Name: TABLE basphysicalperson; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basphysicalperson IS 'pessoa fisica';


--
-- Name: COLUMN basphysicalperson.sex; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalperson.sex IS 'Sexo';


--
-- Name: COLUMN basphysicalperson.maritalstatusid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalperson.maritalstatusid IS 'Estado civil';


--
-- Name: COLUMN basphysicalperson.residentialphone; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalperson.residentialphone IS 'Telefone residencial';


--
-- Name: COLUMN basphysicalperson.workphone; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalperson.workphone IS 'Telefone comercial';


--
-- Name: COLUMN basphysicalperson.cellphone; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalperson.cellphone IS 'Telefone celular';


--
-- Name: COLUMN basphysicalperson.messagephone; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalperson.messagephone IS 'Telefone para recados';


--
-- Name: COLUMN basphysicalperson.messagecontact; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalperson.messagecontact IS 'Contato para recados';


--
-- Name: COLUMN basphysicalperson.datebirth; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalperson.datebirth IS 'Data de nascimento';


--
-- Name: COLUMN basphysicalperson.cityidbirth; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalperson.cityidbirth IS 'Cidade de nascimento';


--
-- Name: COLUMN basphysicalperson.countryidbirth; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalperson.countryidbirth IS 'Pais de nascimento';


--
-- Name: COLUMN basphysicalperson.responsablelegalid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalperson.responsablelegalid IS 'Responsavel legal';


--
-- Name: COLUMN basphysicalperson.carplate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalperson.carplate IS 'Placa do carro';


--
-- Name: COLUMN basphysicalperson.specialnecessityid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalperson.specialnecessityid IS 'Necessidade especial';


--
-- Name: COLUMN basphysicalperson.specialnecessitydescription; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalperson.specialnecessitydescription IS 'Descritivo da necessidade especial';


--
-- Name: COLUMN basphysicalperson.cityidwork; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalperson.cityidwork IS 'Cidade do local de trabalho';


--
-- Name: COLUMN basphysicalperson.zipcodework; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalperson.zipcodework IS 'CEP do local de trabalho';


--
-- Name: COLUMN basphysicalperson.locationwork; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalperson.locationwork IS 'Logradouro do local de trabalho';


--
-- Name: COLUMN basphysicalperson.complementwork; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalperson.complementwork IS 'Complemento do local de trabalho';


--
-- Name: COLUMN basphysicalperson.neighborhoodwork; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalperson.neighborhoodwork IS 'Bairro do local do trabalho';


--
-- Name: COLUMN basphysicalperson.ethnicoriginid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalperson.ethnicoriginid IS 'Origem etnica';


--
-- Name: COLUMN basphysicalperson.datedeath; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalperson.datedeath IS 'Data de obito do aluno';


--
-- Name: COLUMN basphysicalperson.mothername; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalperson.mothername IS 'Armazena temporariamente o nome da mãe, até que o cadastro da pessoa seja validado pela instituição e o campo passe a ser NULL, sendo seu valor substituído por uma referência à própria tabela basPhysicalPerson.';


--
-- Name: COLUMN basphysicalperson.fathername; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalperson.fathername IS 'Armazena temporariamente o nome do pai, até que o cadastro da pessoa seja validado pela instituição e o campo passe a ser NULL, sendo seu valor substituído por uma referência à própria tabela basPhysicalPerson.';


--
-- Name: COLUMN basphysicalperson.namesearch; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalperson.namesearch IS 'Campo utilizado para busca rápida de nomes parecidos';


--
-- Name: obteralunosativosdadisciplina(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obteralunosativosdadisciplina(p_groupid integer) RETURNS SETOF basphysicalperson
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: obterAlunosPorDisciplina
  PURPOSE: Obter os alunos ativos de uma disciplina.
**************************************************************************************/

BEGIN
    RETURN QUERY ( SELECT D.*
                  FROM acdEnroll A
            INNER JOIN acdContract B
                    ON (A.contractId = B.contractId)
            INNER JOIN acdEnrollStatus C
                    ON (C.statusId = A.statusId)
       INNER JOIN ONLY basPhysicalPerson D
                    ON (B.personId = D.personId)
                 WHERE A.groupId = p_groupid
                   AND (A.statusid <> getparameter('ACADEMIC', 'ENROLL_STATUS_CANCELLED')::int 
                   AND  A.statusid <> getparameter('ACADEMIC', 'ENROLL_STATUS_DESISTING')::int 
                   AND  A.statusid <> getparameter('ACADEMIC', 'ENROLL_STATUS_EXCUSED')::int )
              ORDER BY 1 );
END;
$$;


ALTER FUNCTION public.obteralunosativosdadisciplina(p_groupid integer) OWNER TO postgres;

--
-- Name: obteralunosdadisciplina(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obteralunosdadisciplina(p_groupid integer) RETURNS SETOF basphysicalperson
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: obterAlunosPorDisciplina
  PURPOSE: Obter os alunos de uma disciplina.
**************************************************************************************/

BEGIN
    RETURN QUERY ( SELECT D.*
                  FROM acdEnroll A
            INNER JOIN acdContract B
                    ON (A.contractId = B.contractId)
            INNER JOIN acdEnrollStatus C
                    ON (C.statusId = A.statusId)
       INNER JOIN ONLY basPhysicalPerson D
                    ON (B.personId = D.personId)
                 WHERE A.groupId = p_groupid
              ORDER BY 1 );
END;
$$;


ALTER FUNCTION public.obteralunosdadisciplina(p_groupid integer) OWNER TO postgres;

--
-- Name: obteratributototalizador(character varying, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obteratributototalizador(character varying, integer) RETURNS character varying
    LANGUAGE sql
    AS $_$SELECT valor from ava_totalizadores_atributos where chave=$1 and ref_totalizador=$2 $_$;


ALTER FUNCTION public.obteratributototalizador(character varying, integer) OWNER TO postgres;

--
-- Name: obtercidadeestado(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obtercidadeestado(p_cityid integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 
DECLARE
BEGIN
    RETURN (
        SELECT name || ' - ' || stateId
          FROM basCity    
         WHERE cityId = p_cityId
    );
END; 
$$;


ALTER FUNCTION public.obtercidadeestado(p_cityid integer) OWNER TO postgres;

--
-- Name: obtercodpessoamae(bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obtercodpessoamae(p_personid bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$ 
DECLARE
BEGIN
    RETURN ( SELECT personId FROM basPhysicalPersonKinship WHERE relativePersonId = p_personId AND kinshipid = GETPARAMETER('BASIC', 'MOTHER_KINSHIP_ID')::int LIMIT 1 );
END; 
$$;


ALTER FUNCTION public.obtercodpessoamae(p_personid bigint) OWNER TO postgres;

--
-- Name: obtercodpessoapai(bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obtercodpessoapai(p_personid bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$ 
DECLARE
BEGIN
    RETURN ( SELECT personId FROM basPhysicalPersonKinship WHERE relativePersonId = p_personId AND kinshipid = GETPARAMETER('BASIC', 'FATHER_KINSHIP_ID')::int LIMIT 1 );
END; 
$$;


ALTER FUNCTION public.obtercodpessoapai(p_personid bigint) OWNER TO postgres;

--
-- Name: obtercolunachaveprimariadatabela(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obtercolunachaveprimariadatabela(p_tabela character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: obterColunaChavePrimariaDaTabela
  PURPOSE: Retorna o nome da coluna chave primária da tabela.
**************************************************************************************/
DECLARE
BEGIN
    RETURN ( SELECT pg_attribute.attname
               FROM pg_index, pg_class, pg_attribute 
              WHERE pg_class.oid = p_tabela::regclass 
                AND indrelid = pg_class.oid 
                AND pg_attribute.attrelid = pg_class.oid 
                AND pg_attribute.attnum = ANY(pg_index.indkey)
                AND indisprimary );
END;
$$;


ALTER FUNCTION public.obtercolunachaveprimariadatabela(p_tabela character varying) OWNER TO postgres;

--
-- Name: obtercreditosdisciplinatitulos(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obtercreditosdisciplinatitulos() RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 
DECLARE
BEGIN
    RETURN ( SELECT ARRAY_TO_STRING(ARRAY(
        SELECT curricularcomponentcategoryid
          FROM acdcurricularcomponentcategory
      ORDER BY description
    ) , '.') );
END; 
$$;


ALTER FUNCTION public.obtercreditosdisciplinatitulos() OWNER TO postgres;

--
-- Name: obtercreditosdisciplinavalores(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obtercreditosdisciplinavalores(p_curricularcomponentid character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 
DECLARE
BEGIN
    RETURN (
            SELECT ARRAY_TO_STRING(ARRAY(
            SELECT COALESCE(

                   (SELECT CRE.credits
                      FROM acdcurricularcomponentcategorycredit CRE
                     WHERE CRE.curricularcomponentid = p_curricularComponentId
                       AND CRE.curricularcomponentcategoryid = CAT.curricularcomponentcategoryid
                     LIMIT 1)

            , 0)
              FROM acdcurricularcomponentcategory CAT
          ORDER BY CAT.description ), '.') );
END; 
$$;


ALTER FUNCTION public.obtercreditosdisciplinavalores(p_curricularcomponentid character varying) OWNER TO postgres;

--
-- Name: obtercreditosdisciplinavalores(character varying, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obtercreditosdisciplinavalores(p_curricularcomponentid character varying, p_curricularcomponentversion integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 
DECLARE
BEGIN
    RETURN (
            SELECT ARRAY_TO_STRING(ARRAY(
            SELECT COALESCE(

                   (SELECT CRE.credits
                      FROM acdcurricularcomponentcategorycredit CRE
                     WHERE CRE.curricularcomponentid = p_curricularComponentId
                       AND CRE.curricularcomponentversion = p_curricularcomponentversion
                       AND CRE.curricularcomponentcategoryid = CAT.curricularcomponentcategoryid
                     LIMIT 1)

            , 0)
              FROM acdcurricularcomponentcategory CAT
          ORDER BY CAT.description ), '.') );
END; 
$$;


ALTER FUNCTION public.obtercreditosdisciplinavalores(p_curricularcomponentid character varying, p_curricularcomponentversion integer) OWNER TO postgres;

--
-- Name: obterdatainicialnotas(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obterdatainicialnotas(p_degreeid integer, p_enrollid integer) RETURNS timestamp without time zone
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_data timestamp;
BEGIN
    
    IF ( GETPARAMETER('ACADEMIC', 'CONSIDER_HIGHER_PUNCTUATION_DEGREE') = 't' ) THEN
    BEGIN
        SELECT INTO v_data recorddate FROM acddegreeenroll WHERE degreeid = p_degreeid AND enrollid = p_enrollid AND note IS NULL ORDER BY recorddate DESC LIMIT 1;
        
        IF ( v_data IS NULL ) THEN
            SELECT INTO v_data '01-01-1900 00:00:00'::timestamp;
        END IF;
        
    END;
    ELSE
        SELECT INTO v_data '01-01-1900 00:00:00'::timestamp;
    END IF;
    
    RETURN v_data;
    
END;
$$;


ALTER FUNCTION public.obterdatainicialnotas(p_degreeid integer, p_enrollid integer) OWNER TO postgres;

--
-- Name: obterdatareferenciatitulos(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obterdatareferenciatitulos(p_contractid integer, p_learningperiodid integer) RETURNS date
    LANGUAGE sql
    AS $_$
/*************************************************************************************
  NAME: obterDataReferenciaTitulos
  PURPOSE: Retorna a data de referência para a geração de mensalidades. Se já existem títulos
           é a data de emissão do primeiro título. Caso contrário é a data atual.

  REVISIONS:
  Ver       Date       Author             Description
  --------- ---------- -----------------  ------------------------------------
  1.0       05/03/13   Leovan T. da Silva 1. FUNÇÃO criada.
**************************************************************************************/
    SELECT COALESCE(MIN(emissiondate), now()::date) 
      FROM finreceivableinvoice A
     WHERE iscanceled IS FALSE
       AND EXISTS (SELECT contractid FROM finentry
                    WHERE invoiceid = A.invoiceid
                      AND contractid = $1)
       AND EXISTS (SELECT learningperiodid FROM finentry
                    WHERE invoiceid = A.invoiceid
                      AND learningperiodid = $2);
$_$;


ALTER FUNCTION public.obterdatareferenciatitulos(p_contractid integer, p_learningperiodid integer) OWNER TO postgres;

--
-- Name: obterdiaabreviado(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obterdiaabreviado(p_value integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: obterDiaExtenso
  PURPOSE: Retorna o nome do dia por extenso (ex.: 0 = Domingo, 1 = Segunda-feira, etc..)
**************************************************************************************/
BEGIN
    RETURN CASE p_value
        WHEN 0 THEN 'DOM'
        WHEN 1 THEN 'SEG'
        WHEN 2 THEN 'TER'
        WHEN 3 THEN 'QUA'
        WHEN 4 THEN 'QUI'
        WHEN 5 THEN 'SEX'
        WHEN 6 THEN 'SAB'
    END;
END;
$$;


ALTER FUNCTION public.obterdiaabreviado(p_value integer) OWNER TO postgres;

--
-- Name: obterdiaextenso(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obterdiaextenso(p_value integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: obterDiaExtenso
  PURPOSE: Retorna o nome do dia por extenso (ex.: 0 = Domingo, 1 = Segunda-feira, etc..)
**************************************************************************************/
BEGIN
    RETURN CASE p_value
        WHEN 0 THEN 'Domingo'
        WHEN 1 THEN 'Segunda-feira'
        WHEN 2 THEN 'Terça-feira'
        WHEN 3 THEN 'Quarta-feira'
        WHEN 4 THEN 'Quinta-feira'
        WHEN 5 THEN 'Sexta-feira'
        WHEN 6 THEN 'Sábado'
    END;
END;
$$;


ALTER FUNCTION public.obterdiaextenso(p_value integer) OWNER TO postgres;

--
-- Name: seq_degreeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_degreeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_degreeid OWNER TO postgres;

--
-- Name: acddegree; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acddegree (
    degreeid integer DEFAULT nextval('seq_degreeid'::regclass) NOT NULL,
    learningperiodid integer NOT NULL,
    description text NOT NULL,
    limitdate date,
    degreenumber integer NOT NULL,
    weight double precision DEFAULT 1 NOT NULL,
    parentdegreeid integer,
    maybenull boolean DEFAULT false NOT NULL,
    methodcalculating character(3),
    isexam boolean DEFAULT false,
    examcalcmethod character(1),
    examminimumnote double precision,
    exammaximumnote double precision
)
INHERITS (baslog);


ALTER TABLE public.acddegree OWNER TO postgres;

--
-- Name: TABLE acddegree; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acddegree IS 'graus - composiã§ã£o ';


--
-- Name: COLUMN acddegree.degreeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddegree.degreeid IS 'Codigo do grau academico';


--
-- Name: COLUMN acddegree.learningperiodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddegree.learningperiodid IS 'Codigo do periodo letivo';


--
-- Name: COLUMN acddegree.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddegree.description IS 'Descricao';


--
-- Name: COLUMN acddegree.limitdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddegree.limitdate IS 'Data limite';


--
-- Name: COLUMN acddegree.degreenumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddegree.degreenumber IS 'Numero do grau';


--
-- Name: COLUMN acddegree.weight; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddegree.weight IS 'Campo que define o peso do grau que e usado para calculo da media';


--
-- Name: COLUMN acddegree.methodcalculating; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddegree.methodcalculating IS 'Coluna utilizada no grau final para determinar o método utilizado para calcular o grau final (soma, média aritmética, média ponderada)';


--
-- Name: COLUMN acddegree.examminimumnote; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddegree.examminimumnote IS 'Nota minima para NAO fazer o exame';


--
-- Name: obtergrauspordisciplina(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obtergrauspordisciplina(p_groupid integer) RETURNS SETOF acddegree
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: obterGrausPorDisciplina
  PURPOSE: Obter os graus de uma disciplina.
**************************************************************************************/

BEGIN
    RETURN QUERY ( SELECT D.* 
	       FROM acdGroup G 
          LEFT JOIN acdLearningPeriod L ON (G.learningPeriodId = L.learningPeriodId) 
          LEFT JOIN acdDegree D ON (L.learningPeriodId = D.learningPeriodId) 
              WHERE G.groupId = p_groupid
           ORDER BY D.degreeNumber );
END;
$$;


ALTER FUNCTION public.obtergrauspordisciplina(p_groupid integer) OWNER TO postgres;

--
-- Name: obterhoras(interval); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obterhoras(p_interval interval) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_hours double precision;
    v_minutes double precision;
    v_seconds double precision;
BEGIN

    SELECT INTO v_hours EXTRACT(HOURS FROM p_interval);
    SELECT INTO v_minutes EXTRACT(MINUTES FROM p_interval);
    SELECT INTO v_seconds EXTRACT(SECONDS FROM p_interval);
    
    v_minutes := v_minutes + (v_seconds / 60);
    v_hours := v_hours + (v_minutes / 60);
    
    RETURN v_hours;

END;
$$;


ALTER FUNCTION public.obterhoras(p_interval interval) OWNER TO postgres;

--
-- Name: obtermedia(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obtermedia(p_degree integer, p_group integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
DECLARE

    v_note double precision;
    v_total double precision;
    v_numenrolls integer;
    v_media double precision;
    v_enrollid integer;

BEGIN

    v_total := 0;
    v_numenrolls := 0;
    v_media := 0;

    FOR v_enrollid IN SELECT DISTINCT(enrollid) FROM acddegreeenroll WHERE degreeid = p_degree AND enrollid IN (SELECT enrollid FROM acdenroll WHERE groupid = p_group) LOOP
    BEGIN
        v_numenrolls := v_numenrolls + 1;

        SELECT INTO v_note note FROM acddegreeenroll WHERE enrollid = v_enrollid ORDER BY recorddate DESC LIMIT 1;

        v_total := v_total + v_note;
    END;
    END LOOP;

    IF ( v_numenrolls > 0 ) THEN
        RETURN v_total / v_numenrolls;
    ELSE
        RETURN 0;
    END IF;

END;
$$;


ALTER FUNCTION public.obtermedia(p_degree integer, p_group integer) OWNER TO postgres;

--
-- Name: obtermediaglobal(integer); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION obtermediaglobal(p_contractid integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
DECLARE

    v_globalAverage double precision;

BEGIN

    v_globalAverage := 0;    
    
    SELECT INTO v_globalAverage ROUND( ( SUM(( SELECT note FROM acdDegreeEnroll WHERE enrollId = A.enrollId ORDER BY recordDate DESC LIMIT 1 )) / ( SELECT COUNT(EN.*)
                                                 FROM acdEnroll EN
                                           INNER JOIN acdGroup GR
                                                   ON GR.groupId = EN.groupId
                                           INNER JOIN acdLearningPeriod LP
                                                   ON LP.learningPeriodId = GR.learningPeriodId
                                                WHERE EN.contractId = p_contractId
                                                  AND EN.statusId IN ( getParameter('ACADEMIC', 'ENROLL_STATUS_EXCUSED')::int, getParameter('ACADEMIC', 'ENROLL_STATUS_APPROVED')::int ) ) )::NUMERIC, 2) AS mediaGlobal
      FROM acdEnroll A
INNER JOIN acdContract B
        ON B.contractId = A.contractId
INNER JOIN acdMovementContract C
        ON C.contractId = B.contractId
       AND C.stateContractId = getParameter('ACADEMIC', 'STATE_CONTRACT_ID_CONCLUSION_ALL_CURRICULAR_COMPONENT')::INT
     WHERE A.contractId = p_contractId 
       AND A.statusId IN ( getParameter('ACADEMIC', 'ENROLL_STATUS_EXCUSED')::int, getParameter('ACADEMIC', 'ENROLL_STATUS_APPROVED')::int ) ;
    
    RETURN v_globalAverage;

END;
$$;


ALTER FUNCTION public.obtermediaglobal(p_contractid integer) OWNER TO solis;

--
-- Name: obtermesextenso(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obtermesextenso(p_mes integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: obterMesExtenso
  PURPOSE: Gera a representação por extenso de uma data fornecida por parâmetro
**************************************************************************************/
BEGIN
    RETURN CASE p_mes
        WHEN 01 THEN 'Janeiro'
        WHEN 02 THEN 'Fevereiro'
        WHEN 03 THEN 'Março'
        WHEN 04 THEN 'Abril'
        WHEN 05 THEN 'Maio'
        WHEN 06 THEN 'Junho'
        WHEN 07 THEN 'Julho'
        WHEN 08 THEN 'Agosto'
        WHEN 09 THEN 'Setembro'
        WHEN 10 THEN 'Outubro'
        WHEN 11 THEN 'Novembro'
        WHEN 12 THEN 'Dezembro'
    END;
END;
$$;


ALTER FUNCTION public.obtermesextenso(p_mes integer) OWNER TO postgres;

--
-- Name: obternomedisciplina(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obternomedisciplina(p_groupid integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 
DECLARE
BEGIN
    RETURN (
             SELECT CC.curricularcomponentid || ' - ' || CC.name
               FROM acdGroup G
         INNER JOIN acdCurriculum CU
                 ON G.curriculumId = CU.curriculumId
         INNER JOIN acdCurricularComponent CC
                 ON CC.curricularcomponentid = CU.curricularcomponentid
                AND CC.curricularcomponentversion = CU.curricularcomponentversion
              WHERE G.groupId = p_groupId
    );
END; 
$$;


ALTER FUNCTION public.obternomedisciplina(p_groupid integer) OWNER TO postgres;

--
-- Name: obternotaatual(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obternotaatual(p_degreeid integer, p_enrollid integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 
DECLARE
BEGIN
    RETURN (SELECT nota FROM getDegreeEnrollCurrentGrade(p_degreeId, p_enrollId, false));
END; 
$$;


ALTER FUNCTION public.obternotaatual(p_degreeid integer, p_enrollid integer) OWNER TO postgres;

--
-- Name: obternotaouconceitofinal(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obternotaouconceitofinal(p_enrollid integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 
DECLARE
BEGIN
     RETURN (SELECT nota                               
               FROM getDegreeEnrollCurrentGrade(       
                  (SELECT DE.degreeId                   
                     FROM acdDegreeEnroll DE           
               INNER JOIN acdDegree DEG 
                       ON DEG.degreeId = DE.degreeId   
               INNER JOIN acdenroll e 
                       ON (e.enrollid = DE.enrollid)
                LEFT JOIN acdgroup g 
                       ON (g.groupid = e.groupid 
                      AND DEG.learningperiodid = g.learningperiodid)
                    WHERE DE.enrollId = p_enrollId     
                      AND DEG.parentDegreeId IS NULL
                 ORDER BY g.groupid asc
                    LIMIT 1), p_enrollId, false)); 
END; 
$$;


ALTER FUNCTION public.obternotaouconceitofinal(p_enrollid integer) OWNER TO postgres;

--
-- Name: obternumerodeparcelas(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obternumerodeparcelas(p_contractid integer, p_learningperiodid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: obterNumeroDeParcelas
  PURPOSE: Retorna o número de parcelas para divisão do valor do semestre

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       13/02/2013 Leovan Tavares    1. FUNÇÃO criada.
**************************************************************************************/
DECLARE
    -- Número de parcelas definido no contrato
    CPCL integer;
    -- Parcelas passadas
    PPCL integer;
    -- Número de parcelas
    NPCL integer;
    --Numero de parcelas do periodo letivo
    LPCL integer;
    
    --Tipo de regime
    v_tipo_de_regime integer;

    -- Data que será utilizada para verificar o número de parcelas restantes
    v_data_referencia date;
    -- Data inicial do período letivo
    v_data_periodo date;
    -- Parcelas geradas
    v_parcelas_geradas int;
BEGIN
    SELECT INTO v_tipo_de_regime B.regimenId
              FROM acdEnroll A
        INNER JOIN acdGroup B
                ON (A.groupId = B.groupId)
        INNER JOIN acdCurriculum C
                ON (B.curriculumId = C.curriculumId)
        INNER JOIN acdCurricularComponent D
                ON (C.curricularComponentId = D.curricularComponentId AND
                    C.curricularComponentVersion = D.curricularComponentVersion)
        INNER JOIN acdLearningPeriod E
                ON (E.learningPeriodId = B.learningPeriodId)
             WHERE E.periodId IN (SELECT periodId FROM acdLearningPeriod WHERE learningPeriodId = p_learningPeriodId)
               AND A.contractId = p_contractId
               AND A.statusid <> GETPARAMETER('ACADEMIC', 'ENROLL_STATUS_CANCELLED')::integer;
    
    IF( getParameter('FINANCE', 'GERAR_PARCELAS_RESTANTES') = 'YES' )
    THEN

        SELECT INTO v_data_periodo begindate FROM acdlearningperiod WHERE learningperiodid = p_learningPeriodId;

        -- Obter CPCL, que está armazenado na tabela de contratos
        SELECT INTO CPCL parcelsnumber FROM acdcontract WHERE contractid = p_contractId;

        -- Obter PPCL
        -- Se já existem títulos, a data para referência é a emissão dos mesmos
        SELECT INTO v_parcelas_geradas, v_data_referencia
            COUNT(DISTINCT parcelnumber),
            MIN(emissiondate) 
        FROM finreceivableinvoice A
        WHERE iscanceled IS FALSE
        AND EXISTS ( SELECT contractid FROM finentry
                    WHERE invoiceid = A.invoiceid
                    AND contractid = p_contractId)
                    AND EXISTS (SELECT learningperiodid FROM finentry AA
                                    INNER JOIN acdlearningperiod BB USING (learningperiodid) 
                                    WHERE invoiceid = A.invoiceid
                                    AND BB.periodid IN (SELECT periodid FROM acdlearningperiod WHERE learningperiodid = p_learningPeriodId));

        --Caso a data de referencia for menor que a inicial do periodo, assume a data do período como de referencia
        IF ( v_data_referencia < v_data_periodo )
        THEN
            v_data_referencia := v_data_periodo;
        END IF;

        -- Caso não existam títulos, a data de referência é a atual
        IF v_parcelas_geradas > 0 THEN
            PPCL := EXTRACT(MONTH FROM v_data_referencia) - EXTRACT(MONTH FROM v_data_periodo);

            IF ( (CPCL - PPCL) > v_parcelas_geradas ) THEN
            RETURN (CPCL - PPCL);
            ELSE
            RETURN v_parcelas_geradas;
            END IF;
        END IF;

        v_data_referencia := now()::date;

        -- Verifica-se a diferença em meses entre a data de referencia e a data inicial do periodo
        IF v_data_referencia > v_data_periodo THEN
            PPCL := EXTRACT(MONTH FROM v_data_referencia) - EXTRACT(MONTH FROM v_data_periodo);

            NPCL := CPCL - PPCL;
        ELSE
            NPCL := CPCL;
        END IF;

        RETURN NPCL;
    ELSE
        --Obtém o número de parcelas do contrato
        SELECT INTO CPCL parcelsnumber FROM acdcontract WHERE contractid = p_contractId;
        --Obtém o número de parcelas definido no período letivo
        SELECT INTO LPCL parcelsnumber FROM acdLearningPeriod WHERE learningperiodId = p_learningPeriodId;
        --Obtém o numero de parcelas definido no parâmetro
        PPCL := getParameter('BASIC', 'DEFAULT_PARCELS_NUMBER')::INT;

        RETURN COALESCE(CPCL, LPCL, PPCL);

    END IF;    
END;
$$;


ALTER FUNCTION public.obternumerodeparcelas(p_contractid integer, p_learningperiodid integer) OWNER TO postgres;

--
-- Name: obternumeroparcelasprioridade(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION obternumeroparcelasprioridade(p_contrato integer, p_pletivo integer, p_price integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/*********************************************************************************************
  NAME: obternumeroparcelasprioridade
  PURPOSE: Obtem o preco atual do curso e periodo letivo.
    Obtém o número de parcelas, que pode ser definido em trés lugares, por ordem de prioridade:
       1) No contrato do aluno;
       2) No peréodo letivo;
       3) No preéo do curso.
*********************************************************************************************/
DECLARE
BEGIN
    RETURN (CASE WHEN p_contrato > 0 THEN p_contrato
                 WHEN p_pletivo > 0 THEN p_pletivo
                 ELSE p_price END);
END
$$;


ALTER FUNCTION public.obternumeroparcelasprioridade(p_contrato integer, p_pletivo integer, p_price integer) OWNER TO solis;

--
-- Name: obterpercentualdeaprovacoes(integer, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obterpercentualdeaprovacoes(p_contractid integer, p_periodid character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: obterPercentualDeAprovacoes
  PURPOSE: Retorna um percentual(INT) de aprovações entre elas.
**************************************************************************************/
DECLARE
	v_enrolls record;
	v_count INT;
	v_aprovacoes INT;
BEGIN
	v_count := 0;
	
	FOR v_enrolls IN ( SELECT DISTINCT G.name,
				F.semester, 				
				(SELECT count(*) FROM acdcontract AA				    
					    INNER JOIN acdenroll DD
						    ON (AA.contractid = DD.contractid 
							AND DD.statusid::text = getparameter('ACADEMIC', 'ENROLL_STATUS_APPROVED'))
					    INNER JOIN acdgroup EE
						    ON DD.groupid = EE.groupid
					    INNER JOIN acdlearningperiod BB
						    ON BB.learningPeriodId = EE.learningPeriodId
					    INNER JOIN acdcurriculum FF      
						    ON EE.curriculumid = FF.curriculumid
														    
						 WHERE AA.contractid = p_contractId
						   AND BB.periodid = p_periodId
						   AND CASE WHEN getParameter('ACADEMIC', 'PERCENTUAL_DE_APROVACAO_DE_RENOVACAO_DE_CONTRATO') = '2'
							    THEN AA.contractid = DD.contractid ELSE (FF.semester = (SELECT MAX(CU.semester)
														   FROM acdEnroll EN
													     INNER JOIN acdGroup GR
														     ON GR.groupId = EN.groupId
													     INNER JOIN acdLearningPeriod LP
														     ON LP.learningPeriodId = GR.learningPeriodId
													     INNER JOIN acdCurriculum CU
														     ON ( CU.courseId,
															  CU.courseVersion,
															  CU.turnId,
															  CU.unitId ) = ( A.courseid,
																	  A.courseversion,
																	  A.turnid,
																	  A.unitid )
														    AND CU.curriculumId = GR.curriculumId
														  WHERE EN.contractId = A.contractid
														    AND LP.periodId = B.periodId)) END ) AS aprovado
			  FROM acdcontract A
		    INNER JOIN acdcurriculum F 
			    ON ( F.courseId,
				 F.courseVersion,
				 F.turnId,
				 F.unitId ) = ( A.courseid,
						A.courseversion,
						A.turnid,
						A.unitid )
		    INNER JOIN ONLY acdcurricularcomponent G
			         ON (G.curricularcomponentid,
			             G.curricularcomponentversion) = (F.curricularcomponentid,
								      F.curricularcomponentversion)
			      INNER JOIN acdenroll H
				      ON H.curriculumid = F.curriculumid
			      INNER JOIN acdgroup L
			              ON L.groupid = H.groupid 	
			      INNER JOIN acdlearningperiod B
				      ON B.learningPeriodId = L.learningPeriodId		      
			     			
			     WHERE A.contractid = p_contractId
			       AND B.periodId = p_periodId
			       AND CASE WHEN getParameter('ACADEMIC', 'PERCENTUAL_DE_APROVACAO_DE_RENOVACAO_DE_CONTRATO') = '2'
				        THEN (A.contractid = H.contractid AND H.statusId::TEXT != getParameter('ACADEMIC', 'ENROLL_STATUS_CANCELLED')) ELSE (F.semester = (SELECT MAX(CU.semester)
                                                                                                                                                                            FROM acdEnroll EN
                                                                                                                                                                        INNER JOIN acdGroup GR
                                                                                                                                                                                ON GR.groupId = EN.groupId
                                                                                                                                                                        INNER JOIN acdLearningPeriod LP
                                                                                                                                                                                ON LP.learningPeriodId = GR.learningPeriodId
                                                                                                                                                                        INNER JOIN acdCurriculum CU
                                                                                                                                                                                ON ( CU.courseId,
                                                                                                                                                                                    CU.courseVersion,
                                                                                                                                                                                    CU.turnId,
                                                                                                                                                                                    CU.unitId ) = ( A.courseid,
                                                                                                                                                                                                    A.courseversion,
                                                                                                                                                                                                    A.turnid,
                                                                                                                                                                                                    A.unitid )
                                                                                                                                                                                AND CU.curriculumId = GR.curriculumId
                                                                                                                                                                            WHERE EN.contractId = A.contractid
                                                                                                                                                                                AND LP.periodId = B.periodId)) END

			  GROUP BY G.name, F.semester, A.courseid, A.courseversion, A.turnid, A.unitid, A.contractid, B.periodid
			  ORDER BY G.name
 )
	LOOP
		v_count := v_count + 1;

		IF ( v_aprovacoes IS NULL )
		THEN
			v_aprovacoes := v_enrolls.aprovado;
		END IF;
	END LOOP;

	RETURN (v_aprovacoes * 100) / v_count;
END;
$$;


ALTER FUNCTION public.obterpercentualdeaprovacoes(p_contractid integer, p_periodid character varying) OWNER TO postgres;

--
-- Name: obterpercentualdefrequencia(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obterpercentualdefrequencia(p_enrollid integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: obterPercentualDeFrequencia
  PURPOSE: Retorna a frequência de um aluno em uma disciplina, em %.
  DESCRIPTION: vide "PURPOSE".
 REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       09/05/2013 Bruno Fuhr        1. FUNÇÃO criada.
**************************************************************************************/
BEGIN
    RETURN ( SELECT ROUND( ((A.frequency * 100) / D.academicNumberHours)::NUMERIC, getParameter('BASIC', 'GRADE_ROUND_VALUE')::INT ) 
               FROM acdEnroll A
         INNER JOIN acdGroup B
                 ON (A.groupId = B.groupId)
         INNER JOIN acdCurriculum C
                 ON (B.curriculumId = C.curriculumId)
         INNER JOIN acdCurricularComponent D
                 ON (C.curricularComponentId = D.curricularComponentId 
                AND C.curricularComponentVersion = D.curricularComponentVersion)
              WHERE A.enrollid = p_enrollid);
END;
$$;


ALTER FUNCTION public.obterpercentualdefrequencia(p_enrollid integer) OWNER TO postgres;

--
-- Name: obterperiodopeladata(date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obterperiodopeladata(p_date date) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: obterPeriodoPelaData
  PURPOSE: Obtém o código do perído em que a data recebida por parâmetro pertence.
**************************************************************************************/

BEGIN
    RETURN ( SELECT periodId 
	       FROM acdlearningperiod 
	      WHERE p_date BETWEEN beginDate AND endDate
	      LIMIT 1 );
END;
$$;


ALTER FUNCTION public.obterperiodopeladata(p_date date) OWNER TO postgres;

--
-- Name: obterprecoatual(character varying, integer, integer, integer, date); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION obterprecoatual(p_courseid character varying, p_courseversion integer, p_turnid integer, p_unitid integer, p_date date) RETURNS SETOF obterprecotype
    LANGUAGE plpgsql
    AS $$
/*********************************************************************************************
  NAME: obterPrecoAtual
  PURPOSE: Obtem o preco atual do curso e periodo letivo.
*********************************************************************************************/
DECLARE
    V_DATE DATE;
    V_ROW obterprecotype;
BEGIN
    SELECT INTO V_DATE A.startDate
                  FROM finPrice A
                 WHERE A.courseId = p_courseId
                   AND A.courseVersion = p_courseVersion
                   AND A.turnId = p_turnId
                   AND A.unitId = p_unitId
                   AND p_date BETWEEN A.startDate AND A.endDate;

    SELECT INTO V_ROW value::float,
                      startdate,
                      bankaccountid,
                      parcelsnumber,
                      fixedvalue,
                      maturityday,
                      firstparcelatsight,
                      firstparcelatsightfreshman,
                      valueisfixed,
                      valorcreditoferias,
                      parceltype
                 FROM finprice
                WHERE courseid = p_courseid
                  AND courseversion = p_courseversion
                  AND turnid = p_turnid
                  AND unitid = p_unitid
                  AND startdate = V_DATE
                  ;

    RETURN NEXT V_ROW;
END
$$;


ALTER FUNCTION public.obterprecoatual(p_courseid character varying, p_courseversion integer, p_turnid integer, p_unitid integer, p_date date) OWNER TO solis;

--
-- Name: obterprevisaodevalorapagar(integer, integer); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION obterprevisaodevalorapagar(p_contractid integer, p_learningperiodid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: obterprevisaodevalorapagar
  PURPOSE: Obtém previsão do valor a pagar para o período letivo, se não tiver garga horária
  contratada função 

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       04/03/2013 ftomasini    1. FUNÇÃO criada.
**************************************************************************************/
DECLARE
    -- Número de créditos
    CREDITOS integer;
    -- Preço do curso
    PRECO record;
    -- Valor programado do perí­odo
    VPRG numeric;

    CH_CONT numeric;

    CH_PREV numeric;

    -- Data inicial do período letivo
    v_data_periodo date;
    v_contrato acdcontract;
BEGIN
    SELECT INTO v_data_periodo begindate FROM acdlearningperiod WHERE learningperiodid = p_learningPeriodId;

    SELECT INTO v_contrato * FROM acdcontract WHERE contractid = p_contractId;
 
    
    -- Obter o preço de curso vigente na data inicial do período letivo
    PRECO := obterprecoatual(v_contrato.courseid, v_contrato.courseversion, v_contrato.turnid, v_contrato.unitid, v_data_periodo);

    IF PRECO.valueisfixed = 't'
    THEN
	-- Número de horas (disciplinas) que o aluno tá matriculado
        CH_CONT := getTotalHours(p_contractId, p_learningPeriodId);

        -- NÃºmero de horas das disciplinas oferecidas pra turma do aluno no perÃ­odo
        CH_PREV := getHoursAvailableForEnroll(p_contractId, p_learningPeriodId);

	IF CH_CONT IS NULL
	THEN
	    CH_CONT = CH_PREV;
        END IF;
        
        VPRG := PRECO.value * CH_CONT / CH_PREV;
         
    ELSE
        -- Obter o nÃºmero de crÃ©ditos total da matrÃ­cula do contrato no perÃ­odo letivo
        CREDITOS := obtemCreditoMatriculado(p_contractId, p_learningPeriodId);

	IF CREDITOS IS NULL
	THEN
	    CREDITOS := CASE getParameter('ACADEMIC', 'USAR_CREDITOS_ACADEMICOS') 
                                  WHEN 't' THEN SUM(e.academiccredits)
                                  WHEN 'f' THEN SUM(e.lessoncredits)
                               END
                        FROM acdlearningperiod a
                  INNER JOIN acdgroup b
                          ON A.learningperiodid = B.learningperiodid
                  INNER JOIN acdcontract C
                          ON (a.courseid = c.courseid
			      and a.courseversion = c.courseversion
                              and a.turnid = c.turnid
			      and a.unitid = c.unitid)
                  INNER JOIN acdcurriculum D
                          ON d.curriculumid = b.curriculumid		
                  INNER JOIN acdcurricularcomponent E
                          ON (E.curricularcomponentid = D.curricularcomponentid
                         AND E.curricularcomponentversion = D.curricularcomponentversion)
                       where A.learningperiodid = p_learningPeriodId  
                         and c.contractid = p_contractId;

	END IF;
	    
        -- No sistema de crÃ©ditos, multiplica-se o nÃºmero de crÃ©ditos pelo valor por crÃ©dito    
        VPRG := PRECO.value * CREDITOS;
    END IF;

    RETURN VPRG;
END;
$$;


ALTER FUNCTION public.obterprevisaodevalorapagar(p_contractid integer, p_learningperiodid integer) OWNER TO solis;

--
-- Name: obterquantemprestimos(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obterquantemprestimos(p_personid integer) RETURNS bigint
    LANGUAGE plpgsql
    AS $$ 
BEGIN
    RETURN ( SELECT count(*)
               FROM gtcloan
              WHERE personid = p_personid
                AND returnforecastdate::date < now()::date
                AND returndate is null);
END; 
$$;


ALTER FUNCTION public.obterquantemprestimos(p_personid integer) OWNER TO postgres;

--
-- Name: obterquantmultas(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obterquantmultas(p_personid integer) RETURNS bigint
    LANGUAGE plpgsql
    AS $$ 
BEGIN
    RETURN ( SELECT COUNT(*)
               FROM gtcfine f
          LEFT JOIN gtcloan l
                 ON f.loanid = l.loanid
              WHERE finestatusid = ( SELECT value 
                                       FROM basconfig 
                                      WHERE parameter = 'ID_FINESTATUS_OPEN' )::int
                AND personid = p_personid );
END; 
$$;


ALTER FUNCTION public.obterquantmultas(p_personid integer) OWNER TO postgres;

--
-- Name: obterquantpenalidades(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obterquantpenalidades(p_personid integer) RETURNS bigint
    LANGUAGE plpgsql
    AS $$ 
BEGIN
    RETURN ( SELECT COUNT(*)
               FROM gtcpenalty
              WHERE coalesce( penaltyEndDate > now(), penaltyEndDate IS NULL )
                AND personid = p_personid );
END; 
$$;


ALTER FUNCTION public.obterquantpenalidades(p_personid integer) OWNER TO postgres;

--
-- Name: obtersexoextenso(character); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obtersexoextenso(p_value character) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: obterSexoExtenso
  PURPOSE: Retorna o sexo por extenso (ex.: Masculino, Feminino)
**************************************************************************************/
BEGIN
    RETURN CASE lower(p_value)
        WHEN 'm' THEN 'Masculino'
        WHEN 'f' THEN 'Feminino'
    END;
END;
$$;


ALTER FUNCTION public.obtersexoextenso(p_value character) OWNER TO postgres;

--
-- Name: obterstatusatualdocheque(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obterstatusatualdocheque(p_chequeid integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: obterStatusAtualDoCheque
  PURPOSE: Retorna o status da movimentação atual do cheque.
**************************************************************************************/
DECLARE
BEGIN
	RETURN ( SELECT SC.descricao
                   FROM finMovimentacaoCheque MC
             INNER JOIN finStatusCheque SC
                     ON MC.statusChequeId = SC.statusChequeId
                  WHERE MC.chequeId = p_chequeId
                    AND MC.dateTime = ( SELECT MAX(A.dateTime)
                                       FROM finMovimentacaoCheque A
                                 INNER JOIN finStatusCheque B
                                         ON B.statusChequeId = A.statusChequeId
                                      WHERE A.chequeId = p_chequeId
                                        AND A.data = ( SELECT MAX(data)
                                                         FROM finMovimentacaoCheque
                                                        WHERE chequeId = A.chequeId ) ) );
END;
$$;


ALTER FUNCTION public.obterstatusatualdocheque(p_chequeid integer) OWNER TO postgres;

--
-- Name: obtertitulosbloqueados(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obtertitulosbloqueados(p_contractid integer, p_learningperiodid integer) RETURNS TABLE(invoiceid integer, parcelnumber integer, nominalvalue numeric)
    LANGUAGE sql
    AS $_$
/*************************************************************************************
  NAME: obterTitulosBloqueados
  PURPOSE: Obtém os títulos que não podem sofrer alterção, ou seja, títulos pagos e/ou vencidos

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       05/03/2013 Leovan Tavares    1. FUNÇÃO criada.
**************************************************************************************/
    SELECT invoiceid, parcelnumber, nominalvalue
      FROM finreceivableinvoice A
     WHERE titulobloqueado(A.invoiceid, true)
       AND iscanceled IS FALSE
       AND EXISTS (SELECT entryid 
                     FROM finentry 
                    WHERE invoiceid = A.invoiceid 
                      AND contractid = $1)
       AND EXISTS (SELECT entryid
                     FROM finentry AA
                    INNER JOIN acdlearningperiod BB ON (BB.learningperiodid = AA.learningperiodid)
                    WHERE invoiceid = A.invoiceid
                      AND BB.periodid IN (SELECT periodid 
                                            FROM acdlearningperiod 
                                           WHERE learningperiodid = $2))
       
$_$;


ALTER FUNCTION public.obtertitulosbloqueados(p_contractid integer, p_learningperiodid integer) OWNER TO postgres;

--
-- Name: obtertitulosbloqueadosparaincentivos(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obtertitulosbloqueadosparaincentivos(p_contractid integer, p_learningperiodid integer, p_incentivetypeid integer) RETURNS TABLE(invoiceid integer, parcelnumber integer, nominalvalue numeric, incentivevalue numeric)
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: obterTitulosBloqueadosParaIncentivos
  PURPOSE: Obtém os títulos que não podem sofrer alterção, ou seja, títulos pagos e/ou vencidos, com 
           o valor de incentivo concedido em cada um.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       28/05/2013 Leovan Tavares    1. FUNÇÃO criada.
**************************************************************************************/
DECLARE  
    v_tipo_incentivo finincentivetype;
BEGIN
    SELECT INTO v_tipo_incentivo * FROM ONLY finincentivetype WHERE incentivetypeid = p_incentivetypeid;
    
    RETURN QUERY SELECT X.invoiceid, 
                        X.parcelnumber, 
                        X.nominalvalue,
                        (
                         SELECT COALESCE(SUM( CASE WHEN B.operationTypeId = 'C' THEN ( 1 * A.value ) 
                                                   WHEN B.operationTypeId = 'D' THEN ( -1 * A.value ) 
                                               END ), 0)
                           FROM finEntry A 
                          INNER JOIN finOperation B ON (B.operationid = A.operationid)
                          WHERE A.invoiceid = X.invoiceid
                            AND B.operationid IN (v_tipo_incentivo.operationid, v_tipo_incentivo.paymentoperation, v_tipo_incentivo.repaymentoperation)
                        )
                   FROM obtertitulosbloqueados(p_contractid, p_learningperiodid) X;
END;   
$$;


ALTER FUNCTION public.obtertitulosbloqueadosparaincentivos(p_contractid integer, p_learningperiodid integer, p_incentivetypeid integer) OWNER TO postgres;

--
-- Name: obtertitulosdamatricula(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obtertitulosdamatricula(p_contractid integer, p_learningperiodid integer) RETURNS SETOF integer
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: obterTitulosDaMatricula
  PURPOSE: Retorna os títulos gerados na matrícula.

  REVISIONS:
  Ver       Date       Author             Description
  --------- ---------- ------------------ ------------------------------------
  1.0       23/10/13   Augusto A. Silva   1. FUNÇÃO criada.
**************************************************************************************/
DECLARE
	v_periodo record;
BEGIN
	-- Retorna os títulos
	SELECT INTO v_periodo * FROM acdlearningperiod WHERE learningperiodid = p_learningperiodid;
	RETURN QUERY SELECT invoiceid
		       FROM finreceivableinvoice A
		      WHERE A.iscanceled IS FALSE
                 AND EXISTS (SELECT 1
                               FROM finentry
                              WHERE invoiceid = A.invoiceid
                                AND contractid = p_contractId)
                 AND EXISTS (SELECT 1
                               FROM finentry AA
                         INNER JOIN acdlearningperiod BB USING (learningperiodid)
                              WHERE AA.invoiceid = A.invoiceid
                                AND BB.periodid = v_periodo.periodid) 
                   ORDER BY parcelnumber;
END;
$$;


ALTER FUNCTION public.obtertitulosdamatricula(p_contractid integer, p_learningperiodid integer) OWNER TO postgres;

--
-- Name: obterunidadelogada(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obterunidadelogada() RETURNS integer
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
 * Obtem a unidade do usuario atual logado no postgres
******************************************************************************/
DECLARE
BEGIN
    RETURN (SELECT unitid FROM basSessao WHERE login=current_user ORDER BY data DESC LIMIT 1);
END;
$$;


ALTER FUNCTION public.obterunidadelogada() OWNER TO postgres;

--
-- Name: obtervalorapagar(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION obtervalorapagar(p_contractid integer, p_learningperiodid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: obterValorAPagar
  PURPOSE: Obtém o valor a pagar pelo período letivo

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       04/03/2013 Leovan Tavares    1. FUNÇÃO criada.
**************************************************************************************/
DECLARE
    -- Número de créditos
    CREDITOS integer;
    -- Preço do curso
    PRECO record;
    -- Valor programado do perí­odo
    VPRG numeric;

    CH_CONT numeric;

    CH_PREV numeric;

    -- Data inicial do período letivo
    v_data_periodo date;
    v_contrato acdcontract;
BEGIN
    SELECT INTO v_data_periodo begindate FROM acdlearningperiod WHERE learningperiodid = p_learningPeriodId;

    SELECT INTO v_contrato * FROM acdcontract WHERE contractid = p_contractId;
 
    
    -- Obter o preço de curso vigente na data inicial do período letivo
    PRECO := obterprecoatual(v_contrato.courseid, v_contrato.courseversion, v_contrato.turnid, v_contrato.unitid, v_data_periodo);

    IF PRECO.valueisfixed = 't'
    THEN
	-- Número de horas (disciplinas) que o aluno tá matriculado
        CH_CONT := getTotalHours(p_contractId, p_learningPeriodId);

        -- NÃºmero de horas das disciplinas oferecidas pra turma do aluno no perÃ­odo
        CH_PREV := getHoursAvailableForEnroll(p_contractId, p_learningPeriodId);

        VPRG := PRECO.value * CH_CONT / CH_PREV;
         
    ELSE
        -- Obter o nÃºmero de crÃ©ditos total da matrÃ­cula do contrato no perÃ­odo letivo
        CREDITOS := obtemCreditoMatriculado(p_contractId, p_learningPeriodId);

        -- No sistema de crÃ©ditos, multiplica-se o nÃºmero de crÃ©ditos pelo valor por crÃ©dito    
        VPRG := PRECO.value * CREDITOS;
    END IF;

    RETURN VPRG;
END;
$$;


ALTER FUNCTION public.obtervalorapagar(p_contractid integer, p_learningperiodid integer) OWNER TO postgres;

--
-- Name: prc_obterprecodaofertadecurso(integer, character); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION prc_obterprecodaofertadecurso(p_ofertadecursoid integer, p_tipo character) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: prc_obterprecodaofertadecurso
  PURPOSE: Obtem o código do preço a partir da oferta de curso

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       26/11/2013 Jonas Diel        1. Função criada.
**************************************************************************************/
DECLARE
    v_precocursoid prcprecocurso.precocursoid%TYPE;
    v_ocorrenciacursoid prcprecocurso.ocorrenciacursoid%TYPE;
BEGIN
    --Busca preço pela oferta de curso
    SELECT precocursoid INTO v_precocursoid FROM prcprecocurso WHERE ofertacursoid = p_ofertadecursoid AND tipo = p_tipo AND datainicial <= now()::date AND CASE WHEN datafinal is not null THEN datafinal > now()::date ELSE TRUE END;

    --Busca pela ocorrência de curso
    IF ( v_precocursoid IS NULL )
    THEN
        SELECT ocorrenciacursoid INTO v_ocorrenciacursoid FROM acpofertacurso WHERE ofertacursoid = p_ofertadecursoid;
        SELECT precocursoid INTO v_precocursoid FROM prcprecocurso WHERE ocorrenciacursoid = v_ocorrenciacursoid AND tipo = p_tipo AND datainicial <= now()::date AND CASE WHEN datafinal is not null THEN datafinal > now()::date ELSE TRUE END;

    END IF;

    RETURN v_precocursoid;
END;
$$;


ALTER FUNCTION public.prc_obterprecodaofertadecurso(p_ofertadecursoid integer, p_tipo character) OWNER TO solis;

--
-- Name: prc_obterprecodaofertadeturma(integer, character); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION prc_obterprecodaofertadeturma(p_ofertadeturmaid integer, p_tipo character) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: prc_obterprecodaofertadeturma
  PURPOSE: Obtem o código do preço a partir da oferta de turma

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       26/11/2013 Jonas Diel        1. Função criada.
**************************************************************************************/
DECLARE
    v_precocursoid prcprecocurso.precocursoid%TYPE;
    v_ofertacursoid  prcprecocurso.ofertacursoid%TYPE;
    v_ocorrenciacursoid prcprecocurso.ocorrenciacursoid%TYPE;

BEGIN
    --Busca preço pela turma
    SELECT precocursoid INTO v_precocursoid FROM prcprecocurso WHERE ofertaturmaid = p_ofertadeturmaid AND tipo = p_tipo;

    IF ( v_precocursoid IS NULL )
    THEN
        --Busca preço pela oferta de curso
        SELECT ofertacursoid INTO v_ofertacursoid FROM acpofertaturma WHERE ofertaturmaid = p_ofertadeturmaid;
        SELECT precocursoid INTO v_precocursoid FROM prcprecocurso WHERE ofertacursoid = v_ofertacursoid AND tipo = p_tipo;

        IF ( v_precocursoid IS NULL )
        THEN
            --Busca preço pela ocorrencia de curso
            SELECT ocorrenciacursoid INTO v_ocorrenciacursoid FROM acpofertacurso WHERE ofertacursoid = v_ofertacursoid;
            SELECT precocursoid INTO v_precocursoid FROM prcprecocurso WHERE ocorrenciacursoid = v_ocorrenciacursoid AND tipo = p_tipo;
        END IF;
    END IF;

    RETURN v_precocursoid;
END;
$$;


ALTER FUNCTION public.prc_obterprecodaofertadeturma(p_ofertadeturmaid integer, p_tipo character) OWNER TO postgres;

--
-- Name: prc_obterprecoinscricao(integer, date, date); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION prc_obterprecoinscricao(p_ofertacursoid integer, p_datainicial date, p_datafinal date) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: prc_obterprecoinscricao
  PURPOSE: Obtem o código do preço da inscricao a partir da oferta de curso

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       26/11/2013 Jonas Diel        1. Função criada.
**************************************************************************************/
DECLARE
    v_precocursoid prcprecocurso.precocursoid%TYPE;
    v_ofertacursoid  prcprecocurso.ofertacursoid%TYPE;
    v_ocorrenciacursoid prcprecocurso.ocorrenciacursoid%TYPE;

BEGIN
        --Busca preço pela oferta de curso
        SELECT precocursoid INTO v_precocursoid FROM prcprecocurso WHERE ofertacursoid = p_ofertacursoid AND tipo = 'I' AND datainicial <= COALESCE(p_datainicial, now()::date) AND ( datafinal IS NULL OR datafinal  >= COALESCE(p_datafinal, now()::date) );

        IF ( v_precocursoid IS NULL )
        THEN
            --Busca preço pela ocorrencia de curso
            SELECT ocorrenciacursoid INTO v_ocorrenciacursoid FROM acpofertacurso WHERE ofertacursoid = p_ofertacursoid;
            SELECT precocursoid INTO v_precocursoid FROM prcprecocurso WHERE ocorrenciacursoid = v_ocorrenciacursoid AND tipo = 'I' AND datainicial <= COALESCE(p_datainicial, now()::date) AND ( datafinal IS NULL OR datafinal >= COALESCE(p_datafinal, now()::date) );
        END IF;

    RETURN v_precocursoid;
END;
$$;


ALTER FUNCTION public.prc_obterprecoinscricao(p_ofertacursoid integer, p_datainicial date, p_datafinal date) OWNER TO solis;

--
-- Name: prepareallsearchcontent(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION prepareallsearchcontent() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    vClassification varchar;
    vDate varchar;
BEGIN
    vClassification := value FROM basconfig WHERE parameter = 'MARC_CLASSIFICATION_TAG';
    vDate := value FROM basconfig WHERE parameter = 'CATALOGUE_DATE_FIELDS';

    --atualiza o searchContent de todos materiais para unaccent, conforme unaccent do PHP troca a + pelo A
    UPDATE gtcmaterial SET searchcontent = trim( upper( translate( unaccent( content ) ,'+', 'A') ) );

    -- atualiza as tags 090.a e etc considerando a preferencia MARC_CLASSIFICATION_TAG
    UPDATE gtcmaterial EM SET searchContent = prepareTopographicIndex
        ( content,
            ( SELECT content
            FROM gtcmaterial IM
            WHERE fieldid = '090'
                AND subfieldid = 'b'
                AND line = 0
                AND EM.controlnumber = IM.controlNumber
            )
        )
    WHERE fieldid || '.' || subfieldid in (  SELECT regexp_split_to_table( vClassification, ',' ) );

    -- atualiza as tags de data. Observação: na 3.2 tem que ser dd/mm/yyyy
    UPDATE gtcmaterial SET searchContent = to_char( content::date, 'YYYY-mm-dd')
    WHERE fieldid || '.' || subfieldid in ( SELECT regexp_split_to_table( vDate , ',') );

    return true;
END;
$$;


ALTER FUNCTION public.prepareallsearchcontent() OWNER TO postgres;

--
-- Name: preparesearchcontent(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION preparesearchcontent(tag character varying, content character varying, complement character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    isClassification integer;
    isDate integer;
BEGIN
    -- Controla casos onde a tag vem nula ou somente com ponto.
    IF length( tag ) > 1 
    THEN
        isClassification = position( tag in ( SELECT value FROM basconfig WHERE parameter = 'MARC_CLASSIFICATION_TAG' ) );

        IF isClassification > 0
        THEN
            return prepareTopographicIndex( content,complement );
        END IF;

        isDate = position( tag in ( SELECT value FROM basconfig WHERE parameter = 'CATALOGUE_DATE_FIELDS' ) );

        IF isDate > 0
        THEN
            return to_char( content::date, 'YYYY-mm-dd');
            --return to_char( content::date, 'dd/mm/yyyy'); --na 3.2 tem que ser dd/mm/yyyy
        END IF;
    END IF;

    return trim( upper( unaccent( translate( content ,'+', 'A') ) ) );
END;
$$;


ALTER FUNCTION public.preparesearchcontent(tag character varying, content character varying, complement character varying) OWNER TO postgres;

--
-- Name: preparesearchcontentforsearchmodule(character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION preparesearchcontentforsearchmodule(tag character varying, content character varying, complement character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    isClassification integer;
    isDate integer;
BEGIN
    -- Controla casos onde a tag vem nula ou somente com ponto.
    IF length( tag ) > 1 
    THEN
        isClassification = position( tag in ( SELECT value FROM basconfig WHERE parameter = 'MARC_CLASSIFICATION_TAG' ) );

        IF isClassification > 0
        THEN
            return preparetopographicindexsearch( content,complement );
        END IF;

        isDate = position( tag in ( SELECT value FROM basconfig WHERE parameter = 'CATALOGUE_DATE_FIELDS' ) );

        IF isDate > 0
        THEN
            return to_char( content::date, 'YYYY-mm-dd');
            --return to_char( content::date, 'dd/mm/yyyy'); --na 3.2 tem que ser dd/mm/yyyy
        END IF;
    END IF;

    return trim( upper( unaccent( translate( content ,'+', 'A') ) ) );
END;
$$;


ALTER FUNCTION public.preparesearchcontentforsearchmodule(tag character varying, content character varying, complement character varying) OWNER TO postgres;

--
-- Name: preparetopographicindex(character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION preparetopographicindex(content character varying, complement character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
    result varchar;
    resultAux varchar;
    number integer;
    content_v varchar;

    count int;
    new_content varchar;
    letter char;
BEGIN
    --tira acentos e converte pra minusculas e adiciona | como terminador de string.
    result := lower ( unaccent ( trim( content ) ) ) || '|';

    -- Separa somente números
    new_content := '';
    count := 0;
    number := 0;

    WHILE (count < char_length(content))
    LOOP
        -- Obtém caractere.
        letter := substring(content, count+1, 1);

        -- Testa se caractere é numérico.
        IF letter ~ '^[0-9]$'
        THEN
            new_content := new_content || letter;
        ELSE
            IF char_length(new_content) > 0
            THEN
                 number := new_content::integer;
                EXIT;
            END IF;
        END IF;

        count = count + 1;
    END LOOP;

    content_v := substring(content from position(number::text in content));

    /**
        Exemplo de precedência que deve ser levado em conta, vide #12268 :
        658.012.4+657 -> + vem primeiro
        658.012.4/.5 -> / vem segundo
        658.012.4 -> Numeros inteiros em terceiro
        658.012.4:266 -> : depois dos números inteiros
    */
    result := translate( result, '+/|:=("*-.\'0123456789', 'ABCDEFGHIJKMNOPQRSTUV');
    --tratamento da excessão (0 => EI deve vir após (1/9 => EJ/9
    --result := replace( result, 'FJ','FT');

    --tratamento da exceção "(=" vai depois de ([0-9].
    result := replace( result, 'FE','FW');

    --Trata a excessão quando o termo >= 820 e < 900 o (1/9 => F[KLMNOPQRS] vai depois do . => I (J))
    IF (number>= 82 AND number < 90) OR (number >= 820 and number < 900 )
    THEN
        IF ( (content_v ~ E'^(([0-9]{3})|([0-9]{2}))\\([1-9].*$') OR (content_v ~ E'^(([0-9]{3})|([0-9]{2}))\\.[0-9]{1}\\([1-9].*$') )
        THEN
             resultAux = substring(result FROM position(')' in result));
             result = substring(result FROM 0 FOR position(')' in result));

             result := regexp_replace(result, 'F([NOPQRSTUV])', E'L\\1','g');
             result := result || resultAux;

         END IF;
    END IF;

    -- Substitui o ')' por um caractere de baixa prioridade.
    result = translate( result, ')', '5');

    --adiciona F na frente de cada caracter minusculo a fim de priorizar alguns caracteres
    result := trim( regexp_replace( result,'([a-z])',E'GX\\1','g') );

    --caso tenha complemento concatena
    IF complement IS NOT NULL AND result <> ''
    THEN
        result := result || '@' || complement;
    END IF;

    return result;
END;
$_$;


ALTER FUNCTION public.preparetopographicindex(content character varying, complement character varying) OWNER TO postgres;

--
-- Name: preparetopographicindexsearch(character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION preparetopographicindexsearch(content character varying, complement character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
    result varchar;
    resultAux varchar;
    number integer;
    content_v varchar;

    count int;
    new_content varchar;
    letter char;
BEGIN
    --tira acentos e converte pra minusculas e adiciona | como terminador de string.
    result := lower ( unaccent ( trim( content ) ) );

    -- Separa somente números
    new_content := '';
    count := 0;
    number := 0;

    WHILE (count < char_length(content))
    LOOP
        -- Obtém caractere.
        letter := substring(content, count+1, 1);

        -- Testa se caractere é numérico.
        IF letter ~ '^[0-9]$' AND char_length(new_content) < 9
        THEN
            new_content := new_content || letter;
        ELSE
            IF char_length(new_content) > 0
            THEN
                 number := new_content::integer;
                EXIT;
            END IF;
        END IF;

        count = count + 1;
    END LOOP;

    content_v := substring(content from position(number::text in content));

    /**
        Exemplo de precedência que deve ser levado em conta, vide #12268 :
        658.012.4+657 -> + vem primeiro
        658.012.4/.5 -> / vem segundo
        658.012.4 -> Numeros inteiros em terceiro
        658.012.4:266 -> : depois dos números inteiros
    */
    result := translate( result, '+/|:=("*-.\'0123456789', 'ABCDEFGHIJKMNOPQRSTUV');
    --tratamento da excessão (0 => EI deve vir após (1/9 => EJ/9
    --result := replace( result, 'FJ','FT');

    --tratamento da exceção "(=" vai depois de ([0-9].
    result := replace( result, 'FE','FW');

    --Trata a excessão quando o termo >= 820 e < 900 o (1/9 => F[KLMNOPQRS] vai depois do . => I (J))
    IF (number>= 82 AND number < 90) OR (number >= 820 and number < 900 )
    THEN
        IF ( (content_v ~ E'^(([0-9]{3})|([0-9]{2}))\\([1-9].*$') OR (content_v ~ E'^(([0-9]{3})|([0-9]{2}))\\.[0-9]{1}\\([1-9].*$') )
        THEN
             resultAux = substring(result FROM position(')' in result));
             result = substring(result FROM 0 FOR position(')' in result));

             result := regexp_replace(result, 'F([NOPQRSTUV])', E'L\\1','g');
             result := result || resultAux;

         END IF;
    END IF;

    -- Substitui o ')' por um caractere de baixa prioridade.
    result = translate( result, ')', '5');

    --adiciona F na frente de cada caracter minusculo a fim de priorizar alguns caracteres
    result := trim( regexp_replace( result,'([a-z])',E'GX\\1','g') );

    --caso tenha complemento concatena
    IF complement IS NOT NULL AND result <> ''
    THEN
        result := result || '@' || complement;
    END IF;

    return result;
END;
$_$;


ALTER FUNCTION public.preparetopographicindexsearch(content character varying, complement character varying) OWNER TO postgres;

--
-- Name: professortimesheet(integer, integer, integer, integer, integer, character varying, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION professortimesheet(p_professorid integer, p_beginmonth integer, p_beginyear integer, p_endmonth integer, p_endyear integer, p_courseid character varying, p_courseversion integer, p_unitid integer, p_turnid integer) RETURNS SETOF t_professortimesheet
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: professorTimeSheet
  PURPOSE: Monta a tabela de horas do professor, por intervalo de tempo.
  DESCRIPTION: Recebe por parâmetro um professor, mês/ano inicial e mês/ano final.
  Opcionalmente pode receber também uma ocorrência de curso. Retorna o total de horas
  prestadas nas diferentes categorias.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       15/06/2011 Alexandre Schmidt 1. Função criada.
  1.1       10/08/2011 Alex Smith        1. Correção de bug na busca de atividades
                                         internas/externas realizadas.
**************************************************************************************/
DECLARE
    v_professorCurrentCommitment RECORD;
    v_preparationFactor float;
BEGIN
    -- evitar ocorrências de curso informadas parcialmente (deve ser completa ou nula)
    IF COALESCE(p_courseId, p_courseVersion::varchar, p_unitId::varchar, p_turnId::varchar) IS NOT NULL THEN
        IF (p_courseId || p_courseVersion || p_unitId || p_turnId) IS NULL THEN
            RAISE EXCEPTION 'Informe uma ocorrência de curso completa (curso, versão, unidade e turno) ou deixe todos os campos em branco.';
        END IF;
    END IF;

    IF (p_beginMonth + p_beginYear+ p_endMonth + p_endYear) IS NULL THEN
        RAISE EXCEPTION 'Informe mês e ano inicial e final.';
    END IF;

    -- obter informações de comprometimento de horas do professor
    SELECT * INTO v_professorCurrentCommitment
      FROM getProfessorCurrentCommitment(p_professorId);
    -- obter percentual de horas para preparação de aula
    SELECT value::float INTO v_preparationFactor
      FROM basConfig
     WHERE moduleConfig = 'BASIC'
       AND parameter = 'LESSONS_PREPARATION_FACTOR';

    v_preparationFactor := COALESCE(v_preparationFactor, 0);

    RETURN QUERY
        SELECT p_professorId,
               p_courseId,
               p_courseVersion,
               p_unitId,
               p_turnId,
               r_queryYear,
               r_queryMonth,
               COALESCE(v_professorCurrentCommitment.teachWorkLoad, 0) - (r_programmedTeachHours + r_programmedPreparationHours + r_directionHours + r_internalExternalActivitiesProgrammedHours) AS r_availableProgrammedHours,
               COALESCE(v_professorCurrentCommitment.teachWorkLoad, 0) - (r_realizedTeachHours + r_realizedPreparationHours + r_directionHours + r_internalExternalActivitiesRealizedHours) AS r_availableRealizedHours,
               r_programmedTeachHours,
               r_realizedTeachHours,
               r_programmedPreparationHours,
               r_realizedPreparationHours,
               r_directionHours,
               r_internalExternalActivitiesProgrammedHours,
               r_internalExternalActivitiesRealizedHours,
               -- totalizadores
               r_programmedTeachHours + r_programmedPreparationHours + r_directionHours + r_internalExternalActivitiesProgrammedHours AS r_totalProgrammedHours,
               r_realizedTeachHours + r_realizedPreparationHours + r_directionHours + r_internalExternalActivitiesRealizedHours AS r_totalRealizedHours
          FROM (SELECT EXTRACT(YEAR FROM Dates.beginDate)::integer AS r_queryYear,
                       EXTRACT(MONTH FROM Dates.beginDate)::integer AS r_queryMonth,
                       -- carga horaria de aula prevista
                       getProgrammedTeachHours(
                           p_professorId,
                           Dates.beginDate,
                           Dates.endDate,
                           p_courseId,
                           p_courseVersion,
                           p_turnId,
                           p_unitId) AS r_programmedTeachHours,
                       -- carga horaria de aula realizada
                       getRealizedTeachHours(
                           p_professorId,
                           Dates.beginDate,
                           Dates.endDate,
                           p_courseId,
                           p_courseVersion,
                           p_turnId,
                           p_unitId) AS r_realizedTeachHours,
                       -- carga horaria prevista para preparacao de aulas (fixo em 30%)
                       getProgrammedTeachHours(
                           p_professorId,
                           Dates.beginDate,
                           Dates.endDate,
                           p_courseId,
                           p_courseVersion,
                           p_turnId,
                           p_unitId) * v_preparationFactor AS r_programmedPreparationHours,
                       -- carga horaria realizada de preparacao de aulas (fixo em 30% da carga horaria de aula)
                       getRealizedTeachHours(
                           p_professorId,
                           Dates.beginDate,
                           Dates.endDate,
                           p_courseId,
                           p_courseVersion,
                           p_turnId,
                           p_unitId) * v_preparationFactor AS r_realizedPreparationHours,
                       -- carga horaria total de orientacao no periodo
                       getDirectionHours(
                           p_professorId,
                           Dates.beginDate,
                           Dates.endDate,
                           p_courseId,
                           p_courseVersion,
                           p_turnId,
                           p_unitId) AS r_directionHours,
                       -- carga horaria programada para atividades internas ou externas
                       getInternalExternalActivitiesProgrammedHours(
                           p_professorId,
                           Dates.beginDate,
                           Dates.endDate) AS r_internalExternalActivitiesProgrammedHours,
                       -- carga horaria realizada em atividades internas ou externas
                       getInternalExternalActivitiesRealizedHours(
                           p_professorId,
                           Dates.beginDate,
                           Dates.endDate) AS r_internalExternalActivitiesRealizedHours
                       -- Geracao dos intervalos de data a consultar
                  FROM (SELECT A.queryDate::date AS beginDate,
                               (A.queryDate + '1 MONTH'::interval)::date - 1 AS endDate
                          FROM (SELECT generate_series((p_beginYear || '-' || p_beginMonth || '-' || '01')::date,
                                                       (p_endYear || '-' || p_endMonth || '-' || '01')::date,
                                                       '1 MONTH'::interval) AS queryDate) A) Dates) A;
END;
$$;


ALTER FUNCTION public.professortimesheet(p_professorid integer, p_beginmonth integer, p_beginyear integer, p_endmonth integer, p_endyear integer, p_courseid character varying, p_courseversion integer, p_unitid integer, p_turnid integer) OWNER TO postgres;

--
-- Name: ptcgeneraterequestnumber(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION ptcgeneraterequestnumber(p_subjectid integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
/*************************************************************************************
  NAME: ptcgeneraterequestnumber
  PURPOSE: Retorna o número de cadastro de solicitação, baseando-se na
     configuração REQUEST_NUMBER_FORMAT.

  REVISIONS:
  Ver       Date       Author                Description
  --------- ---------- -------------------- ------------------------------------
  1.0       15/02/2012 moises                Criado função.
**************************************************************************************/
DECLARE
    v_retVal varchar;
    v_seqYearLast int;
    v_seqYearNumber int;
    v_seqIncremental int;
    v_currentYear int;
    v_request record;
BEGIN
    -- Obtem configuracoes
    v_retVal := GETPARAMETER('PROTOCOL', 'REQUEST_NUMBER_FORMAT');

    -- Substituicao de tags
    v_retVal := REPLACE(v_retVal, '$DAY$', TO_CHAR(NOW(), 'dd'));
    v_retVal := REPLACE(v_retVal, '$MONTH$', TO_CHAR(NOW(), 'mm'));
    v_retVal := REPLACE(v_retVal, '$YEAR$', TO_CHAR(NOW(), 'yyyy'));
    v_retVal := REPLACE(v_retVal, '$SUBJECTID$', p_subjectid::varchar);

    --
    -- Trata parametro $SEQ$
    --
    IF STRPOS(v_retVal, '$SEQ$') > 0
    THEN
        v_seqIncremental := GETPARAMETER('PROTOCOL', 'SEQ_INCREMENTAL')::int + 1;

        -- Substitui parametro
        v_retVal := REPLACE(v_retVal, '$SEQ$', v_seqIncremental::varchar);

        -- Atualiza nas configuracoes
        UPDATE basConfig SET value = v_seqIncremental::varchar WHERE parameter='SEQ_INCREMENTAL' AND moduleConfig='PROTOCOL';
    END IF;

    --
    -- Trata parametro $SEQ_YEAR$
    --
    IF STRPOS(v_retVal, '$SEQ_YEAR$') > 0
    THEN
        v_currentYear = TO_CHAR(NOW(), 'yyyy')::int;
        v_seqYearLast := GETPARAMETER('PROTOCOL', 'SEQ_YEAR_LAST')::int;

        -- Quando mudar o ano, tambem zera o numero incremental
        IF v_seqYearLast != v_currentYear
        THEN
            UPDATE basConfig SET value = (v_seqYearLast + 1)::varchar WHERE parameter='SEQ_YEAR_LAST' AND moduleConfig='PROTOCOL';
            UPDATE basConfig SET value = '0' WHERE parameter='SEQ_YEAR_NUMBER' AND moduleConfig='PROTOCOL';
        END IF;

        -- Obtem ultimo numero da sequencia (por ano)
        v_seqYearNumber := GETPARAMETER('PROTOCOL', 'SEQ_YEAR_NUMBER')::int + 1;

        -- Substitui parametro
        v_retVal := REPLACE(v_retVal, '$SEQ_YEAR$', v_seqYearNumber::varchar);

        -- Atualiza nas configuracoes
        UPDATE basConfig SET value = v_seqYearNumber::varchar WHERE parameter='SEQ_YEAR_NUMBER' AND moduleConfig='PROTOCOL';
    END IF;

    --
    RETURN v_retVal;
END;
$_$;


ALTER FUNCTION public.ptcgeneraterequestnumber(p_subjectid integer) OWNER TO postgres;

--
-- Name: reserveposition(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION reserveposition(p_reserveid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
    DECLARE

        v_position integer;
        v_position_aux integer;
        v_reservestatusid integer;
       -- v_linha RECORD;
        v_itemnumber varchar;
    BEGIN 
	SELECT INTO v_reservestatusid reservestatusid FROM gtcreserve WHERE reserveid=p_reserveid;

	--se for atendida ou comunicada retorna 0 para depois ser tratado de outra forma
        IF v_reservestatusid = 2 OR v_reservestatusid = 3
        THEN
  	    v_position = 0;
	    
	ELSE --senão busca a posição da reserva  
            v_position = 0;
 
            FOR v_itemnumber IN (SELECT itemnumber FROM gtcreservecomposition WHERE reserveid = p_reserveid)
            LOOP
                
                SELECT INTO v_position_aux COUNT(DISTINCT gtcreserve.reserveid) 
              FROM gtcreserve 
        INNER JOIN gtcreservecomposition 
	        ON(gtcreserve.reserveid = gtcreservecomposition.reserveid) 
             WHERE gtcreservecomposition.itemnumber = v_itemnumber
               AND requesteddate <= (SELECT requesteddate 
                                       FROM gtcreserve 
	                              WHERE reserveid= p_reserveid) 
                AND reservestatusid='1'; 

                IF v_position_aux > v_position
                THEN 
                    v_position = v_position_aux;
                END IF; 
           
            END LOOP;

            
      	END IF;

        RETURN v_position;

     END;

$$;


ALTER FUNCTION public.reserveposition(p_reserveid integer) OWNER TO postgres;

--
-- Name: sea_bibliography_data(integer, character varying, integer, character varying); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION sea_bibliography_data(p_controlnumber integer, p_content character varying, p_libraryunit integer, p_tags character varying) RETURNS SETOF type_bibliography_data
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_line TYPE_BIBLIOGRAPHY_DATA;
    v_select text;
    
BEGIN
       
    v_select  = 'SELECT DISTINCT controlnumber
                           FROM gtcmaterial 
                         WHERE subfieldid <> ''#''';
  
 
    IF p_controlnumber IS NOT NULL
    THEN
        v_select = v_select || ' AND controlnumber = ' || p_controlnumber;
    END IF;
                                              
    IF p_content IS NOT NULL 
    THEN
        v_select = v_select || ' AND lower( unaccent( searchcontent ) ) LIKE lower( unaccent( ''%' || p_content || '%'' ) )';
    END IF;

                 
    v_select = 'SELECT controlnumber,
                       fieldid,
                       subfieldid,
                       content
                 FROM gtcmaterial
                WHERE controlnumber IN ( ' || v_select || ')';
                
    IF p_tags IS NOT NULL 
    THEN
        v_select = v_select || ' AND fieldid || ''.'' || subfieldid IN ( '''|| replace(p_tags, ',', ''',''') || ''')';
    END IF;            
               
    v_select = v_select || ' ORDER BY controlnumber, fieldid, subfieldid';        
                        
    FOR v_line IN EXECUTE v_select
    LOOP
        RETURN NEXT v_line;
    END LOOP;
    
    RETURN;
          
END;
$$;


ALTER FUNCTION public.sea_bibliography_data(p_controlnumber integer, p_content character varying, p_libraryunit integer, p_tags character varying) OWNER TO solis;

--
-- Name: sea_multas_em_aberto(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION sea_multas_em_aberto(p_codigo_da_pessoa integer) RETURNS SETOF type_multas_em_aberto
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_select varchar;
    v_line type_multas_em_aberto;
BEGIN

    -- Funcao para buscar as multas em aberto. Será utilizado pelo SAGU
    v_select := 'SELECT F.fineId as codigodamulta , F.loanId as codigodoemprestimo, F.value as valor, F.observation as observacao, F.begindate as datahora FROM gtcFine F INNER JOIN gtcLoan L ON (F.loanId = L.loanId) WHERE L.personId = ' || p_codigo_da_pessoa || ' AND F.fineStatusId = 1';

    FOR v_line IN EXECUTE v_select
    LOOP
        RETURN NEXT v_line;
    END LOOP;
END;
$$;


ALTER FUNCTION public.sea_multas_em_aberto(p_codigo_da_pessoa integer) OWNER TO postgres;

--
-- Name: semestreconclusaocursopessoacenso(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION semestreconclusaocursopessoacenso(p_contractid integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: semestreConclusaoCursoPessoaCenso
  PURPOSE: Verifica o semestre em que foi concluído o curso, caso tenha sido.
**************************************************************************************/
BEGIN
    RETURN ( CASE WHEN ( 11 IN ( SELECT stateContractId
                                   FROM acdMovementContract
                                  WHERE contractId = p_contractId ) ) -- Verifica se o contrato possui movimentaç?o de colaç?o de grau
                  THEN
                       ( CASE WHEN ( TO_CHAR( ( SELECT endDate
						  FROM acdLearningPeriod
						 WHERE learningPeriodId = ( SELECT learningPeriodId
									      FROM acdMovementContract
									     WHERE contractId = p_contractId
									       AND stateContractId = 11 ) ), 'mm' ) )::INT > 07
                              THEN
                                   '2'
                              ELSE
                                   '1'
                         END )
                  ELSE 
                       NULL
             END );
END;
$$;


ALTER FUNCTION public.semestreconclusaocursopessoacenso(p_contractid integer) OWNER TO postgres;

--
-- Name: setinvoicebalance(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION setinvoicebalance() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: setinvoicebalance
  DESCRIPTION: Trigger que atualiza o campo fininvoice.balance com o saldo do titulo,
               de acordo com os lancamentos.

  REVISIONS:
  Ver       Date       Author             Description
  --------- ---------- ------------------ ------------------------------------
  1.0       30/09/2011 Leovan T. da Silva 1. Trigger criada.
******************************************************************************/
DECLARE
    v_balance NUMERIC;
    v_invoiceid INTEGER;
BEGIN
    IF TG_OP = 'INSERT' THEN
        v_invoiceid = NEW.invoiceId;
    END IF;

    IF TG_OP = 'DELETE' OR TG_OP = 'UPDATE' THEN
        v_invoiceid = OLD.invoiceId;
    END IF;
    
    SELECT INTO v_balance COALESCE(SUM( CASE WHEN B.operationTypeId = 'D' THEN ( 1 * A.value ) 
                                    WHEN B.operationTypeId = 'C' THEN ( -1 * A.value ) 
                               END ), 0)
      FROM finEntry A
     INNER JOIN finOperation B ON (B.operationId = A.operationId) 
     WHERE A.invoiceId = v_invoiceId;

    UPDATE finInvoice SET balance = v_balance WHERE invoiceId = v_invoiceId;

    IF TG_OP = 'INSERT' THEN
        RETURN NEW;
    END IF;

    IF TG_OP = 'DELETE' OR TG_OP = 'UPDATE' THEN
        RETURN OLD;
    END IF;
END;
$$;


ALTER FUNCTION public.setinvoicebalance() OWNER TO postgres;

--
-- Name: setinvoicenominalvalue(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION setinvoicenominalvalue() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: setinvoicenominalvalue
  DESCRIPTION: Trigger que atualiza o campo finreceivableinvoice.balance com o
               valor nominal de acordo com os lançamentos de débito.

  REVISIONS:
  Ver       Date       Author             Description
  --------- ---------- ------------------ ------------------------------------
  1.0       05/03/13   Leovan T. da Silva 1. Trigger criada.
******************************************************************************/
DECLARE
    v_value NUMERIC;
    v_invoiceid INTEGER;
BEGIN
    IF TG_OP = 'INSERT' THEN
        v_invoiceid = NEW.invoiceId;
    END IF;

    IF TG_OP = 'DELETE' OR TG_OP = 'UPDATE' THEN
        v_invoiceid = OLD.invoiceId;
    END IF;

    SELECT INTO v_value
                COALESCE(SUM( CASE WHEN B.operationTypeId = 'D' THEN ( 1 * A.value ) 
                                   WHEN B.operationTypeId = 'C' THEN ( -1 * A.value ) 
                               END ), 0)
    FROM finentry A
    INNER JOIN finoperation B ON (B.operationid = A.operationid)
    WHERE A.invoiceid = v_invoiceid 
      AND ((B.operationtypeid = 'D' AND
           A.operationid NOT IN (SELECT interestoperation
                                   FROM findefaultoperations
                                 UNION 
                                 SELECT otheradditionsoperation
                                   FROM findefaultoperations))
       OR A.operationid IN (SELECT cancelcurricularcomponentoperation
                              FROM findefaultoperations));

    UPDATE finInvoice SET nominalvalue = v_value WHERE invoiceId = v_invoiceid;

    IF TG_OP = 'INSERT' THEN
        RETURN NEW;
    END IF;

    IF TG_OP = 'DELETE' OR TG_OP = 'UPDATE' THEN
        RETURN OLD;
    END IF;
END;
$$;


ALTER FUNCTION public.setinvoicenominalvalue() OWNER TO postgres;

--
-- Name: settotalenrolled(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION settotalenrolled() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: setTotalEnrolled
  DESCRIPTION: Atualiza o valor de total de alunos matriculados
******************************************************************************/
DECLARE
    v_totalenrolled INTEGER;
    v_subscriptionTotalVacancies INTEGER;
    v_vacant INTEGER;
    v_checkStatus boolean;
BEGIN
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN

        SELECT INTO v_totalenrolled COUNT(*) FROM acdenroll WHERE groupid = NEW.groupid AND statusid <> 5
            -- Trata regra de pre-matricula (consumir vaga)
            AND ( CASE WHEN statusId = GETPARAMETER('ACADEMIC', 'ENROLL_STATUS_PRE_ENROLLED')::int
              THEN
                NEW.preEnrollConsumeVacant IS NOT FALSE
              ELSE
                1=1
              END
            );

        -- Obtem o total de vagas
        SELECT INTO v_vacant vacant FROM acdGroup WHERE groupid = NEW.groupid;

        -- Caso estiver matriculado em uma disciplina cheia e estiver fazendo uma edicao de matricula, nao exibir o erro
        IF TG_OP = 'UPDATE'
        THEN
            v_checkStatus := NEW.statusid != OLD.statusid;
        ELSE
            v_checkStatus := TRUE;
        END IF;

        IF ( (v_subscriptionTotalVacancies >= v_vacant) AND ( NEW.statusid != 5 ) AND v_checkStatus IS TRUE )
        THEN
            RAISE EXCEPTION 'O número de inscritos não pode exceder o total de vagas. O total de vagas para esta disciplina é (%)', v_vacant;
            RETURN NULL;
        END IF;

        UPDATE acdgroup SET totalenrolled = v_totalenrolled WHERE groupid = NEW.groupid;
        RETURN NEW;
    END IF;
    IF TG_OP = 'DELETE' THEN
        SELECT INTO v_totalenrolled COUNT(*) FROM acdenroll WHERE groupid = OLD.groupid AND statusid <> 5;
        UPDATE acdgroup SET totalenrolled = v_totalenrolled WHERE groupid = OLD.groupid;
        RETURN OLD;
    END IF;
END;
$$;


ALTER FUNCTION public.settotalenrolled() OWNER TO postgres;

--
-- Name: situacaovinculocursopessoacenso(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION situacaovinculocursopessoacenso(p_val character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: situacaoVinculoCursoPessoaCenso
  PURPOSE: Valida o id do estado contratual para o censo cujos ids s?o diferentes do sagu.
**************************************************************************************/
BEGIN
    RETURN 
    ( CASE WHEN ( p_val = 'Matricula' OR p_val = 'Reingresso' OR p_val = 'Renovacao' ) 
           THEN 
                '2' --MATRICULADO / CURSANDO
           WHEN ( p_val = 'Trancamento' OR p_val = 'Cancelamento' ) 
           THEN 
                '3' --TRANCAMENTO
           WHEN ( p_val = 'Mudanca de curso (S)' )  
           THEN 
                '4' --DESVINCULADO DO CURSO
           WHEN ( p_val = 'Transferencia (S)' OR p_val = 'Transferencia (E)' ) 
           THEN 
                '5' --TRANSFER?NCIA
           WHEN ( p_val = 'Concluintes' ) 
           THEN 
                '6' --COLAÇ?O DE GRAU / FORMADO
           WHEN ( p_val = 'Falecimento' ) 
           THEN 
                '7' --FALECIMENTO
           ELSE 
                p_val
      END );
END;
$$;


ALTER FUNCTION public.situacaovinculocursopessoacenso(p_val character varying) OWNER TO postgres;

--
-- Name: syncacdenrollfrequencytoacdfrequenceenroll(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION syncacdenrollfrequencytoacdfrequenceenroll() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: syncAcdEnrollFrequencyToAcdFrequenceEnroll
  PURPOSE: Manter o campo acdEnroll.frequency atualizado.
  DESCRIPTION:
  Trigger executada sempre que a acdFrequenceEnroll sofre alguma alteração, para que o
  valor de total de frequéncia na acdEnroll seja definido como sendo a soma de todas
  as horas em que o aluno tem frequéncia registrada.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       10/06/2011 Alex Smith        1. FUNÇÃO criada.
  1.1       30/11/2011 Moises Heberle    1. Corrigindo arrendondamento para padrao
                                           do SAGU.
  1.2       12/06/2012 Jonas e Samuel    1. Corrigindo calculo de horas/aula.
  1.3       05/06/2014 Nataniel          1. Corrigindo calculo de horas/aula.
**************************************************************************************/
BEGIN
    IF TG_OP <> 'DELETE'
    THEN
    UPDATE acdEnroll A
       SET frequency = COALESCE(ROUND((SELECT SUM(
                                              EXTRACT(HOURS   FROM (C.numberminutes) * B.frequency) +       
                                              EXTRACT(MINUTES FROM (C.numberminutes) * B.frequency) / 60 +  
                                              EXTRACT(SECONDS FROM (C.numberminutes) * B.frequency) / 60 / 6)::float
                                         FROM acdFrequenceEnroll B
                                   INNER JOIN acdTime C
                                           ON C.timeId = B.timeId
                                   INNER JOIN acdSchedule D
			                   ON ( B.scheduleId = D.scheduleId
                                          AND   B.frequencyDate = ANY (D.occurrencedates) )
                                        WHERE B.enrollId = A.enrollId)::numeric,  GETPARAMETER('BASIC','FREQUENCY_ROUND_VALUE')::int), frequency)
    WHERE A.enrollId = NEW.enrollId;

        RETURN NEW;
    ELSE

    UPDATE acdEnroll A
       SET frequency = COALESCE(ROUND((SELECT SUM(
                                              EXTRACT(HOURS   FROM (C.numberminutes) * B.frequency) +       
                                              EXTRACT(MINUTES FROM (C.numberminutes) * B.frequency) / 60 +  
                                              EXTRACT(SECONDS FROM (C.numberminutes) * B.frequency) / 60 / 6)::float
                                         FROM acdFrequenceEnroll B
                                   INNER JOIN acdTime C
                                           ON C.timeId = B.timeId
                                   INNER JOIN acdSchedule D
			                   ON ( B.scheduleId = D.scheduleId
                                          AND   B.frequencyDate = ANY (D.occurrencedates) )
                                        WHERE B.enrollId = A.enrollId)::numeric,  GETPARAMETER('BASIC','FREQUENCY_ROUND_VALUE')::int), frequency)
     WHERE A.enrollId = OLD.enrollId;

        RETURN OLD;
    END IF;
END;
$$;


ALTER FUNCTION public.syncacdenrollfrequencytoacdfrequenceenroll() OWNER TO postgres;

--
-- Name: syncdatabase(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION syncdatabase(p_applicationversion integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    line RECORD;
    result_change BOOLEAN;
BEGIN
    --Percorre comandos que nï¿½o foram executados e aplica na base
    FOR line IN  SELECT * 
                   FROM dbchanges 
                  WHERE applied IS false 
                    AND applicationversion <= p_applicationversion 
                    AND error IS NULL
               ORDER BY applicationversion,orderchange
    LOOP
        SELECT INTO result_change applyChanges(line.change, line.changeid);

        IF result_change IS TRUE
        THEN
            EXECUTE 'UPDATE dbchanges SET applied = true, error = null, applieddate = now() WHERE changeId = '|| line.changeid || '';
        END IF;

    END LOOP;

    RETURN True;
END;
$$;


ALTER FUNCTION public.syncdatabase(p_applicationversion integer) OWNER TO postgres;

--
-- Name: synchronizedocument(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION synchronizedocument() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
        v_DOCUMENTTYPE VARCHAR;
        v_CONTENT TEXT;
        v_ORGAN VARCHAR;
        v_DATEEXPEDITION VARCHAR;
        v_OBSERVATION TEXT;

        v_COMMAND VARCHAR;
        v_RESULT VARCHAR;
        v_CONFIG VARCHAR;

        v_EQUIV VARCHAR[]:= '{}';

    BEGIN
        -- Trigger de sincronização de documentos

        -- Obtém a configuração da base de dados.
        v_CONFIG := value FROM basConfig WHERE parameter = 'GNUTECA_DATABASE_ADRESS';

        IF ( length(v_CONFIG) > 0 AND v_CONFIG != 'FALSE' )
        THEN
            -- Equivalência no tipo de documento entre Gnuteca e Sagu.
            v_EQUIV[1] := 'RG';
            v_EQUIV[2] := 'CPF';
            v_EQUIV[3] := 'HISTORICO_ESCOLAR';
            v_EQUIV[4] := 'TITULO_ELEITOR';
            v_EQUIV[5] := 'QUITACAO_ELEITORAL';
            v_EQUIV[6] := 'DOCUMENTACAO_MILITAR';
            v_EQUIV[7] := 'FOTO';
            v_EQUIV[8] := 'HISTORICO_ORIGINAL';
            v_EQUIV[9] := 'ATESTADO_MEDICO';
            v_EQUIV[10] := 'DIPLOMA_AUTENTICADO';
            v_EQUIV[11] := 'SOLTEIRO_EMANCIPADO';

            IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE'
            THEN
                IF NEW.content IS NOT NULL
                THEN
                    v_CONTENT := '''' || NEW.content || '''';
                ELSE
                    v_CONTENT := ''' ''';
                END IF;

                IF NEW.organ IS NOT NULL
                THEN
                    v_ORGAN := '''' || NEW.organ || '''';
               ELSE
                    v_ORGAN := 'NULL';
               END IF;

                IF NEW.dateexpedition IS NOT NULL
                THEN
                    v_DATEEXPEDITION := '''' || NEW.dateexpedition || '''';
                ELSE
                    v_DATEEXPEDITION := 'NULL';
                END IF;

                IF NEW.obs IS NOT NULL
                THEN
                    v_OBSERVATION := '''' || NEW.obs || '''';
                ELSE
                    v_OBSERVATION := 'NULL';
                END IF;

                -- Obtém o tipo de documento.
                v_DOCUMENTTYPE := '''' || v_EQUIV[NEW.documenttypeid] || '''';
            END IF;

            IF TG_OP = 'INSERT'
            THEN
                v_COMMAND := 'INSERT INTO basDocument ( personId,
                                                        documenttypeid,
                                                        content,
                                                        organ,
                                                        dateexpedition,
                                                        observation )
                                             VALUES (' || NEW.personId ||','
                                                       || v_DOCUMENTTYPE || ','
                                                       || v_CONTENT || ','
                                                       || V_ORGAN || ','
                                                       || v_DATEEXPEDITION || ','
                                                       || v_OBSERVATION || ');';
            ELSE
                IF TG_OP = 'UPDATE'
                THEN
                    v_COMMAND := 'UPDATE basDocument
                                     SET documenttypeid = ' || v_DOCUMENTTYPE || ',
                                         content = ' || v_CONTENT || ',
                                         organ = ' || v_ORGAN || ',
                                         dateexpedition = ' || v_DATEEXPEDITION || ',
                                         observation = ' || v_OBSERVATION || '
                                   WHERE personId = ' || OLD.personId || '
                                     AND documenttypeid = ' || v_DOCUMENTTYPE || ';';
                ELSE
                    -- Obtém o tipo de documento.
                    v_DOCUMENTTYPE := '''' || v_EQUIV[OLD.documenttypeid] || '''';

                    v_COMMAND := 'DELETE FROM basDocument WHERE personId = ' || OLD.personId || '
                                                            AND documenttypeid = ' || v_DOCUMENTTYPE || ';';
                END IF;
            END IF;

            -- Executa o comando na base do Gnuteca.
            SELECT INTO v_RESULT dblink_exec(v_CONFIG, v_COMMAND );
        END IF;

        RETURN NULL;
    END;
$$;


ALTER FUNCTION public.synchronizedocument() OWNER TO postgres;

--
-- Name: synchronizelink(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION synchronizelink() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
        v_LEVEL VARCHAR;
        v_COMMAND VARCHAR;
        v_RESULT VARCHAR;
        v_CONFIG VARCHAR;

    BEGIN
        -- Obtém a configuração da base de dados.
        v_CONFIG := value FROM basConfig WHERE parameter = 'GNUTECA_DATABASE_ADRESS';

        IF ( length(v_CONFIG) > 0 AND v_CONFIG != 'FALSE' )
        THEN
            IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE'
            THEN
                IF NEW.level IS NOT NULL
                THEN
                    v_LEVEL := '''' || NEW.level || '''';
                ELSE
                    v_LEVEL := 'NULL';
                END IF;
            END IF;

            IF TG_OP = 'INSERT'
            THEN
                v_COMMAND := 'INSERT INTO basLink ( linkId,
                                                    description,
                                                    level,
                                                    isVisibleToPerson )
                                             VALUES (' || NEW.linkId ||','''
                                                       || convert_to(NEW.description::text, 'LATIN1') || ''','
                                                       || v_LEVEL || ',
                                                       true);';
            ELSE
                IF TG_OP = 'UPDATE'
                THEN
                    v_COMMAND := 'UPDATE basLink
                                     SET description = ''' || NEW.description || ''',
                                               level = ' || v_LEVEL || '
                                   WHERE linkId = ' || OLD.linkId || ';';
                ELSE
                    v_COMMAND := 'DELETE FROM basLink WHERE linkId = ' || OLD.linkId || ';';
                END IF;
            END IF;

            -- Executa o comando na base do Gnuteca.
            SELECT INTO v_RESULT dblink_exec(v_CONFIG, v_COMMAND );
        END IF;

        RETURN NULL;
    END;
$$;


ALTER FUNCTION public.synchronizelink() OWNER TO postgres;

--
-- Name: synchronizepasswordofperson(); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION synchronizepasswordofperson() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
        v_RESULT VARCHAR;
        v_CONFIG VARCHAR;
        v_PASSWORD VARCHAR;
        v_PERSON INT;
    BEGIN
        --Trigger para sincronização da senha do usuário do sagu com o do gnuteca
        -- Obtém a configuração da base de dados.
        v_CONFIG := value FROM basConfig WHERE parameter = 'GNUTECA_DATABASE_ADRESS';
        v_PERSON := personId FROM ONLY basPhysicalPerson WHERE miolousername = NEW.login AND miolousername IS NOT NULL LIMIT 1;

        IF (length(v_CONFIG) > 0) AND (v_PERSON IS NOT NULL) AND ( v_CONFIG != 'FALSE' )
        THEN

            v_PASSWORD := NEW.m_password;

            --SE PERSON_PASSWORD_ENCRYPT = 1 entao usa md5 no gnuteca.
            IF (SELECT value FROM dblink (v_CONFIG, 'SELECT value FROM basconfig WHERE PARAMETER = ''PERSON_PASSWORD_ENCRYPT'' ') as foo (value varchar)) = '1'
            THEN
                v_PASSWORD := md5(v_PASSWORD::text);
            END IF;            

            -- Executa o comando na base do Gnuteca.
            SELECT INTO v_RESULT dblink_exec(v_CONFIG, 'UPDATE basPerson SET password = ''' || v_PASSWORD || '''
                                                             WHERE personId = ' || V_PERSON || ';' );

            SELECT INTO v_RESULT dblink_exec(v_CONFIG, 'UPDATE basPerson SET login = ''' || NEW.login || '''
                                                             WHERE personId = ' || V_PERSON || ';' );
        END IF;
	
        RETURN NULL;
    END;
$$;


ALTER FUNCTION public.synchronizepasswordofperson() OWNER TO solis;

--
-- Name: synchronizeperson(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION synchronizeperson() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
        v_PASSWORD VARCHAR;
        v_CITY VARCHAR;
        v_COLUMNS VARCHAR;
        v_VALUES VARCHAR;
        v_UPDATE VARCHAR;
        v_COMMAND VARCHAR;
        v_RESULT VARCHAR;
        v_CONFIG VARCHAR;
        v_TMP VARCHAR;

        v_PHONE_CEL VARCHAR;
        v_PHONE_PRO VARCHAR;
        v_PHONE_REC VARCHAR;
        v_PHONE_RES VARCHAR;

        v_REGISTER RECORD;

    BEGIN
        --Trigger para sincronizar as pessoas com o gnuteca

        -- Obtém a configuração da base de dados.
        v_CONFIG := value FROM basConfig WHERE parameter = 'GNUTECA_DATABASE_ADRESS';

        IF ( length(v_CONFIG) > 0 AND v_CONFIG != 'FALSE' )
        THEN
            IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE'
            THEN
                SELECT INTO v_REGISTER * FROM ONLY basPhysicalPerson WHERE personId = NEW.personId;

                -- Testa se jé existe pessoa na basphysicalperson, caso não tenha, sai da trigger.
                IF v_REGISTER.personId IS NULL
                THEN
                    RETURN NULL;
                END IF;

                v_COLUMNS := '';
                v_VALUES := '';
                v_UPDATE := '';

                -- Ajusta o valor nome.
                IF v_REGISTER.name IS NOT NULL
                THEN
                    v_TMP := '''' || convert_to(replace(v_REGISTER.name::text, '''', ''''''), 'UTF8') || ''',';
                ELSE
                    v_TMP := 'NULL,';
                END IF;

                v_COLUMNS := v_COLUMNS || 'name,';
                v_VALUES := v_VALUES || v_TMP;
                v_UPDATE := v_UPDATE || 'name = ' || v_TMP;

                -- Ajusta a cidade.
                v_CITY := name FROM basCity WHERE cityid = v_REGISTER.cityid;

                IF v_CITY IS NOT NULL
                THEN
                    v_TMP := '''' || v_CITY || ''',';
                ELSE
                    v_TMP := 'NULL,';
                END IF;

                v_COLUMNS := v_COLUMNS || 'city,';
                v_VALUES := v_VALUES || v_TMP;
                v_UPDATE := v_UPDATE || 'city = '|| v_TMP;

                -- Ajusta o CEP.
                IF v_REGISTER.zipcode IS NOT NULL
                THEN
                    v_TMP := '''' || v_REGISTER.zipcode || ''',';
                ELSE
                    v_TMP := 'NULL,';
                END IF;

                v_COLUMNS := v_COLUMNS || 'zipcode,';
                v_VALUES := v_VALUES || v_TMP;
                v_UPDATE := v_UPDATE || 'zipcode = '|| v_TMP;

                -- Ajusta o local.
                IF v_REGISTER.location IS NOT NULL
                THEN
                    v_TMP := '''' || convert_to(replace(v_REGISTER.location::text, '''', ''''''), 'UTF8') || ''',';
                ELSE
                    v_TMP := 'NULL,';
                END IF;

                v_COLUMNS := v_COLUMNS || 'location,';
                v_VALUES := v_VALUES || v_TMP;
                v_UPDATE := v_UPDATE || 'location = ' || v_TMP;

                -- Ajusta o número.
                IF v_REGISTER.number IS NOT NULL
                THEN
                    v_TMP := '''' ||v_REGISTER.number|| ''',';
                ELSE
                    v_TMP := 'NULL,';
                END IF;

                v_COLUMNS := v_COLUMNS || 'number,';
                v_VALUES := v_VALUES || v_TMP;
                v_UPDATE := v_UPDATE || 'number = ' || v_TMP;

                -- Ajusta o complemento.
                IF v_REGISTER.complement IS NOT NULL
                THEN
                    v_TMP := '''' || convert_to(replace(v_REGISTER.complement::text, '''', ''''''), 'UTF8') || ''',';
                ELSE
                    v_TMP := 'NULL,';
                END IF;

                v_COLUMNS := v_COLUMNS || 'complement,';
                v_VALUES := v_VALUES || v_TMP;
                v_UPDATE := v_UPDATE || 'complement =' || v_TMP;

                -- Ajusta o bairro.
                IF v_REGISTER.neighborhood IS NOT NULL
                THEN
                    v_TMP := '''' || convert_to(replace(v_REGISTER.neighborhood::text, '''', ''''''), 'UTF8') || ''',';
                ELSE
                    v_TMP := 'NULL,';
                END IF;

                v_COLUMNS := v_COLUMNS || 'neighborhood,';
                v_VALUES := v_VALUES || v_TMP;
                v_UPDATE := v_UPDATE || 'neighborhood = ' || v_TMP;

                -- Ajusta o e-mail.
                IF CHAR_LENGTH(v_REGISTER.email) > 0
                THEN
                    v_TMP := '''' || convert_to(v_REGISTER.email::text, 'UTF8') || ''',';
                ELSE
                    v_TMP := 'NULL,';
                END IF;

                v_COLUMNS := v_COLUMNS || 'email,';
                v_VALUES := v_VALUES || v_TMP;
                v_UPDATE := v_UPDATE || 'email = ' || v_TMP;

                -- Ajusta a senha.
                v_PASSWORD:= m_password FROM miolo_user WHERE login =v_REGISTER.miolousername;

                IF v_PASSWORD IS NOT NULL
                THEN
                    --SE PERSON_PASSWORD_ENCRYPT = 1 entao usa md5 no gnuteca.
                    IF (SELECT value FROM dblink (v_CONFIG, 'SELECT value FROM basconfig WHERE PARAMETER = ''PERSON_PASSWORD_ENCRYPT'' ') as foo (value varchar)) = '1'
                    THEN
                        v_TMP := '''' || md5(convert_to(v_PASSWORD::text, 'UTF8')) || ''',';
                    ELSE
                        v_TMP := '''' || convert_to(v_PASSWORD::text, 'UTF8') || ''',';                   
                    END IF;
                ELSE
                    v_TMP := 'NULL,';
                END IF;

                v_COLUMNS := v_COLUMNS || 'password,';
                v_VALUES := v_VALUES || v_TMP;
                v_UPDATE := v_UPDATE || 'password = ' || v_TMP;

                -- Ajusta o login.
                IF v_REGISTER.miolousername IS NOT NULL
                THEN
                    v_TMP := '''' || convert_to(v_REGISTER.miolousername::text, 'UTF8') || ''',';
                ELSE
                    v_TMP := 'NULL,';
                END IF;

                v_COLUMNS := v_COLUMNS || 'login,';
                v_VALUES := v_VALUES || v_TMP;
                v_UPDATE := v_UPDATE || 'login = ' || v_TMP;

                -- Ajusta o sexo.
                IF v_REGISTER.sex IS NOT NULL
                THEN
                    v_TMP := '''' || v_REGISTER.sex || ''',';
                ELSE
                    v_TMP := 'NULL,';
                END IF;

                v_COLUMNS := v_COLUMNS || 'sex,';
                v_VALUES := v_VALUES || v_TMP;
                v_UPDATE := v_UPDATE || 'sex = ' || v_TMP;

                -- Ajusta a data de nascimento.
                IF v_REGISTER.datebirth IS NOT NULL
                THEN
                    v_TMP := '''' || v_REGISTER.datebirth || ''',';
                ELSE
                    v_TMP := 'NULL,';
                END IF;

                v_COLUMNS := v_COLUMNS || 'datebirth,';
                v_VALUES := v_VALUES || v_TMP;
                v_UPDATE := v_UPDATE || 'datebirth = ' || v_TMP;

                -- Ajusta o emprego.
                IF v_REGISTER.workfunction IS NOT NULL
                THEN
                    v_TMP := '''' || convert_to(v_REGISTER.workfunction::text, 'UTF8') || ''',';
                ELSE
                    v_TMP := 'NULL,';
                END IF;

                v_COLUMNS := v_COLUMNS || 'profession,';
                v_VALUES := v_VALUES || v_TMP;
                v_UPDATE := v_UPDATE || 'profession = ' || v_TMP;

                -- Ajusta o local de trabalho.
                IF v_REGISTER.workemployername IS NOT NULL
                THEN
                    v_TMP := '''' || convert_to(v_REGISTER.workemployername::text, 'UTF8') || ''',';
                ELSE
                    v_TMP := 'NULL,';
                END IF;

                v_COLUMNS := v_COLUMNS || 'workplace,';
                v_VALUES := v_VALUES || v_TMP;
                v_UPDATE := v_UPDATE || 'workplace = '|| v_TMP;

                -- Prepara o comando de inclusão.
                IF TG_OP = 'INSERT'
                THEN
                    IF NEW.personId IS NOT NULL
                    THEN
                        v_COLUMNS := v_COLUMNS || 'personid,';
                        v_VALUES := v_VALUES || '''' || NEW.personId || ''',';
                    END IF;

                    -- Ajusta as colunas e valores retirando a "," no final dos valores.
                    v_COLUMNS := substring(v_COLUMNS FROM 0 FOR length(v_COLUMNS));
                    v_VALUES := substring(v_VALUES FROM 0 FOR length(v_VALUES));

                    v_COMMAND := 'INSERT INTO basperson (' || v_COLUMNS || ') VALUES (' || v_VALUES || ');';
                END IF;

                -- Prepara comando de atualização.
                IF TG_OP = 'UPDATE'
                THEN
                    v_UPDATE := substring(v_UPDATE FROM 0 FOR length(v_UPDATE));
                    v_COMMAND := 'UPDATE basperson SET ' || v_UPDATE || ' WHERE personId = ' || NEW.personId;
                END IF;

                -- Executa o comando na base do Gnuteca.
                SELECT INTO v_RESULT dblink_exec(v_CONFIG, v_COMMAND );

                -- Apaga os telefones.
                SELECT INTO v_RESULT dblink_exec(v_CONFIG, 'DELETE FROM basPhone WHERE personId = ' || NEW.personId );

                -- Insere os telefones.
                v_PHONE_CEL := cellphone FROM ONLY basPhysicalPerson WHERE personId = NEW.personId;
                IF v_PHONE_CEL IS NOT NULL
                THEN
                    SELECT INTO v_RESULT dblink_exec(v_CONFIG, 'INSERT INTO basPhone VALUES (' || NEW.personId || ',''CEL'',''' || v_PHONE_CEL || ''')');
                END IF;

                v_PHONE_PRO := workphone FROM ONLY basPhysicalPerson WHERE personId = NEW.personId;
                IF v_PHONE_PRO IS NOT NULL
                THEN
                    SELECT INTO v_RESULT dblink_exec(v_CONFIG, 'INSERT INTO basPhone VALUES (' || NEW.personId || ',''PRO'',''' || v_PHONE_PRO || ''')');
                END IF;

                v_PHONE_REC:= messagephone FROM ONLY basPhysicalPerson WHERE personId = NEW.personId;
                IF v_PHONE_REC IS NOT NULL
                THEN
                    SELECT INTO v_RESULT dblink_exec(v_CONFIG, 'INSERT INTO basPhone VALUES (' || NEW.personId || ',''REC'',''' || v_PHONE_REC || ''')');
                END IF;

                v_PHONE_RES:= residentialphone FROM ONLY basPhysicalPerson WHERE personId = NEW.personId;
                 IF v_PHONE_RES IS NOT NULL
                THEN
                    SELECT INTO v_RESULT dblink_exec(v_CONFIG, 'INSERT INTO basPhone VALUES (' || NEW.personId || ',''RES'',''' || v_PHONE_RES || ''')');
                END IF;
            ELSE
                -- Apaga os telefones.
                SELECT INTO v_RESULT dblink_exec(v_CONFIG, 'DELETE FROM basPhone WHERE personId = ' || OLD.personId );

                -- Prepara comando para apagar.
                V_COMMAND := 'DELETE FROM basPerson WHERE personId = ' || OLD.personId;

                -- Executa o comando na base do Gnuteca.
                SELECT INTO v_RESULT dblink_exec(v_CONFIG, v_COMMAND );

            END IF;
        END IF;

        RETURN NULL;
    END;
$$;


ALTER FUNCTION public.synchronizeperson() OWNER TO postgres;

--
-- Name: synchronizepersonlink(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION synchronizepersonlink() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
        v_VALIDATE DATE;
        v_COMMAND VARCHAR;
        v_RESULT VARCHAR;
        v_CONFIG VARCHAR;

    BEGIN
        -- Obtém a configuração da base de dados.
        v_CONFIG := value FROM basConfig WHERE parameter = 'GNUTECA_DATABASE_ADRESS';
        
        IF ( length(v_CONFIG) > 0 ) AND ( UPPER(v_CONFIG) <> 'FALSE' )
        THEN
            IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE'
            THEN
                IF NEW.datevalidate IS NOT NULL
                THEN
                    v_VALIDATE := NEW.datevalidate;
                ELSE
                    -- SOMA 50 anos na data atual caso não tenha data de validade.
                    v_VALIDATE := (now() + interval '50 year')::date;
                END IF;
            END IF;

            IF TG_OP = 'INSERT'
            THEN
                v_COMMAND := 'INSERT INTO basPersonLink ( personId,
                                                          linkId,
                                                          datevalidate )
                                             VALUES (' || NEW.personId ||','
                                                       || NEW.linkId || ',''' 
                                                       || v_VALIDATE || ''');';
            ELSE 
                IF TG_OP = 'UPDATE'
                THEN
                    v_COMMAND := 'UPDATE basPersonLink 
                                     SET dateValidate = ''' || v_VALIDATE || '''
                                   WHERE personId = ' || OLD.personId || '
                                     AND linkId = ' || OLD.linkId || ';';
                ELSE
                    v_COMMAND := 'DELETE FROM basPersonLink WHERE personId = ' || OLD.personId || '
                                                              AND linkId = ' || OLD.linkId || ';';
                END IF;
            END IF;
                                                      
            -- Executa o comando na base do Gnuteca.
            SELECT INTO v_RESULT dblink_exec(v_CONFIG, v_COMMAND );
        END IF;
        
        RETURN NULL;
    END;
$$;


ALTER FUNCTION public.synchronizepersonlink() OWNER TO postgres;

--
-- Name: syncpassword(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION syncpassword() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: syncphones
  DESCRIPTION: sincroniza o password entre a basperson e a miolo_user.

  REVISIONS:
  Ver       Date       Author             Description
  --------- ---------- ------------------ ------------------------------------
  1.0       31/08/2012 Jonas Guilherme Dahmer   1. Trigger criada.
******************************************************************************/
BEGIN
    IF TG_OP = 'UPDATE' THEN
        IF TG_TABLE_NAME = 'basperson' THEN 
            IF OLD.password != NEW.password THEN
                    UPDATE miolo_user SET m_password = NEW.password WHERE login = NEW.miolousername;
            END IF;
        END IF;
        IF TG_TABLE_NAME = 'miolo_user' THEN
            IF OLD.m_password != NEW.m_password THEN
                    UPDATE basperson SET password = NEW.m_password WHERE miolousername = NEW.login;
            END IF;	
        END IF;
    END IF;
 RETURN NEW;
END;
$$;


ALTER FUNCTION public.syncpassword() OWNER TO postgres;

--
-- Name: syncphones(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION syncphones() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: syncphones
  DESCRIPTION: sincroniza os telefones entre a basphysicalperson e a basphone.

  REVISIONS:
  Ver       Date       Author             Description
  --------- ---------- ------------------ ------------------------------------
  1.0       27/08/2012 Jonas Guilherme Dahmer   1. Trigger criada.
******************************************************************************/
DECLARE
v_phone RECORD;
BEGIN

    IF TG_TABLE_NAME = 'basphysicalperson' THEN

        IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN

            IF NEW.residentialphone IS NOT NULL THEN

                IF TG_OP = 'UPDATE' THEN
                    IF EXISTS ( SELECT phoneid FROM basphone WHERE personid = NEW.personid AND type = 'RES' ) THEN
                        UPDATE basphone SET phone = NEW.residentialphone WHERE personid = NEW.personid AND type = 'RES' AND phone = OLD.residentialphone;
                    ELSE
                        INSERT INTO basphone (personid, type, phone) VALUES (NEW.personid, 'RES', NEW.residentialphone);
                    END IF;

                ELSEIF TG_OP = 'INSERT' THEN

                
                    IF NOT EXISTS ( SELECT phoneid FROM basphone WHERE personid = NEW.personid AND type = 'RES' AND phone = NEW.residentialphone ) THEN
                        INSERT INTO basphone (personid, type, phone) VALUES (NEW.personid, 'RES', NEW.residentialphone);
                    END IF;
                END IF;

            ELSE
                IF TG_OP = 'UPDATE' THEN
                    IF OLD.residentialphone IS NOT NULL THEN
                        IF EXISTS ( SELECT phoneid FROM basphone WHERE personid = NEW.personid AND type = 'RES' AND phone = OLD.residentialphone) THEN
                            DELETE FROM basphone WHERE personid = NEW.personid AND type = 'RES' AND phone = OLD.residentialphone;
                        END IF;
                    END IF;
                END IF;
            END IF;
            
            IF NEW.workphone IS NOT NULL THEN

                IF TG_OP = 'UPDATE' THEN
                    IF EXISTS ( SELECT phoneid FROM basphone WHERE personid = NEW.personid AND type = 'PRO' ) THEN
                        UPDATE basphone SET phone = NEW.workphone WHERE personid = NEW.personid AND type = 'PRO' AND phone = OLD.workphone;
                    ELSE
                        INSERT INTO basphone (personid, type, phone) VALUES (NEW.personid, 'PRO', NEW.workphone);                            
                    END IF;
                ELSE IF TG_OP = 'INSERT' THEN
                    IF NOT EXISTS ( SELECT phoneid FROM basphone WHERE personid = NEW.personid AND type = 'PRO' AND phone = NEW.workphone ) THEN
                        INSERT INTO basphone (personid, type, phone) VALUES (NEW.personid, 'PRO', NEW.workphone);                            
                    END IF;
                END IF;
            END IF;

            ELSE
                IF TG_OP = 'UPDATE' THEN
                    IF OLD.workphone IS NOT NULL THEN
                        IF EXISTS ( SELECT phoneid FROM basphone WHERE personid = NEW.personid AND type = 'PRO' AND phone = OLD.workphone) THEN
                            DELETE FROM basphone WHERE personid = NEW.personid AND type = 'PRO' AND phone = OLD.workphone;
                        END IF;
                    END IF;
                END IF;
            END IF;

            IF NEW.cellphone IS NOT NULL THEN
                IF TG_OP = 'UPDATE' THEN
                    IF EXISTS ( SELECT phoneid FROM basphone WHERE personid = NEW.personid AND type = 'CEL' ) THEN
                        UPDATE basphone SET phone = NEW.cellphone WHERE personid = NEW.personid AND type = 'CEL' AND phone = OLD.cellphone;
                    ELSE
                        INSERT INTO basphone (personid, type, phone) VALUES (NEW.personid, 'CEL', NEW.cellphone);
                    END IF;

                ELSEIF TG_OP = 'INSERT' THEN
                    IF NOT EXISTS ( SELECT phoneid FROM basphone WHERE personid = NEW.personid AND type = 'CEL' AND phone = NEW.cellphone ) THEN                        
                        INSERT INTO basphone (personid, type, phone) VALUES (NEW.personid, 'CEL', NEW.cellphone);                        
                    END IF;
                END IF;

            ELSE
                IF TG_OP = 'UPDATE' THEN
                    IF OLD.cellphone IS NOT NULL THEN       
                        IF EXISTS ( SELECT phoneid FROM basphone WHERE personid = NEW.personid AND type = 'CEL' AND phone = OLD.cellphone) THEN
                            DELETE FROM basphone WHERE personid = NEW.personid AND type = 'CEL' AND phone = OLD.cellphone;
                        END IF;
                    END IF;        
                END IF;
            END IF;
            
            IF NEW.messagephone IS NOT NULL THEN

                IF TG_OP = 'UPDATE' THEN
                    IF EXISTS ( SELECT phoneid FROM basphone WHERE personid = NEW.personid AND type = 'REC' ) THEN
                        UPDATE basphone SET phone = NEW.messagephone WHERE personid = NEW.personid AND type = 'REC' AND phone = OLD.messagephone;
                    ELSE
                        INSERT INTO basphone (personid, type, phone) VALUES (NEW.personid, 'REC', NEW.messagephone);
                    END IF;

                ELSEIF TG_OP = 'INSERT' THEN
                    IF NOT EXISTS ( SELECT phoneid FROM basphone WHERE personid = NEW.personid AND type = 'REC' AND phone = NEW.messagephone ) THEN
                        IF NEW.cellphone IS NOT NULL THEN
                            INSERT INTO basphone (personid, type, phone) VALUES (NEW.personid, 'REC', NEW.messagephone);
                        END IF;
                    END IF;
                END IF;

            ELSE
                IF TG_OP = 'UPDATE' THEN
                    IF OLD.messagephone IS NOT NULL THEN
                        IF EXISTS ( SELECT phoneid FROM basphone WHERE personid = NEW.personid AND type = 'REC' AND phone = OLD.messagephone) THEN
                            DELETE FROM basphone WHERE personid = NEW.personid AND type = 'REC' AND phone = OLD.messagephone;
                        END IF;
                    END IF;
                END IF;
            END IF;
            
        END IF;
        
        IF TG_OP = 'DELETE' THEN
            IF EXISTS ( SELECT phoneid FROM basphone WHERE personid = OLD.personid ) THEN
                DELETE FROM basphone WHERE personid = OLD.personid;
            END IF;
        END IF;
    
    END IF;
    
    
    IF TG_TABLE_NAME = 'basphone' THEN

        IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        
            IF NEW.type = 'RES' THEN
                IF NOT EXISTS ( SELECT 1 FROM basphysicalperson WHERE personid = NEW.personid AND residentialphone = NEW.phone )
                THEN
                    UPDATE basphysicalperson SET residentialphone = NEW.phone WHERE personid = NEW.personid;
                END IF;
            END IF;
            
            IF NEW.type = 'PRO' THEN
                IF NOT EXISTS ( SELECT 1 FROM basphysicalperson WHERE personid = NEW.personid AND workphone = NEW.phone )
                THEN
                    UPDATE basphysicalperson SET workphone = NEW.phone WHERE personid = NEW.personid;
                END IF;
            END IF;
            
            IF NEW.type = 'CEL' THEN
                IF NOT EXISTS ( SELECT 1 FROM basphysicalperson WHERE personid = NEW.personid AND cellphone = NEW.phone )
                THEN
                    UPDATE basphysicalperson SET cellphone = NEW.phone WHERE personid = NEW.personid;
                END IF;
            END IF;
            
            IF NEW.type = 'REC' THEN
                IF NOT EXISTS ( SELECT 1 FROM basphysicalperson WHERE personid = NEW.personid AND messagephone = NEW.phone )
                THEN
                    UPDATE basphysicalperson SET messagephone = NEW.phone WHERE personid = NEW.personid;
                END IF;
            END IF;
        
        END IF;
        
        IF TG_OP = 'DELETE' THEN

            IF OLD.type = 'RES' THEN
                UPDATE basphysicalperson SET residentialphone = '' WHERE personid = OLD.personid;
            END IF;
            
            IF OLD.type = 'PRO' THEN
                UPDATE basphysicalperson SET workphone = '' WHERE personid = OLD.personid;
            END IF;
            
            IF OLD.type = 'CEL' THEN
                UPDATE basphysicalperson SET cellphone = '' WHERE personid = OLD.personid;
            END IF;
            
            IF OLD.type = 'REC' THEN
                UPDATE basphysicalperson SET messagephone = '' WHERE personid = OLD.personid;
            END IF;
        
        END IF;
    
    END IF;

 RETURN NEW;

END;
$$;


ALTER FUNCTION public.syncphones() OWNER TO postgres;

--
-- Name: testar_valor_vazio(character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION testar_valor_vazio(p_tabela character varying, chave_origem integer, chave_destino integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: testar_valor_vazio
  PURPOSE: Verifica se o registro de origem possui dados na tabela que o registro de destino não possui e os insere.
**************************************************************************************/
DECLARE
    v_select record;
    v_return record;
    v_primary_key varchar;
BEGIN
    SELECT INTO v_primary_key obterColunaChavePrimariaDaTabela(p_tabela);

    FOR v_select IN
        ( SELECT column_name AS coluna 
            FROM information_schema.columns 
           WHERE table_name = p_tabela )
    LOOP
        EXECUTE 'SELECT length(trim(' || v_select.coluna || '::text)) > 0 AS is_null 
                   FROM ' || p_tabela ||
                ' WHERE ' || v_primary_key || ' = ' || chave_destino || '' INTO v_return;

        IF v_return.is_null IS NULL
        THEN
            EXECUTE 'UPDATE ' || p_tabela || 
                      ' SET ' || v_select.coluna || ' = ( SELECT ' || v_select.coluna ||
                                                     ' FROM ONLY ' || p_tabela || 
                                                         ' WHERE ' || v_primary_key || ' = ' || chave_origem || ')
                      WHERE ' || v_primary_key || ' = ' || chave_destino;
        END IF;
    END LOOP;

    RETURN;
END;
$$;


ALTER FUNCTION public.testar_valor_vazio(p_tabela character varying, chave_origem integer, chave_destino integer) OWNER TO postgres;

--
-- Name: timestamptodb(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION timestamptodb(p_date character varying) RETURNS timestamp without time zone
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: timestampToDb
  PURPOSE: Converte um timestamp do usuario para a base.
**************************************************************************************/
BEGIN
    RETURN TO_TIMESTAMP(p_date, 'dd/mm/yyyy hh24:mi');
END;
$$;


ALTER FUNCTION public.timestamptodb(p_date character varying) OWNER TO postgres;

--
-- Name: timestamptouser(timestamp without time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION timestamptouser(p_date timestamp without time zone) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: timestampToUser
  PURPOSE: Converte um timestamp vindo da base para o usuario.
**************************************************************************************/
BEGIN
    RETURN TO_CHAR(p_date, 'dd/mm/yyyy hh24:mi');
END;
$$;


ALTER FUNCTION public.timestamptouser(p_date timestamp without time zone) OWNER TO postgres;

--
-- Name: timestamptouser(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION timestamptouser(p_date timestamp with time zone) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: timestampToUser
  PURPOSE: Converte um timestamp vindo da base para o usuario.
**************************************************************************************/
BEGIN
    RETURN TO_CHAR(p_date, 'dd/mm/yyyy hh24:mi');
END;
$$;


ALTER FUNCTION public.timestamptouser(p_date timestamp with time zone) OWNER TO postgres;

--
-- Name: timetouser(time without time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION timetouser(p_value time without time zone) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: timeToUser
  PURPOSE: Converte uma hora vinda da base para o usuario.
**************************************************************************************/
BEGIN
    RETURN TO_CHAR(p_value, 'hh24:mi');
END;
$$;


ALTER FUNCTION public.timetouser(p_value time without time zone) OWNER TO postgres;

--
-- Name: titulobloqueado(integer, boolean); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION titulobloqueado(p_invoiceid integer, v_somentetitulosemdia boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: tituloBloqueado
  PURPOSE: Verifica se um tí­tulo está bloqueado, ou seja, se foi pago ou se está vencido

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       05/03/2013 Leovan Tavares    1. FUNÇÃO criada.
**************************************************************************************/
DECLARE
BEGIN
    RETURN EXISTS (SELECT 1
                     FROM finreceivableinvoice A
                    WHERE A.invoiceid = p_invoiceid AND
                         (EXISTS (SELECT 1
                                    FROM finentry
                                   WHERE invoiceid = A.invoiceid
                                       AND operationid IN (SELECT paymentoperation
                                                           FROM findefaultoperations))
                          OR CASE WHEN (getParameter('FINANCE', 'GERAR_TITULOS_RETROATIVOS') = 'NO' AND v_somenteTitulosEmDia IS TRUE )
                                  THEN maturitydate < now()::DATE
                                  ELSE FALSE 
                                  END  
                          OR EXISTS (SELECT 1
                                       FROM finhistoricoremessa
                                      WHERE invoiceid = A.invoiceid) ) );
END;       
$$;


ALTER FUNCTION public.titulobloqueado(p_invoiceid integer, v_somentetitulosemdia boolean) OWNER TO solis;

--
-- Name: tmp_getbalancediscounts(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION tmp_getbalancediscounts(p_invoiceid integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$
BEGIN
   return (SELECT SUM( 
                CASE WHEN A.operationTypeId = 'D' THEN ( 1 * B.value ) 
                WHEN A.operationTypeId = 'C' THEN ( -1 * B.value )    
                END 
               )    
               FROM finOperation A,                                                 
                    finEntry B                                                      
               WHERE A.operationId = B.operationId
                    AND A.operationId not in (5, 9, 11, 25, 26, 90) 
                    AND A.useInDiscounts is true
                    AND B.invoiceId = $1)::FLOAT;
END;
$_$;


ALTER FUNCTION public.tmp_getbalancediscounts(p_invoiceid integer) OWNER TO postgres;

--
-- Name: tmp_getbalancefines(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION tmp_getbalancefines(p_invoiceid integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$
/*************************************************************************************
  NAME: tmp_getbalancefines
  PURPOSE: Mesma funcionalidade getbalancefines, porém não considera os valores já pagos.

**************************************************************************************/
BEGIN
   return (SELECT SUM( 
                CASE WHEN A.operationTypeId = 'D' THEN ( 1 * B.value )
                END 
               )    
               FROM finOperation A,                                                 
                    finEntry B                                                      
               WHERE A.operationId = B.operationId 
                    AND A.useInFines is true
                    AND B.invoiceId = $1)::FLOAT;
END;
$_$;


ALTER FUNCTION public.tmp_getbalancefines(p_invoiceid integer) OWNER TO postgres;

--
-- Name: tmp_getbalanceinterests(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION tmp_getbalanceinterests(p_invoiceid integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$
/*************************************************************************************
  NAME: tmp_getbalancefines
  PURPOSE: Mesma funcionalidade getbalancefines, porém não considera os valores já pagos.

**************************************************************************************/
BEGIN
   return (SELECT SUM( 
                CASE WHEN A.operationTypeId = 'D' THEN ( 1 * B.value )
                END 
               )    
               FROM finOperation A,                                                 
                    finEntry B                                                      
               WHERE A.operationId = B.operationId 
                    AND A.useInInterests is true
                    AND B.invoiceId = $1)::FLOAT;
END;
$_$;


ALTER FUNCTION public.tmp_getbalanceinterests(p_invoiceid integer) OWNER TO postgres;

--
-- Name: tmp_getinvoiceconvenantvalue(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION tmp_getinvoiceconvenantvalue(p_invoiceid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_convenant RECORD;
    v_convenantValue NUMERIC;
    v_balance NUMERIC;
    v_invoice RECORD;
    v_date DATE;
BEGIN
    v_convenantValue := 0;
    v_balance := tmp_getBalanceDiscounts(p_invoiceId);

    SELECT INTO v_invoice * FROM finreceivableinvoice WHERE invoiceid = p_invoiceid;

    v_date := v_invoice.maturitydate - interval '2 day';
  
    IF v_invoice.parcelnumber = 0 THEN RETURN 0; END IF;

    FOR v_convenant IN SELECT * FROM tmp_getinvoiceconvenants(p_invoiceid) AS convenant(convenantid integer, description text, value numeric, ispercent boolean, convenantoperation int)
    LOOP
        v_convenantValue := v_convenantValue + v_convenant.value;
    END LOOP;

    IF v_convenantValue > v_balance THEN v_convenantValue := v_balance; END IF;

    RETURN v_convenantValue;
END;
$$;


ALTER FUNCTION public.tmp_getinvoiceconvenantvalue(p_invoiceid integer) OWNER TO postgres;

--
-- Name: tmp_getinvoicediscountvalue(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION tmp_getinvoicediscountvalue(p_invoiceid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$

DECLARE
    v_policyInfo RECORD;
    v_invoiceInfo RECORD;
    v_policyDiscountInfo RECORD;
    v_release RECORD;
    v_releaseValue NUMERIC;
    v_discountValue NUMERIC;
    v_balanceValue NUMERIC;
    v_balance NUMERIC;
    v_numberDays INTEGER;   
    v_applyDiscounts BOOLEAN;
    v_date DATE;
    v_maturityMonth INTEGER;
    v_maturityYear INTEGER;
    v_maturityDay INTEGER;
    v_nowMonth INTEGER;  
    v_to_date DATE;
    v_to_dateMonth INTEGER;
    v_hasFinancialAid BOOLEAN;
    v_referenceMaturityDate DATE;
    v_calcNumberDays INTEGER;
BEGIN
    v_discountValue := 0;
    v_releaseValue := 0;

    v_balanceValue := tmp_getBalanceDiscounts(p_invoiceid);
    
    --Caso o título possuir um lançamento que seu tipo de incentivo (incentivetypeid) nao aplique descontos (finincentivetype.applydiscounts) retorna o desconto como 0
    v_applyDiscounts := FALSE;
    
    SELECT INTO v_applyDiscounts COUNT(*) > 0
      FROM finEntry E
INNER JOIN finIncentiveType I
        ON E.incentivetypeid = I.incentivetypeid
     WHERE E.invoiceId = p_invoiceid AND I.applydiscounts = 'f';

    IF v_applyDiscounts THEN
	    RETURN 0;
    END IF;

    -- Invoice data
    SELECT INTO v_invoiceInfo *
      FROM ONLY finReceivableInvoice
     WHERE invoiceId = p_invoiceid;
     
    v_date := v_invoiceInfo.maturityDate - interval '2 day';

    IF EXISTS (SELECT convenantid FROM (SELECT * FROM getinvoiceconvenants(v_invoiceinfo.invoiceid, v_invoiceinfo.maturitydate) AS A(convenantid integer, description text, value numeric, ispercent boolean, convenantoperation int)) A INNER JOIN finconvenant B USING (convenantid) WHERE B.aplica_descontos IS FALSE AND A.value > 0 AND A.convenantid <> 18) THEN
      RETURN 0;
    END IF;
     
    -- Policy's invoice data
    SELECT INTO v_policyInfo *
      FROM finPolicy
     WHERE policyId = v_invoiceInfo.policyId;

    --Antes do vencimento
    IF v_date <= v_invoiceInfo.maturityDate THEN
        v_numberDays := v_invoiceInfo.maturityDate::date - v_date::date;

        --Obtem o primeiro desconto para dias antes do vencimento que seja menor que o numero de dias
        SELECT INTO v_policyDiscountInfo *
          FROM finPolicyDiscount
         WHERE beforeafter LIKE 'B'
           AND daystodiscount <= v_numberDays
           AND policyId = v_policyInfo.policyId
      ORDER BY daystodiscount DESC
         LIMIT 1;

        --Se nao ha configuracao para descontos antes do vencimento, obtem o primeiro desconto depois do vencimento
        IF v_policyDiscountInfo IS NULL THEN
            SELECT INTO v_policyDiscountInfo *
              FROM finPolicyDiscount
             WHERE beforeafter LIKE 'A'
               AND policyId = v_policyInfo.policyId
          ORDER BY daystodiscount
             LIMIT 1;
        END IF;
    --Depois do vencimento
    ELSE
        IF v_date > v_invoiceInfo.maturityDate THEN

            IF getParameter('FINANCE', 'DESCARTAR_DIA_31') = 'YES' THEN
                v_numberDays := p_date::date - v_referenceMaturityDate;
                v_numberDays := v_numberDays - v_calcNumberDays;

                v_maturityMonth := EXTRACT(MONTH FROM v_referenceMaturityDate);
                v_maturityYear := EXTRACT(YEAR FROM v_referenceMaturityDate);
                v_nowMonth := EXTRACT(MONTH FROM p_date::date);
                v_to_date := TO_DATE('31/' || v_maturityMonth || '/' || v_maturityYear, 'dd/mm/yyyy');
                v_to_dateMonth := EXTRACT(MONTH FROM v_to_date);

                IF ( (v_maturityMonth <> v_nowMonth) AND (v_maturityMonth = v_to_dateMonth) ) THEN
                    v_numberDays := v_numberDays - 1;
                END IF;
            ELSE
                v_numberDays := v_date::date - v_invoiceInfo.referenceMaturityDate::date;
            END IF;

            --Caso for segunda feira desconta 1 dia extendendo o desconto de domingo
            IF getParameter('FINANCE', 'EXTENDER_DESCONTOS_NA_SEGUNDA') = 'YES'
            THEN
                IF ( EXTRACT('DOW' FROM (v_invoiceInfo.referenceMaturityDate::date+v_numberDays)) = 1 ) THEN
                    v_numberDays := v_numberDays-1;
                END IF;
            END IF;

            --Obtem o primeiro desconto para depois do vencimento
            SELECT INTO v_policyDiscountInfo *
              FROM finPolicyDiscount
             WHERE beforeafter = 'A'
               AND daystodiscount >= v_numberDays
               AND policyId = v_policyInfo.policyId
          ORDER BY daystodiscount
             LIMIT 1;
        END IF;
    END IF;
    IF v_policyDiscountInfo.discountValue > 0 THEN
        IF v_policyDiscountInfo.isPercent = TRUE THEN
            v_discountValue := v_balanceValue*(v_policyDiscountInfo.discountValue/100);
        ELSE
            v_discountValue := v_policyDiscountInfo.discountValue;
        END IF;
    END IF;

    --Descontos concedidos - finRelease
    FOR v_release IN SELECT discountValue, isPercent
                       FROM finRelease
                      WHERE invoiceid = p_invoiceId
                        AND v_date BETWEEN beginDate AND endDate
    LOOP
        IF v_release.discountValue > 0 THEN
            IF v_release.isPercent = TRUE THEN
                v_releaseValue := v_releaseValue + (v_balanceValue - v_discountValue) * (v_release.discountValue/100);
            ELSE
                v_releaseValue := v_releaseValue + v_release.discountValue;
            END IF;
    END IF;
    END LOOP;

    IF (v_discountValue + v_releaseValue) > v_balanceValue THEN
        RETURN v_balanceValue;
    ELSE
        RETURN (v_discountValue + v_releaseValue);
    END IF;
END;
$$;


ALTER FUNCTION public.tmp_getinvoicediscountvalue(p_invoiceid integer) OWNER TO postgres;

--
-- Name: tmp_getinvoicefinevalue(integer, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION tmp_getinvoicefinevalue(p_invoiceid integer, p_date date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: tmp_getInvoiceFineValue
  PURPOSE: Calcula o valor referente a multas para um título, se fosse baixado em p_date.
**************************************************************************************/
DECLARE
    v_policyInfo RECORD;
    v_invoiceInfo RECORD;
    v_release BOOLEAN;
    v_fineValue NUMERIC;
    v_balanceValue NUMERIC;
    v_date DATE;
    v_maturityMonth INTEGER;
    v_maturityYear INTEGER;
    v_nowMonth INTEGER;  
    v_to_date DATE;
    v_to_dateMonth INTEGER;
    v_index INTEGER;
    v_referenceDate DATE;
BEGIN
    v_fineValue = 0;
    v_date := p_date;

    -- Invoice data
    SELECT INTO v_invoiceInfo *
      FROM ONLY finReceivableInvoice
     WHERE invoiceId = p_invoiceId;

    --Release data
    FOR v_release IN SELECT releaseInterest
                       FROM finRelease
                      WHERE invoiceid = p_invoiceId
                        AND v_date BETWEEN beginDate AND endDate
    LOOP
        IF v_release = true THEN RETURN 0; END IF;
    END LOOP;

    -- Policy's invoice data
    SELECT INTO v_policyInfo *
      FROM finPolicy
     WHERE policyId = v_invoiceInfo.policyId;

    SELECT INTO v_balanceValue *
      FROM tmp_getBalanceFines(p_invoiceId);

    IF getParameter('FINANCE', 'DESCARTAR_DIA_31') = 'YES' THEN
        v_maturityMonth := EXTRACT(MONTH FROM v_invoiceInfo.referenceMaturityDate::date);
        v_maturityYear := EXTRACT(YEAR FROM v_invoiceInfo.referenceMaturityDate::date);
        v_nowMonth := EXTRACT(MONTH FROM p_date::date);
        v_to_date := TO_DATE('31/' || v_maturityMonth || '/' || v_maturityYear, 'dd/mm/yyyy');
        v_to_dateMonth := EXTRACT(MONTH FROM v_to_date);

        v_index = 0;

        IF ( (v_maturityMonth <> v_nowMonth) AND (v_maturityMonth = v_to_dateMonth) ) THEN
            v_index := 1;
        END IF;

        v_referenceDate := ((v_index||' days')::interval+v_invoiceInfo.referenceMaturityDate+(v_policyInfo.daysToFine||' days')::interval)::date;

    ELSE
        v_referenceDate := (v_invoiceInfo.referenceMaturityDate+(v_policyInfo.daysToFine||' days')::interval)::date;
    END IF;

    IF getParameter('BASIC', 'ENABLE_BUSINESS_USER') = '1'
    THEN
        IF ( EXTRACT('DOW' FROM v_referenceDate) = 6 ) THEN
            v_referenceDate := v_referenceDate+'2 DAYS'::interval;
        ELSEIF ( EXTRACT('DOW' FROM v_referenceDate) = 0 ) THEN    
            v_referenceDate := v_referenceDate+'1 DAY'::interval;
        END IF;
    END IF;

    --Caso for segunda feira desconta 1 dia extendendo o desconto de domingo
    IF getParameter('FINANCE', 'EXTENDER_DESCONTOS_NA_SEGUNDA') = 'YES'
    THEN
        --Verifica se ira cobrar multa
        IF v_date > v_referenceDate THEN
            --Se A data de referencia for uma segunda
            IF ( EXTRACT('DOW' FROM v_date) = 1 ) THEN
                --Caso não cobrou a multa no dia anterior (domingo) então não cobra na segunda
                IF ( v_date-('1 days')::interval <= v_referenceDate ) THEN
                    RETURN 0;
                END IF;               
            END IF;
        END IF;
    END IF;

    IF v_policyInfo.applyFine = TRUE THEN
    -- Check if maturity date is in fine period (sum interest and fine days if have interest period)
        IF v_date > v_referenceDate THEN
            v_fineValue := v_balanceValue * ( ((v_policyInfo.finePercent)/100));
        END IF;
    END IF;

    RETURN v_fineValue;
END
$$;


ALTER FUNCTION public.tmp_getinvoicefinevalue(p_invoiceid integer, p_date date) OWNER TO postgres;

--
-- Name: tmp_getinvoiceinterestvalue(integer, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION tmp_getinvoiceinterestvalue(p_invoiceid integer, p_date date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: getInvoiceInterestValue
  PURPOSE: Calcula os juros que um título teria, se baixado em p_date.
**************************************************************************************/
DECLARE
    v_policyInfo RECORD;
    v_invoiceInfo RECORD;
    v_release BOOLEAN;
    v_interestValue NUMERIC;
    v_balanceValue NUMERIC;
    v_interestPercent NUMERIC;
    v_numDays NUMERIC;
    v_date DATE;
    v_maturityMonth INTEGER;
    v_maturityYear INTEGER;
    v_nowMonth INTEGER;  
    v_to_date DATE;
    v_to_dateMonth INTEGER;
    v_index INTEGER;
    v_referenceDate DATE;
BEGIN
    v_interestValue = 0;
    v_date := p_date;

    -- Invoice data
    SELECT INTO v_invoiceInfo *
      FROM ONLY finReceivableInvoice
     WHERE invoiceId = p_invoiceId;

    FOR v_release IN SELECT releaseInterest
                       FROM finRelease
                      WHERE invoiceid = p_invoiceId
                        AND v_date BETWEEN beginDate AND endDate
    LOOP
        IF v_release = true THEN RETURN 0; END IF;
    END LOOP;

    -- Policy's invoice data
    SELECT INTO v_policyInfo *
      FROM finPolicy
     WHERE policyId = v_invoiceInfo.policyId;

    SELECT INTO v_balanceValue *
      FROM tmp_getBalanceInterests(p_invoiceId);

    IF getParameter('FINANCE', 'DESCARTAR_DIA_31') = 'YES' THEN
        v_maturityMonth := EXTRACT(MONTH FROM v_invoiceInfo.referenceMaturityDate::date);
        v_maturityYear := EXTRACT(YEAR FROM v_invoiceInfo.referenceMaturityDate::date);
        v_nowMonth := EXTRACT(MONTH FROM p_date::date);
        v_to_date := TO_DATE('31/' || v_maturityMonth || '/' || v_maturityYear, 'dd/mm/yyyy');
        v_to_dateMonth := EXTRACT(MONTH FROM v_to_date);

        v_index = 0;

        IF ( (v_maturityMonth <> v_nowMonth) AND (v_maturityMonth = v_to_dateMonth) ) THEN
            v_index := 1;
        END IF;

        v_referenceDate := ((v_index||' days')::interval+v_invoiceInfo.referenceMaturityDate+(v_policyInfo.daysToFine||' days')::interval)::date;
    ELSE
            v_referenceDate := (v_invoiceInfo.referenceMaturityDate+(v_policyInfo.daysToInterest||' days')::interval)::date;
    END IF;

    IF getParameter('BASIC', 'ENABLE_BUSINESS_USER') = '1'
        THEN
            IF ( EXTRACT('DOW' FROM v_referenceDate) = 6 ) THEN
                v_referenceDate := v_referenceDate+'2 DAYS'::interval;
            ELSEIF ( EXTRACT('DOW' FROM v_referenceDate) = 0 ) THEN    
                v_referenceDate := v_referenceDate+'1 DAY'::interval;
            END IF;
        END IF;

    IF v_policyInfo.applyInterest = TRUE THEN
        -- Check if maturity date is in interest period
        IF v_date > v_referenceDate THEN
            -- function that returns the difference in months of 2 dates
            v_numDays := v_date::date - v_invoiceInfo.referenceMaturityDate::date;
            v_interestPercent := (v_policyInfo.monthlyInterestPercent/30)/100;
            IF v_policyInfo.interestType = 'S' THEN
                -- Apply simple interest formula
                v_interestValue := (v_balanceValue * v_interestPercent) * v_numDays;
            ELSE
                -- Apply compound interest formula
                v_interestValue := (v_balanceValue * ( POWER(1 + (v_interestPercent) , v_numDays) ) - v_balanceValue);
            END IF;
        END IF;
    END IF;

    --Caso for segunda feira desconta 1 dia extendendo o desconto de domingo
    IF getParameter('FINANCE', 'EXTENDER_DESCONTOS_NA_SEGUNDA') = 'YES'
    THEN
        --Verifica se ira cobrar multa
        IF v_date > v_referenceDate THEN
            --Se A data de referencia for uma segunda
            IF ( EXTRACT('DOW' FROM v_date) = 1 ) THEN
                --Caso não cobrou a multa no dia anterior (domingo) então não cobra na segunda
                IF ( v_date-('1 days')::interval <= v_referenceDate ) THEN
                    v_interestValue := 0;
                END IF;               
            END IF;
        END IF;
    END IF;

    RETURN v_interestValue;
END
$$;


ALTER FUNCTION public.tmp_getinvoiceinterestvalue(p_invoiceid integer, p_date date) OWNER TO postgres;

--
-- Name: totalcountermovement(integer, date, date, integer, character); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION totalcountermovement(p_counterid integer, p_begindate date, p_enddate date, p_specieid integer, p_operation character) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: totalCounterMovement
  PURPOSE: Calcula o saldo de movimentaçães conforme caixa, peréodo e espécie.
  DESCRIPTION: vide "PURPOSE".
**************************************************************************************/
DECLARE
    v_total numeric;
    v_select text;
BEGIN
 v_select := '';

    IF p_counterId IS NOT NULL
    THEN
        v_select := v_select || 'B.counterId = ''' || p_counterId || ''' AND ';
    END IF;

    IF p_beginDate IS NOT NULL
    THEN
        v_select := v_select || 'A.movementdate::date >= ''' || p_beginDate || ''' AND ';
    END IF;

    IF p_endDate IS NOT NULL
    THEN
        v_select := v_select || 'A.movementdate::date <= ''' || p_endDate || ''' AND ';
    END IF;

    IF p_specieId IS NOT NULL
    THEN
        v_select := v_select || 'A.speciesid = ''' || p_specieId || ''' AND ';
    END IF;

    IF p_operation IS NOT NULL
    THEN
        v_select := v_select || 'A.operation = ''' || p_operation || ''' AND ';
    END IF;

  IF v_select <> ''
    THEN
        v_select := ' WHERE ' || substring( v_select from 0 for (char_length(v_select)-4) );
    END IF;

    v_select:= 'SELECT ROUND(SUM(A.value),2)
	        FROM fincountermovement A
          INNER JOIN finOpenCounter B
 	          ON (B.openCounterId = A.openCounterId)' || v_select;

	FOR v_total IN EXECUTE v_select
	LOOP
		RETURN v_total;
	END LOOP;
END
$$;


ALTER FUNCTION public.totalcountermovement(p_counterid integer, p_begindate date, p_enddate date, p_specieid integer, p_operation character) OWNER TO postgres;

--
-- Name: totaldepontosobtidospeloaluno(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION totaldepontosobtidospeloaluno(p_subscriptionid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: totalDePontosObtidosPeloAluno
  PURPOSE: Retorna o total de pontos obtidos pelo aluno até a etapa atual de
           um processo seletivo.
**************************************************************************************/
DECLARE
BEGIN
    RETURN (  SELECT totalpoints
                FROM spr.subscriptionstepinfo AA
          INNER JOIN spr.subscription BB
                  ON ( AA.subscriptionid = BB.subscriptionid
                       AND AA.subscriptionid = p_subscriptionid)
               WHERE AA.stepid = (SELECT B.stepid 
                                   FROM spr.subscriptionstepinfo A
                             INNER JOIN spr.step B
                                     ON A.stepid = B.stepid
                                  WHERE selectiveprocessid = BB.selectiveprocessid
                                    AND totalpoints IS NOT NULL
                               ORDER BY steporder DESC
                                  LIMIT 1)   );
END;
$$;


ALTER FUNCTION public.totaldepontosobtidospeloaluno(p_subscriptionid integer) OWNER TO postgres;

--
-- Name: transitaprematriculadosparamatriculados(); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION transitaprematriculadosparamatriculados() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: transitaPreMatriculadosParaMatriculados
  PURPOSE: Função criada para corrigir problemas que ocorrem de alunos que pagaram suas primeiras parcelas 
  e não trocaram de pré-matriculados para matriculados.

  REVISIONS:
  Ver       Date          Author               Description
  --------- ------------- -------------------- ------------------------------------
  1.0       09/05/2014    Augusto A. Silva     1. Função criada.
**************************************************************************************/
DECLARE
	V_PRE_MATRICULADOS RECORD;
BEGIN
	-- Obtém todos alunos pré-matriculados que já pagaram a primeira parcela.
	FOR V_PRE_MATRICULADOS IN
		( SELECT A.personId,
		         A.contractId,
		         B.learningPeriodId
		    FROM acdContract A
	      INNER JOIN acdlearningperiod B
		      ON ( B.courseid,
			   B.courseVersion,
			   B.turnid,
			   B.unitId ) = ( A.courseId,
					  A.courseVersion,
					  A.turnId,
					  A.unitId )
		   WHERE verificaseprimeiraparcelarealmentefoipaga(A.contractId, B.learningPeriodId)
		     AND getContractState(A.contractId) = getParameter('ACADEMIC', 'STATE_CONTRACT_ID_PRE_ENROLL')::INT
		     AND B.periodId = getparameter('BASIC', 'CURRENT_PERIOD_ID') )
	LOOP
		-- Atualiza as matrículas do aluno para MATRICULADO.
		UPDATE acdEnroll
		   SET statusId = getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED')::INT
		 WHERE enrollId IN ( SELECT A.enrollId
				       FROM acdEnroll A
				 INNER JOIN acdGroup B
					 ON B.groupId = A.groupId
				 INNER JOIN acdLearningPeriod C
					 ON C.learningPeriodId = B.learningPeriodId
				      WHERE A.contractId = V_PRE_MATRICULADOS.contractId
					AND C.learningPeriodId = V_PRE_MATRICULADOS.learningPeriodId );

		-- Insere movimentação contratual de MATRÍCULA para o aluno.
		INSERT INTO acdMovementContract
			    ( contractId,
			      stateContractId,
			      statetime,
			      learningPeriodId )
		     VALUES ( V_PRE_MATRICULADOS.contractId,
			      getParameter('BASIC', 'STATE_CONTRACT_ID_ENROLLED')::INT,
			      TO_CHAR(NOW(), getparameter('BASIC', 'MASK_TIMESTAMP'))::TIMESTAMP,
			      V_PRE_MATRICULADOS.learningPeriodId );

		RAISE NOTICE 'Aluno % do contrato %, MATRICULADO.', V_PRE_MATRICULADOS.personId, V_PRE_MATRICULADOS.contractId;
	END LOOP;

	RETURN TRUE;
END; 
$$;


ALTER FUNCTION public.transitaprematriculadosparamatriculados() OWNER TO solis;

--
-- Name: trg_acdlearningperiod_proc(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION trg_acdlearningperiod_proc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: trg_acdLearningPeriod_proc
  PURPOSE: Não permite INSERT e UPDATE se já existir outro período letivo com
           mesmo período letivo anterior.
  DESCRIPTION:
  Dispara uma exceção se um INSERT ou UPDATE tentar definir o período letivo
  anterior como sendo um período letivo que já é anterior de algum outro.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       12/11/2010 Alexandre Schmidt 1. Função criada.
  1.1       20/11/2010 Alexandre Schmidt 1. Correção quando a trigger é exe-
                                            cutada em updates.
******************************************************************************/
DECLARE
    v_row RECORD;
    v_found BOOLEAN;
BEGIN
    v_found := FALSE;
    
    -- if previous learning period is null, there is nothing
    -- to check, so let update happen
    IF NEW.previousLearningPeriodId IS NOT NULL THEN
        -- make sure no other learning period has a previous learning period
        -- equal to this being inserted or updated
        FOR v_row IN SELECT *
                       FROM acdLearningPeriod
                      WHERE previousLearningPeriodId = NEW.previousLearningPeriodId
                        AND ((TG_OP = 'UPDATE' AND learningPeriodId != NEW.learningPeriodId)
                             OR (TG_OP != 'UPDATE')) LOOP

            v_found := TRUE;
            RAISE NOTICE 'Período letivo % já tem período letivo anterior %.', v_row.learningPeriodId, v_row.previousLearningPeriodId;
        END LOOP;
    END IF;

    IF v_found THEN
        RAISE EXCEPTION 'Já existe um período letivo com o mesmo período letivo anterior.';
    END IF;

    -- if we reach this point, the record can be inserted/updated
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.trg_acdlearningperiod_proc() OWNER TO postgres;

--
-- Name: trg_atualiza_identificador(); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION trg_atualiza_identificador() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NEW.documenttypeid = 2 AND ( GETPARAMETER('BASIC', 'IDENTIFICADOR_PADRAO_PESSOA') = 'CPF' )
    THEN
        UPDATE basphysicalperson SET identifier = new.content WHERE personid = new.personid;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION public.trg_atualiza_identificador() OWNER TO solis;

--
-- Name: trg_can_delete_option_proc(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION trg_can_delete_option_proc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: chk_can_delete_option
  PURPOSE: Verifica se a opção pode ser deletada (se ela não tem respostas).
  DESCRIPTION: Verifica se alguma pessoa já respondeu uma determinada questão,
  caso tenha retorna um alerta informando que não pode ser deletada a opção.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       12/01/2011 Samuel Koch       1. Função criada.
**************************************************************************************/
DECLARE
    v_count integer;
BEGIN
    SELECT COUNT(*) INTO v_count
      FROM rshAnswer
     WHERE optionId = OLD.optionId;

    IF ( v_count != 0 ) THEN
        RAISE EXCEPTION 'Esta opção não pode ser excluída, pois já possui respostas. Para excluir esta opção você deve excluir as respostas.';
    END IF;
END;
$$;


ALTER FUNCTION public.trg_can_delete_option_proc() OWNER TO postgres;

--
-- Name: trg_can_delete_question_proc(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION trg_can_delete_question_proc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: chk_can_delete_question
  PURPOSE: Verifica se a questão pode ser deletada (se ela não tem opções).
  DESCRIPTION: Verifica se a questão tem opções, caso tenha retorna um alerta
  dizendo que não pode ser deletada.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       09/12/2010 Arthur Lehdermann 1. Função criada.
  1.1       06/01/2011 Moises Heberle    2. Funcão alterada.
**************************************************************************************/
DECLARE
    v_count integer;
BEGIN
    SELECT COUNT(*) INTO v_count
      FROM rshOption
     WHERE questionId = OLD.questionId;

    IF ( v_count != 0 ) THEN
        RAISE EXCEPTION 'Esta questão não pode ser excluída pois possui opções de respostas. Para poder excluir esta questão você deve excluir as opções.';
    END IF;

    RETURN OLD;
END;
$$;


ALTER FUNCTION public.trg_can_delete_question_proc() OWNER TO postgres;

--
-- Name: trg_finprice_unique_proc(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION trg_finprice_unique_proc() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: trg_finPrice_unique_proc
  PURPOSE: Não permite INSERT e UPDATE se já existir outro preço cujas datas de
           vigência sobreponham a que se está querendo atualizar ou inserir.
  DESCRIPTION: Verifica a existência de outros registros conflitantes.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       22/11/2010 Alexandre Schmidt 1. Função criada.
******************************************************************************/
DECLARE
    v_count integer;
BEGIN
    IF NEW.startDate > NEW.endDate THEN
        RAISE EXCEPTION 'Data final menor do que data inicial.';
    END IF;

    SELECT COUNT(*) INTO v_count
      FROM finPrice A
     WHERE A.courseId = NEW.courseId
       AND A.courseVersion = NEW.courseVersion
       AND A.turnId = NEW.turnId
       AND A.unitId = NEW.unitId
       AND (NEW.startDate BETWEEN A.startDate AND A.endDate
            OR NEW.endDate BETWEEN A.startDate AND A.endDate);

    -- allow only one (in case of update) or zero (in case of insert) price with same records
    IF (TG_OP = 'UPDATE' AND v_count > 1) THEN
        RAISE EXCEPTION 'A vigência informada para o preço sobrepõe a vigência de outro preço. Atualização não efetuada.';
    ELSIF (TG_OP = 'INSERT' AND v_count > 0) THEN
        RAISE EXCEPTION 'A vigência informada para o preço sobrepõe a vigência de outro preço. Inserção não efetuada.';
    END IF;

    -- if we reach this point, the record can be inserted/updated
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.trg_finprice_unique_proc() OWNER TO postgres;

--
-- Name: trg_noduplicateddocuments(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION trg_noduplicateddocuments() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: trg_professorCommitment
  DESCRIPTION: não permite que um mesmo documento seja cadastrado para mais de
  uma pessoa.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       01/03/2011 Alex Smith        1. FUNÇÃO criada.
******************************************************************************/
DECLARE
    v_count integer;
    v_documentTypeDescription varchar;
BEGIN
    --Verificação para não permitir que mais pessoas utilizem o mesmo documento
    IF NEW.content IS NOT NULL
    THEN
        SELECT COUNT(*) INTO v_count
          FROM basDocument
    INNER JOIN basDocumentType
         USING (documenttypeid)
         WHERE documentTypeId = NEW.documentTypeId
           AND content = NEW.content
           AND documentTypeId != getParameter('basic', 'DEFAULT_DOCUMENT_TYPE_ID_RG')::integer
           AND validaconteudo = TRUE
           AND CASE WHEN TG_OP = 'UPDATE'
                   THEN personId != NEW.personId
               ELSE
                   TRUE
               END;

        IF v_count != 0 THEN
            -- obtém descrição do documento para mensagem mais informativa
            SELECT name INTO v_documentTypeDescription
              FROM basDocumentType
             WHERE documentTypeId = NEW.documentTypeId;
             
            RAISE EXCEPTION 'O % % jé esté cadastrado para outra pessoa.', v_documentTypeDescription, NEW.content;
        END IF;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION public.trg_noduplicateddocuments() OWNER TO postgres;

--
-- Name: trg_professorcommitment(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION trg_professorcommitment() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: trg_professorCommitment
  DESCRIPTION: Não permite que haja sobreposição de datas nos diferentes
  contratos do professor e obriga que exista apenas um endDate
  nulo por pessoa.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       08/02/2011 Moises Heberle    1. Função criada.
******************************************************************************/
DECLARE
    v_count integer;
BEGIN
    --Verificação para não permitir mais de uma data final (endDate) por pessoa
    IF NEW.endDate IS NULL
    THEN
        SELECT COUNT(*) INTO v_count
          FROM basProfessorCommitment
         WHERE personId = NEW.personId
            AND endDate IS NULL;

         IF v_count <> 0 THEN
            RAISE EXCEPTION 'Não é possível existir mais de uma data final vazia para um mesmo professor.';
         END IF;
    END IF;

    --Verificacao para não haver sobreposição de datas nos diferentes contratos do professor
    SELECT COUNT(*) INTO v_count
      FROM basProfessorCommitment
     WHERE personId = NEW.personId
        AND (NEW.beginDate BETWEEN beginDate AND endDate
          OR  NEW.endDate BETWEEN beginDate AND endDate);

    IF v_count <> 0 THEN
        RAISE EXCEPTION 'Já existe uma data inicial ou final que está entre as datas informadas.';
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION public.trg_professorcommitment() OWNER TO postgres;

--
-- Name: trg_updateinvoideiddependence(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION trg_updateinvoideiddependence() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: trg_updateinvoiceiddependence
  DESCRIPTION: Trigger que libera as parcelas dependentes quando um tÃ­tulo for pago.

  REVISIONS:
  Ver       Date       Author             Description
  --------- ---------- ------------------ ------------------------------------
  1.0       06/07/2012 Leovan T. Da Silva 1. Trigger criada.
******************************************************************************/
DECLARE
    v_paymentoperation INTEGER;
BEGIN
    IF TG_OP = 'INSERT' THEN
        SELECT INTO v_paymentoperation paymentoperation FROM findefaultoperations LIMIT 1;
        
        IF NEW.operationid = v_paymentoperation OR balance(NEW.invoiceid) <= 0 THEN
            UPDATE fininvoice SET invoiceiddependence = NULL WHERE invoiceiddependence = NEW.invoiceid;
        END IF;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION public.trg_updateinvoideiddependence() OWNER TO postgres;

--
-- Name: trg_valida_data_cancelamento(); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION trg_valida_data_cancelamento() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
/***************************************************************
  PURPOSE: Impede de alterar o status de uma matrícula que 
  possuí data de cancelamento. 
           Trigger criada para resolução ticket #28523.
****************************************************************/
DECLARE    
    
BEGIN
    IF OLD.datecancellation IS NOT NULL 
    THEN
        IF NEW.statusid != OLD.statusid 
        THEN
            IF OLD.statusid = getParameter('ACADEMIC', 'ENROLL_STATUS_CANCELLED')::int
            THEN
                UPDATE acdEnroll
                   SET datecancellation = NULL
                 WHERE enrollid = OLD.enrollid;
            END IF;
        END IF;
    END IF;
    
    RETURN NEW;	 
END;
$$;


ALTER FUNCTION public.trg_valida_data_cancelamento() OWNER TO solis;

--
-- Name: trgdigitacaodenotastrocaexamepormenornota(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION trgdigitacaodenotastrocaexamepormenornota() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    
BEGIN

    PERFORM digitacaoDeNotasTrocaExamePorMenorNota(NEW.enrollid, NEW.degreeid, NEW.note);

    RETURN NEW;

END;
$$;


ALTER FUNCTION public.trgdigitacaodenotastrocaexamepormenornota() OWNER TO postgres;

--
-- Name: txtcatspc(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION txtcatspc(text, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
BEGIN
RETURN $1 || ' ' || $2;
END
$_$;


ALTER FUNCTION public.txtcatspc(text, text) OWNER TO postgres;

--
-- Name: unaccent(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION unaccent(text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
BEGIN
     RETURN translate($1, 'ãáàâãäéèêëíìïóòôõöúùûüÁÀÂÃÄÉÈÊËÍÌÏÓÒÔÕÖÚÙÛÜçÇñÑ', 'aaaaaaeeeeiiiooooouuuuAAAAAEEEEIIIOOOOOUUUUcCnN');
END;
$_$;


ALTER FUNCTION public.unaccent(text) OWNER TO postgres;

--
-- Name: uniao_de_registros(character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION uniao_de_registros(tabela_principal character varying, chave_origem integer, chave_destino integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: uniao_de_registros
  PURPOSE: Unifica registros duplicados na base de dados, 
  recebendo a tabela e os dois códigos a serem unificados da mesma.
**************************************************************************************/
DECLARE
    row record;
    primary_key VARCHAR;
BEGIN	
    FOR row IN 
        ( SELECT tc.table_name AS tabela, 
	         tc.constraint_schema AS esquema, 
	         kcu.column_name AS coluna
	    FROM information_schema.table_constraints AS tc 
	    JOIN information_schema.key_column_usage AS kcu 
	      ON tc.constraint_name = kcu.constraint_name
	    JOIN information_schema.constraint_column_usage AS ccu 
	      ON ccu.constraint_name = tc.constraint_name
	   WHERE constraint_type = 'FOREIGN KEY' 
	     AND ccu.table_name = tabela_principal )
    LOOP
        IF row.tabela = 'gtclibperson' THEN
            DELETE FROM gtclibperson  WHERE personid =  chave_origem;
            END IF;

        IF row.tabela <> tabela_principal AND row.tabela <> 'gtclibperson'
    THEN
        BEGIN
            RAISE NOTICE 'UPDATE %.% SET % = % WHERE % = %', row.esquema, row.tabela, row.coluna, chave_destino, row.coluna, chave_origem;
            EXECUTE 'UPDATE ' || row.esquema || '.' || row.tabela || ' SET ' || row.coluna || ' = ' || chave_destino || ' WHERE ' || row.coluna || ' = ' || chave_origem;
        EXCEPTION WHEN unique_violation 
        THEN
            EXECUTE 'DELETE FROM ' ||  row.esquema || '.' || row.tabela || ' WHERE ' || row.coluna || ' = ' || chave_origem;
        END;
    END IF;
    END LOOP;
        
    SELECT INTO primary_key obterColunaChavePrimariaDaTabela(tabela_principal);

    RAISE NOTICE 'DELETE FROM % WHERE % = %', tabela_principal, primary_key, chave_origem;
    EXECUTE 'DELETE FROM ' || tabela_principal || ' WHERE ' || primary_key || ' = ' || chave_origem;

    RETURN;
END;
$$;


ALTER FUNCTION public.uniao_de_registros(tabela_principal character varying, chave_origem integer, chave_destino integer) OWNER TO postgres;

--
-- Name: unificarcidade(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION unificarcidade(p_decidade integer, p_paracidade integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: unificarCidade
  PURPOSE: Processo de unificação de cidades.

  REVISIONS:
  Ver       Date       Author              Description
  --------- ---------- ------------------  ----------------------------------
  1.0       17/12/13   Nataniel I. Silva   1. FUNÇÃO criada.
**************************************************************************************/
DECLARE
    v_deCidadeDados RECORD;
    v_paraCidadeDados RECORD;
    v_tabela TEXT;

BEGIN
    v_tabela := 'bascity';
    
    SELECT INTO v_deCidadeDados
                *
           FROM basCity
          WHERE cityId = p_deCidade;

    SELECT INTO v_paraCidadeDados
                *
           FROM basCity
          WHERE cityId = p_paraCidade;
    
    --Verifica se as cidades são do mesmo estado.
    IF v_deCidadeDados.stateid = v_paraCidadeDados.stateid THEN
	-- Executa o processo de unificação das cidades.
	EXECUTE 'SELECT testar_valor_vazio(''' || v_tabela || ''', ''' || p_deCidade || ''', ''' || p_paraCidade || ''')';
	EXECUTE 'SELECT uniao_de_registros(''' || v_tabela || ''', ''' || p_deCidade || ''', ''' || p_paraCidade || ''')';	
    ELSE
        RAISE EXCEPTION 'As cidades devem pertencerem ao mesmo estado para serem unificadas.';
    END IF; 

    RETURN TRUE;
END;
$$;


ALTER FUNCTION public.unificarcidade(p_decidade integer, p_paracidade integer) OWNER TO postgres;

--
-- Name: unificarcontrato(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION unificarcontrato(p_decontrato integer, p_paracontrato integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: unificarContrato
  PURPOSE: Processo de unificação de contratos.
**************************************************************************************/
DECLARE
    v_deContratoDados RECORD;
    v_paraContratoDados RECORD;

    v_deEnrolls RECORD;
    v_paraEnrolls RECORD;

    v_matriculado INT := getParameter('ACADEMIC', 'ENROLL_STATUS_ENROLLED')::INT;
    v_aprovado INT := getParameter('ACADEMIC', 'ENROLL_STATUS_APPROVED')::INT;
    v_spc_movement BOOLEAN;
    v_titulo_aberto RECORD;
    v_deSemestreContrato RECORD;
BEGIN
    SELECT INTO v_deContratoDados
                *
           FROM acdContract
          WHERE contractId = p_deContrato;

    SELECT INTO v_paraContratoDados
                *
           FROM acdContract
          WHERE contractId = p_paraContrato;

    -- Valida se os dois contratos são da mesma ocorrência de curso.
    IF ( v_deContratoDados.courseid = v_paraContratoDados.courseid AND
         v_deContratoDados.courseversion = v_paraContratoDados.courseversion AND
         v_deContratoDados.turnid = v_paraContratoDados.turnid AND
         v_deContratoDados.unitid = v_paraContratoDados.unitid )
    THEN
        -- Valida se existe a mesma disciplina com status de matriculado/aprovado nas matrículas.
        FOR v_deEnrolls IN
                ( SELECT *
                    FROM acdEnroll
                   WHERE contractId = p_deContrato )
        LOOP
            FOR v_paraEnrolls IN 
                    ( SELECT *
                        FROM acdEnroll
                       WHERE contractId = p_paraContrato )
            LOOP
                IF v_deEnrolls.groupid = v_paraEnrolls.groupid
                THEN
                    IF ( v_deEnrolls.statusid = v_matriculado AND
                         v_paraEnrolls.statusid = v_matriculado )
                    OR ( v_deEnrolls.statusid = v_aprovado AND
                         v_paraEnrolls.statusid = v_aprovado )
                    OR ( v_deEnrolls.statusid = v_aprovado AND
                         v_paraEnrolls.statusid = v_matriculado )
                    OR ( v_deEnrolls.statusid = v_matriculado AND
                         v_paraEnrolls.statusid = v_aprovado )
                    THEN
                        RAISE EXCEPTION 'Disciplinas duplicadas.';
                    END IF;
                END IF;
            END LOOP;
        END LOOP;
        
        SELECT INTO v_spc_movement COUNT(*) > 0 FROM finspcmovement  WHERE  personid = v_deContratoDados.personid;
        IF v_spc_movement = TRUE 
        THEN
            SELECT INTO v_titulo_aberto invoiceid FROM finspcmovement  WHERE  personid = v_deContratoDados.personid;
            RAISE EXCEPTION 'O processo de unificação não pode ser concluído, pois a pessoa % do contrato % está com registro no spc referente ao título %.', v_deContratoDados.personid, p_deContrato, v_titulo_aberto.invoiceid;
        END IF;
        
        FOR v_deSemestreContrato IN ( SELECT periodid, COUNT(contractid)  
                                        FROM acdsemestercontractperiod 
                                       WHERE contractid = p_deContrato OR contractid = p_paraContrato
                                    GROUP BY periodid 
                                      HAVING COUNT(contractid) > 1 )

        LOOP
            DELETE FROM acdsemestercontractperiod WHERE contractid = p_deContrato AND periodid = v_deSemestreContrato.periodid;
        END LOOP;

        -- Executa o processo de unificação dos contratos.
        EXECUTE 'SELECT uniao_de_registros(''acdcontract'', ''' || p_deContrato || ''', ''' || p_paraContrato || ''')';		
    ELSE
        RAISE EXCEPTION 'Os contratos precisam pertencer a mesma ocorrência de curso.';
    END IF;

    RETURN TRUE;
END;
$$;


ALTER FUNCTION public.unificarcontrato(p_decontrato integer, p_paracontrato integer) OWNER TO postgres;

--
-- Name: unificarpessoa(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION unificarpessoa(p_depessoa integer, p_parapessoa integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: unificarPessoa
  PURPOSE: Processo de unificacao de pessoa.
**************************************************************************************/
DECLARE
    v_documentos RECORD;
    v_email VARCHAR;
    v_login_de VARCHAR;
    v_login_para VARCHAR;
    v_iduser_de INT;
    v_iduser_para INT;

    v_deTitulosEmAberto BOOLEAN;
    v_paraTitulosEmAberto BOOLEAN;
    
    v_tabela VARCHAR;
    v_tabelas VARCHAR[] := ARRAY[
        'basphysicalpersonprofessor',
        'basphysicalpersonemployee',
        'basphysicalpersonstudent',
        'basphysicalperson',
        'basperson'
    ];
    v_spc_movement BOOLEAN;
    v_titulo_aberto RECORD;
    v_exits BOOLEAN;
    v_pessoa_que_fica RECORD;
    v_isstudent BOOLEAN;
    v_isprofessor BOOLEAN;
    v_isemployee BOOLEAN;

    v_sql TEXT;
BEGIN
    --Verifica se a pessoa que sai e aluno e a que fica nao
    SELECT INTO v_isstudent COUNT(*) = 1 
      FROM ONLY basphysicalpersonstudent
          WHERE personid = p_dePessoa
            AND NOT EXISTS (SELECT 1 
                         FROM ONLY basphysicalpersonstudent
                             WHERE personid = p_paraPessoa);
     
    --Verifica se a pessoa que sai e professor e a que fica nao
    SELECT INTO v_isprofessor COUNT(*) = 1
      FROM ONLY basphysicalpersonprofessor
          WHERE personid = p_dePessoa
            AND NOT EXISTS (SELECT 1 
                         FROM ONLY basphysicalpersonprofessor
                             WHERE personid = p_paraPessoa);
     
    --Verifica se a pessoa que sai e funcionario e a que fica nao
    SELECT INTO v_isemployee COUNT(*) = 1
      FROM ONLY basphysicalpersonemployee
          WHERE personid = p_dePessoa
            AND NOT EXISTS (SELECT 1 
                         FROM ONLY basphysicalpersonemployee
                             WHERE personid = p_paraPessoa);
     
    --Obtem dados da pessoa que fica
    SELECT INTO v_pessoa_que_fica * 
      FROM ONLY basphysicalperson
          WHERE personid = p_paraPessoa;

    --Insere a pessoa que fica como aluno 
    IF v_isstudent = TRUE THEN
        INSERT INTO basphysicalpersonstudent(personid,name,sex) 
             VALUES (p_paraPessoa,v_pessoa_que_fica.name,v_pessoa_que_fica.sex);
    END IF;

    --Insere a pessoa que fica como professor 
    IF v_isprofessor = TRUE THEN
        INSERT INTO basphysicalpersonprofessor(personid,name,sex) 
             VALUES (p_paraPessoa,v_pessoa_que_fica.name,v_pessoa_que_fica.sex);
    END IF;

    --Insere a pessoa que fica como funcionario 
    IF v_isemployee = TRUE THEN
        INSERT INTO basphysicalpersonemployee(personid,name,sex) 
             VALUES (p_paraPessoa,v_pessoa_que_fica.name,v_pessoa_que_fica.sex);
    END IF;
    
    -- Pega as 'unic constraints' de email e login da pessoa que sai para ser setado na que fica.
    SELECT INTO v_email email
      FROM ONLY basPerson
          WHERE personId = p_dePessoa;
          
    SELECT INTO v_login_de miolousername
      FROM ONLY basPerson
          WHERE personId = p_dePessoa;

    SELECT INTO v_login_para miolousername
      FROM ONLY basPerson
          WHERE personId = p_paraPessoa;

    -- Obtem iduser da pessoa que sai
    SELECT INTO v_iduser_de u.iduser FROM miolo_user u WHERE u.login = v_login_de;

    UPDATE basPerson 
       SET email = NULL,
           miolousername = NULL
     WHERE personId = p_dePessoa;

    -- Desabilita trigger de documentos unicos
    ALTER TABLE basdocument DISABLE TRIGGER ALL;

    -- Verifica se as duas pessoas possuem os mesmos documentos.
    FOR v_documentos IN 
	( SELECT documentTypeId
	    FROM basDocument
	   WHERE personid = p_dePessoa )
    LOOP
        SELECT INTO v_exits count(*) > 0
	       FROM basDocument
	      WHERE personid = p_paraPessoa
	        AND documentTypeId = v_documentos.documentTypeId;
        IF v_exits = 't'THEN
            DELETE FROM basDocument
		  WHERE personid = p_dePessoa
		    AND documentTypeId = v_documentos.documentTypeId;
	END IF;
    END LOOP;

    -- Verifica se existe financeiro em aberto para as duas pessoas.
    SELECT INTO v_deTitulosEmAberto
		COUNT(*) > 0
	   FROM finReceivableInvoice
	  WHERE personid = p_dePessoa
            AND iscanceled = FALSE
	    AND invoiceIdDependence IS NULL
	    AND ROUND(balance(invoiceId)::numeric, 2) > 0.00;

    SELECT INTO v_paraTitulosEmAberto
		COUNT(*) > 0
	   FROM finReceivableInvoice
	  WHERE personid = p_paraPessoa
            AND iscanceled = FALSE
	    AND invoiceIdDependence IS NULL
	    AND ROUND(balance(invoiceId)::numeric, 2) > 0.00;

    IF v_deTitulosEmAberto = TRUE AND v_paraTitulosEmAberto = TRUE
    THEN
	RAISE EXCEPTION 'Ambas as pessoas possuem financeiro em aberto, favor ajustar para prosseguir com o processo.';
    END IF;

    SELECT INTO v_spc_movement COUNT(*) > 0 FROM finspcmovement  WHERE  personid = p_dePessoa;
    IF v_spc_movement = TRUE 
    THEN
        SELECT INTO v_titulo_aberto invoiceid FROM finspcmovement  WHERE  personid = p_dePessoa;
        RAISE EXCEPTION 'O processo de unificacao nao pode ser concluido, pois a pessoa % esta com registro no spc referente ao titulo %.', p_dePessoa, v_titulo_aberto.invoiceid;
    END IF;

--v_titulo_aberto

    -- Executa o processo de unificacao dos registros.
    FOR v_tabela IN 
	( SELECT vt
	    FROM unnest(v_tabelas) x(vt) )
    LOOP
        BEGIN
            EXECUTE 'SELECT testar_valor_vazio(''' || v_tabela || ''', ''' || p_dePessoa || ''', ''' || p_paraPessoa || ''')';
            EXECUTE 'SELECT uniao_de_registros(''' || v_tabela || ''', ''' || p_dePessoa || ''', ''' || p_paraPessoa || ''')';
        EXCEPTION 
            WHEN foreign_key_violation THEN
		CASE v_tabela
                    WHEN 'basphysicalpersonprofessor' THEN
		        RAISE EXCEPTION 'A pessoa % nao e um professor, para prosseguir com o processo, cadastre a pessoa como professor.', p_paraPessoa;
		    WHEN 'basphysicalpersonemployee' THEN
		        RAISE EXCEPTION 'A pessoa % nao e um funcionario, para prosseguir com o processo, cadastre a pessoa como funcionario.', p_paraPessoa;
		    WHEN 'basphysicalpersonstudent' THEN
		        RAISE EXCEPTION 'A pessoa % nao e um aluno, para prosseguir com o processo, cadastre a pessoa como aluno.', p_paraPessoa;
                    ELSE
			RAISE EXCEPTION 'Erro ao atualizar o registro % da tabela %. ERRO: %', p_dePessoa, v_tabela, SQLERRM;
		END CASE;
        END;
    END LOOP;

    -- Seta email e login da pessoa que foi removida para a que fica.
    UPDATE basPerson 
       SET email = v_email
     WHERE personId = p_paraPessoa
       AND email IS NULL;

    UPDATE basPerson 
       SET miolousername = v_login_de
     WHERE personId = p_paraPessoa
       AND miolousername IS NULL;

    -- Obtem o iduser da pessoa que fica
    SELECT INTO v_iduser_para u.iduser FROM miolo_user u WHERE u.login = v_login_para;

    -- Transfere as permissoes da pessoa que sai para pessoa que fica, caso as duas tenham usuario
    IF ( v_login_de IS NOT NULL AND v_login_para IS NOT NULL AND v_login_de <> v_login_para )
    THEN
        RAISE NOTICE 'Set perms: % (%) to % (%)', v_login_de, v_iduser_de, v_login_para, v_iduser_para;

        UPDATE miolo_groupUser
                SET iduser = v_iduser_para
              WHERE iduser = v_iduser_de
                AND NOT EXISTS(SELECT 1
                                 FROM miolo_groupUser mu
                                WHERE iduser = v_iduser_para
                                  AND idgroup = mu.idgroup
                                  AND unitid = mu.unitid);

        -- Remove permissoes que ficaram ainda penduradas para usuario antigo
        DELETE FROM miolo_groupUser WHERE iduser = v_iduser_de;

        -- Atualiza nas tabelas referenciadas, trocando do iduser/login antigo para o novo
        FOR v_sql IN (
            SELECT 'UPDATE ' || tc.table_schema || '.' || tc.table_name || ' SET ' || kcu.column_name || ' = ''' || (CASE WHEN ccu.column_name = 'iduser' THEN v_iduser_para::text ELSE v_login_para END ) || ''' WHERE ' || kcu.column_name || ' = ''' || (CASE WHEN ccu.column_name = 'iduser' THEN v_iduser_de::text ELSE v_login_de END ) || '''' AS sql
            FROM information_schema.table_constraints tc
            JOIN information_schema.key_column_usage kcu ON tc.constraint_name = kcu.constraint_name
            JOIN information_schema.constraint_column_usage ccu ON ccu.constraint_name = tc.constraint_name
            WHERE constraint_type = 'FOREIGN KEY'
            AND ccu.table_name='miolo_user' )
        LOOP
            --RAISE NOTICE '%', v_sql;
            EXECUTE v_sql;
        END LOOP;

        -- E por fim, exclui o usuario antigo
        DELETE FROM miolo_user WHERE login = v_login_de;
    END IF;

    -- Habilita novamente a trigger de documentos unicos
    ALTER TABLE basdocument ENABLE TRIGGER ALL;

    RETURN TRUE;
END;
$$;


ALTER FUNCTION public.unificarpessoa(p_depessoa integer, p_parapessoa integer) OWNER TO postgres;

--
-- Name: unmask(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION unmask(text) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
     RETURN translate($1, '.-/', '')::varchar;
END;
$_$;


ALTER FUNCTION public.unmask(text) OWNER TO postgres;

--
-- Name: unmaskcpf(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION unmaskcpf(p_cpf text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    RETURN lpad( regexp_replace( p_cpf, '[^0-9]', '', 'gi'),  11, '0');
END;
 $$;


ALTER FUNCTION public.unmaskcpf(p_cpf text) OWNER TO postgres;

--
-- Name: upd_gerar_boleto_multa(integer, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION upd_gerar_boleto_multa(p_codigo_da_multa integer, p_operador character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_select varchar;
    v_line gtcFine;
BEGIN

    -- Funcao para pagar uma multa em aberto. Será utilizado pelo SAGU

    SELECT INTO v_line * from gtcFine where fineId = p_codigo_da_multa;

    IF ( v_line.fineStatusId = 2 )
    THEN
        raise exception 'Não foi possível gerar o boleto da multa % pois ela está como paga.', v_line.fineId;
        return FALSE;
    END IF;

    IF ( v_line.fineStatusId = 4 )
    THEN
        raise exception 'Não foi possível gerar o boleto da multa % pois ela está como abonada.', v_line.fineId;
        return FALSE;
    END IF;

    IF ( v_line.fineStatusId = 3 )
    THEN
        raise exception 'Não foi possível gerar o boleto da multa % pois ela está como paga via boleto.', v_line.fineId;
        return FALSE;
    END IF;

    UPDATE gtcFine SET fineStatusId = 3, enddate = now() where fineId = p_codigo_da_multa;
    INSERT INTO gtcFineStatusHistory (fineid, finestatusid, date, operator) VALUES (p_codigo_da_multa, 3, now(), p_operador);

    return true;
END;
$$;


ALTER FUNCTION public.upd_gerar_boleto_multa(p_codigo_da_multa integer, p_operador character varying) OWNER TO postgres;

--
-- Name: upd_pagar_multa(integer, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION upd_pagar_multa(p_codigo_da_multa integer, p_operador character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_select varchar;
    v_line gtcFine;
BEGIN
    -- Funcao para pagar uma multa em aberto. Será utilizado pelo SAGU

    SELECT INTO v_line * from gtcFine where fineId = p_codigo_da_multa;

    IF ( v_line.fineStatusId = 2 OR v_line.fineStatusId = 3 )
    THEN
        raise exception 'Não foi possível pagar a multa % pois ela está como paga.', v_line.fineId;
        return FALSE;
    END IF;

    IF (v_line.fineStatusId = 4)
    THEN
        raise exception 'Não foi possível pagar a multa % pois ela está como abonada.', v_line.fineId;
        return FALSE;
    END IF;

    UPDATE gtcFine SET fineStatusId = 2, enddate = now() where fineId = p_codigo_da_multa;
    INSERT INTO gtcFineStatusHistory (fineid, finestatusid, date, operator) VALUES (p_codigo_da_multa, 2, now(), p_operador);

    return true;
END;
$$;


ALTER FUNCTION public.upd_pagar_multa(p_codigo_da_multa integer, p_operador character varying) OWNER TO postgres;

--
-- Name: update_miolo_user_passwords(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION update_miolo_user_passwords(p_password text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_user TEXT;
BEGIN
    --cria usuarios que faltam
    FOR v_user IN  SELECT distinct login FROM ( SELECT DISTINCT login, ( SELECT usename FROM pg_catalog.pg_user WHERE usename = login ) AS usename, ( SELECT rolname FROM pg_catalog.pg_roles WHERE rolname = login ) AS rolname FROM miolo_user ) AS foo WHERE usename IS NULL and rolname IS NULL
    LOOP
	IF CHAR_LENGTH(v_user) > 0
	THEN
	        EXECUTE 'CREATE USER "'|| v_user ||'" WITH password '''|| p_password ||''' SUPERUSER IN GROUP miolo_users';
	END IF;
    END LOOP;

    --atualiza senha dos que for necessario
    FOR v_user IN SELECT login FROM miolo_user WHERE login IN (SELECT usename FROM pg_catalog.pg_user)
    LOOP
	IF CHAR_LENGTH(v_user) > 0
	THEN
	        EXECUTE 'ALTER ROLE "' || v_user || '" WITH PASSWORD ''' || p_password || '''';
	END IF;
    END LOOP;

    RETURN True;
END;
$$;


ALTER FUNCTION public.update_miolo_user_passwords(p_password text) OWNER TO postgres;

--
-- Name: updatedtime(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION updatedtime(integer) RETURNS character varying
    LANGUAGE sql
    AS $_$
SELECT CASE WHEN balance($1) = 0
            THEN '(x)'
            ELSE EXTRACT(DAY FROM (NOW() - (SELECT maturityDate 
                                              FROM finReceivableInvoice
                                             WHERE invoiceId = $1)
                                  )
                        )::varchar
            END $_$;


ALTER FUNCTION public.updatedtime(integer) OWNER TO postgres;

--
-- Name: updateloginperson(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION updateloginperson() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
        DECLARE
            v_login_value TEXT;
            v_texto_msg TEXT;
        BEGIN

            SELECT personid INTO v_login_value
              FROM ONLY basperson
             WHERE login = new.miolousername
               AND personid != new.personid;

            IF v_login_value IS NOT NULL
            THEN
                IF TG_OP = 'UPDATE'
                THEN
                    RAISE EXCEPTION 'Não foi possível atualizar a pessoa de código % pois o usuário % já existe na pessoa de código % ',new.personid, new.miolousername, v_login_value;
                ELSE        
                    RAISE EXCEPTION 'Não foi possível inserir a pessoa pois o usuário % já existe na pessoa código % ',new.miolousername , v_login_value;
                END IF;
            ELSE
                new.login = new.miolousername;             
            END IF;

            RETURN NEW;
        END;
        $$;


ALTER FUNCTION public.updateloginperson() OWNER TO postgres;

--
-- Name: updateorinsertfrequenceenroll(character varying, inet, integer, integer, integer, date, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION updateorinsertfrequenceenroll(var_username character varying, var_ipaddress inet, var_timeid integer, var_enrollid integer, var_scheduleid integer, var_frequencydate date, var_frequency double precision) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE acdFrequenceEnroll
        SET frequency     = var_frequency
        WHERE enrollid    = var_enrollid AND
            scheduleid    = var_scheduleId AND
            frequencydate = var_frequencydate AND
            timeId        = var_timeId;

    IF NOT FOUND THEN
        INSERT INTO acdFrequenceEnroll
           (username,
           ipaddress,
           enrollid,
           scheduleid,
           frequencydate,
           timeid,
           frequency)
        VALUES (var_username,
           var_ipaddress,
           var_enrollid,
           var_scheduleid,
           var_frequencydate,
           var_timeid,
           var_frequency);
    END IF;

    RETURN TRUE;
END;
$$;


ALTER FUNCTION public.updateorinsertfrequenceenroll(var_username character varying, var_ipaddress inet, var_timeid integer, var_enrollid integer, var_scheduleid integer, var_frequencydate date, var_frequency double precision) OWNER TO postgres;

--
-- Name: updateournumber(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION updateournumber() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_ourNumber bigint;    
    v_query varchar;

    v_validournumber CHARACTER VARYING;
    v_maxournumber CHARACTER VARYING;
    v_update BOOLEAN;
BEGIN
/**
* FUNÇÃO chamada ao atualizar a conta bancéria
* Atualiza a sequéncia do nosso numero
**/
    v_ourNumber := new.bankaccountId::bigint; --Converte o nosso numero para numerico

    --Somente executa se o campo ourNumber foi alterado
    IF old.ourNumber != new.ourNumber
    THEN
        v_update := FALSE;
        SELECT INTO v_maxournumber MAX(ournumber) FROM finbankinvoiceinfo WHERE bankAccountId = NEW.bankAccountId;

        --Caso o numero informado seja menor ou igual a um nosso numero jé gerado incrementa
        IF NEW.ournumber::bigint < v_maxournumber::bigint
        THEN
            v_validournumber := LPAD((v_maxournumber::bigint + 1)::varchar, length(NEW.ournumber), '0');
            v_update := TRUE;
        ELSE
            v_validournumber := NEW.ournumber;
        END IF;

        -- Verifica se existe sequencia e seta o novo valor, caso nao exista ainda, cria
        BEGIN
            v_ourNumber := setval('seq_ourNumber_bankAccountId_' || new.bankAccountId, v_validournumber::bigint);
        EXCEPTION
            WHEN OTHERS THEN
                -- cai no erro se a sequencia ainda nao existir e cria a sequencia
                v_query := 'CREATE SEQUENCE seq_ourNumber_bankAccountId_' || new.bankAccountId || ' START ' || v_validournumber::bigint ;
                EXECUTE v_query;
        END;
        
        --Caso o numero for invalido incrementa e atualiza novamente
        IF v_update IS TRUE 
        THEN
            NEW.ournumber := v_validournumber;
        END IF;
        
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION public.updateournumber() OWNER TO postgres;

--
-- Name: updatesequences(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION updatesequences() RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
/*************************************************************************************
  NAME: updateSequences
  PURPOSE: Atualizar todas as sequences do banco para os valores de acordo com a
  tabela que gerenciam, fazendo SELECT MAX(coluna_gerenciada) FROM tabela.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       09/07/2011 Alex Smith        1. Função criada.
**************************************************************************************/
DECLARE
    v_row RECORD;
BEGIN
    FOR v_row IN SELECT DISTINCT 'SELECT setval(''' || REGEXP_REPLACE(pg_catalog.pg_get_expr(d.adbin, d.adrelid), '(^.*''([^'']*)[''].*$)',E'\\2') || ''', COALESCE((SELECT MAX(' || a.attname || ') FROM ' || n.nspname || '.' || c.relname || '), 1));' AS sqlToRun
                   FROM pg_catalog.pg_attribute a
             INNER JOIN pg_catalog.pg_attrdef d
                     ON d.adrelid = a.attrelid
                    AND d.adnum = a.attnum
                    AND a.atthasdef
             INNER JOIN pg_class c
                     ON a.attrelid = c.oid
              LEFT JOIN pg_catalog.pg_namespace n
                     ON n.oid = c.relnamespace
                  WHERE a.attnum > 0
                    AND NOT a.attisdropped
                    AND a.attislocal -- somente campos nao herdados
                    AND d.adsrc like '%nextval%'
               ORDER BY 1
    LOOP
        RAISE NOTICE '%', v_row.sqlToRun;
        EXECUTE v_row.sqlToRun;
    END LOOP;

    RETURN TRUE;
END;
$_$;


ALTER FUNCTION public.updatesequences() OWNER TO postgres;

--
-- Name: usuariotempermissao(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION usuariotempermissao(v_iduser integer, v_unitid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
    Retorna se usuario (userId) tem permissao na unidade (unitId) passada.
******************************************************************************/
DECLARE
BEGIN
    RETURN EXISTS(
        SELECT 1
          FROM miolo_groupuser
         WHERE iduser = v_iduser
           AND (unitid = v_unitid OR unitid IS NULL)
    );
END;
$$;


ALTER FUNCTION public.usuariotempermissao(v_iduser integer, v_unitid integer) OWNER TO postgres;

--
-- Name: validaregistrodemovimentacaocontratual(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION validaregistrodemovimentacaocontratual(p_contractid integer, p_statecontractid integer, p_learningperiodid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE	
BEGIN
	-- Se o estado contratual for de matrícula e não está sendo registrado período letivo, retorna false.
	IF ( p_statecontractid = getParameter('BASIC', 'STATE_CONTRACT_ID_ENROLLED')::INT OR
	     p_statecontractid = getParameter('ACADEMIC', 'STATE_CONTRACT_ID_PRE_ENROLL')::INT )
	THEN
		IF p_learningperiodid IS NULL
		THEN
			RAISE EXCEPTION 'Para ser registrada uma movimentação contratual de pré-matrícula ou matrícula, é requerido o período letivo. Contate o administrador do sistema.';
		END IF;
	END IF;

	RETURN TRUE;
END;
$$;


ALTER FUNCTION public.validaregistrodemovimentacaocontratual(p_contractid integer, p_statecontractid integer, p_learningperiodid integer) OWNER TO postgres;

--
-- Name: validate_acccostcenter(); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION validate_acccostcenter() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_check boolean;
BEGIN

    v_check = TRUE;
    
    IF ( length(NEW.parentcostcenterid) > 0 ) THEN
    BEGIN
        SELECT INTO v_check isCostCenterActive(NEW.parentcostcenterid);
    END;
    END IF;
    
    IF ( v_check IS FALSE ) THEN
    BEGIN
        RAISE EXCEPTION 'O centro de custo % está inativo.', NEW.parentcostcenterid;
    END;
    END IF;
    
    RETURN NEW;

END;
$$;


ALTER FUNCTION public.validate_acccostcenter() OWNER TO solis;

--
-- Name: validate_costcenter(); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION validate_costcenter() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_check boolean;
BEGIN

    v_check = TRUE;
    
    IF ( length(NEW.costcenterid) > 0 ) THEN
    BEGIN
        SELECT INTO v_check isCostCenterActive(NEW.costcenterid);
    END;
    END IF;
    
    IF ( v_check IS FALSE ) THEN
    BEGIN
        RAISE EXCEPTION 'O centro de custo % está inativo.', NEW.costcenterid;
    END;
    END IF;
    
    RETURN NEW;

END;
$$;


ALTER FUNCTION public.validate_costcenter() OWNER TO solis;

--
-- Name: validate_cpf(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION validate_cpf(p_cpf character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: VALIDATE_CPF
  DESCRIPTION: FUNÇÃO responsável por validar CPF.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       14/01/2011 Arthur Lehdermann 1. FUNÇÃO criada.
  1.1       14/01/2011 Alex Smith        2. Identação e otimização.
******************************************************************************/
DECLARE
    v_digit integer;
    v_sum integer;
    v_cpf varchar;
BEGIN
    -- verificar se cpf contém caracteres inválidos para um cpf
    v_cpf := regexp_replace(p_cpf, '[^0-9.-]', '', 'g');

    IF ( v_cpf != p_cpf )
    THEN
        RETURN FALSE;
    END IF;

    -- deixar somente números
    v_cpf := regexp_replace(p_cpf, '[.-]', '', 'g');

    -- testes de sanidade
    IF (v_cpf IS NULL
        OR LENGTH(v_cpf) < 11
        OR v_cpf = '00000000000'
        OR v_cpf = '11111111111'
        OR v_cpf = '22222222222'
        OR v_cpf = '33333333333'
        OR v_cpf = '44444444444'
        OR v_cpf = '55555555555'
        OR v_cpf = '66666666666'
        OR v_cpf = '77777777777'
        OR v_cpf = '88888888888'
        OR v_cpf = '99999999999')
    THEN
        RETURN FALSE;
    END IF;

    -- cálculo do primeiro dígito
    v_digit := 0;
    v_sum := 0;

    FOR i IN 1..9
    LOOP
        v_sum := v_sum + (SUBSTR(v_cpf, i, 1))::integer * (11 - i);
    END LOOP;

    v_digit := 11 - MOD (v_sum, 11);

    IF v_digit > 9
    THEN
        v_digit := 0;
    END IF;

    -- validação do primeiro dígito
    IF v_digit != (SUBSTR (v_cpf, 10, 1))::integer
    THEN
        RETURN FALSE;
    END IF;

    -- cálculo do segundo dígito
    v_digit := 0;
    v_sum := 0;

    FOR i IN 1..10
    LOOP
        v_sum := v_sum + (SUBSTR (v_cpf, i, 1))::integer * (12 - i);
    END LOOP;

    v_digit := 11 - MOD (v_sum, 11);

    IF v_digit > 9
    THEN
        v_digit := 0;
    END IF;

    -- validação do segundo dígito
    IF v_digit != (SUBSTR (v_cpf, 11, 1))::integer
    THEN
        RETURN FALSE;
    END IF;

    RETURN TRUE;
END;
$$;


ALTER FUNCTION public.validate_cpf(p_cpf character varying) OWNER TO postgres;

--
-- Name: valorbloqueadoadesconsiderar(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION valorbloqueadoadesconsiderar(p_invoiceid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
    --Recebe o valor das operações salvas no parâmetro
    v_operacao_a_desconsiderar TEXT;
    
    --Recebe o valor dos invoices
    v_value NUMERIC;

BEGIN
    v_operacao_a_desconsiderar := GETPARAMETER('FINANCE','DESCONSIDERA_DO_VALOR_PAGO_MENSALIDADES');
    v_value := 0;

    IF LENGTH(v_operacao_a_desconsiderar)>0 THEN

	SELECT INTO v_value COALESCE(sum(value),0) 
	       FROM finentry
	      WHERE invoiceid = p_invoiceid
	        AND operationid::TEXT IN (SELECT regexp_split_to_table(GETPARAMETER('FINANCE','DESCONSIDERA_DO_VALOR_PAGO_MENSALIDADES'), E','));

        RETURN v_value;

    END IF;

    RETURN 0;
END;
$$;


ALTER FUNCTION public.valorbloqueadoadesconsiderar(p_invoiceid integer) OWNER TO postgres;

--
-- Name: verificaorigemetnicapessoacenso(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION verificaorigemetnicapessoacenso(p_val integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: verificaSexoPessoaCenso
  PURPOSE: Valida o id da entina para ocenso cujos ids s?o diferentes do sagu.
**************************************************************************************/
BEGIN
    RETURN 
    ( CASE WHEN p_val = 2 THEN 3
           WHEN p_val = 3 THEN 2
           WHEN p_val IS NULL THEN 6
           ELSE p_val
      END );
END;
$$;


ALTER FUNCTION public.verificaorigemetnicapessoacenso(p_val integer) OWNER TO postgres;

--
-- Name: verificapossuifinanceamentoestudantil(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION verificapossuifinanceamentoestudantil(p_personid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: verificarFormaDeIngressoCursoCenso
  PURPOSE: Obtem os dados da forma de ingresso do aluno no curso.
**************************************************************************************/
DECLARE
    v_invoices RECORD;

BEGIN
    SELECT INTO v_invoices 
                E.invoiceId
           FROM finEntry E
          WHERE E.invoiceId IN ( SELECT invoiceId
                              FROM ONLY finReceivableInvoice
                                  WHERE personId = p_personId )
            AND E.operationId IN ( SELECT operationId
                                     FROM finloan );

     IF v_invoices IS NULL
     THEN
          RETURN 0;
     ELSE
          RETURN 1;
     END IF;
END;
$$;


ALTER FUNCTION public.verificapossuifinanceamentoestudantil(p_personid integer) OWNER TO postgres;

--
-- Name: verificaprimeiraparcela(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION verificaprimeiraparcela(p_enrollid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: verificaPrimeiraParcela
  PURPOSE: Retorna TRUE quando primeira parcela foi paga ou configuracao/modulo estiver desabilitado.
  DESCRIPTION: vide "PURPOSE".
**************************************************************************************/
DECLARE
BEGIN
    RETURN      GETPARAMETER('BASIC', 'MODULE_FINANCE_INSTALLED') <> 'YES'
             OR GETPARAMETER('ACADEMIC', 'GRADE_TYPING_CHECK_FIRST_PARCEL') <> 't'
             OR EXISTS(SELECT 1
                         FROM acdEnroll E
                   INNER JOIN acdGroup G
                           ON E.groupId = G.groupId
                   INNER JOIN acdLearningPeriod LP
                           ON LP.learningPeriodId = G.learningPeriodId
                   INNER JOIN finEntry E1
                           ON ( E1.contractId = E.contractId AND E1.learningPeriodId = LP.learningPeriodId )
                   INNER JOIN finInvoice I
                           ON I.invoiceId = E1.invoiceId
                        WHERE E.enrollId = p_enrollId
                          AND I.isCanceled IS FALSE
                          AND I.parcelNumber = 1
                          AND BALANCE(I.invoiceId) = 0 );
END;
$$;


ALTER FUNCTION public.verificaprimeiraparcela(p_enrollid integer) OWNER TO postgres;

--
-- Name: verificaprimeiraparcela(integer, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION verificaprimeiraparcela(p_enrollid integer, p_period character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: verificaPrimeiraParcela
  PURPOSE: Retorna TRUE quando primeira parcela foi paga ou configuracao/modulo estiver desabilitado.
  DESCRIPTION: vide "PURPOSE".
 REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       XX/XX/2012 XXXXXXXXXX        1. FUNÇÂO criada.
  1.1       03/10/2012 Samuel Koch       1. Correção na verificaÃ§Ã£o do perÃ­odo letivo
                                            A verificaÃ§Ã£o nos lanÃ§amentos estava incorreta.
                                         2. Alterada para adicionar uma verificaÃ§Ã£o quanto a
                                            existência de títulos não cancelados e de outros 
                                            contratos.
 1.2        23/11/2012 Samuel Koch       1. Adicionado verificação quanto a existência da primeira
                                            parcela.
**************************************************************************************/
DECLARE
    v_invoice BOOLEAN;
BEGIN

    SELECT count(*) > 0 INTO v_invoice
      FROM acdEnroll A
INNER JOIN acdContract B
        ON (A.contractId = B.contractId)
INNER JOIN finEntry C
        ON (B.contractId = C.contractId)
INNER JOIN finInvoice D
        ON (C.invoiceId = D.invoiceId)
     WHERE A.enrollId = p_enrollId
       AND balance(C.invoiceId)>0
       AND D.iscanceled = 'f'
       AND D.parcelNumber = 1;

    IF v_invoice = 'f'  THEN
        return true;
    END IF;

    RETURN    GETPARAMETER('BASIC', 'MODULE_FINANCE_INSTALLED') <> 'YES'
           OR GETPARAMETER('ACADEMIC', 'GRADE_TYPING_CHECK_FIRST_PARCEL') <> 't'
           OR verificaseprimeiraparcelafoipaga(p_enrollid, p_period);
END;
$$;


ALTER FUNCTION public.verificaprimeiraparcela(p_enrollid integer, p_period character varying) OWNER TO postgres;

--
-- Name: verificarcampoobrigatoriocenso(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION verificarcampoobrigatoriocenso(p_val character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: verificarCampoObrigatorioCenso
  PURPOSE: Verifica se o valor trazido por parâmetro é nulo setando 'Campo obrigatório' caso sim.
**************************************************************************************/
BEGIN
    RETURN 
    ( CASE WHEN p_val IS NULL
           THEN
                'Campo obrigatório'
           ELSE
                p_val
      END );
END;
$$;


ALTER FUNCTION public.verificarcampoobrigatoriocenso(p_val character varying) OWNER TO postgres;

--
-- Name: verificarformadeingressocursocenso(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION verificarformadeingressocursocenso(p_contractid integer, p_statecontractid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: verificarFormaDeIngressoCursoCenso
  PURPOSE: Obtem os dados da forma de ingresso do aluno no curso.
**************************************************************************************/
BEGIN
    RETURN ( CASE WHEN ( SELECT stateContractId
		           FROM acdMovementContract 
		          WHERE contractId = p_contractId 
		            AND stateTime = ( SELECT MIN(stateTime) 
				           	FROM acdMovementContract 
                                               WHERE contractId = p_contractId ) 
		          LIMIT 1 ) = p_stateContractId
		  THEN 
                       1
                  ELSE
                       0
             END );
END;
$$;


ALTER FUNCTION public.verificarformadeingressocursocenso(p_contractid integer, p_statecontractid integer) OWNER TO postgres;

--
-- Name: verificarunidade(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION verificarunidade() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
 * Adiciona a unidade atual logada na INSERCAO de tabelas multiunidade
******************************************************************************/
BEGIN
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE'
    THEN
        IF NEW.unitid IS NULL AND TG_OP = 'INSERT'
        THEN
            NEW.unitid := obterunidadelogada();
        END IF;

        RETURN NEW;
    END IF;

    RETURN OLD;
END;
$$;


ALTER FUNCTION public.verificarunidade() OWNER TO postgres;

--
-- Name: verificasealunoereingressantenoperiodo(integer, integer); Type: FUNCTION; Schema: public; Owner: solis
--

CREATE FUNCTION verificasealunoereingressantenoperiodo(p_contractid integer, p_learningperiodid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: verificaSeAlunoEReingressanteNoPeriodo
  PURPOSE: Verifica se o aluno é reingressante no curso no período letivo.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       05/03/2013 Augusto A. Silva  1. FUNÇÃO criada.
**************************************************************************************/
DECLARE
BEGIN
      RETURN ( SELECT COUNT(*) > 0
                 FROM acdMovementContract
                WHERE contractId = p_contractid
                  AND learningPeriodId = p_learningperiodid
                  AND stateContractId = getParameter('ACADEMIC', 'STATE_CONTRACT_ID_UNLOCKED')::INT );
END;
$$;


ALTER FUNCTION public.verificasealunoereingressantenoperiodo(p_contractid integer, p_learningperiodid integer) OWNER TO solis;

--
-- Name: verificaseprimeiraparcelafoipaga(integer, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION verificaseprimeiraparcelafoipaga(p_enrollid integer, p_period character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: verificaseprimeiraparcelafoipaga
  PURPOSE: Retorna TRUE quando primeira parcela foi paga.
  DESCRIPTION: vide "PURPOSE".
 REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       21/06/2013 Augusto A. Silva  1. Função criada.
**************************************************************************************/
DECLARE
BEGIN

    RETURN EXISTS( SELECT 1
                     FROM acdEnroll A
               INNER JOIN acdContract B
                       ON A.contractId = B.contractId
               INNER JOIN acdGroup C
                       ON A.groupId = C.groupId
               INNER JOIN acdLearningPeriod D
                       ON C.learningPeriodId = D.learningPeriodId
               INNER JOIN finEntry E
                       ON A.contractId = E.contractId
               INNER JOIN finInvoice F
                       ON E.invoiceId = F.invoiceId
                    WHERE A.enrollId = p_enrollId
                      AND F.isCanceled IS FALSE
                      AND F.parcelNumber = 1
                      AND BALANCE(F.invoiceId) = 0
                      AND D.periodId = p_period );
END;
$$;


ALTER FUNCTION public.verificaseprimeiraparcelafoipaga(p_enrollid integer, p_period character varying) OWNER TO postgres;

--
-- Name: verificaseprimeiraparcelarealmentefoipaga(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION verificaseprimeiraparcelarealmentefoipaga(p_contractid integer, p_learningperiodid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: verificaseprimeiraparcelarealmentefoipaga
  PURPOSE: Retorna TRUE quando primeira parcela foi paga.
  DESCRIPTION: vide "PURPOSE".
 REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       18/12/2013 Augusto A. Silva  1. Função criada.
**************************************************************************************/
DECLARE
    v_pagou BOOLEAN;
BEGIN
    SELECT INTO v_pagou (ROUND(balance(A.invoiceId)::numeric, getParameter('BASIC', 'REAL_ROUND_VALUE')::int) <= 0.0)
      FROM ONLY finreceivableinvoice A
     INNER JOIN finEntry B
             ON B.invoiceId = A.invoiceId
     INNER JOIN acdLearningPeriod C
	     ON C.learningPeriodid = B.learningPeriodId
          WHERE A.iscanceled = FALSE
            AND A.parcelnumber = 1
            AND B.contractId = p_contractid
            AND C.periodId = ( SELECT periodId
				 FROM acdLearningPeriod
				WHERE learningPeriodId = p_learningperiodid );

    IF v_pagou IS NULL
    THEN
        v_pagou := FALSE;
    END IF;
    
    RETURN v_pagou;
END;
$$;


ALTER FUNCTION public.verificaseprimeiraparcelarealmentefoipaga(p_contractid integer, p_learningperiodid integer) OWNER TO postgres;

--
-- Name: workloadprofessorcheck(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION workloadprofessorcheck(p_groupid integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: trg_workLoadProfessorCheck
  DESCRIPTION: Não permite que a carga horaria do professor seja ultrapassada.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       10/02/2011 Moises Heberle    1. Função criada.
  1.1       21/02/2011 Moises Heberle    1. Correção para funcionar versao 8.4
  1.2       10/03/2011 Moises Heberle    1. Transformando a trigger para funcao,
                                            pois nao poderá mais abortar a
                                            operação, apenas alertar o usuário.
******************************************************************************/
DECLARE
    v_workLoad float;
    v_workLoadCommitment float;
    v_personName varchar;
    schedule record;
    _schedule record;
BEGIN
    --Seleciona os horarios agrupando pelo mes + ano
    FOR schedule IN (SELECT
	         S.scheduleId,
	         TO_CHAR(UNNEST(S.occurrencedates), 'mm') AS _month,
	         TO_CHAR(UNNEST(S.occurrencedates), 'yyyy') AS _year,
	         SP.professorId
	    FROM acdSchedule S
      INNER JOIN acdScheduleProfessor SP
              ON (S.scheduleId = SP.scheduleId)
           WHERE S.groupid = p_groupId
        GROUP BY 1,2,3,4)
    LOOP
        v_workLoadCommitment := 0;
	v_workLoad := 0;

        --Obtem os horarios separando pelas datas de ocorrencia (occurrenceDates)
	FOR _schedule IN (SELECT UNNEST(occurrenceDates) AS occurrenceDate, timeids AS timeids FROM acdSchedule WHERE scheduleId = schedule.scheduleId)
	LOOP
	    --Filtra pelo mes
            IF ((SELECT EXTRACT(month FROM _schedule.occurrenceDate)) = schedule._month::int)
            THEN
                IF (v_workLoadCommitment = 0)
                THEN
                    --Calcula a carga horaria de comprometimento do professor, neste mes
                    v_workLoadCommitment := (SELECT workLoad FROM basprofessorcommitment WHERE personId = schedule.professorId AND _schedule.occurrenceDate BETWEEN beginDate AND endDate);
		END IF;

                --Soma a carga horaria somada vinda do
                v_workLoad := v_workLoad + EXTRACT(EPOCH FROM ((SELECT SUM(numberminutes) FROM acdtime WHERE timeid = ANY(_schedule.timeids))))::float/60/60;

            END IF;
	END LOOP;

        --RAISE NOTICE '% - %', v_workLoad, v_workLoadCommitment;

        IF ((v_workLoad > 0) AND (v_workLoadCommitment > 0) AND (v_workLoad > v_workLoadCommitment))
        THEN
            v_personName := (SELECT name FROM basPhysicalPersonProfessor WHERE personId = schedule.professorId);
            RETURN 'A carga horária do professor ' || v_personName ||' (' || schedule.professorId || ') está excedendo o limite de tempo para o mês ' || schedule._month || ' de ' || schedule._year || '. (limite: ' || v_workLoadCommitment || ' horas)';
        END IF;
    END LOOP;

    RETURN NULL;
END;
$$;


ALTER FUNCTION public.workloadprofessorcheck(p_groupid integer) OWNER TO postgres;

SET search_path = res, pg_catalog;

--
-- Name: cargahorariatotal(integer, integer); Type: FUNCTION; Schema: res; Owner: postgres
--

CREATE FUNCTION cargahorariatotal(p_residenteid integer, p_unidadetematicaid integer) RETURNS real
    LANGUAGE plpgsql
    AS $$
/*********************************************************************************************
  NAME: res.cargaHorariaTotal
  PURPOSE: Obter a carga horéria total cursada por um residente em uma determinada
  unidade temática.
  DESCRIPTION: A FUNÇÃO percorre todos os locais onde o residente possa ter carga
  horéria registrada para a unidade temática informada, somando tudo o que for carga
  horéria vélida.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       18/07/2011 Alex Smith        1. FUNÇÃO criada.
  1.1       27/07/2011 ftomasini         1. estava comparando o Código da ultima ocorréncia
                                            com os status de ocorréncia de carga horéria vélida.
  1.2       23/08/2011 Moises Heberle    1. Modificado para que suporte que seja passado uma
                                            unidadeTematicaId como NULL, fazendo o somatorio total,
                                            sem filtrar por unidade tematica.
  1.3       26/08/2011 ftomasini         1. Correção no somatorio carga horéria
*********************************************************************************************/
DECLARE
    v_retVal res.encontro.cargaHoraria%TYPE;
    v_cargahoraria res.encontro.cargaHoraria%TYPE;
    v_cargahorariacomplementar res.encontro.cargaHoraria%TYPE;
BEGIN
    SELECT COALESCE (SUM(JJ2.cargaHoraria), 0) INTO v_cargahoraria
               FROM (SELECT B.cargaHoraria,
                            res.ultimaOcorrenciaDeOfertaId(A.residenteId, B.ofertaDeUnidadeTematicaId) as ultimaOcorrenciaDeOfertaId
                       FROM res.frequencia A
                 INNER JOIN res.encontro B
                         ON B.encontroId = A.encontroId
                 INNER JOIN res.ofertaDeUnidadeTematica C
                         ON C.ofertaDeUnidadeTematicaId = B.ofertaDeUnidadeTematicaId
                 INNER JOIN res.unidadeTematica D
                         ON D.unidadeTematicaId = C.unidadeTematicaId
                         -- considerar somente presenca ou falta justificada
                      WHERE A.presenca IN ('P', 'J')
                        AND A.residenteId = p_residenteId
               AND CASE WHEN p_unidadeTematicaId IS NOT NULL THEN D.unidadeTematicaId = p_unidadeTematicaId ELSE 1=1 END ) JJ2
         INNER JOIN res.ocorrenciaDeoferta E
                 ON (E.ocorrenciadeofertaid = JJ2.ultimaOcorrenciaDeOfertaId )
         INNER JOIN res.ofertadoresidente ODR
                 ON ODR.ofertadoresidenteid = E.ofertadoresidenteid       
                   -- considerar somente ofertas cujo status para o residente
                   -- seja de Aprovacao, Interrupcao com aproveitamento de
                   -- carga horaria ou Apto
               Where E.status IN (1, 2, 4);
             
            -- carga horaria oriunda de outras fontes (aproveitamentos, por exemplo)
            SELECT COALESCE(SUM(A.cargaHoraria),0) INTO v_cargahorariacomplementar
              FROM res.cargaHorariaComplementar A
             WHERE A.residenteId = p_residenteId
               AND CASE WHEN p_unidadeTematicaId IS NOT NULL THEN A.unidadeTematicaId = p_unidadeTematicaId ELSE 1=1 END;

            -- Total da carga horéria (carga horéria complementar + carga horéria total das unidades temáticas)
	    v_retVal = ROUND(COALESCE((v_cargahorariacomplementar + v_cargahoraria),0)::numeric,2);

    RETURN v_retVal;
END;
$$;


ALTER FUNCTION res.cargahorariatotal(p_residenteid integer, p_unidadetematicaid integer) OWNER TO postgres;

--
-- Name: periodosocorrenciadecontrato(integer); Type: FUNCTION; Schema: res; Owner: postgres
--

CREATE FUNCTION periodosocorrenciadecontrato(p_residenteid integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: res.periodosOcorrenciaDeContrato
  PURPOSE: Retorna periodos separados por \n

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       23/08/2011 Moises Heberle    1. FUNÇÃO criada.
  1.0       20/10/2011 ftomasini         1. Alteração para não aparecer 1° periodo
                                            quando só existe um.
**************************************************************************************/
DECLARE
    v_retVal text[];
    v_tempVal text;
    v_row RECORD;
    v_bloqueia boolean;
    v_lastPeriod timestamp;
    v_count int;
    v_forCount int;
    v_periodCount int;
    v_aux varchar;
BEGIN
    v_aux := ' ';
    v_forCount := 0;
    v_periodCount := 1;

    SELECT INTO v_count COUNT(*)
           FROM res.ocorrenciaDeContrato ODC
          WHERE ODC.residenteId = p_residenteId;

    FOR v_row IN (SELECT ODC.dataHora,
                         SOC.bloqueiaResidencia
                    FROM res.ocorrenciaDeContrato ODC
              INNER JOIN res.statusDaOcorrenciaDeContrato SOC
                      ON SOC.statusdaocorrenciadecontratoid = ODC.statusdaocorrenciadecontratoid
                   WHERE ODC.residenteId = p_residenteId
                ORDER BY dataHora)
    LOOP
        v_forCount := v_forCount + 1;

        -- Caso nao tenha ainda status, define o atual
        IF v_bloqueia IS NULL
        THEN
            v_bloqueia = v_row.bloqueiaResidencia;
        END IF;

        -- Caso nao tenha ainda lastPeriod, define ultimo
        IF v_lastPeriod IS NULL
        THEN
            v_lastPeriod = v_row.dataHora;
        END IF;

        -- Quando muda o status OU ultimo contador, adiciona uma mensagem na fila
        IF ( (v_row.bloqueiaResidencia != v_bloqueia) OR (v_count = v_forCount) )
        THEN
            IF ( v_bloqueia IS FALSE )
            THEN
                v_aux := 'Período: ' || dataPorExtenso(v_lastPeriod::date) || ' à ' || dataPorExtenso(v_row.dataHora::date);
                IF v_periodCount > 1
                THEN
                   v_aux := v_periodCount ||'° '|| v_aux;
                END IF;

                v_retVal := array_append(v_retVal,  v_aux::text);
                v_periodCount := v_periodCount + 1;
            END IF;

            v_lastPeriod := v_row.dataHora;
        END IF;

        -- Define o status atual
        v_bloqueia = v_row.bloqueiaResidencia;
    END LOOP;

    RETURN array_to_string(v_retVal, E'\n');
END;
$$;


ALTER FUNCTION res.periodosocorrenciadecontrato(p_residenteid integer) OWNER TO postgres;

--
-- Name: ultimaocorrenciadecontratoid(integer); Type: FUNCTION; Schema: res; Owner: postgres
--

CREATE FUNCTION ultimaocorrenciadecontratoid(p_residenteid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: res.ultimaOcorrenciaDeContratoId
  PURPOSE: Retorna o identificador da ocorrência de contrato mais recente para o residente informado.

  REVISIONS:
  Ver       Date       Author                Description
  --------- ---------- -------------------- ------------------------------------
  1.0       18/07/2011 Jonas Gualberto Diel   1. Função criada.
  1.1       03/02/2012 Jonas Guilherme Dahmer 1. Pequena alteração.
            03/02/2012 Fabiano Tomasini
**************************************************************************************/
DECLARE
    v_retVal res.ocorrenciaDeContrato.ocorrenciaDeContratoId%TYPE;
BEGIN
    SELECT A.ocorrenciaDeContratoId INTO v_retVal
      FROM res.ocorrenciaDeContrato A
     WHERE A.residenteId = p_residenteId
            AND A.dataHora < now()
  ORDER BY A.dataHora DESC
     LIMIT 1;

    RETURN v_retVal;
END;
$$;


ALTER FUNCTION res.ultimaocorrenciadecontratoid(p_residenteid integer) OWNER TO postgres;

--
-- Name: ultimaocorrenciadeofertaid(integer, integer); Type: FUNCTION; Schema: res; Owner: postgres
--

CREATE FUNCTION ultimaocorrenciadeofertaid(p_residenteid integer, p_ofertadeunidadetematicaid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: res.ultimaOcorrenciaDeOfertaId
  PURPOSE: Retorna o identificador da ocorrência de oferta mais recente da oferta de
  unidade temática informada, para o residente informado.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       18/07/2011 Alex Smith        1. Função criada.
**************************************************************************************/
DECLARE
    v_retVal res.ocorrenciaDeOferta.ocorrenciaDeOfertaId%TYPE;
BEGIN
    SELECT A.ocorrenciaDeOfertaId INTO v_retVal
      FROM res.ocorrenciaDeOferta A
INNER JOIN res.ofertaDoResidente B
        ON B.ofertaDoResidenteId = A.ofertaDoResidenteId
     WHERE B.residenteId = p_residenteId
       AND B.ofertaDeUnidadeTematicaId = p_ofertaDeUnidadeTematicaId
  ORDER BY A.dataHora DESC
     LIMIT 1;

    RETURN v_retVal;
END;
$$;


ALTER FUNCTION res.ultimaocorrenciadeofertaid(p_residenteid integer, p_ofertadeunidadetematicaid integer) OWNER TO postgres;

SET search_path = spr, pg_catalog;

--
-- Name: check_if_classification_was_generated_in_step(integer); Type: FUNCTION; Schema: spr; Owner: postgres
--

CREATE FUNCTION check_if_classification_was_generated_in_step(p_step_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: CHECK_IF_CLASSIFICATION_WAS_GENERATED_IN_STEP
  DESCRIPTION: Verifica se todas as pessoas inscritas na etapa anterior tem status
  diferente de inscrito.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       12/01/2011 Fabiano Tomasini 1. Função criada.
  1.1       01/07/2011 Alex Smith       1. Adequação de encoding e substitui-
                                           ção do esquema antigo para o novo.
******************************************************************************/
DECLARE
v_select text;
v_step record;
v_subscription record;
v_result boolean;

BEGIN
    v_select:= 'SELECT A.subscriptionStatusId
                  FROM spr.subscriptionstepinfo A
                 WHERE A.stepId = '||p_step_id ;

    v_result:= TRUE;
    FOR v_subscription IN EXECUTE v_select
    LOOP
        --Caso encontre alguem com status inscrito retorna false
        IF( v_subscription.subscriptionStatusId = 1 )
        THEN
            v_result:= FALSE;
        END IF;
    END LOOP;

    RETURN v_result;
END;

$$;


ALTER FUNCTION spr.check_if_classification_was_generated_in_step(p_step_id integer) OWNER TO postgres;

--
-- Name: check_if_evaluations_of_subscription_received_minpoints(integer, integer); Type: FUNCTION; Schema: spr; Owner: postgres
--

CREATE FUNCTION check_if_evaluations_of_subscription_received_minpoints(p_subscription_id integer, p_step_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: spr.CHECK_IF_EVALUATIONS_OF_SUBSCRIPTION_RECEIVED_MINPOINTS
  DESCRIPTION: verifica se inscrito obteve nota maior que a minima em todas
  avaliações, TRUE se obteve nota maior que a mínima em todas avaliações,
  FALSE se não obteve nota maior que a minima em todas as avaliações, usada na
  função spr.SET_STEP_SUBSCRIPTIONS_STATUS

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       12/01/2011 Fabiano Tomasini 1. Função criada.
  1.1       01/07/2011 Alex Smith       1. Adequação de encoding e substitui-
                                           ção do esquema antigo para o novo.
  1.2       02/02/2012 Jonas Diel       1. Correção para reprovar os inscritos
                                           sem notas registradas.
******************************************************************************/
DECLARE
v_select text;
v_subscription record;
v_result boolean;

BEGIN
    v_select:= 'SELECT A.totalpoints,
                       B.minPoints
                  FROM spr.evaluationpoints A
            INNER JOIN spr.evaluation B
                    ON (A.evaluationId = B.evaluationId)
            INNER JOIN spr.step C
                    ON (C.stepId = B.stepId)
                 WHERE A.subscriptionid = '''|| p_subscription_id ||'''
                   AND C.stepId = ''' || p_step_id || '''';

    v_result:= TRUE;
    FOR v_subscription IN EXECUTE v_select
    LOOP
        --Result = false caso total de pontos seja menor que o mínimo
        IF( v_subscription.totalpoints < v_subscription.minPoints OR v_subscription.totalpoints IS NULL )
        THEN
            v_result:= FALSE;
        END IF;
    END LOOP;

    RETURN v_result;
END;

$$;


ALTER FUNCTION spr.check_if_evaluations_of_subscription_received_minpoints(p_subscription_id integer, p_step_id integer) OWNER TO postgres;

--
-- Name: classification_in_step(integer); Type: FUNCTION; Schema: spr; Owner: postgres
--

CREATE FUNCTION classification_in_step(p_stepid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: spr.classification_in_step
  DESCRIPTION: Função principal responsável por calcular pontos e setar o status
  dos inscritos na etapa.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       12/01/2011 Fabiano Tomasini 1. Função criada.
  1.1       01/07/2011 Alex Smith       1. Adequação de encoding e substitui-
                                           ção do esquema antigo para o novo.
  1.2       08/08/2011 Alex Smith       1. Adequação do código da função aos
                                           coding standards.
******************************************************************************/
DECLARE
    v_step record;
BEGIN

    -- Atribui as informações da etapa na variável record v_step
    SELECT * INTO v_step FROM spr.step WHERE stepId = p_stepId;

    -- Gera o total de pontos para cada inscrição na etapa
    RAISE NOTICE 'Gerando total de pontos para etapa %', p_stepId;
    PERFORM * FROM spr.generate_total_points_step(p_stepId);

    -- Se a classificação for do tipo automática
    IF v_step.classificationmethod = 'A' THEN
        -- Seta statusId nas informações da inscrição
        RAISE NOTICE 'Alterando status das inscrições da etapa %', p_stepId;
        PERFORM * FROM spr.set_step_subscriptions_status(p_stepId);
    END IF;

    RETURN TRUE;
END;
$$;


ALTER FUNCTION spr.classification_in_step(p_stepid integer) OWNER TO postgres;

--
-- Name: classification_option_course(integer); Type: FUNCTION; Schema: spr; Owner: postgres
--

CREATE FUNCTION classification_option_course(p_stepid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: spr.classification_option_course
  DESCRIPTION: Classifica os inscritos no processo seletivo conforme sua opção
  de curso esta FUNÇÃO é executada somente para a ultima etapa do processo.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       12/01/2011 Fabiano Tomasini 1. FUNÇÃO criada.
  1.1       01/07/2011 Alex Smith       1. Adequação de encoding e substitui-
                                           ção do esquema antigo para o novo.
  1.2       08/08/2011 Alex Smith       1. Coding standard.
******************************************************************************/
DECLARE
    v_subscriptionStepInfo record;
    v_subscriptionOptionCourse record;
    v_option record;
    v_step record;
    v_maxPosition integer;
    v_subscriptionConfirmed boolean;
    v_substitutes integer;
BEGIN
    -- Update subscription option seta status inscrito para todos e zera posiçães
    UPDATE spr.subscriptionOption
       SET position = null,
           subscriptionStatusId = 1
     WHERE subscriptionId IN (SELECT subscriptionId
                                FROM spr.subscriptionStepInfo
                               WHERE stepId = p_stepId);

    RAISE NOTICE 'Gerando classificação por opção a partir da etapa %.', p_stepId;

    -- Percorre todos os inscritos na ultima etapa e classifica nos cursos pelo total de pontos
    FOR v_subscriptionStepInfo IN SELECT *
                                    FROM spr.subscriptionStepInfo
                                   WHERE stepid = p_stepId
                                ORDER BY position
    LOOP
        RAISE NOTICE 'Processando inscrição %.', v_subscriptionStepInfo.subscriptionId;

        -- Flag que determina que o inscrito passo nessa opção.
        v_subscriptionConfirmed := FALSE;

        -- Percorre todas as opçães de curso do inscrito ordenada pelo optionnumber
        FOR v_subscriptionOptionCourse IN SELECT *
                                            FROM spr.subscriptionOption A
                                      INNER JOIN spr.option B
                                              ON B.optionId = A.optionId
                                           WHERE subscriptionId = v_subscriptionStepInfo.subscriptionId
                                        ORDER BY optionNumber
        LOOP
            -- se status jé confirmado em outra opção
            IF v_subscriptionConfirmed THEN
                RAISE NOTICE ' Opção % definida como classificado em outra opção.', v_subscriptionOptionCourse.optionId || '-' || v_subscriptionOptionCourse.description;
                -- Status de classificado em outra opção
                UPDATE spr.subscriptionOption
                   SET subscriptionStatusId = 6
                 WHERE optionId = v_subscriptionOptionCourse.optionId
                   AND subscriptionId = v_subscriptionOptionCourse.subscriptionId;
            ELSE
                -- Obtem a posição de valor mais alto até o momento
                SELECT COALESCE(MAX(position), 0) INTO v_maxPosition
                  FROM spr.subscriptionOption
                 WHERE optionId = v_subscriptionOptionCourse.optionId;

                -- número de vagas maior que o valor da ultima posição e status diferente de reprovado e desistente.
                IF v_subscriptionOptionCourse.vacancies > v_maxPosition 
                   AND v_subscriptionStepInfo.subscriptionStatusId != 4  
                   AND v_subscriptionStepInfo.subscriptionStatusId != 5
                   AND v_subscriptionStepInfo.subscriptionStatusId != 1
                   THEN
                    RAISE NOTICE ' Opção % definida como aprovado.', v_subscriptionOptionCourse.optionId || '-' || v_subscriptionOptioncourse.description;
                    -- Aprova o inscrito na opção de curso
                    UPDATE spr.subscriptionOption
                       SET subscriptionStatusId = 2,
                           position = v_maxPosition + 1
                     WHERE optionId = v_subscriptionOptionCourse.optionId
                       AND subscriptionId = v_subscriptionOptionCourse.subscriptionId;

                    -- Flag que determina que o inscrito passou nessa opção.
                    v_subscriptionConfirmed := TRUE;
                ELSE
                    -- Obtem o total de suplentes para a opção mais 1
                    SELECT COALESCE(COUNT(*), 0) + 1 INTO v_substitutes
                      FROM spr.subscriptionOption
                     WHERE optionId = v_subscriptionOptionCourse.optionId
                       AND subscriptionStatusId = 3;

                    --Atribui as informaçães da etapa atual na variável record v_step
                    SELECT * INTO v_step FROM spr.step WHERE stepId = p_stepId;

                    -- Se nao excedeu o numero de suplentes e status diferente de reprovado e desistente.                    
                    IF v_subscriptionStepInfo.subscriptionStatusId != 4 AND v_subscriptionStepInfo.subscriptionStatusId != 5 THEN
                        RAISE NOTICE ' Opção % definida como suplente.', v_subscriptionOptionCourse.optionId || '-' || v_subscriptionOptioncourse.description;
                        -- Suplente
                        UPDATE spr.subscriptionOption
                           SET subscriptionStatusId = 3,
                               position = v_maxPosition + 1
                         WHERE optionId = v_subscriptionOptionCourse.optionId
                           AND subscriptionId = v_subscriptionOptionCourse.subscriptionId;

                    ELSEIF v_subscriptionStepInfo.subscriptionStatusId = 5 THEN
                        -- Desistente
                        UPDATE spr.subscriptionOption
                           SET subscriptionStatusId = 5,
                               position = v_maxPosition + 1
                         WHERE optionId = v_subscriptionOptionCourse.optionId
                           AND subscriptionId = v_subscriptionOptionCourse.subscriptionId;

                    ELSE
                        RAISE NOTICE ' Opção % definida como reprovado.', v_subscriptionOptionCourse.optionId || '-' || v_subscriptionOptioncourse.description;
                        -- Reprovado
                        UPDATE spr.subscriptionOption
                           SET subscriptionStatusId = 4,
                               position = v_maxPosition + 1
                         WHERE optionId = v_subscriptionOptionCourse.optionId
                           AND subscriptionId = v_subscriptionOptionCourse.subscriptionId;
                    END IF;
                END IF;
            END IF;
        END LOOP;
    END LOOP;

    RETURN TRUE;
END;
$$;


ALTER FUNCTION spr.classification_option_course(p_stepid integer) OWNER TO postgres;

--
-- Name: generate_total_points_step(integer); Type: FUNCTION; Schema: spr; Owner: postgres
--

CREATE FUNCTION generate_total_points_step(p_stepid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: spr.GENERATE_TOTAL_POINTS_STEP
  DESCRIPTION: FUNÇÃO responsável por calcular o total de pontos dos inscritos
  na etapa, usada na FUNÇÃO spr.CLASSIFICATION_STEP

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       12/01/2011 Fabiano Tomasini 1. FUNÇÃO criada.
  1.1       01/07/2011 Alex Smith       1. Adequação de encoding e substitui-
                                           ção do esquema antigo para o novo.
  1.2       08/08/2011 Alex Smith       1. Correção para utilização de tipos
                                           de dados corretos na FUNÇÃO ROUND.
                                        2. Adequação da FUNÇÃO aos coding
                                           standards.
  1.3       12/12/2011 Moises Heberle   1. Alteracao de calculo para considerar
                                           tambem o campo spr.step.weight
  1.4       26/12/2011 ftomasini        1. Ajustes calculo pontuação
  1.5       19/04/2013 Jonas Diel       1. Adicionada opção para cálculo de 
                                           notas por soma ou média
******************************************************************************/
DECLARE
    v_step record;
    v_subscriptionStepInfo record;
    v_evaluationPoints record;
    v_totalPoints numeric;
    v_totalWeight numeric;
    v_result numeric;
    v_totalPointsInThePreviousStep numeric;
    v_total_weight_steps numeric;
    v_total_points_step numeric;

BEGIN
    v_totalPoints := 0;
    v_totalWeight := 0;

    --Atribui as informações da etapa na variável record v_step
    SELECT * INTO v_step
      FROM spr.step
     WHERE stepId = p_stepId;

    --Atribui as informações da tabela subscriptionstepinfo na variável v_subscriptionStepInfo
    FOR v_subscriptionStepInfo IN SELECT *
                                    FROM spr.subscriptionStepInfo
                                   WHERE stepId = p_stepId
    LOOP
        RAISE NOTICE 'Processando inscrição %', v_subscriptionStepInfo.subscriptionId;

        v_totalPoints := 0;
        v_totalWeight := 0;
        v_total_points_step := 0;
        v_total_weight_steps  := 0;

        FOR v_evaluationPoints IN SELECT A.totalpoints,
                                         B.weight,
                                         C.weight as weightStep
                                    FROM spr.evaluationpoints A
                              INNER JOIN spr.evaluation B
                                      ON (A.evaluationId = B.evaluationId)
                              INNER JOIN spr.step C
                                      ON (C.stepId = B.stepId)
                                   WHERE A.subscriptionId = v_subscriptionStepInfo.subscriptionId
                                     AND C.stepId = v_subscriptionStepInfo.stepId
                                     AND B.isinternal = v_subscriptionStepInfo.useInternalEvaluations
        LOOP
            --Soma os pesos de todas as avaliações da etapa
            v_totalWeight := v_totalWeight + COALESCE(v_evaluationPoints.weight, 0);

	    IF v_step.calculationMethod = 1 THEN	    
		--Média do total de pontos de todas as avaliações da etapa considerando o peso de cada uma
		v_total_points_step := ROUND( (v_total_points_step + (COALESCE(v_evaluationPoints.totalPoints, 0) * COALESCE(v_evaluationPoints.weight,1)))::numeric, 2);		
		RAISE NOTICE 'Total de pontos + (Total de pontos avaliação(%) * Total peso avaliação(%)) = %', COALESCE(v_evaluationPoints.totalPoints, 0), COALESCE(v_evaluationPoints.weight,1), v_total_points_step;
	    END IF; 
	    IF v_step.calculationMethod = 2 THEN
		--Calcula a soma das avaliações da etapa
		v_total_points_step := ROUND(v_total_points_step + (COALESCE(v_evaluationPoints.totalPoints, 0))::numeric, 2);
		RAISE NOTICE 'Total de pontos + (Total de pontos avaliação(%)) = %', COALESCE(v_evaluationPoints.totalPoints, 0), v_total_points_step;
	    END IF;

        END LOOP;
        RAISE NOTICE 'Total de pontos = %', v_total_points_step;
        
        -- evitar divisão por zero
        IF v_totalWeight = 0 THEN
           v_totalWeight := 1;
        END IF;

	--Se for média
	IF v_step.calculationMethod = 1 THEN
		--Total de pontos dividido pelo total dos pesos das avaliações	
		v_total_points_step := (v_total_points_step / v_totalWeight);
		RAISE NOTICE 'Total de pontos da etapa(%) / Total dos pesos das avaliações(%) = %',v_total_points_step,v_totalWeight,(v_total_points_step / v_totalWeight);
	END IF;

        --Total de pesos de todas etapas do processo seletivo
        v_total_weight_steps := SUM(weight) FROM spr.step WHERE selectiveProcessId = v_step.selectiveprocessid;

        -- evitar divisão por zero
        IF v_total_weight_steps = 0 THEN
           v_total_weight_steps := 1;
        END IF;

	--Se for média
	IF v_step.calculationMethod = 1 THEN
		--Pontuação na etapa multiplicada pelo peso da etapa e dividida pelo total dos pesos das etapas
		v_totalPoints := v_total_points_step  * COALESCE(v_step.weight,1) / v_total_weight_steps;
        END IF;
        --Se for Soma
        IF v_step.calculationMethod = 2 THEN
		v_totalPoints := v_total_points_step;
	END IF;
	
        --Se soma total com o total de pontos da etapa anterior caso accumulateprevioussteps for true
        IF v_step.accumulatePreviousSteps THEN
                SELECT totalPoints
                  INTO v_totalPointsInThePreviousStep
                  FROM spr.subscriptionStepInfo A
            INNER JOIN spr.step B
                    ON (A.stepId = B.stepId)
            INNER JOIN spr.selectiveProcess C
                    ON (B.selectiveProcessId = C.selectiveProcessId)
                 WHERE C.selectiveProcessId = v_step.selectiveProcessid
                   AND B.stepOrder = (v_step.stepOrder - 1)
                   AND A.subscriptionId = v_subscriptionStepInfo.subscriptionId;

            --RAISE NOTICE ' Pontuação da etapa anterior (%) + ((Pontuação total (%) / Soma dos pesos (%)) . Peso da etapa(%) / Soma dos pesos das etapas(%)) = %', COALESCE(v_totalPointsInThePreviousStep, 0), v_totalPoints, v_totalWeight, v_step.weight, v_total_weight_steps, v_result + COALESCE(v_totalPointsInThePreviousStep, 0);

            v_totalPoints := v_totalPoints + COALESCE(v_totalPointsInThePreviousStep, 0);

        ELSE
            --RAISE NOTICE ' Pontuação total da etapa(%) . Peso da etapa(%) / Soma dos pesos das etapas (%) = %', v_total_points_step, v_step.weight, v_total_weight_steps, v_totalPoints;
        END IF;

        RAISE NOTICE '%', v_totalPoints;

        --Atualiza as informações da inscrições na etapa com o total de pontos obtidos na etapa
        UPDATE spr.subscriptionStepInfo
           SET totalPoints = v_totalPoints,
               totalPointsstep = v_total_points_step
         WHERE subscriptionid = v_subscriptionStepInfo.subscriptionId
           AND stepId = p_stepId;

    END LOOP;

    RETURN TRUE;
END;
$$;


ALTER FUNCTION spr.generate_total_points_step(p_stepid integer) OWNER TO postgres;

--
-- Name: set_step_subscriptions_status(integer); Type: FUNCTION; Schema: spr; Owner: postgres
--

CREATE FUNCTION set_step_subscriptions_status(p_stepid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: spr.set_step_subscriptions_status
  DESCRIPTION: FUNÇÃO responsável por setar o status dos inscritos na etapa,
  usada na FUNÇÃO spr.classification_in_step

  REVISIONS:
  Ver       Date       Author             Description
  --------- ---------- -----------------  ------------------------------------
  1.0       12/01/2011 Fabiano Tomasini   1. FUNÇÃO criada.
  1.1       01/06/2011 Fabiano Tomasini   1. Novo critério de desempate por
                                             prioridade de avaliação
  1.2       02/06/2011 Leovan Tavares     1. Pequenos ajustes na verificação
                                             do novo critério de desempate
                                             por prioridade de avaliação
  1.3       08/08/2011 Alex Smith         1. Coding standard.
  1.4       09/08/2011 Fabiano Tomasini   1. Novo critério de desempate
											 por etapa.
******************************************************************************/
DECLARE
    v_select text;
    v_tiebreak record;
    v_orderBy text;
    v_subscriptionStepInfo record;
    v_step record;
    v_statusId integer;
    v_count integer;
    v_countPosition integer;
    v_stepEvaluations record;
    v_selectBestPunctuationInStep text;
    v_selectEvaluation text;
	v_dynamicOrder integer;
BEGIN

    --Atribui as informaçães da etapa na variável record v_step
    SELECT * INTO v_step FROM spr.step WHERE stepId = p_stepId;

    v_selectBestPunctuationInStep :='';
    v_selectEvaluation :='';
    v_dynamicOrder := 8;
    v_count := 1;
    v_countPosition := 1;
    v_orderBy := ' ORDER BY 7 ASC, 4 DESC,';

    --Percorre todos os critérios de desempate da etapa ordenados pela prioridade e concatena na variável v_order_by
    FOR v_tiebreak IN SELECT tiebreakid,
                             steptiebreakid,
                             tiebreakstepid 
                        FROM spr.steptiebreak 
                       WHERE stepId = p_stepId 
                         AND priority IS NOT NULL
                    ORDER BY priority
    LOOP
        --Critério de desempate idade em ordem decrescente
        IF v_tiebreak.tiebreakId = 1 THEN
            v_orderBy := v_orderBy || '5 DESC,';
        END IF;
        --Critério de desempate idade em ordem crescente
        IF v_tiebreak.tiebreakId = 2 THEN
            v_orderBy := v_orderBy || '5 ASC,';
        END IF;
        --Critério de desempate ordem de inscrição (controlada pela flag subscriptionorder da tabela subscription)
        IF v_tiebreak.tiebreakId = 3 THEN
            v_orderBy := v_orderBy || '6 ASC,';
        END IF;
        --Critério de desempate sorteio
        IF v_tiebreak.tiebreakId = 4 THEN
            v_orderBy := v_orderBy || 'RANDOM(),';
        END IF;
        --Critério de desempate por prioridade de provas
        IF  v_tiebreak.tiebreakid = 5 THEN            
			 --Atribui avaliaéoes da etapa na variável v_step_evaluations e percorre elas ordenado pela prioridade
             FOR v_stepEvaluations IN SELECT * 
                                         FROM spr.evaluation 
                                        WHERE stepId = p_stepId
                                          AND priority IS NOT NULL 
                                     ORDER BY priority
             LOOP
                 v_selectEvaluation:= v_selectEvaluation || ',(SELECT AA.totalpoints
                                                                 FROM spr.evaluationpoints AA
                                                           INNER JOIN spr.evaluation BB
                                                                   ON (AA.evaluationId = BB.evaluationId)
                                                           INNER JOIN spr.step CC
                                                                   ON (CC.stepId = BB.stepId)
                                                                WHERE AA.subscriptionid = A.subscriptionid
                                                                  AND BB.evaluationId = '''||v_stepEvaluations.evaluationid||'''
                                                                  AND CC.stepId = ''' || p_stepId || ''') as evaluation_' ||v_dynamicOrder;

                 v_orderBy:= v_orderBy || v_dynamicOrder || ' DESC,';
                 v_dynamicOrder:= v_dynamicOrder + 1;

             END LOOP;
        END IF;
        --Critério de desempate por etapa
        IF v_tiebreak.tiebreakid = 6 THEN
            v_selectBestPunctuationInStep:= v_selectBestPunctuationInStep || ',(SELECT AA.totalpoints
                                                                                  FROM spr.subscriptionstepinfo AA
                                                                            INNER JOIN spr.subscription BB
                                                                                    ON (AA.subscriptionId = BB.subscriptionId)
                                                                                 WHERE AA.subscriptionid = A.subscriptionid
                                                                                   AND AA.stepId = ''' || v_tiebreak.tiebreakstepid || ''') AS stepPoints_' ||v_dynamicOrder;
            v_orderBy:= v_orderBy || v_dynamicOrder || ' DESC,';
            v_dynamicOrder:= v_dynamicOrder + 1;
        END IF;
    END LOOP;

    v_orderBy := substr( v_orderBy, 1, length(v_orderBy)-1);

    v_select := 'SELECT A.subscriptionId,
                        A.stepId,
                        A.subscriptionStatusId,
                        A.totalPoints,
                        (extract(YEAR from current_date) - extract(YEAR FROM E.datebirth))::integer AS age,
                        D.subscriptionorder,
                        CASE WHEN (NOT spr.CHECK_IF_EVALUATIONS_OF_SUBSCRIPTION_RECEIVED_MINPOINTS(A.subscriptionId,A.stepId))
                                  OR (C.minPoints > A.totalPoints)
                            THEN 4
                            ELSE -1
                        END AS initialStatus
                        --Avaliaçães caso tenha
                        '||v_selectEvaluation||'
                        '||v_selectBestPunctuationInStep||'
                  FROM spr.subscriptionStepInfo A
            INNER JOIN spr.step C
                    ON (C.stepId = A.stepId)
            INNER JOIN spr.subscription D
                    ON (D.subscriptionId = A.subscriptionId)
       INNER JOIN ONLY basphysicalPerson E
                    ON (E.personId = D.personId)
                 WHERE A.stepId = ''' || p_stepId || ''''||v_orderBy ;

    -- Percorre todas inscrições e seta o status conforme número de vagas, pontos mínimos da etapa e das avaliaçães.
    FOR v_subscriptionStepInfo IN EXECUTE v_select
    LOOP
        -- Reprova o inscrito caso ele tenha obtido uma nota menor que a nota mínima em uma das avaliaçães
        IF( v_subscriptionStepInfo.initialStatus != -1 )
        THEN
            -- statusid 4 = REPROVADO
            v_statusId := v_subscriptionStepInfo.initialStatus;

        ELSE
            -- Aprova os primeiros da lista conforme o número de vagas. Se a quantidade de vagas é NULL,
            -- significa que não hé limite de vagas, ou seja, todos podem ser aprovados.
            IF( COALESCE(v_step.vacancies, v_count) >= v_count )
            THEN

                -- statusid 2 = APROVADO
                v_statusId := 2;
                v_count := v_count+1;
            -- Suplentes
            ELSE
                -- statusid 3 = SUPLENTE
                v_statusId := 3;
            END IF;
        END IF;

        RAISE NOTICE 'Inscrição %: setando status para % e colocação para %', v_subscriptionStepInfo.subscriptionId, v_statusId, v_countPosition;

        -- Atualiza as informaçães da inscrição
        UPDATE spr.subscriptionStepInfo
           SET subscriptionStatusId = v_statusId,
               position = v_countPosition
         WHERE subscriptionid = v_subscriptionStepInfo.subscriptionId
           AND stepId = p_stepId;

        -- Incrementa a posição
        v_countPosition := v_countPosition + 1;
    END LOOP;

    RETURN TRUE;
END;
$$;


ALTER FUNCTION spr.set_step_subscriptions_status(p_stepid integer) OWNER TO postgres;

--
-- Name: set_subcription_final_status(integer); Type: FUNCTION; Schema: spr; Owner: postgres
--

CREATE FUNCTION set_subcription_final_status(p_step_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: SET_SUBCRIPTION_FINAL_STATUS
  DESCRIPTION: Se for a ultima etapa, classifica a pessoa no processo seletivo
  conforme o status. Return true se atualizou inscritos e false se não atualizou

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       12/01/2011 Fabiano Tomasini 1. Função criada.
  1.1       01/07/2011 Alex Smith       1. Adequação de encoding e substitui-
                                           ção do esquema antigo para o novo.
******************************************************************************/
DECLARE
v_select text;
v_step record;
v_last_step record;
v_classification_generated boolean;
v_result boolean;

BEGIN
    --Atribui as informações da etapa atual na variável record v_step
    SELECT * INTO v_step FROM spr.step WHERE stepId = p_step_id;
    --Obtem o step order da ultima etapa do processo seletivo
    SELECT max(steporder)as steporder INTO v_last_step FROM spr.step B WHERE B.selectiveprocessId = v_step.selectiveprocessid;

    --Result default false
    v_result:= FALSE;

    --Verifica se a etapa informada é a ultima etapa
    IF ( v_step.steporder = v_last_step.steporder )
    THEN
        --Verifica se todos os inscritos na etapa estão com status diferente de inscrito.
        SELECT * INTO v_classification_generated FROM spr.CHECK_IF_CLASSIFICATION_WAS_GENERATED_IN_STEP(p_step_id);
        IF ( v_classification_generated = TRUE )
        THEN
            --Classifica os aprovados na ultima etapa em suas opções de curso
            PERFORM * FROM spr.CLASSIFICATION_OPTION_COURSE(v_step.stepId);
            --Result true, atualizo o status das inscrições
            v_result:= TRUE;
        END IF;
    END IF;
    RETURN v_result;
END;

$$;


ALTER FUNCTION spr.set_subcription_final_status(p_step_id integer) OWNER TO postgres;

--
-- Name: set_subscription_final_status(integer); Type: FUNCTION; Schema: spr; Owner: postgres
--

CREATE FUNCTION set_subscription_final_status(p_stepid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/******************************************************************************
  NAME: set_subscription_final_status
  DESCRIPTION: Se for a ultima etapa, classifica a pessoa no processo seletivo
  conforme o status. Return true se atualizou inscritos e false se não atualizou

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       12/01/2011 Fabiano Tomasini 1. Função criada.
  1.1       01/07/2011 Alex Smith       1. Adequação de encoding e substitui-
                                           ção do esquema antigo para o novo.
  1.2       08/08/2011 Alex Smith       1. Coding standards
******************************************************************************/
DECLARE
    v_select text;
    v_step record;
    v_lastStep record;
    v_classificationGenerated boolean;
    v_result boolean;
BEGIN
    --Atribui as informações da etapa atual na variável record v_step
    SELECT * INTO v_step FROM spr.step WHERE stepId = p_stepId;

    --Obtem o step order da ultima etapa do processo seletivo
    SELECT MAX(stepOrder) AS stepOrder
      INTO v_lastStep
      FROM spr.step B
     WHERE B.selectiveprocessId = v_step.selectiveProcessId;

    --Result default false
    v_result := FALSE;

    --Verifica se a etapa informada é a ultima etapa
    IF v_step.stepOrder != v_lastStep.stepOrder THEN
        RAISE NOTICE 'A etapa % não é uma etapa final, portanto não será gerada a classificação final.', p_stepId;
    ELSE
        --Verifica se todos os inscritos na etapa estão com status diferente de inscrito.
        SELECT * INTO v_classificationGenerated
          FROM spr.check_if_classification_was_generated_in_step(p_stepId);

        IF NOT v_classificationGenerated THEN
            RAISE NOTICE 'Classificação final não executada, pois não foi feita a classificação da etapa %.', p_stepId;
        ELSE
            RAISE NOTICE 'Gerando classificação final';
            --Classifica os aprovados na ultima etapa em suas opções de curso
            PERFORM * FROM spr.classification_option_course(v_step.stepId);
            --Result true, atualizo o status das inscrições
            v_result := TRUE;
        END IF;
    END IF;

    RETURN v_result;
END;
$$;


ALTER FUNCTION spr.set_subscription_final_status(p_stepid integer) OWNER TO postgres;

SET search_path = tra, pg_catalog;

--
-- Name: chk_unit_area(integer, integer, integer, date, date); Type: FUNCTION; Schema: tra; Owner: postgres
--

CREATE FUNCTION chk_unit_area(p_unitareaid integer, p_unitid integer, p_areaid integer, p_begindate date, p_enddate date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: chk_unit_area
  PURPOSE: Não deixar inserir várias vezes a mesma área para a mesma unidade no mesmo
  período de vigência.
           .
  DESCRIPTION:

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       30/03/2011 Fabiano Tomasini 1. Função criada.
**************************************************************************************/
DECLARE
    v_count integer;

BEGIN
    v_count:=0;

        SELECT COUNT(*) INTO v_count
          FROM tra.UnitArea A
         WHERE A.unitId = p_unitId
           AND A.areaId = p_areaId
           AND ((A.endDate IS NULL)
            OR (p_beginDate BETWEEN A.beginDate AND A.endDate)
            OR (p_endDate BETWEEN A.beginDate AND A.endDate))
           AND A.unitareaId != p_unitAreaId;

    IF ( v_count != 0 )
    THEN
	RAISE Exception 'Já existe a mesma área com período vigente para esta unidade.';
    END IF;

    RETURN (v_count = 0);

END;
$$;


ALTER FUNCTION tra.chk_unit_area(p_unitareaid integer, p_unitid integer, p_areaid integer, p_begindate date, p_enddate date) OWNER TO postgres;

--
-- Name: fn_chk_date_conflict(integer, date, date); Type: FUNCTION; Schema: tra; Owner: postgres
--

CREATE FUNCTION fn_chk_date_conflict(p_subscriptionid integer, p_begindate date, p_enddate date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: fn_chk_date_conflict
  DESCRIPTION: Verifica se as datas estao se sobrepondo na alocacao de inscricoes em equipes.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       13/07/2011 Moises Heberle    1. Funcao criada
**************************************************************************************/
DECLARE
    v_hasconflict boolean;
BEGIN
    SELECT COUNT(*) > 0 INTO v_hasconflict
      FROM tra.subscriptionTeam
     WHERE subscriptionId = p_subscriptionId
        AND ((beginDate BETWEEN p_beginDate AND p_endDate)
           OR (endDate BETWEEN p_beginDate AND p_endDate));

    RETURN v_hasconflict;
END;
$$;


ALTER FUNCTION tra.fn_chk_date_conflict(p_subscriptionid integer, p_begindate date, p_enddate date) OWNER TO postgres;

--
-- Name: fn_chk_has_preceptor_substitution(integer, integer, integer, date, date); Type: FUNCTION; Schema: tra; Owner: postgres
--

CREATE FUNCTION fn_chk_has_preceptor_substitution(p_preceptorsubstitutionid integer, p_teamid integer, p_personid integer, p_begindate date, p_enddate date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: fn_chk_has_preceptor_substitution
  PURPOSE: Verifica se a equipe já não tem um preceptor substituto para esse período de tempo.
  DESCRIPTION: Verifica se a equipe já não tem um preceptor substituto para esse período de tempo.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       20/06/2011 Arthur Lehdermann 1. Função criada.
**************************************************************************************/
DECLARE
    v_valid boolean;
BEGIN
    SELECT COUNT(*) > 0 INTO v_valid
      FROM tra.preceptorSubstitution
     WHERE (p_preceptorSubstitutionId IS NULL OR preceptorSubstitutionId != p_preceptorSubstitutionId)
       AND teamId = p_teamId
            -- Caso haja uma substituição sem data de fim, e:
            -- "p_endDate" seja nulo ou se
            -- "p_endDate" seja após a data de início.
       AND ((endDate IS NULL AND (p_endDate IS NULL OR
                                  p_endDate > beginDate)) OR
            -- Caso "p_endDate" seja nulo e "p_beginDate" for menor que a data de fim ou
            -- "p_endDate" esteja entre a data de início ou de de fim ou
            -- "p_beginDate" esteja entre a data de início ou de de fim.
            ((p_endDate IS NULL AND p_beginDate < endDate) OR
             (p_beginDate BETWEEN beginDate AND endDate) OR
             (p_endDate BETWEEN beginDate AND endDate) OR
             (p_beginDate < beginDate AND p_endDate > endDate)));

    RETURN v_valid;

END;
$$;


ALTER FUNCTION tra.fn_chk_has_preceptor_substitution(p_preceptorsubstitutionid integer, p_teamid integer, p_personid integer, p_begindate date, p_enddate date) OWNER TO postgres;

--
-- Name: fn_chk_minimum_interval_to_new_request_to_training_type(integer, integer, integer, date, date); Type: FUNCTION; Schema: tra; Owner: postgres
--

CREATE FUNCTION fn_chk_minimum_interval_to_new_request_to_training_type(p_requestid integer, p_personid integer, p_trainingtypeid integer, p_begindate date, p_enddate date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: tra.fn_chk_minimum_interval_to_new_request_to_training_type
  PURPOSE:Função que verifica se a pessoa ja cursou um estágio na instituição e está obedecendo o período de carência para solicitar um novo
  estágio na mesma modalidade.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       01/07/2011 Fabiano Tomasini 1. Função criada.
**************************************************************************************/
DECLARE
    v_valid boolean;
    v_request_id integer;
BEGIN

    SELECT requestid FROM tra.request INTO v_request_id WHERE requestid = p_requestid;

    SELECT COUNT(*) = 0
      FROM tra.requestCurrentData A
      INTO v_valid
INNER JOIN tra.trainingType B
        ON (A.trainingTypeId = B.trainingTypeId)
     WHERE A.status != 'D' --desistente
       AND personId = p_personId
       AND A.trainingtypeid = p_trainingtypeid
       AND p_begindate::date < A.endDate::date + B.minimumInterval
       AND B.minimumInterval IS NOT NULL
       AND (v_request_id IS NULL OR A.requestId != v_request_id);

    RETURN v_valid;

END;
$$;


ALTER FUNCTION tra.fn_chk_minimum_interval_to_new_request_to_training_type(p_requestid integer, p_personid integer, p_trainingtypeid integer, p_begindate date, p_enddate date) OWNER TO postgres;

--
-- Name: fn_chk_minimum_interval_to_new_request_to_training_type(integer, integer, bigint, integer, date, date); Type: FUNCTION; Schema: tra; Owner: postgres
--

CREATE FUNCTION fn_chk_minimum_interval_to_new_request_to_training_type(p_unitareaid integer, p_requestid integer, p_personid bigint, p_trainingtypeid integer, p_begindate date, p_enddate date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: tra.fn_chk_minimum_interval_to_new_request_to_training_type
  PURPOSE:FUNÇÃO que verifica se a pessoa ja cursou um estégio na instituição e esté obedecendo o peréodo de caréncia para solicitar um novo
  estégio na mesma modalidade.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       01/07/2011 Fabiano Tomasini 1. FUNÇÃO criada.
**************************************************************************************/
DECLARE
    v_valid boolean;
    v_request_id integer;
BEGIN

    SELECT requestid FROM tra.request INTO v_request_id WHERE requestid = p_requestid;

    SELECT COUNT(*) = 0
      FROM tra.requestCurrentData A
      INTO v_valid
INNER JOIN tra.trainingType B
        ON (A.trainingTypeId = B.trainingTypeId)
     WHERE A.status != 'D' --desistente
       AND A.status != 'N' --não autorizado
       AND personId = p_personId
       AND A.trainingtypeid = p_trainingtypeid
       AND p_begindate::date < A.endDate::date + B.minimumInterval
       AND B.minimumInterval IS NOT NULL
       AND B.minimumInterval !=0
       AND (v_request_id IS NULL OR A.requestId != v_request_id)
       AND unitAreaId = p_unitAreaId;

    RETURN v_valid;

END;
$$;


ALTER FUNCTION tra.fn_chk_minimum_interval_to_new_request_to_training_type(p_unitareaid integer, p_requestid integer, p_personid bigint, p_trainingtypeid integer, p_begindate date, p_enddate date) OWNER TO postgres;

--
-- Name: fn_chk_preceptor_substitution(bigint, integer, bigint, date, date); Type: FUNCTION; Schema: tra; Owner: postgres
--

CREATE FUNCTION fn_chk_preceptor_substitution(p_preceptorsubstitutionid bigint, p_teamid integer, p_personid bigint, p_begindate date, p_enddate date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: fn_chk_preceptor_substitution
  PURPOSE: Verifica:
  - Se as datas são vélidas (endDate deve ser maior ou igual a beginDate(ou nula)).
  DESCRIPTION: Verifica se tem as datas são vélidas (endDate deve ser maior ou igual a beginDate(ou nula)).

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       20/06/2011 Arthur Lehdermann 1. FUNÇÃO criada.
**************************************************************************************/
DECLARE
    v_valid boolean;
BEGIN
    -- Verifica a data de fim
    SELECT p_beginDate <= p_endDate INTO v_valid;

    IF ( v_valid IS TRUE )
    THEN
        -- Verifica se jé existe um preceptor substituto para a equipe nessa data
        SELECT tra.fn_chk_has_preceptor_substitution(p_preceptorSubstitutionId,
                                                     p_teamId,
                                                     p_personId,
                                                     p_beginDate,
                                                     p_endDate) IS FALSE INTO v_valid;
    END IF;

    IF ( v_valid IS TRUE )
    THEN
        -- Verifica seo preceptor substituto jé esté em alguma equipe nessa data
        SELECT tra.fn_chk_preceptor_substitution_has_team(p_preceptorSubstitutionId,
                                                          p_teamId,
                                                          p_personId,
                                                          p_beginDate,
                                                          p_endDate) IS FALSE INTO v_valid;
    END IF;

    RETURN v_valid;

END;
$$;


ALTER FUNCTION tra.fn_chk_preceptor_substitution(p_preceptorsubstitutionid bigint, p_teamid integer, p_personid bigint, p_begindate date, p_enddate date) OWNER TO postgres;

--
-- Name: fn_chk_preceptor_substitution_has_team(integer, integer, integer, date, date); Type: FUNCTION; Schema: tra; Owner: postgres
--

CREATE FUNCTION fn_chk_preceptor_substitution_has_team(p_preceptorsubstitutionid integer, p_teamid integer, p_personid integer, p_begindate date, p_enddate date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: fn_chk_preceptor_substitution_has_team
  PURPOSE: Verifica se o preceptor substituto já não está em alguma equipe para para esse período de tempo.
  DESCRIPTION: Verifica se o preceptor substituto já não está em alguma equipe para para esse período de tempo.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       20/06/2011 Arthur Lehdermann 1. Função criada.
**************************************************************************************/
DECLARE
    v_valid boolean;
BEGIN
    SELECT COUNT(*) > 0 INTO v_valid
      FROM tra.preceptorSubstitution
     WHERE (p_preceptorSubstitutionId IS NULL OR preceptorSubstitutionId != p_preceptorSubstitutionId)
       AND personId = p_personId
            -- Caso haja uma substituição sem data de fim, e:
            -- "p_endDate" seja nulo ou se
            -- "p_endDate" seja após a data de início.
       AND ((endDate IS NULL AND (p_endDate IS NULL OR
                                  p_endDate > beginDate)) OR
            -- Caso "p_endDate" seja nulo e "p_beginDate" for menor que a data de fim ou
            -- "p_endDate" esteja entre a data de início ou de de fim ou
            -- "p_beginDate" esteja entre a data de início ou de de fim.
            ((p_endDate IS NULL AND p_beginDate < endDate) OR
             (p_beginDate BETWEEN beginDate AND endDate) OR
             (p_endDate BETWEEN beginDate AND endDate) OR
             (p_beginDate < beginDate AND p_endDate > endDate)));

    RETURN v_valid;

END;
$$;


ALTER FUNCTION tra.fn_chk_preceptor_substitution_has_team(p_preceptorsubstitutionid integer, p_teamid integer, p_personid integer, p_begindate date, p_enddate date) OWNER TO postgres;

--
-- Name: fn_chk_training_request_start(integer, integer, date); Type: FUNCTION; Schema: tra; Owner: postgres
--

CREATE FUNCTION fn_chk_training_request_start(p_unitareaid integer, p_trainingtypeid integer, p_begindate date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: fn_chk_training_request_start
  PURPOSE:FUNÇÃO que verifica se a solicitação esta sendo feita dentro do intervalo mínimo e méximo de solicitação.

  OBS: Parametro trainingTypeId esté DEPRECATED, mantido para compatibilidade.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       30/06/2011 Fabiano Tomasini  1. FUNÇÃO criada.
  1.1       28/07/2011 Arthur Lehdermann 2. Corrigido verificação de dias mínimos e méximo.
  1.2       12/08/2011 Moises Heberle    3. Alterando de areaId para unitAreaId
  1.3       10/10/2011 Moises Heberle    4. Alterando chamada de tabela tra.trainingTypeArea
                                             para tra.unit (campos movidos)
**************************************************************************************/
DECLARE
    v_valid BOOLEAN;
    v_rules RECORD;

BEGIN
    v_valid:= TRUE;

        SELECT (COUNT(*) > 0) AS existingRule,
               U.maximumDaysUntilTrainingStart,
               U.minimumDaysUntilTrainingStart
          INTO v_rules
          FROM tra.unitArea UA
    INNER JOIN tra.unit U
            ON U.unitId = UA.unitId
         WHERE UA.unitAreaId = p_unitAreaId
      GROUP BY 2,3;

    IF ( v_rules.existingRule IS TRUE )
    AND ( v_rules.minimumDaysUntilTrainingStart <> 0 )
    AND ( v_rules.maximumDaysUntilTrainingStart <> 0 )
    THEN
        SELECT (p_begindate::date >= NOW()::date + v_rules.minimumDaysUntilTrainingStart
           AND p_begindate::date <= NOW()::date + v_rules.maximumDaysUntilTrainingStart )
          INTO v_valid;
    END IF;

    RETURN v_valid;

END;
$$;


ALTER FUNCTION tra.fn_chk_training_request_start(p_unitareaid integer, p_trainingtypeid integer, p_begindate date) OWNER TO postgres;

--
-- Name: getrequeststatus(integer); Type: FUNCTION; Schema: tra; Owner: postgres
--

CREATE FUNCTION getrequeststatus(p_requestid integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
/*************************************************************************************
  NAME: getRequestStatus
  PURPOSE: Retorna o status de uma solicitação de estágio.

  DESCRIPTION:
  Retorna o status de uma solicitação de estágio.

  REVISIONS:
  Ver       Date       Author            Description
  --------- ---------- ----------------- ------------------------------------
  1.0       11/05/2011 Arthur Lehdermann 1. FUNÇÃO criada.
  1.1       13/07/2011 Fabiano Tomasini  1.1 Adicionado status desistente para quando
                                         solicitante desiste da solicitação.
**************************************************************************************/
DECLARE
    v_status RECORD;
    v_request_status VARCHAR;

BEGIN
    v_request_status := '';

    SELECT INTO v_status
                COUNT(C.subscriptionTeamId) AS subscriptionTeamData,
                B.status AS subscriptionStatus,
                A.status AS requestStatus
           FROM tra.request A
      LEFT JOIN tra.subscription B
             ON A.requestId = B.requestId
      LEFT JOIN tra.subscriptionTeam C
             ON B.subscriptionId = C.subscriptionId
          WHERE A.requestId = p_requestId
       GROUP BY 2,3;

    IF v_status.subscriptionTeamData > 0
    THEN
        v_request_status := 'ENTURMADO';
    ELSIF v_status.subscriptionStatus = 'P'
    THEN
        v_request_status := 'EM ANÁLISE';
    ELSIF v_status.subscriptionStatus = 'A'
    THEN
        v_request_status := 'INSCRITO';
    ELSIF v_status.subscriptionStatus = 'N'
    THEN
        v_request_status := 'NÃO ACEITO';
    ELSIF v_status.subscriptionStatus = 'D'
    THEN
        v_request_status := 'DESISTENTE';
    ELSIF v_status.requestStatus = 'D'
    THEN
        v_request_status := 'DESISTENTE';
    ELSIF v_status.requestStatus = 'P'
    THEN
        v_request_status := 'SOLICITADO';
    ELSIF v_status.requestStatus = 'A'
    THEN
        v_request_status := 'EM ANÁLISE';
    ELSIF v_status.requestStatus = 'N'
    THEN
        v_request_status := 'NÃO ACEITO';
    ELSE
        v_request_status := '-';
    END IF;

    RETURN v_request_status;

END;
$$;


ALTER FUNCTION tra.getrequeststatus(p_requestid integer) OWNER TO postgres;

SET search_path = public, pg_catalog;

--
-- Name: array_agg(anyelement); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE array_agg(anyelement) (
    SFUNC = array_append,
    STYPE = anyarray,
    INITCOND = '{}'
);


ALTER AGGREGATE public.array_agg(anyelement) OWNER TO postgres;

--
-- Name: concat(text); Type: AGGREGATE; Schema: public; Owner: postgres
--

CREATE AGGREGATE concat(text) (
    SFUNC = txtcatspc,
    STYPE = text,
    INITCOND = ''
);


ALTER AGGREGATE public.concat(text) OWNER TO postgres;

SET search_path = bas, pg_catalog;

--
-- Name: task; Type: TABLE; Schema: bas; Owner: postgres; Tablespace: 
--

CREATE TABLE task (
    taskid integer NOT NULL,
    taskstatusid integer NOT NULL,
    details text,
    creationdate timestamp without time zone NOT NULL,
    creatoriduser integer,
    assignedto integer,
    taskconfigid integer NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE bas.task OWNER TO postgres;

--
-- Name: TABLE task; Type: COMMENT; Schema: bas; Owner: postgres
--

COMMENT ON TABLE task IS 'Pendências';


--
-- Name: COLUMN task.taskid; Type: COMMENT; Schema: bas; Owner: postgres
--

COMMENT ON COLUMN task.taskid IS 'Código da pendência.';


--
-- Name: COLUMN task.taskstatusid; Type: COMMENT; Schema: bas; Owner: postgres
--

COMMENT ON COLUMN task.taskstatusid IS 'Código do status da pendência.';


--
-- Name: COLUMN task.details; Type: COMMENT; Schema: bas; Owner: postgres
--

COMMENT ON COLUMN task.details IS 'Detalhes da pendência';


--
-- Name: COLUMN task.creationdate; Type: COMMENT; Schema: bas; Owner: postgres
--

COMMENT ON COLUMN task.creationdate IS 'Data de criação';


--
-- Name: bastask_taskid_seq; Type: SEQUENCE; Schema: bas; Owner: postgres
--

CREATE SEQUENCE bastask_taskid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE bas.bastask_taskid_seq OWNER TO postgres;

--
-- Name: bastask_taskid_seq; Type: SEQUENCE OWNED BY; Schema: bas; Owner: postgres
--

ALTER SEQUENCE bastask_taskid_seq OWNED BY task.taskid;


--
-- Name: systemtask; Type: TABLE; Schema: bas; Owner: postgres; Tablespace: 
--

CREATE TABLE systemtask (
    systemtaskid integer NOT NULL,
    taskconfigid integer NOT NULL,
    modulename character varying(60) NOT NULL,
    description character varying(255) NOT NULL,
    notificationinterval integer NOT NULL,
    enabled boolean NOT NULL,
    notificationmethod character(1) NOT NULL,
    callmethod character varying(255) NOT NULL,
    emailid integer,
    lastrun timestamp without time zone,
    observation text
)
INHERITS (public.baslog);


ALTER TABLE bas.systemtask OWNER TO postgres;

--
-- Name: COLUMN systemtask.callmethod; Type: COMMENT; Schema: bas; Owner: postgres
--

COMMENT ON COLUMN systemtask.callmethod IS 'Nome da classe e método que será chamado quando esta tarefa de sistema for executada. Sempre estará no formato className::method (sem os parênteses)';


--
-- Name: systemtask_systemtaskid_seq; Type: SEQUENCE; Schema: bas; Owner: postgres
--

CREATE SEQUENCE systemtask_systemtaskid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE bas.systemtask_systemtaskid_seq OWNER TO postgres;

--
-- Name: systemtask_systemtaskid_seq; Type: SEQUENCE OWNED BY; Schema: bas; Owner: postgres
--

ALTER SEQUENCE systemtask_systemtaskid_seq OWNED BY systemtask.systemtaskid;


--
-- Name: taskconfig_taskconfigid_seq; Type: SEQUENCE; Schema: bas; Owner: postgres
--

CREATE SEQUENCE taskconfig_taskconfigid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE bas.taskconfig_taskconfigid_seq OWNER TO postgres;

--
-- Name: taskconfig; Type: TABLE; Schema: bas; Owner: postgres; Tablespace: 
--

CREATE TABLE taskconfig (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    taskconfigid integer DEFAULT nextval('taskconfig_taskconfigid_seq'::regclass) NOT NULL,
    iduser integer,
    idgroup integer,
    description character varying(255) NOT NULL,
    visibleonlytoassigned boolean DEFAULT false NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE bas.taskconfig OWNER TO postgres;

--
-- Name: taskconfiggroup; Type: TABLE; Schema: bas; Owner: postgres; Tablespace: 
--

CREATE TABLE taskconfiggroup (
    taskconfiggroupid integer NOT NULL,
    taskconfigid integer NOT NULL,
    idgroup integer NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE bas.taskconfiggroup OWNER TO postgres;

--
-- Name: taskconfiggroup_taskconfiggroupid_seq; Type: SEQUENCE; Schema: bas; Owner: postgres
--

CREATE SEQUENCE taskconfiggroup_taskconfiggroupid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE bas.taskconfiggroup_taskconfiggroupid_seq OWNER TO postgres;

--
-- Name: taskconfiggroup_taskconfiggroupid_seq; Type: SEQUENCE OWNED BY; Schema: bas; Owner: postgres
--

ALTER SEQUENCE taskconfiggroup_taskconfiggroupid_seq OWNED BY taskconfiggroup.taskconfiggroupid;


SET search_path = fin, pg_catalog;

--
-- Name: bankmovement; Type: TABLE; Schema: fin; Owner: postgres; Tablespace: 
--

CREATE TABLE bankmovement (
    bankmovementid integer NOT NULL,
    invoiceid integer,
    ournumber character varying NOT NULL,
    value double precision NOT NULL,
    valuepaid double precision NOT NULL,
    branch character varying(30) NOT NULL,
    branchnumber character varying(30) NOT NULL,
    wallet character varying(3) NOT NULL,
    occurrencedate date NOT NULL,
    fileid integer,
    filediscount double precision DEFAULT 0 NOT NULL,
    sagudiscount double precision DEFAULT 0 NOT NULL,
    fileinterestfine double precision DEFAULT 0 NOT NULL,
    saguinterestfine double precision DEFAULT 0 NOT NULL,
    balance double precision,
    balancewithpolicies double precision,
    creditdate date,
    filematuritydate date,
    sagumaturitydate date,
    fileline text,
    otherdiscounts double precision DEFAULT 0 NOT NULL,
    otheradditions double precision DEFAULT 0 NOT NULL,
    expenditure double precision DEFAULT 0 NOT NULL,
    bankid character varying(3) NOT NULL,
    bankmovementstatusid integer NOT NULL,
    occurrence character varying
)
INHERITS (public.baslog);


ALTER TABLE fin.bankmovement OWNER TO postgres;

--
-- Name: TABLE bankmovement; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON TABLE bankmovement IS 'Armazena o log dos arquivos de retorno.';


--
-- Name: COLUMN bankmovement.bankmovementid; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN bankmovement.bankmovementid IS 'Codigo identificador da tabela.';


--
-- Name: COLUMN bankmovement.invoiceid; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN bankmovement.invoiceid IS 'Codigo identificador do titulo.';


--
-- Name: COLUMN bankmovement.ournumber; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN bankmovement.ournumber IS 'Nosso numero.';


--
-- Name: COLUMN bankmovement.value; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN bankmovement.value IS 'Valor nominal do título.';


--
-- Name: COLUMN bankmovement.valuepaid; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN bankmovement.valuepaid IS 'Valor pago.';


--
-- Name: COLUMN bankmovement.branch; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN bankmovement.branch IS 'Agencia mantenedora da conta.';


--
-- Name: COLUMN bankmovement.branchnumber; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN bankmovement.branchnumber IS 'Numero da conta corrente da empresa.';


--
-- Name: COLUMN bankmovement.wallet; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN bankmovement.wallet IS 'Numero da carteira.';


--
-- Name: COLUMN bankmovement.occurrencedate; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN bankmovement.occurrencedate IS 'Data do pagamento.';


--
-- Name: COLUMN bankmovement.fileid; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN bankmovement.fileid IS 'Codigo do arquivo.';


--
-- Name: COLUMN bankmovement.filediscount; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN bankmovement.filediscount IS 'Valor de desconto obtido do arquivo.';


--
-- Name: COLUMN bankmovement.sagudiscount; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN bankmovement.sagudiscount IS 'Valor de desconto calculado pelo Sagu.';


--
-- Name: COLUMN bankmovement.fileinterestfine; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN bankmovement.fileinterestfine IS 'Valor de juros/multa obtido do arquivo.';


--
-- Name: COLUMN bankmovement.saguinterestfine; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN bankmovement.saguinterestfine IS 'Valor de juros/multa calculado pelo Sagu.';


--
-- Name: COLUMN bankmovement.balance; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN bankmovement.balance IS 'Saldo do titulo no momento do processamento.';


--
-- Name: COLUMN bankmovement.balancewithpolicies; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN bankmovement.balancewithpolicies IS 'Saldo do título com políticas aplicadas na data dos lançamentos do arquivo.';


--
-- Name: COLUMN bankmovement.creditdate; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN bankmovement.creditdate IS 'Data do crédito do pagamento no banco.';


--
-- Name: COLUMN bankmovement.filematuritydate; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN bankmovement.filematuritydate IS 'Data de vencimento do título no arquivo.';


--
-- Name: COLUMN bankmovement.sagumaturitydate; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN bankmovement.sagumaturitydate IS 'Data de vencimento do título no Sagu no momento do processamento do arquivo.';


--
-- Name: COLUMN bankmovement.fileline; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN bankmovement.fileline IS 'Linha completa do arquivo referente ao título.';


--
-- Name: COLUMN bankmovement.otherdiscounts; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN bankmovement.otherdiscounts IS 'Outros descontos concedidos pelo banco.';


--
-- Name: COLUMN bankmovement.otheradditions; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN bankmovement.otheradditions IS 'Outros acréscimos aplicados pelo banco.';


--
-- Name: COLUMN bankmovement.expenditure; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN bankmovement.expenditure IS 'Taxa de serviço cobrada pelo banco.';


--
-- Name: COLUMN bankmovement.bankid; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN bankmovement.bankid IS 'Código do banco.';


--
-- Name: bankmovement_bankmovementid_seq; Type: SEQUENCE; Schema: fin; Owner: postgres
--

CREATE SEQUENCE bankmovement_bankmovementid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fin.bankmovement_bankmovementid_seq OWNER TO postgres;

--
-- Name: bankmovement_bankmovementid_seq; Type: SEQUENCE OWNED BY; Schema: fin; Owner: postgres
--

ALTER SEQUENCE bankmovement_bankmovementid_seq OWNED BY bankmovement.bankmovementid;


--
-- Name: bankmovementstatus; Type: TABLE; Schema: fin; Owner: postgres; Tablespace: 
--

CREATE TABLE bankmovementstatus (
    bankmovementstatusid integer NOT NULL,
    description text NOT NULL
);


ALTER TABLE fin.bankmovementstatus OWNER TO postgres;

--
-- Name: bankmovementstatus_bankmovementstatusid_seq; Type: SEQUENCE; Schema: fin; Owner: postgres
--

CREATE SEQUENCE bankmovementstatus_bankmovementstatusid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fin.bankmovementstatus_bankmovementstatusid_seq OWNER TO postgres;

--
-- Name: bankmovementstatus_bankmovementstatusid_seq; Type: SEQUENCE OWNED BY; Schema: fin; Owner: postgres
--

ALTER SEQUENCE bankmovementstatus_bankmovementstatusid_seq OWNED BY bankmovementstatus.bankmovementstatusid;


--
-- Name: filelog; Type: TABLE; Schema: fin; Owner: postgres; Tablespace: 
--

CREATE TABLE filelog (
    filelogid integer NOT NULL,
    fileid integer NOT NULL,
    invoiceid integer NOT NULL,
    accountnumber character varying NOT NULL,
    balance double precision NOT NULL,
    discountvalue double precision NOT NULL,
    operation character varying NOT NULL,
    iscanceled boolean DEFAULT false NOT NULL,
    value double precision NOT NULL,
    maturitydate date NOT NULL,
    bankaccountid integer,
    monthlyinterestpercent integer,
    wallet character varying(3),
    branchnumber character varying(30),
    ournumber character varying,
    referencematuritydate date,
    daystofine integer,
    daystoprotest integer
)
INHERITS (public.baslog);


ALTER TABLE fin.filelog OWNER TO postgres;

--
-- Name: TABLE filelog; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON TABLE filelog IS 'Armazena o log de geração dos arquivos de remessa.';


--
-- Name: COLUMN filelog.filelogid; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN filelog.filelogid IS 'Codigo identificador da tabela.';


--
-- Name: COLUMN filelog.fileid; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN filelog.fileid IS 'Codigo do arquivo.';


--
-- Name: COLUMN filelog.invoiceid; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN filelog.invoiceid IS 'Codigo identificador do titulo.';


--
-- Name: COLUMN filelog.accountnumber; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN filelog.accountnumber IS 'Codigo da conta bancária.';


--
-- Name: COLUMN filelog.balance; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN filelog.balance IS 'Saldo atual do título.';


--
-- Name: COLUMN filelog.discountvalue; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN filelog.discountvalue IS 'Valor referente a descontos ou abatimentos.';


--
-- Name: COLUMN filelog.operation; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN filelog.operation IS 'Indica a operação realizada.';


--
-- Name: COLUMN filelog.iscanceled; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN filelog.iscanceled IS 'Indica se um título foi cancelado ou nao.';


--
-- Name: COLUMN filelog.value; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN filelog.value IS 'Valor do título.';


--
-- Name: COLUMN filelog.maturitydate; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN filelog.maturitydate IS 'Data de vencimento do titulo.';


--
-- Name: COLUMN filelog.bankaccountid; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN filelog.bankaccountid IS 'Codigo da conta corrente (finBankAccount) que recebera o dinheiro deste pagamento.';


--
-- Name: COLUMN filelog.monthlyinterestpercent; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN filelog.monthlyinterestpercent IS 'Percentual de juros a serem cobrados no mes.';


--
-- Name: COLUMN filelog.wallet; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN filelog.wallet IS 'Carteira na qual a conta faz parte.';


--
-- Name: COLUMN filelog.branchnumber; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN filelog.branchnumber IS 'Numero da agencia.';


--
-- Name: COLUMN filelog.ournumber; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN filelog.ournumber IS 'Valor do nosso número.';


--
-- Name: COLUMN filelog.referencematuritydate; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN filelog.referencematuritydate IS 'Data de vencimento de referência.';


--
-- Name: COLUMN filelog.daystofine; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN filelog.daystofine IS 'A partir de quantos dias sera cobrada multa.';


--
-- Name: COLUMN filelog.daystoprotest; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN filelog.daystoprotest IS 'A partir de quantos dias sera protestado o titulo.';


--
-- Name: filelog_filelogid_seq; Type: SEQUENCE; Schema: fin; Owner: postgres
--

CREATE SEQUENCE filelog_filelogid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fin.filelog_filelogid_seq OWNER TO postgres;

--
-- Name: filelog_filelogid_seq; Type: SEQUENCE OWNED BY; Schema: fin; Owner: postgres
--

ALTER SEQUENCE filelog_filelogid_seq OWNED BY filelog.filelogid;


--
-- Name: invoicenegociationconfig; Type: TABLE; Schema: fin; Owner: postgres; Tablespace: 
--

CREATE TABLE invoicenegociationconfig (
    financeinformationid integer NOT NULL,
    bankaccountid integer NOT NULL,
    operationid integer NOT NULL,
    costcenterid character varying NOT NULL,
    policyid integer NOT NULL,
    parcelsnumber integer NOT NULL,
    minvalueforfinesandinterestrelease real NOT NULL,
    maxvaluefornonadmins real NOT NULL,
    negotiationfee real NOT NULL,
    maturitydays integer NOT NULL,
    operation character(1) DEFAULT 'A'::bpchar,
    percentvalueentry real
)
INHERITS (public.baslog);


ALTER TABLE fin.invoicenegociationconfig OWNER TO postgres;

--
-- Name: COLUMN invoicenegociationconfig.financeinformationid; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN invoicenegociationconfig.financeinformationid IS 'Codigo identificador da tabela.';


--
-- Name: COLUMN invoicenegociationconfig.bankaccountid; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN invoicenegociationconfig.bankaccountid IS 'Código da conta bancária.';


--
-- Name: COLUMN invoicenegociationconfig.operationid; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN invoicenegociationconfig.operationid IS 'Código da operação.';


--
-- Name: COLUMN invoicenegociationconfig.costcenterid; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN invoicenegociationconfig.costcenterid IS 'Código do centro de custo.';


--
-- Name: COLUMN invoicenegociationconfig.policyid; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN invoicenegociationconfig.policyid IS 'Código da política.';


--
-- Name: COLUMN invoicenegociationconfig.parcelsnumber; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN invoicenegociationconfig.parcelsnumber IS 'Número de parcelas.';


--
-- Name: COLUMN invoicenegociationconfig.minvalueforfinesandinterestrelease; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN invoicenegociationconfig.minvalueforfinesandinterestrelease IS 'Valor mínimo para permitir liberação de juros e multas.';


--
-- Name: COLUMN invoicenegociationconfig.maxvaluefornonadmins; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN invoicenegociationconfig.maxvaluefornonadmins IS 'Valor máximo negociável por usuário não administrador.';


--
-- Name: COLUMN invoicenegociationconfig.negotiationfee; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN invoicenegociationconfig.negotiationfee IS 'Taxa de negociação.';


--
-- Name: COLUMN invoicenegociationconfig.maturitydays; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN invoicenegociationconfig.maturitydays IS 'Dias para vencimento.';


--
-- Name: COLUMN invoicenegociationconfig.percentvalueentry; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN invoicenegociationconfig.percentvalueentry IS 'Valor percentual';


--
-- Name: invoicenegociationconfig_financeinformationid_seq; Type: SEQUENCE; Schema: fin; Owner: postgres
--

CREATE SEQUENCE invoicenegociationconfig_financeinformationid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fin.invoicenegociationconfig_financeinformationid_seq OWNER TO postgres;

--
-- Name: invoicenegociationconfig_financeinformationid_seq; Type: SEQUENCE OWNED BY; Schema: fin; Owner: postgres
--

ALTER SEQUENCE invoicenegociationconfig_financeinformationid_seq OWNED BY invoicenegociationconfig.financeinformationid;


--
-- Name: invoicespeciebank; Type: TABLE; Schema: fin; Owner: postgres; Tablespace: 
--

CREATE TABLE invoicespeciebank (
    bankid character varying(3) NOT NULL,
    invoicespecieid character varying(3) NOT NULL,
    invoicespeciebankvalue character varying NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE fin.invoicespeciebank OWNER TO postgres;

--
-- Name: negotiation; Type: TABLE; Schema: fin; Owner: postgres; Tablespace: 
--

CREATE TABLE negotiation (
    negotiationid integer NOT NULL,
    policyid integer NOT NULL,
    adminuser integer,
    feerelease boolean NOT NULL,
    discount double precision NOT NULL,
    observation text,
    recordtype character(1),
    discountbyvalue boolean DEFAULT true,
    entryvalue real,
    finerelease boolean,
    interestrelease boolean
)
INHERITS (public.baslog);


ALTER TABLE fin.negotiation OWNER TO postgres;

--
-- Name: TABLE negotiation; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON TABLE negotiation IS 'Armazena as negociações efetuadas para poder desfaze-las, se necessário.';


--
-- Name: COLUMN negotiation.negotiationid; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN negotiation.negotiationid IS 'Identificador da negociação.';


--
-- Name: COLUMN negotiation.policyid; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN negotiation.policyid IS 'Política utilizada para efetuar a negociação.';


--
-- Name: COLUMN negotiation.adminuser; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN negotiation.adminuser IS 'Usuário administrador que autorizou a negociação.';


--
-- Name: COLUMN negotiation.feerelease; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN negotiation.feerelease IS 'Indica se houve liberação da taxa administrativa cobrada para negociação.';


--
-- Name: COLUMN negotiation.discount; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN negotiation.discount IS 'Valor do desconto dado na negociação.';


--
-- Name: COLUMN negotiation.observation; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN negotiation.observation IS 'Alguma observação necessária sobre a negociação.';


--
-- Name: COLUMN negotiation.entryvalue; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN negotiation.entryvalue IS 'Valor de entrada';


--
-- Name: COLUMN negotiation.finerelease; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN negotiation.finerelease IS 'Liberar multas';


--
-- Name: COLUMN negotiation.interestrelease; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN negotiation.interestrelease IS 'Liberar juros';


--
-- Name: negotiation_negotiationid_seq; Type: SEQUENCE; Schema: fin; Owner: postgres
--

CREATE SEQUENCE negotiation_negotiationid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE fin.negotiation_negotiationid_seq OWNER TO postgres;

--
-- Name: negotiation_negotiationid_seq; Type: SEQUENCE OWNED BY; Schema: fin; Owner: postgres
--

ALTER SEQUENCE negotiation_negotiationid_seq OWNED BY negotiation.negotiationid;


--
-- Name: negotiationgeneratedentries; Type: TABLE; Schema: fin; Owner: postgres; Tablespace: 
--

CREATE TABLE negotiationgeneratedentries (
    negotiationid integer NOT NULL,
    entryid integer NOT NULL,
    generated boolean
)
INHERITS (public.baslog);


ALTER TABLE fin.negotiationgeneratedentries OWNER TO postgres;

--
-- Name: TABLE negotiationgeneratedentries; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON TABLE negotiationgeneratedentries IS 'Armazena os lançamentos gerados a partir da negociação. Para retornar ao estado anterior, estes lançamentos devem ser excluídos.';


--
-- Name: COLUMN negotiationgeneratedentries.negotiationid; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN negotiationgeneratedentries.negotiationid IS 'Código da negociação relacionada.';


--
-- Name: COLUMN negotiationgeneratedentries.entryid; Type: COMMENT; Schema: fin; Owner: postgres
--

COMMENT ON COLUMN negotiationgeneratedentries.entryid IS 'Código do lançamento.';


SET search_path = hur, pg_catalog;

--
-- Name: activitytype; Type: TABLE; Schema: hur; Owner: postgres; Tablespace: 
--

CREATE TABLE activitytype (
    activitytypeid integer NOT NULL,
    description character varying(255) NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE hur.activitytype OWNER TO postgres;

--
-- Name: activitytype_activitytypeid_seq; Type: SEQUENCE; Schema: hur; Owner: postgres
--

CREATE SEQUENCE activitytype_activitytypeid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hur.activitytype_activitytypeid_seq OWNER TO postgres;

--
-- Name: activitytype_activitytypeid_seq; Type: SEQUENCE OWNED BY; Schema: hur; Owner: postgres
--

ALTER SEQUENCE activitytype_activitytypeid_seq OWNED BY activitytype.activitytypeid;


--
-- Name: realizedactivity; Type: TABLE; Schema: hur; Owner: postgres; Tablespace: 
--

CREATE TABLE realizedactivity (
    realizedactivityid integer NOT NULL,
    scheduledactivityid integer,
    startdate timestamp without time zone,
    enddate timestamp without time zone,
    activitytypeid integer NOT NULL,
    description text NOT NULL,
    isinternal boolean,
    fileid integer,
    canceldate timestamp without time zone,
    CONSTRAINT chk_realization_xor_cancelation CHECK ((((((canceldate IS NULL) AND (startdate IS NOT NULL)) AND (enddate IS NOT NULL)) AND (isinternal IS NOT NULL)) OR ((((canceldate IS NOT NULL) AND (startdate IS NULL)) AND (enddate IS NULL)) AND (isinternal IS NULL))))
)
INHERITS (public.baslog);


ALTER TABLE hur.realizedactivity OWNER TO postgres;

--
-- Name: CONSTRAINT chk_realization_xor_cancelation ON realizedactivity; Type: COMMENT; Schema: hur; Owner: postgres
--

COMMENT ON CONSTRAINT chk_realization_xor_cancelation ON realizedactivity IS 'Garante que seja inserido um cancelamento ou uma realização, mas nunca os dois.';


--
-- Name: realizedactivity_realizedactivityid_seq; Type: SEQUENCE; Schema: hur; Owner: postgres
--

CREATE SEQUENCE realizedactivity_realizedactivityid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hur.realizedactivity_realizedactivityid_seq OWNER TO postgres;

--
-- Name: realizedactivity_realizedactivityid_seq; Type: SEQUENCE OWNED BY; Schema: hur; Owner: postgres
--

ALTER SEQUENCE realizedactivity_realizedactivityid_seq OWNED BY realizedactivity.realizedactivityid;


--
-- Name: realizedactivityparticipant; Type: TABLE; Schema: hur; Owner: postgres; Tablespace: 
--

CREATE TABLE realizedactivityparticipant (
    realizedactivityid integer NOT NULL,
    personid bigint NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE hur.realizedactivityparticipant OWNER TO postgres;

--
-- Name: scheduledactivity; Type: TABLE; Schema: hur; Owner: postgres; Tablespace: 
--

CREATE TABLE scheduledactivity (
    scheduledactivityid integer NOT NULL,
    startdate timestamp without time zone NOT NULL,
    enddate timestamp without time zone NOT NULL,
    activitytypeid integer NOT NULL,
    description text NOT NULL,
    isinternal boolean NOT NULL,
    location text
)
INHERITS (public.baslog);


ALTER TABLE hur.scheduledactivity OWNER TO postgres;

--
-- Name: scheduledactivity_scheduledactivityid_seq; Type: SEQUENCE; Schema: hur; Owner: postgres
--

CREATE SEQUENCE scheduledactivity_scheduledactivityid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hur.scheduledactivity_scheduledactivityid_seq OWNER TO postgres;

--
-- Name: scheduledactivity_scheduledactivityid_seq; Type: SEQUENCE OWNED BY; Schema: hur; Owner: postgres
--

ALTER SEQUENCE scheduledactivity_scheduledactivityid_seq OWNED BY scheduledactivity.scheduledactivityid;


--
-- Name: scheduledactivityparticipant; Type: TABLE; Schema: hur; Owner: postgres; Tablespace: 
--

CREATE TABLE scheduledactivityparticipant (
    scheduledactivityid integer NOT NULL,
    personid bigint NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE hur.scheduledactivityparticipant OWNER TO postgres;

SET search_path = ins, pg_catalog;

--
-- Name: material; Type: TABLE; Schema: ins; Owner: postgres; Tablespace: 
--

CREATE TABLE material (
    materialid integer NOT NULL,
    physicalresourceid integer NOT NULL,
    physicalresourceversion integer NOT NULL,
    materialtypeid integer NOT NULL,
    description character varying(255) NOT NULL,
    detaileddescription text,
    isavailable boolean NOT NULL,
    unavailabilityreason text,
    unavailabilitydate date,
    internalcode character varying(30)
)
INHERITS (public.baslog);


ALTER TABLE ins.material OWNER TO postgres;

--
-- Name: material_materialid_seq; Type: SEQUENCE; Schema: ins; Owner: postgres
--

CREATE SEQUENCE material_materialid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ins.material_materialid_seq OWNER TO postgres;

--
-- Name: material_materialid_seq; Type: SEQUENCE OWNED BY; Schema: ins; Owner: postgres
--

ALTER SEQUENCE material_materialid_seq OWNED BY material.materialid;


--
-- Name: materialloan; Type: TABLE; Schema: ins; Owner: postgres; Tablespace: 
--

CREATE TABLE materialloan (
    materialloanid integer NOT NULL,
    materialrequestid integer,
    personid bigint NOT NULL,
    materialid integer NOT NULL,
    begindate timestamp without time zone NOT NULL,
    expectedenddate timestamp without time zone NOT NULL,
    enddate timestamp without time zone,
    returnobs text,
    loandate timestamp without time zone,
    canceldate timestamp without time zone
)
INHERITS (public.baslog);


ALTER TABLE ins.materialloan OWNER TO postgres;

--
-- Name: materialloan_materialloanid_seq; Type: SEQUENCE; Schema: ins; Owner: postgres
--

CREATE SEQUENCE materialloan_materialloanid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ins.materialloan_materialloanid_seq OWNER TO postgres;

--
-- Name: materialloan_materialloanid_seq; Type: SEQUENCE OWNED BY; Schema: ins; Owner: postgres
--

ALTER SEQUENCE materialloan_materialloanid_seq OWNED BY materialloan.materialloanid;


--
-- Name: materialloan_personid_seq; Type: SEQUENCE; Schema: ins; Owner: postgres
--

CREATE SEQUENCE materialloan_personid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ins.materialloan_personid_seq OWNER TO postgres;

--
-- Name: materialloan_personid_seq; Type: SEQUENCE OWNED BY; Schema: ins; Owner: postgres
--

ALTER SEQUENCE materialloan_personid_seq OWNED BY materialloan.personid;


--
-- Name: materialrequest; Type: TABLE; Schema: ins; Owner: postgres; Tablespace: 
--

CREATE TABLE materialrequest (
    materialrequestid integer NOT NULL,
    materialtypeid integer,
    personid bigint NOT NULL,
    begindate timestamp without time zone NOT NULL,
    enddate timestamp without time zone NOT NULL,
    canceldate timestamp without time zone,
    materialid integer,
    observation text,
    reasonrejected text,
    CONSTRAINT chk_materialid_or_materialtypeid_is_null CHECK ((((materialid IS NOT NULL) AND (materialtypeid IS NULL)) OR ((materialtypeid IS NOT NULL) AND (materialid IS NULL))))
)
INHERITS (public.baslog);


ALTER TABLE ins.materialrequest OWNER TO postgres;

--
-- Name: materialrequest_materialrequestid_seq; Type: SEQUENCE; Schema: ins; Owner: postgres
--

CREATE SEQUENCE materialrequest_materialrequestid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ins.materialrequest_materialrequestid_seq OWNER TO postgres;

--
-- Name: materialrequest_materialrequestid_seq; Type: SEQUENCE OWNED BY; Schema: ins; Owner: postgres
--

ALTER SEQUENCE materialrequest_materialrequestid_seq OWNED BY materialrequest.materialrequestid;


--
-- Name: materialrequest_personid_seq; Type: SEQUENCE; Schema: ins; Owner: postgres
--

CREATE SEQUENCE materialrequest_personid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ins.materialrequest_personid_seq OWNER TO postgres;

--
-- Name: materialrequest_personid_seq; Type: SEQUENCE OWNED BY; Schema: ins; Owner: postgres
--

ALTER SEQUENCE materialrequest_personid_seq OWNED BY materialrequest.personid;


--
-- Name: materialtype; Type: TABLE; Schema: ins; Owner: postgres; Tablespace: 
--

CREATE TABLE materialtype (
    materialtypeid integer NOT NULL,
    description character varying(255) NOT NULL,
    allowloanbytype boolean NOT NULL,
    allowloanbymaterial boolean NOT NULL,
    availabilitycontrol boolean DEFAULT true NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE ins.materialtype OWNER TO postgres;

--
-- Name: materialtype_materialtypeid_seq; Type: SEQUENCE; Schema: ins; Owner: postgres
--

CREATE SEQUENCE materialtype_materialtypeid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ins.materialtype_materialtypeid_seq OWNER TO postgres;

--
-- Name: materialtype_materialtypeid_seq; Type: SEQUENCE OWNED BY; Schema: ins; Owner: postgres
--

ALTER SEQUENCE materialtype_materialtypeid_seq OWNED BY materialtype.materialtypeid;


SET search_path = public, pg_catalog;

--
-- Name: accaccountbalance; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE accaccountbalance (
    accountschemeid character varying(30) NOT NULL,
    source character(1) NOT NULL,
    balancedate date NOT NULL,
    value numeric(14,4) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.accaccountbalance OWNER TO postgres;

--
-- Name: TABLE accaccountbalance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE accaccountbalance IS 'contem os saldos das contas contabeis em uma determinada data';


--
-- Name: COLUMN accaccountbalance.accountschemeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accaccountbalance.accountschemeid IS 'Codigo identificador da conta contabil';


--
-- Name: COLUMN accaccountbalance.source; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accaccountbalance.source IS 'Define se o saldo em questao tem origem nas previsoes (P) ou nos lancamentos (L)';


--
-- Name: COLUMN accaccountbalance.balancedate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accaccountbalance.balancedate IS 'Data que define quando saldo desta conta/origem foi calculado';


--
-- Name: COLUMN accaccountbalance.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accaccountbalance.value IS 'Valor do saldo.';


--
-- Name: seq_accountinglimitid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_accountinglimitid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_accountinglimitid OWNER TO postgres;

--
-- Name: accaccountinglimit; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE accaccountinglimit (
    accountinglimitid integer DEFAULT nextval('seq_accountinglimitid'::regclass) NOT NULL,
    recorddate date NOT NULL,
    accountinguser character varying(40) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.accaccountinglimit OWNER TO postgres;

--
-- Name: TABLE accaccountinglimit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE accaccountinglimit IS 'contem os registros que controlam os limites contabeis, que definem quando os titulos e lancamentos ainda podem ser alterados';


--
-- Name: COLUMN accaccountinglimit.accountinglimitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accaccountinglimit.accountinglimitid IS 'Codigo do limite contabil';


--
-- Name: COLUMN accaccountinglimit.recorddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accaccountinglimit.recorddate IS 'Data que define que os lancamentos e titulos inferiores a essa data nao podem ser mais alterados';


--
-- Name: COLUMN accaccountinglimit.accountinguser; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accaccountinglimit.accountinguser IS 'Usuario que grava a informacao';


--
-- Name: seq_accountreduced; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_accountreduced
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_accountreduced OWNER TO postgres;

--
-- Name: accaccountscheme; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE accaccountscheme (
    accountschemeid character varying(30) NOT NULL,
    description text NOT NULL,
    accountreduced integer DEFAULT nextval('seq_accountreduced'::regclass),
    incomeorexpense character(1) DEFAULT 'I'::bpchar NOT NULL,
    parentaccountschemeid character varying(30),
    CONSTRAINT chk_accountschemeid_not_used_in_operations CHECK (chk_accountschemeid_not_used_in_operations(parentaccountschemeid))
)
INHERITS (baslog);


ALTER TABLE public.accaccountscheme OWNER TO postgres;

--
-- Name: TABLE accaccountscheme; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE accaccountscheme IS 'tabela de contas contabeis';


--
-- Name: COLUMN accaccountscheme.accountschemeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accaccountscheme.accountschemeid IS 'Codigo identificador da conta contabil';


--
-- Name: COLUMN accaccountscheme.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accaccountscheme.description IS 'Descricao da conta contabil';


--
-- Name: acccostcenter; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acccostcenter (
    costcenterid character varying(30) NOT NULL,
    description text NOT NULL,
    parentcostcenterid character varying(30),
    allowpaymentrequest boolean DEFAULT false,
    personidowner integer,
    active boolean DEFAULT true
)
INHERITS (baslog);


ALTER TABLE public.acccostcenter OWNER TO postgres;

--
-- Name: TABLE acccostcenter; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acccostcenter IS 'centro de custos indicando setores, cursos, qualquer coisa que tenha movimentacao financeira e precise de contabilizacao';


--
-- Name: COLUMN acccostcenter.costcenterid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acccostcenter.costcenterid IS 'Codigo identificador do centro de custo';


--
-- Name: COLUMN acccostcenter.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acccostcenter.description IS 'Descricao do centro de custo';


--
-- Name: COLUMN acccostcenter.allowpaymentrequest; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acccostcenter.allowpaymentrequest IS 'Aceita solicitação de pagamento. Quando este estiver como VERDADEIRO, deve existir o chefe de centro de custo (personidowner)';


--
-- Name: COLUMN acccostcenter.personidowner; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acccostcenter.personidowner IS 'Chefe do centro de custo';


--
-- Name: acccourseaccount; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acccourseaccount (
    courseid character varying(10) NOT NULL,
    courseversion integer NOT NULL,
    unitid integer NOT NULL,
    accountschemeid character varying(30) NOT NULL,
    costcenterid character varying(30) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acccourseaccount OWNER TO postgres;

--
-- Name: TABLE acccourseaccount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acccourseaccount IS 'define a conta contabil e o centro de custo para um curso  e sua versao em um campus';


--
-- Name: COLUMN acccourseaccount.courseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acccourseaccount.courseid IS 'Codigo identificador do curso';


--
-- Name: COLUMN acccourseaccount.courseversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acccourseaccount.courseversion IS 'Versao do curso';


--
-- Name: COLUMN acccourseaccount.unitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acccourseaccount.unitid IS 'Codigo identificador do campus';


--
-- Name: COLUMN acccourseaccount.accountschemeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acccourseaccount.accountschemeid IS 'Codigo identificador da conta contabil';


--
-- Name: COLUMN acccourseaccount.costcenterid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acccourseaccount.costcenterid IS 'Codigo identificador do centro de custo';


--
-- Name: seq_coursebalanceid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_coursebalanceid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_coursebalanceid OWNER TO postgres;

--
-- Name: acccoursebalance; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acccoursebalance (
    coursebalanceid integer DEFAULT nextval('seq_coursebalanceid'::regclass) NOT NULL,
    accountschemeid character varying(30) NOT NULL,
    source character(1) NOT NULL,
    balancedate date NOT NULL,
    courseid character varying(10) NOT NULL,
    courseversion integer NOT NULL,
    unitid integer NOT NULL,
    value numeric(14,4) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acccoursebalance OWNER TO postgres;

--
-- Name: TABLE acccoursebalance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acccoursebalance IS 'saldo de um determinado curso e sua versao em uma unidade, com uma conta contabil em uma determinada data';


--
-- Name: COLUMN acccoursebalance.coursebalanceid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acccoursebalance.coursebalanceid IS 'Codigo identificador do saldo do curso';


--
-- Name: COLUMN acccoursebalance.accountschemeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acccoursebalance.accountschemeid IS 'Codigo identificador da conta contabil';


--
-- Name: COLUMN acccoursebalance.source; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acccoursebalance.source IS 'Define se a origem e de Previsoes (P) ou Lancamentos (L)';


--
-- Name: COLUMN acccoursebalance.balancedate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acccoursebalance.balancedate IS 'Data em que o saldo desse curso foi computado';


--
-- Name: COLUMN acccoursebalance.courseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acccoursebalance.courseid IS 'Codigo identificador do curso';


--
-- Name: COLUMN acccoursebalance.courseversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acccoursebalance.courseversion IS 'Versao do curso';


--
-- Name: COLUMN acccoursebalance.unitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acccoursebalance.unitid IS 'Codigo identificador do campus';


--
-- Name: COLUMN acccoursebalance.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acccoursebalance.value IS 'Valor do saldo do curso';


--
-- Name: seq_accintegrationid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_accintegrationid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_accintegrationid OWNER TO postgres;

--
-- Name: accintegration; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE accintegration (
    accintegrationid integer DEFAULT nextval('seq_accintegrationid'::regclass) NOT NULL,
    operationid integer NOT NULL,
    operationtypeid character(1) NOT NULL,
    debitaccount character varying(20),
    creditaccount character varying(20),
    externalentryid integer NOT NULL,
    operationdescription character varying(40),
    debitcostcenter character varying(30),
    creditcostcenter character varying(30)
)
INHERITS (baslog);


ALTER TABLE public.accintegration OWNER TO postgres;

--
-- Name: TABLE accintegration; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE accintegration IS 'contem os registros necessarios para a integracao com o siga';


--
-- Name: COLUMN accintegration.accintegrationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accintegration.accintegrationid IS 'Codigo identificador da integracao';


--
-- Name: COLUMN accintegration.operationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accintegration.operationid IS 'Codigo identificador da operacao';


--
-- Name: COLUMN accintegration.operationtypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accintegration.operationtypeid IS 'Define se a operacao eh debito ou credito';


--
-- Name: COLUMN accintegration.debitaccount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accintegration.debitaccount IS 'plano de contas ou mascara para plano de contas se a operacao for debito';


--
-- Name: COLUMN accintegration.creditaccount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accintegration.creditaccount IS 'plano de contas ou mascara para plano de contas se a operacao for credito';


--
-- Name: COLUMN accintegration.externalentryid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accintegration.externalentryid IS 'Codigo identificador do lancamento para o SIGA';


--
-- Name: COLUMN accintegration.operationdescription; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accintegration.operationdescription IS 'Descricao da operacao para o SIGA';


--
-- Name: COLUMN accintegration.debitcostcenter; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accintegration.debitcostcenter IS 'Centro de custo se a operacao for debito';


--
-- Name: COLUMN accintegration.creditcostcenter; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accintegration.creditcostcenter IS 'Centro de custo se a operacao for credito';


--
-- Name: accentryintegration; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE accentryintegration (
    value character varying(20),
    usercode text,
    debititem character varying(20),
    credititem character varying(20),
    reversaloperation character varying(40)
)
INHERITS (accintegration);


ALTER TABLE public.accentryintegration OWNER TO postgres;

--
-- Name: TABLE accentryintegration; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE accentryintegration IS 'contem os registros necessarios para a integracao de lancamentos com o siga (sagu1: integra_lancamentos). herda a accintegration';


--
-- Name: COLUMN accentryintegration.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accentryintegration.value IS 'Valor';


--
-- Name: COLUMN accentryintegration.usercode; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accentryintegration.usercode IS 'Campo que pode conter um codigo php pra alterar informacoes do usuario';


--
-- Name: COLUMN accentryintegration.debititem; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accentryintegration.debititem IS 'Item do debito';


--
-- Name: COLUMN accentryintegration.credititem; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accentryintegration.credititem IS 'Item de credito';


--
-- Name: COLUMN accentryintegration.reversaloperation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accentryintegration.reversaloperation IS 'Descricao da operacao de estorno';


--
-- Name: accincomeforecastintegration; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE accincomeforecastintegration (
    accountitem character varying(20)
)
INHERITS (accintegration);


ALTER TABLE public.accincomeforecastintegration OWNER TO postgres;

--
-- Name: TABLE accincomeforecastintegration; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE accincomeforecastintegration IS 'contem os registros necessarios para a integracao de previsoes com o siga (sagu1: integra_previsoes). herda a accintegration';


--
-- Name: COLUMN accincomeforecastintegration.accountitem; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accincomeforecastintegration.accountitem IS 'Intem contabil';


--
-- Name: seq_personbalanceid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_personbalanceid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_personbalanceid OWNER TO postgres;

--
-- Name: accpersonbalance; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE accpersonbalance (
    personbalanceid integer DEFAULT nextval('seq_personbalanceid'::regclass) NOT NULL,
    accountschemeid character varying(30) NOT NULL,
    personid bigint NOT NULL,
    source character(1) NOT NULL,
    balancedate date NOT NULL,
    courseid character varying(10),
    courseversion integer,
    unitid integer,
    value numeric(14,4) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.accpersonbalance OWNER TO postgres;

--
-- Name: TABLE accpersonbalance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE accpersonbalance IS 'contem os saldos por conta, origem e pessoa em determinada data.';


--
-- Name: COLUMN accpersonbalance.accountschemeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accpersonbalance.accountschemeid IS 'Codigo identificador da conta. Obtido da tabela fin_plano_conta.';


--
-- Name: COLUMN accpersonbalance.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accpersonbalance.personid IS 'Codigo identificador da pessoa. Obtido da tabela basPerson.';


--
-- Name: COLUMN accpersonbalance.source; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accpersonbalance.source IS 'Define se o saldo em questao tem origem nas previsoes (P) ou nos lancamentos (L).';


--
-- Name: COLUMN accpersonbalance.balancedate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accpersonbalance.balancedate IS 'Data identificando quando o saldo desta conta/origem/pessoa era esse.';


--
-- Name: COLUMN accpersonbalance.courseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accpersonbalance.courseid IS 'informacoes que nao precisam ser obrigatorias';


--
-- Name: COLUMN accpersonbalance.unitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accpersonbalance.unitid IS 'informacoes que nao precisam ser obrigatorias';


--
-- Name: COLUMN accpersonbalance.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN accpersonbalance.value IS 'Valor do saldo.';


--
-- Name: acdacademiccalendar; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdacademiccalendar (
    calendaryear integer NOT NULL,
    description text,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acdacademiccalendar OWNER TO postgres;

--
-- Name: TABLE acdacademiccalendar; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdacademiccalendar IS 'Tabela responsábel por armazenar os calendários acadêmicos';


--
-- Name: COLUMN acdacademiccalendar.calendaryear; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdacademiccalendar.calendaryear IS 'Ano do calendário e código identificador da tabela';


--
-- Name: COLUMN acdacademiccalendar.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdacademiccalendar.description IS 'Descrição do calendário acadêmico';


--
-- Name: acdacademiccalendarevent; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdacademiccalendarevent (
    eventdate date NOT NULL,
    calendaryear integer NOT NULL,
    description text,
    haveclass boolean DEFAULT false,
    academiccalendareventid integer NOT NULL,
    courseid character varying(10),
    courseversion integer,
    turnid integer,
    unitid integer,
    ocorrenciacursoid integer
)
INHERITS (baslog);


ALTER TABLE public.acdacademiccalendarevent OWNER TO postgres;

--
-- Name: TABLE acdacademiccalendarevent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdacademiccalendarevent IS 'Tabela responsábel por armazenar os eventos do calendário acadêmico';


--
-- Name: COLUMN acdacademiccalendarevent.eventdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdacademiccalendarevent.eventdate IS 'Data do evento e identificador da tabela';


--
-- Name: COLUMN acdacademiccalendarevent.calendaryear; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdacademiccalendarevent.calendaryear IS 'Ano do calendário e código identificador da tabela acdacademiccalendar';


--
-- Name: COLUMN acdacademiccalendarevent.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdacademiccalendarevent.description IS 'Descrição do calendário acadêmico';


--
-- Name: COLUMN acdacademiccalendarevent.haveclass; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdacademiccalendarevent.haveclass IS 'Indica se haverá ou não aula na data';


--
-- Name: COLUMN acdacademiccalendarevent.courseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdacademiccalendarevent.courseid IS 'Curso da ocorrência';


--
-- Name: COLUMN acdacademiccalendarevent.courseversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdacademiccalendarevent.courseversion IS 'Versão de curso da ocorrência';


--
-- Name: COLUMN acdacademiccalendarevent.turnid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdacademiccalendarevent.turnid IS 'Turno da ocorrência de curso';


--
-- Name: COLUMN acdacademiccalendarevent.unitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdacademiccalendarevent.unitid IS 'Unidade da ocorrência de curso';


--
-- Name: acdacademiccalendarevent_academiccalendareventid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acdacademiccalendarevent_academiccalendareventid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acdacademiccalendarevent_academiccalendareventid_seq OWNER TO postgres;

--
-- Name: acdacademiccalendarevent_academiccalendareventid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acdacademiccalendarevent_academiccalendareventid_seq OWNED BY acdacademiccalendarevent.academiccalendareventid;


--
-- Name: acdcamposconfiguraveispessoa; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcamposconfiguraveispessoa (
    camposconfiguraveispessoaid integer NOT NULL,
    campo text NOT NULL,
    editavel boolean DEFAULT false,
    ordem integer,
    submodulo character(1) DEFAULT 'P'::bpchar,
    validador boolean DEFAULT true
)
INHERITS (baslog);


ALTER TABLE public.acdcamposconfiguraveispessoa OWNER TO postgres;

--
-- Name: acdcamposconfiguraveispessoa_camposconfiguraveispessoaid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acdcamposconfiguraveispessoa_camposconfiguraveispessoaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acdcamposconfiguraveispessoa_camposconfiguraveispessoaid_seq OWNER TO postgres;

--
-- Name: acdcamposconfiguraveispessoa_camposconfiguraveispessoaid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acdcamposconfiguraveispessoa_camposconfiguraveispessoaid_seq OWNED BY acdcamposconfiguraveispessoa.camposconfiguraveispessoaid;


--
-- Name: seq_centerid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_centerid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_centerid OWNER TO postgres;

--
-- Name: acdcenter; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcenter (
    centerid integer DEFAULT nextval('seq_centerid'::regclass) NOT NULL,
    name text NOT NULL,
    shortname character varying(30) NOT NULL,
    directorid integer
)
INHERITS (baslog);


ALTER TABLE public.acdcenter OWNER TO postgres;

--
-- Name: TABLE acdcenter; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdcenter IS 'centros';


--
-- Name: COLUMN acdcenter.centerid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcenter.centerid IS 'Codigo do centro';


--
-- Name: COLUMN acdcenter.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcenter.name IS 'Nome do centro';


--
-- Name: COLUMN acdcenter.shortname; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcenter.shortname IS 'Nome suscinto do centro';


--
-- Name: COLUMN acdcenter.directorid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcenter.directorid IS 'Codigo do diretor do centro';


--
-- Name: acdcertified_certifiedid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acdcertified_certifiedid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acdcertified_certifiedid OWNER TO postgres;

--
-- Name: acdcertified; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcertified (
    certifiedid integer DEFAULT nextval('acdcertified_certifiedid'::regclass) NOT NULL,
    dateissue date NOT NULL,
    certifiedtypeid integer NOT NULL,
    personid bigint NOT NULL,
    courseid character varying(10),
    courseversion integer,
    unitid integer,
    turnid integer,
    certifiednumber integer
)
INHERITS (baslog);


ALTER TABLE public.acdcertified OWNER TO postgres;

--
-- Name: TABLE acdcertified; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdcertified IS 'atestados';


--
-- Name: COLUMN acdcertified.certifiedid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcertified.certifiedid IS 'Codigo do atestado';


--
-- Name: COLUMN acdcertified.dateissue; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcertified.dateissue IS 'Data de publicacao';


--
-- Name: COLUMN acdcertified.certifiedtypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcertified.certifiedtypeid IS 'Codigo do tipo de atestado';


--
-- Name: COLUMN acdcertified.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcertified.personid IS 'Codigo da pessoa a qual o atestado se refere';


--
-- Name: COLUMN acdcertified.courseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcertified.courseid IS 'Codigo do curso';


--
-- Name: COLUMN acdcertified.courseversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcertified.courseversion IS 'Versao do curso';


--
-- Name: COLUMN acdcertified.unitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcertified.unitid IS 'Codigo da unidade';


--
-- Name: COLUMN acdcertified.turnid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcertified.turnid IS 'Codigo do turno';


--
-- Name: COLUMN acdcertified.certifiednumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcertified.certifiednumber IS 'Indica o número de certificados emitidos no ano.';


--
-- Name: seq_certifiedtypeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_certifiedtypeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_certifiedtypeid OWNER TO postgres;

--
-- Name: acdcertifiedtype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcertifiedtype (
    certifiedtypeid integer DEFAULT nextval('seq_certifiedtypeid'::regclass) NOT NULL,
    description text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdcertifiedtype OWNER TO postgres;

--
-- Name: TABLE acdcertifiedtype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdcertifiedtype IS 'tipos de atestados';


--
-- Name: COLUMN acdcertifiedtype.certifiedtypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcertifiedtype.certifiedtypeid IS 'Codigo do tipo de atestado';


--
-- Name: COLUMN acdcertifiedtype.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcertifiedtype.description IS 'Descricao';


--
-- Name: acdclass; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdclass (
    classid character varying(20) NOT NULL,
    name text NOT NULL,
    initiallearningperiodid integer NOT NULL,
    vacant integer NOT NULL,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acdclass OWNER TO postgres;

--
-- Name: TABLE acdclass; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdclass IS 'cadastro da turma dos alunos';


--
-- Name: COLUMN acdclass.classid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdclass.classid IS 'Código da turma';


--
-- Name: COLUMN acdclass.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdclass.name IS 'Nome completo da turma';


--
-- Name: COLUMN acdclass.initiallearningperiodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdclass.initiallearningperiodid IS 'Período letivo que iniciou a turma';


--
-- Name: COLUMN acdclass.vacant; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdclass.vacant IS 'Numero de vagas da turma';


--
-- Name: acdclasspupil; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdclasspupil (
    classid character varying(20) NOT NULL,
    contractid integer NOT NULL,
    begindate date NOT NULL,
    enddate date,
    reasonid integer,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acdclasspupil OWNER TO postgres;

--
-- Name: TABLE acdclasspupil; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdclasspupil IS 'cadastro para armazenar todos os alunos que forma um turma';


--
-- Name: COLUMN acdclasspupil.classid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdclasspupil.classid IS 'Código da turma';


--
-- Name: COLUMN acdclasspupil.contractid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdclasspupil.contractid IS 'Codigo do contrato do aluno';


--
-- Name: COLUMN acdclasspupil.begindate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdclasspupil.begindate IS 'Data que o aluno entrou na turma';


--
-- Name: COLUMN acdclasspupil.enddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdclasspupil.enddate IS 'Data de saida do aluno dessa turma';


--
-- Name: seq_complementaryactivitiesid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_complementaryactivitiesid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_complementaryactivitiesid OWNER TO postgres;

--
-- Name: acdcomplementaryactivities; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcomplementaryactivities (
    complementaryactivitiesid integer DEFAULT nextval('seq_complementaryactivitiesid'::regclass) NOT NULL,
    complementaryactivitiescategoryid integer NOT NULL,
    periodid character varying(10) NOT NULL,
    enrollid integer NOT NULL,
    description text NOT NULL,
    totalhours double precision NOT NULL,
    totalcredits double precision NOT NULL,
    degree double precision,
    concept character varying(15),
    curriculumidold integer
)
INHERITS (baslog);


ALTER TABLE public.acdcomplementaryactivities OWNER TO postgres;

--
-- Name: TABLE acdcomplementaryactivities; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdcomplementaryactivities IS 'atividades complementares';


--
-- Name: COLUMN acdcomplementaryactivities.complementaryactivitiesid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcomplementaryactivities.complementaryactivitiesid IS 'Codigo da atividade complementar';


--
-- Name: COLUMN acdcomplementaryactivities.complementaryactivitiescategoryid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcomplementaryactivities.complementaryactivitiescategoryid IS 'Categoria da atividade complementar';


--
-- Name: COLUMN acdcomplementaryactivities.periodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcomplementaryactivities.periodid IS 'Período que a atividade foi cursada';


--
-- Name: COLUMN acdcomplementaryactivities.enrollid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcomplementaryactivities.enrollid IS 'Matricula';


--
-- Name: COLUMN acdcomplementaryactivities.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcomplementaryactivities.description IS 'Descrição da atividade complementar';


--
-- Name: COLUMN acdcomplementaryactivities.totalhours; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcomplementaryactivities.totalhours IS 'Numero de horas';


--
-- Name: COLUMN acdcomplementaryactivities.totalcredits; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcomplementaryactivities.totalcredits IS 'Numero de créditos';


--
-- Name: COLUMN acdcomplementaryactivities.degree; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcomplementaryactivities.degree IS 'Grau/Nota';


--
-- Name: COLUMN acdcomplementaryactivities.concept; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcomplementaryactivities.concept IS 'Conceito';


--
-- Name: seq_complementaryactivitiescategoryid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_complementaryactivitiescategoryid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_complementaryactivitiescategoryid OWNER TO postgres;

--
-- Name: acdcomplementaryactivitiescategory; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcomplementaryactivitiescategory (
    complementaryactivitiescategoryid integer DEFAULT nextval('seq_complementaryactivitiescategoryid'::regclass) NOT NULL,
    description text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdcomplementaryactivitiescategory OWNER TO postgres;

--
-- Name: TABLE acdcomplementaryactivitiescategory; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdcomplementaryactivitiescategory IS 'categorias das atividades complementares';


--
-- Name: COLUMN acdcomplementaryactivitiescategory.complementaryactivitiescategoryid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcomplementaryactivitiescategory.complementaryactivitiescategoryid IS 'Codigo da categoria da atividade complementar';


--
-- Name: COLUMN acdcomplementaryactivitiescategory.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcomplementaryactivitiescategory.description IS 'Descricao da categoria (ensino, pesquisa e extensão)';


--
-- Name: seq_complementaryactivitiescategoryrulesid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_complementaryactivitiescategoryrulesid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_complementaryactivitiescategoryrulesid OWNER TO postgres;

--
-- Name: acdcomplementaryactivitiescategoryrules; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcomplementaryactivitiescategoryrules (
    complementaryactivitiescategoryrulesid integer DEFAULT nextval('seq_complementaryactivitiescategoryrulesid'::regclass) NOT NULL,
    curriculumid integer NOT NULL,
    complementaryactivitiescategoryid integer NOT NULL,
    minimumhours double precision NOT NULL,
    maximumhours double precision NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdcomplementaryactivitiescategoryrules OWNER TO postgres;

--
-- Name: TABLE acdcomplementaryactivitiescategoryrules; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdcomplementaryactivitiescategoryrules IS 'regras para as categorias das atividades complementares';


--
-- Name: COLUMN acdcomplementaryactivitiescategoryrules.complementaryactivitiescategoryrulesid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcomplementaryactivitiescategoryrules.complementaryactivitiescategoryrulesid IS 'Codigo da regra da categoria da atividade complementar';


--
-- Name: COLUMN acdcomplementaryactivitiescategoryrules.curriculumid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcomplementaryactivitiescategoryrules.curriculumid IS 'Código do currículo da atividade complementar';


--
-- Name: COLUMN acdcomplementaryactivitiescategoryrules.complementaryactivitiescategoryid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcomplementaryactivitiescategoryrules.complementaryactivitiescategoryid IS 'Código da categoria da atividade complementar';


--
-- Name: COLUMN acdcomplementaryactivitiescategoryrules.minimumhours; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcomplementaryactivitiescategoryrules.minimumhours IS 'Quantidade mínima de horas exigidas nessa categoria ';


--
-- Name: COLUMN acdcomplementaryactivitiescategoryrules.maximumhours; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcomplementaryactivitiescategoryrules.maximumhours IS 'Quantidade máxima de horas permitidas nessa categoria';


--
-- Name: seq_complementaryenrollid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_complementaryenrollid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_complementaryenrollid OWNER TO postgres;

--
-- Name: acdcomplementaryenroll; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcomplementaryenroll (
    complementaryenrollid integer DEFAULT nextval('seq_complementaryenrollid'::regclass) NOT NULL,
    contractid integer NOT NULL,
    enrollstatusid integer NOT NULL,
    institutionid integer,
    period character varying(10),
    curricularcomponent text NOT NULL,
    ordering character varying(50),
    note text,
    obs text,
    curriculumid integer
)
INHERITS (baslog);


ALTER TABLE public.acdcomplementaryenroll OWNER TO postgres;

--
-- Name: TABLE acdcomplementaryenroll; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdcomplementaryenroll IS 'Cadastro complementar da matrícula';


--
-- Name: COLUMN acdcomplementaryenroll.contractid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcomplementaryenroll.contractid IS 'Código do contrato associado';


--
-- Name: COLUMN acdcomplementaryenroll.enrollstatusid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcomplementaryenroll.enrollstatusid IS 'Código do status de matrícula associado';


--
-- Name: COLUMN acdcomplementaryenroll.institutionid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcomplementaryenroll.institutionid IS 'Código da instituição associada ';


--
-- Name: COLUMN acdcomplementaryenroll.period; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcomplementaryenroll.period IS 'Informação sobre o período em que a disciplina foi cursada';


--
-- Name: COLUMN acdcomplementaryenroll.curricularcomponent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcomplementaryenroll.curricularcomponent IS 'Nome da disciplina que foi cursada';


--
-- Name: COLUMN acdcomplementaryenroll.ordering; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcomplementaryenroll.ordering IS 'Ordem em que a disciplina irá aparecer no histórico (equivalente a semestre)';


--
-- Name: COLUMN acdcomplementaryenroll.note; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcomplementaryenroll.note IS 'Nota ou conceito que indica a avaliação do aluno na disciplina';


--
-- Name: COLUMN acdcomplementaryenroll.obs; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcomplementaryenroll.obs IS 'Informação eventualmente necessária';


--
-- Name: COLUMN acdcomplementaryenroll.curriculumid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcomplementaryenroll.curriculumid IS 'Código do currículo associado';


--
-- Name: acdconcept; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdconcept (
    conceptid integer NOT NULL,
    conceptgroupid integer NOT NULL,
    description character varying(30) NOT NULL,
    conceptorder integer NOT NULL,
    enrollstatusid integer NOT NULL,
    subtitle character varying
)
INHERITS (baslog);


ALTER TABLE public.acdconcept OWNER TO postgres;

--
-- Name: TABLE acdconcept; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdconcept IS 'Tabela responsábel por armazenar os conceitos';


--
-- Name: COLUMN acdconcept.conceptid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdconcept.conceptid IS 'Código identificador do conceito';


--
-- Name: COLUMN acdconcept.conceptgroupid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdconcept.conceptgroupid IS 'Código identificador do grupo de conceitos';


--
-- Name: COLUMN acdconcept.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdconcept.description IS 'Descrição do conceito';


--
-- Name: COLUMN acdconcept.conceptorder; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdconcept.conceptorder IS 'Ordem em que o grau deverá aparecer na listagem';


--
-- Name: COLUMN acdconcept.enrollstatusid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdconcept.enrollstatusid IS 'Estado da matricula que o conceito representa';


--
-- Name: acdconcept_conceptid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acdconcept_conceptid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acdconcept_conceptid_seq OWNER TO postgres;

--
-- Name: acdconcept_conceptid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acdconcept_conceptid_seq OWNED BY acdconcept.conceptid;


--
-- Name: acdconceptgroup; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdconceptgroup (
    conceptgroupid integer NOT NULL,
    description character varying(255) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdconceptgroup OWNER TO postgres;

--
-- Name: TABLE acdconceptgroup; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdconceptgroup IS 'Tabela responsábel por armazenar os grupos de conceitos';


--
-- Name: COLUMN acdconceptgroup.conceptgroupid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdconceptgroup.conceptgroupid IS 'Código identificador do grupo de conceitos';


--
-- Name: COLUMN acdconceptgroup.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdconceptgroup.description IS 'Descrição do grupo de conceitos';


--
-- Name: acdconceptgroup_conceptgroupid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acdconceptgroup_conceptgroupid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acdconceptgroup_conceptgroupid_seq OWNER TO postgres;

--
-- Name: acdconceptgroup_conceptgroupid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acdconceptgroup_conceptgroupid_seq OWNED BY acdconceptgroup.conceptgroupid;


--
-- Name: seq_conditionid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_conditionid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_conditionid OWNER TO postgres;

--
-- Name: acdcondition; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcondition (
    conditionid integer DEFAULT nextval('seq_conditionid'::regclass) NOT NULL,
    type character(1) NOT NULL,
    curriculumid integer NOT NULL,
    conditioncurriculumid integer,
    credits integer,
    numberhour integer,
    educationareaid integer,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acdcondition OWNER TO postgres;

--
-- Name: TABLE acdcondition; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdcondition IS 'condicoes para cursar a disciplina - requisitos';


--
-- Name: COLUMN acdcondition.conditionid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcondition.conditionid IS 'Codigo da condicao - requisito';


--
-- Name: COLUMN acdcondition.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcondition.type IS 'Tipo de pré-requisito (Pré / Co-requisito) P e C';


--
-- Name: COLUMN acdcondition.curriculumid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcondition.curriculumid IS 'Código da disciplina';


--
-- Name: COLUMN acdcondition.conditioncurriculumid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcondition.conditioncurriculumid IS 'Disciplina Pré-Requisito';


--
-- Name: COLUMN acdcondition.credits; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcondition.credits IS 'Pré-requisito por número de créditos';


--
-- Name: COLUMN acdcondition.numberhour; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcondition.numberhour IS 'Pré-requisito por número de horas';


--
-- Name: COLUMN acdcondition.educationareaid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcondition.educationareaid IS 'Créditos ou número de horas pode ser definifo por área';


--
-- Name: seq_contractid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_contractid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_contractid OWNER TO postgres;

--
-- Name: acdcontract; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcontract (
    contractid integer DEFAULT nextval('seq_contractid'::regclass) NOT NULL,
    personid bigint NOT NULL,
    courseid character varying(10) NOT NULL,
    courseversion integer NOT NULL,
    turnid integer NOT NULL,
    unitid integer NOT NULL,
    formationdate date,
    formationperiodid character varying(10),
    conclusiondate date,
    emendsdate date,
    diplomadate date,
    maturityday integer,
    islistener boolean DEFAULT false NOT NULL,
    isrequestacademicdegree boolean DEFAULT false NOT NULL,
    globalaverage double precision,
    contractnumber character varying(20),
    obs text,
    parcelsnumber integer,
    enadestatusid integer,
    bankaccountid integer,
    exploitenrollsintransfer boolean DEFAULT false NOT NULL,
    internalcontractid integer,
    internalcourseoccurrenceid character varying(10),
    internalcourseoccurrenceversion integer,
    externalcourseid integer,
    internalunitid integer,
    internalturnid integer,
    externalconclusionperiod character varying(10),
    cityid integer,
    externalconclusioninstitutionid integer,
    externalconclusiondate date,
    year integer,
    institutionid integer,
    subscriptionid integer
)
INHERITS (baslog);


ALTER TABLE public.acdcontract OWNER TO postgres;

--
-- Name: TABLE acdcontract; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdcontract IS 'contratos';


--
-- Name: COLUMN acdcontract.contractid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.contractid IS 'Codigo do contrato';


--
-- Name: COLUMN acdcontract.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.personid IS 'Codigo da pessoa';


--
-- Name: COLUMN acdcontract.courseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.courseid IS 'Codigo do curso';


--
-- Name: COLUMN acdcontract.courseversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.courseversion IS 'Versao do curso';


--
-- Name: COLUMN acdcontract.turnid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.turnid IS 'Codigo do turno';


--
-- Name: COLUMN acdcontract.unitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.unitid IS 'Codigo do campus';


--
-- Name: COLUMN acdcontract.formationdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.formationdate IS 'Data de formatura';


--
-- Name: COLUMN acdcontract.formationperiodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.formationperiodid IS 'Período de formatura';


--
-- Name: COLUMN acdcontract.conclusiondate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.conclusiondate IS 'Data de conclusao';


--
-- Name: COLUMN acdcontract.emendsdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.emendsdate IS 'Data da apostila';


--
-- Name: COLUMN acdcontract.diplomadate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.diplomadate IS 'Data de diploma';


--
-- Name: COLUMN acdcontract.maturityday; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.maturityday IS 'Dia do vencimento';


--
-- Name: COLUMN acdcontract.islistener; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.islistener IS 'Aluno Ouvinte';


--
-- Name: COLUMN acdcontract.isrequestacademicdegree; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.isrequestacademicdegree IS 'Pedido de Grau Acadêmico (Formatura)';


--
-- Name: COLUMN acdcontract.globalaverage; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.globalaverage IS 'Média Global - Ingresso cursos sequenciais';


--
-- Name: COLUMN acdcontract.contractnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.contractnumber IS 'Numero do contrato';


--
-- Name: COLUMN acdcontract.obs; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.obs IS 'Observacao';


--
-- Name: COLUMN acdcontract.parcelsnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.parcelsnumber IS 'Numero de parcelas a serem geredas nas matrículas do aluno';


--
-- Name: COLUMN acdcontract.internalcontractid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.internalcontractid IS 'Codigo do contrato interno';


--
-- Name: COLUMN acdcontract.internalcourseoccurrenceid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.internalcourseoccurrenceid IS 'Codigo interno da ocorrência do curso';


--
-- Name: COLUMN acdcontract.internalcourseoccurrenceversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.internalcourseoccurrenceversion IS 'Codigo interno da ocorrência da versão de curso';


--
-- Name: COLUMN acdcontract.externalcourseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.externalcourseid IS 'Codigo do curso externo';


--
-- Name: COLUMN acdcontract.internalunitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.internalunitid IS 'Codigo da unidade';


--
-- Name: COLUMN acdcontract.internalturnid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.internalturnid IS 'Codigo do turno';


--
-- Name: COLUMN acdcontract.externalconclusionperiod; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.externalconclusionperiod IS 'Período de conclusão do curso externo';


--
-- Name: COLUMN acdcontract.externalconclusioninstitutionid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.externalconclusioninstitutionid IS 'Código da instituição de conclusão externa';


--
-- Name: COLUMN acdcontract.externalconclusiondate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.externalconclusiondate IS 'Data de conclusão';


--
-- Name: COLUMN acdcontract.subscriptionid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontract.subscriptionid IS 'Código da inscrição no processo seletivo.';


--
-- Name: seq_contractexaminingboardid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_contractexaminingboardid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_contractexaminingboardid OWNER TO postgres;

--
-- Name: acdcontractexaminingboard; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcontractexaminingboard (
    contractexaminingboardid integer DEFAULT nextval('seq_contractexaminingboardid'::regclass) NOT NULL,
    contractid integer,
    examiningboarddate date,
    title text,
    professorids integer[],
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acdcontractexaminingboard OWNER TO postgres;

--
-- Name: COLUMN acdcontractexaminingboard.examiningboarddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontractexaminingboard.examiningboarddate IS 'Data em que a banca ira ocorrer';


--
-- Name: COLUMN acdcontractexaminingboard.title; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcontractexaminingboard.title IS 'Título do trabalho da pessoa';


--
-- Name: acdcourse; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcourse (
    courseid character varying(10) NOT NULL,
    formationlevelid integer NOT NULL,
    name text NOT NULL,
    shortname character varying(50) NOT NULL,
    acronym character varying(10),
    centerid integer,
    begindate date,
    moreinfo text,
    enddate date,
    knowledgeareaid integer,
    requirements text,
    obs text,
    reportorder integer,
    educationareaid integer,
    incomesourceid integer,
    enrollbooksequence integer,
    degree text
)
INHERITS (baslog);


ALTER TABLE public.acdcourse OWNER TO postgres;

--
-- Name: TABLE acdcourse; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdcourse IS 'cursos';


--
-- Name: COLUMN acdcourse.courseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourse.courseid IS 'Codigo do curso';


--
-- Name: COLUMN acdcourse.formationlevelid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourse.formationlevelid IS 'Codigo do nivel de formacao (graduacao, tecnico, etc)';


--
-- Name: COLUMN acdcourse.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourse.name IS 'Nome do curso';


--
-- Name: COLUMN acdcourse.shortname; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourse.shortname IS 'Nome suscinto do curso';


--
-- Name: COLUMN acdcourse.acronym; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourse.acronym IS 'Abreviatura';


--
-- Name: COLUMN acdcourse.centerid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourse.centerid IS 'Codigo do centro ao qual o curso pertence';


--
-- Name: COLUMN acdcourse.begindate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourse.begindate IS 'Data de inicio';


--
-- Name: COLUMN acdcourse.moreinfo; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourse.moreinfo IS 'Mais informacoes';


--
-- Name: COLUMN acdcourse.enddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourse.enddate IS 'Data de termino';


--
-- Name: COLUMN acdcourse.knowledgeareaid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourse.knowledgeareaid IS 'Codigo da area de conhecimento';


--
-- Name: COLUMN acdcourse.requirements; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourse.requirements IS 'Exigencias';


--
-- Name: COLUMN acdcourse.obs; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourse.obs IS 'Observacao';


--
-- Name: COLUMN acdcourse.reportorder; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourse.reportorder IS 'Sequencia de ordenação de cursos para relatorios';


--
-- Name: COLUMN acdcourse.educationareaid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourse.educationareaid IS 'Area de ensino';


--
-- Name: COLUMN acdcourse.incomesourceid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourse.incomesourceid IS 'Codigo da origem';


--
-- Name: COLUMN acdcourse.enrollbooksequence; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourse.enrollbooksequence IS 'Número que determina a ordem em que o curso aparecerá no documento do livro matrícula';


--
-- Name: COLUMN acdcourse.degree; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourse.degree IS 'Grau academico. Ex.: Bacharel';


--
-- Name: seq_courseabilityid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_courseabilityid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_courseabilityid OWNER TO postgres;

--
-- Name: acdcourseability; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcourseability (
    courseabilityid integer DEFAULT nextval('seq_courseabilityid'::regclass) NOT NULL,
    courseversion integer NOT NULL,
    courseid character varying(10) NOT NULL,
    description text NOT NULL,
    type character(1) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdcourseability OWNER TO postgres;

--
-- Name: TABLE acdcourseability; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdcourseability IS 'competãªncias de curso';


--
-- Name: COLUMN acdcourseability.courseabilityid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseability.courseabilityid IS 'Codigo da competencia de curso';


--
-- Name: COLUMN acdcourseability.courseversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseability.courseversion IS 'Versao do curso';


--
-- Name: COLUMN acdcourseability.courseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseability.courseid IS 'Codigo do curso';


--
-- Name: COLUMN acdcourseability.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseability.description IS 'Descricao';


--
-- Name: COLUMN acdcourseability.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseability.type IS 'Tipo (Geral (G) ou Especifica (E))';


--
-- Name: acdcoursecoordinator; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcoursecoordinator (
    courseid character varying(10) NOT NULL,
    courseversion integer NOT NULL,
    turnid integer NOT NULL,
    unitid integer NOT NULL,
    coordinatorid integer NOT NULL,
    begindate date,
    enddate date,
    level integer,
    issendemail boolean DEFAULT false NOT NULL,
    email character varying(60),
    expirationlevel interval
)
INHERITS (baslog);


ALTER TABLE public.acdcoursecoordinator OWNER TO postgres;

--
-- Name: TABLE acdcoursecoordinator; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdcoursecoordinator IS 'coordenadores dos cursos';


--
-- Name: COLUMN acdcoursecoordinator.courseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcoursecoordinator.courseid IS 'Codigo do curso';


--
-- Name: COLUMN acdcoursecoordinator.courseversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcoursecoordinator.courseversion IS 'Versao do curso';


--
-- Name: COLUMN acdcoursecoordinator.turnid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcoursecoordinator.turnid IS 'Codigo do turno';


--
-- Name: COLUMN acdcoursecoordinator.unitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcoursecoordinator.unitid IS 'Codigo da unidade';


--
-- Name: COLUMN acdcoursecoordinator.coordinatorid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcoursecoordinator.coordinatorid IS 'Codigo do coordenador do curso';


--
-- Name: COLUMN acdcoursecoordinator.begindate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcoursecoordinator.begindate IS 'Data de inicio da gestao';


--
-- Name: COLUMN acdcoursecoordinator.enddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcoursecoordinator.enddate IS 'Data de fim da gestao';


--
-- Name: COLUMN acdcoursecoordinator.level; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcoursecoordinator.level IS 'Nivel';


--
-- Name: COLUMN acdcoursecoordinator.issendemail; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcoursecoordinator.issendemail IS 'Se recebe/envia e-mail';


--
-- Name: COLUMN acdcoursecoordinator.email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcoursecoordinator.email IS 'E-mail do coordenador';


--
-- Name: COLUMN acdcoursecoordinator.expirationlevel; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcoursecoordinator.expirationlevel IS 'Nivel de expiracao';


--
-- Name: acdcourseoccurrence; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcourseoccurrence (
    courseid character varying(10) NOT NULL,
    courseversion integer NOT NULL,
    turnid integer NOT NULL,
    unitid integer NOT NULL,
    authorizationdate date,
    authorizationdocument text,
    status boolean DEFAULT true NOT NULL,
    minimumconclusioncourse double precision,
    maximumconclusioncourse double precision,
    costcenterid character varying(30),
    daystofrequencenotification integer,
    idcursoinep character varying(9),
    vagasinep integer
)
INHERITS (baslog);


ALTER TABLE public.acdcourseoccurrence OWNER TO postgres;

--
-- Name: TABLE acdcourseoccurrence; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdcourseoccurrence IS 'ocorrencia de curso';


--
-- Name: COLUMN acdcourseoccurrence.courseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseoccurrence.courseid IS 'Codigo do curso';


--
-- Name: COLUMN acdcourseoccurrence.courseversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseoccurrence.courseversion IS 'Versao do curso';


--
-- Name: COLUMN acdcourseoccurrence.turnid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseoccurrence.turnid IS 'Codigo do turno';


--
-- Name: COLUMN acdcourseoccurrence.unitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseoccurrence.unitid IS 'Codigo da unidade';


--
-- Name: COLUMN acdcourseoccurrence.authorizationdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseoccurrence.authorizationdate IS 'Data de autorizacao';


--
-- Name: COLUMN acdcourseoccurrence.authorizationdocument; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseoccurrence.authorizationdocument IS 'Documento de autorizacao';


--
-- Name: COLUMN acdcourseoccurrence.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseoccurrence.status IS 'Estado (Ativo (true) ou Inativo (false))';


--
-- Name: COLUMN acdcourseoccurrence.minimumconclusioncourse; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseoccurrence.minimumconclusioncourse IS 'Prazo mínimo para conclusão de Curso';


--
-- Name: COLUMN acdcourseoccurrence.maximumconclusioncourse; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseoccurrence.maximumconclusioncourse IS 'Prazo máximo para conclusão de curso. Se este campo for preenchido ativa o esquema de jubilamento';


--
-- Name: COLUMN acdcourseoccurrence.daystofrequencenotification; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseoccurrence.daystofrequencenotification IS 'Informa  o prazo (em dias) para registro de frequências';


--
-- Name: seq_courseparentid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_courseparentid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_courseparentid OWNER TO postgres;

--
-- Name: acdcourseparent; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcourseparent (
    courseparentid integer DEFAULT nextval('seq_courseparentid'::regclass) NOT NULL,
    courseid character varying(10) NOT NULL,
    courseversion integer NOT NULL,
    turnid integer NOT NULL,
    unitid integer NOT NULL,
    parentcourseid character varying(10) NOT NULL,
    parentcourseversion integer NOT NULL,
    parentturnid integer NOT NULL,
    parentunitid integer NOT NULL,
    parentcurricularcomponentsperiod integer
)
INHERITS (baslog);


ALTER TABLE public.acdcourseparent OWNER TO postgres;

--
-- Name: TABLE acdcourseparent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdcourseparent IS 'Cadastro do complemento de matriz curricular';


--
-- Name: COLUMN acdcourseparent.courseparentid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseparent.courseparentid IS 'Código do complemento de matriz curricular';


--
-- Name: COLUMN acdcourseparent.courseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseparent.courseid IS 'Código do curso';


--
-- Name: COLUMN acdcourseparent.courseversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseparent.courseversion IS 'Versão do curso';


--
-- Name: COLUMN acdcourseparent.turnid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseparent.turnid IS 'Turno do curso';


--
-- Name: COLUMN acdcourseparent.unitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseparent.unitid IS 'Unidade do curso';


--
-- Name: COLUMN acdcourseparent.parentcourseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseparent.parentcourseid IS 'Código do curso complementar';


--
-- Name: COLUMN acdcourseparent.parentcourseversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseparent.parentcourseversion IS 'Versão do curso complementar';


--
-- Name: COLUMN acdcourseparent.parentturnid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseparent.parentturnid IS 'Turno do curso complementar';


--
-- Name: COLUMN acdcourseparent.parentunitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseparent.parentunitid IS 'Unidade do curso complementar';


--
-- Name: COLUMN acdcourseparent.parentcurricularcomponentsperiod; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseparent.parentcurricularcomponentsperiod IS 'Ordem complementar';


--
-- Name: acdcourseversion; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcourseversion (
    courseversion integer NOT NULL,
    courseid character varying(10) NOT NULL,
    courseversiontypeid integer NOT NULL,
    begindate date,
    enddate date,
    periodtotal integer,
    credits double precision,
    hourtotal double precision,
    hourrequired double precision,
    perioddescription character varying(30) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdcourseversion OWNER TO postgres;

--
-- Name: TABLE acdcourseversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdcourseversion IS 'versao do curso';


--
-- Name: COLUMN acdcourseversion.courseversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseversion.courseversion IS 'Versao do curso';


--
-- Name: COLUMN acdcourseversion.courseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseversion.courseid IS 'Codigo do curso';


--
-- Name: COLUMN acdcourseversion.courseversiontypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseversion.courseversiontypeid IS 'Codigo para o tipo de versao de curso';


--
-- Name: COLUMN acdcourseversion.begindate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseversion.begindate IS 'Data de inicio';


--
-- Name: COLUMN acdcourseversion.enddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseversion.enddate IS 'Data de termino';


--
-- Name: COLUMN acdcourseversion.periodtotal; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseversion.periodtotal IS 'Total de perÃ­odos da matriz curricular';


--
-- Name: COLUMN acdcourseversion.credits; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseversion.credits IS 'Numero de creditos';


--
-- Name: COLUMN acdcourseversion.hourtotal; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseversion.hourtotal IS 'Carga horaria total';


--
-- Name: COLUMN acdcourseversion.hourrequired; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseversion.hourrequired IS 'Carga horaria exigida';


--
-- Name: COLUMN acdcourseversion.perioddescription; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseversion.perioddescription IS 'Descrição de subdivisão do curso (semestre, período, ano, série, etc)';


--
-- Name: seq_courseversiontypeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_courseversiontypeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_courseversiontypeid OWNER TO postgres;

--
-- Name: acdcourseversiontype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcourseversiontype (
    courseversiontypeid integer DEFAULT nextval('seq_courseversiontypeid'::regclass) NOT NULL,
    description text NOT NULL,
    regimen character(1),
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acdcourseversiontype OWNER TO postgres;

--
-- Name: TABLE acdcourseversiontype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdcourseversiontype IS 'tipo de curso - credito, seriado semestral, anual';


--
-- Name: COLUMN acdcourseversiontype.courseversiontypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseversiontype.courseversiontypeid IS 'Codigo do tipo de versao';


--
-- Name: COLUMN acdcourseversiontype.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcourseversiontype.description IS 'Descricao';


--
-- Name: acdcurricularcomponent; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcurricularcomponent (
    curricularcomponentid character varying NOT NULL,
    curricularcomponentversion integer NOT NULL,
    centerid integer,
    name text NOT NULL,
    shortname character varying(80) NOT NULL,
    summary text,
    academiccredits double precision NOT NULL,
    lessoncredits double precision NOT NULL,
    academicnumberhours double precision NOT NULL,
    lessonnumberhours double precision NOT NULL,
    begindate date,
    enddate date,
    educationareaid integer
)
INHERITS (baslog);


ALTER TABLE public.acdcurricularcomponent OWNER TO postgres;

--
-- Name: TABLE acdcurricularcomponent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdcurricularcomponent IS 'componente curricular - disciplina';


--
-- Name: COLUMN acdcurricularcomponent.curricularcomponentid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponent.curricularcomponentid IS 'Codigo do componente curricular';


--
-- Name: COLUMN acdcurricularcomponent.curricularcomponentversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponent.curricularcomponentversion IS 'Versao do componente curricular';


--
-- Name: COLUMN acdcurricularcomponent.centerid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponent.centerid IS 'Codigo do centro do componente curricular';


--
-- Name: COLUMN acdcurricularcomponent.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponent.name IS 'Nome';


--
-- Name: COLUMN acdcurricularcomponent.shortname; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponent.shortname IS 'Nome suscinto';


--
-- Name: COLUMN acdcurricularcomponent.summary; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponent.summary IS 'Ementa';


--
-- Name: COLUMN acdcurricularcomponent.academiccredits; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponent.academiccredits IS 'Número de créditos acadêmicos, de acordo como está no projeto pedagógico';


--
-- Name: COLUMN acdcurricularcomponent.lessoncredits; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponent.lessoncredits IS 'Número de créditos aula, que deve sair no registro de notas e caderno de chamada';


--
-- Name: COLUMN acdcurricularcomponent.academicnumberhours; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponent.academicnumberhours IS 'Carga horaria academica';


--
-- Name: COLUMN acdcurricularcomponent.lessonnumberhours; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponent.lessonnumberhours IS 'Carga horaria em aulas';


--
-- Name: COLUMN acdcurricularcomponent.begindate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponent.begindate IS 'Data de inicio';


--
-- Name: COLUMN acdcurricularcomponent.enddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponent.enddate IS 'Data de termino';


--
-- Name: COLUMN acdcurricularcomponent.educationareaid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponent.educationareaid IS 'Codigo da area de ensino';


--
-- Name: acdcurricularcomponentcategorycredit; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcurricularcomponentcategorycredit (
    curricularcomponentcategorycreditid integer NOT NULL,
    curricularcomponentid character varying NOT NULL,
    curricularcomponentversion integer NOT NULL,
    curricularcomponentcategoryid character varying(10) NOT NULL,
    credits double precision NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdcurricularcomponentcategorycredit OWNER TO postgres;

--
-- Name: acdcurricularcomponentcategor_curricularcomponentcategorycr_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acdcurricularcomponentcategor_curricularcomponentcategorycr_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acdcurricularcomponentcategor_curricularcomponentcategorycr_seq OWNER TO postgres;

--
-- Name: acdcurricularcomponentcategor_curricularcomponentcategorycr_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acdcurricularcomponentcategor_curricularcomponentcategorycr_seq OWNED BY acdcurricularcomponentcategorycredit.curricularcomponentcategorycreditid;


--
-- Name: acdcurricularcomponentcategory; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcurricularcomponentcategory (
    curricularcomponentcategoryid character varying(10) NOT NULL,
    description character varying NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdcurricularcomponentcategory OWNER TO postgres;

--
-- Name: seq_curricularcomponentgroupid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_curricularcomponentgroupid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_curricularcomponentgroupid OWNER TO postgres;

--
-- Name: acdcurricularcomponentgroup; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcurricularcomponentgroup (
    curricularcomponentgroupid integer DEFAULT nextval('seq_curricularcomponentgroupid'::regclass) NOT NULL,
    name text NOT NULL,
    shortname character varying(100) NOT NULL,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acdcurricularcomponentgroup OWNER TO postgres;

--
-- Name: TABLE acdcurricularcomponentgroup; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdcurricularcomponentgroup IS 'grupo da disciplina';


--
-- Name: COLUMN acdcurricularcomponentgroup.curricularcomponentgroupid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponentgroup.curricularcomponentgroupid IS 'Codigo do grupo';


--
-- Name: COLUMN acdcurricularcomponentgroup.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponentgroup.name IS 'Nome';


--
-- Name: COLUMN acdcurricularcomponentgroup.shortname; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponentgroup.shortname IS 'Nome suscinto';


--
-- Name: seq_curricularcomponenttypeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_curricularcomponenttypeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_curricularcomponenttypeid OWNER TO postgres;

--
-- Name: acdcurricularcomponenttype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcurricularcomponenttype (
    curricularcomponenttypeid integer DEFAULT nextval('seq_curricularcomponenttypeid'::regclass) NOT NULL,
    description text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdcurricularcomponenttype OWNER TO postgres;

--
-- Name: TABLE acdcurricularcomponenttype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdcurricularcomponenttype IS 'tipos de disciplina - normal, intensivo, distã¢ncia, estã¡gio, regime especial';


--
-- Name: COLUMN acdcurricularcomponenttype.curricularcomponenttypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponenttype.curricularcomponenttypeid IS 'Codigo do tipo de disciplina';


--
-- Name: COLUMN acdcurricularcomponenttype.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponenttype.description IS 'Descricao';


--
-- Name: seq_curricularcomponentunblockid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_curricularcomponentunblockid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_curricularcomponentunblockid OWNER TO postgres;

--
-- Name: acdcurricularcomponentunblock; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcurricularcomponentunblock (
    curricularcomponentunblockid integer DEFAULT nextval('seq_curricularcomponentunblockid'::regclass) NOT NULL,
    learningperiodid integer NOT NULL,
    contractid integer NOT NULL,
    curriculumid integer,
    curricularcomponentid character varying,
    curricularcomponentversion integer,
    isconditionbreak boolean DEFAULT false NOT NULL,
    issubstituted boolean DEFAULT false NOT NULL,
    isscheduleshock boolean DEFAULT false NOT NULL,
    isoutofcurriculum boolean DEFAULT false NOT NULL,
    flminimumcredits boolean DEFAULT false NOT NULL,
    flminimumturn boolean DEFAULT false NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdcurricularcomponentunblock OWNER TO postgres;

--
-- Name: TABLE acdcurricularcomponentunblock; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdcurricularcomponentunblock IS 'desbloqueios de disciplinas';


--
-- Name: COLUMN acdcurricularcomponentunblock.curricularcomponentunblockid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponentunblock.curricularcomponentunblockid IS 'Codigo do desbloqueio';


--
-- Name: COLUMN acdcurricularcomponentunblock.learningperiodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponentunblock.learningperiodid IS 'Codigo do periodo letivo em que o desbloqueio ocorre';


--
-- Name: COLUMN acdcurricularcomponentunblock.contractid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponentunblock.contractid IS 'Codigo do contrato ao qual o desbloqueio se aplica';


--
-- Name: COLUMN acdcurricularcomponentunblock.curriculumid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponentunblock.curriculumid IS 'Codigo da disciplina do curriculo do aluno';


--
-- Name: COLUMN acdcurricularcomponentunblock.curricularcomponentid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponentunblock.curricularcomponentid IS 'Codigo da disciplina a ser cursada no lugar da disciplina do currículo';


--
-- Name: COLUMN acdcurricularcomponentunblock.curricularcomponentversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponentunblock.curricularcomponentversion IS 'Versao da disciplina a ser cursada no lugar da disciplina do curriculo';


--
-- Name: COLUMN acdcurricularcomponentunblock.isconditionbreak; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponentunblock.isconditionbreak IS 'Não checa requisitos da disciplina do currículo';


--
-- Name: COLUMN acdcurricularcomponentunblock.issubstituted; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponentunblock.issubstituted IS 'Permite que seja cursada uma outra disciplina (curricularComponentId) no lugar da disciplina do currículo (curriculumId)';


--
-- Name: COLUMN acdcurricularcomponentunblock.isscheduleshock; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponentunblock.isscheduleshock IS 'Permite que a disciplina do curriculo (curriculumId) seja cursada em paralelo (mesmo horario) que outra';


--
-- Name: COLUMN acdcurricularcomponentunblock.isoutofcurriculum; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponentunblock.isoutofcurriculum IS 'Permite cursar uma disciplina fora do curriculo';


--
-- Name: COLUMN acdcurricularcomponentunblock.flminimumcredits; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponentunblock.flminimumcredits IS 'Liberação do limite de créditos - para calouro e veterenos';


--
-- Name: COLUMN acdcurricularcomponentunblock.flminimumturn; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurricularcomponentunblock.flminimumturn IS 'Liberação para cursar disciplinas em outro turno que nao o do curso';


--
-- Name: seq_curriculumid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_curriculumid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_curriculumid OWNER TO postgres;

--
-- Name: acdcurriculum; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcurriculum (
    curriculumid integer DEFAULT nextval('seq_curriculumid'::regclass) NOT NULL,
    courseid character varying(10) NOT NULL,
    courseversion integer NOT NULL,
    turnid integer NOT NULL,
    unitid integer NOT NULL,
    curricularcomponentid character varying NOT NULL,
    curricularcomponentversion integer NOT NULL,
    curricularcomponenttypeid integer NOT NULL,
    semester integer NOT NULL,
    showinscholarshipdescription boolean DEFAULT true NOT NULL,
    curricularcomponentgroupdocumentendcourseid integer NOT NULL,
    curricularcomponentgroupelectiveid integer,
    curriculumtypeid integer NOT NULL,
    enddate date,
    showinbulletin boolean DEFAULT true NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdcurriculum OWNER TO postgres;

--
-- Name: TABLE acdcurriculum; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdcurriculum IS 'curriculo de curso';


--
-- Name: COLUMN acdcurriculum.curriculumid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurriculum.curriculumid IS 'Codigo da disciplina do curriculo';


--
-- Name: COLUMN acdcurriculum.courseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurriculum.courseid IS 'Codigo do curso';


--
-- Name: COLUMN acdcurriculum.courseversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurriculum.courseversion IS 'Versao do curso';


--
-- Name: COLUMN acdcurriculum.turnid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurriculum.turnid IS 'Codigo do turno';


--
-- Name: COLUMN acdcurriculum.unitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurriculum.unitid IS 'Codigo da unidade';


--
-- Name: COLUMN acdcurriculum.curricularcomponentid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurriculum.curricularcomponentid IS 'Codigo da disciplina presente no curriculo';


--
-- Name: COLUMN acdcurriculum.curricularcomponentversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurriculum.curricularcomponentversion IS 'Versao da disciplina presente no curriculo';


--
-- Name: COLUMN acdcurriculum.curricularcomponenttypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurriculum.curricularcomponenttypeid IS 'Tipo da disciplina no currículo - Eletiva, estágio, normal...';


--
-- Name: COLUMN acdcurriculum.semester; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurriculum.semester IS 'Semestre previsto para que o aluno curse a disciplina';


--
-- Name: COLUMN acdcurriculum.showinscholarshipdescription; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurriculum.showinscholarshipdescription IS 'Exibida no histórico escolar';


--
-- Name: COLUMN acdcurriculum.curricularcomponentgroupdocumentendcourseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurriculum.curricularcomponentgroupdocumentendcourseid IS 'Grupo de disciplina que vai no histórico final';


--
-- Name: COLUMN acdcurriculum.curricularcomponentgroupelectiveid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurriculum.curricularcomponentgroupelectiveid IS 'Grupo de disciplina para autorizar a matricula em eletivas (deste grupo)';


--
-- Name: COLUMN acdcurriculum.curriculumtypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurriculum.curriculumtypeid IS 'Tipo de curriculo - antigo currículo MCO';


--
-- Name: COLUMN acdcurriculum.enddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurriculum.enddate IS 'Data que a disciplina deixa de fazer parte do currículo';


--
-- Name: COLUMN acdcurriculum.showinbulletin; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurriculum.showinbulletin IS 'Exibe as informações no boletim';


--
-- Name: acdcurriculumconcurrence; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcurriculumconcurrence (
    curriculumoutid integer NOT NULL,
    curriculuminid integer NOT NULL,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acdcurriculumconcurrence OWNER TO postgres;

--
-- Name: TABLE acdcurriculumconcurrence; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdcurriculumconcurrence IS 'disciplinas concorrentes, ou seja, apenas uma delas podera ser cursada pelo aluno';


--
-- Name: COLUMN acdcurriculumconcurrence.curriculumoutid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurriculumconcurrence.curriculumoutid IS 'Disciplina que ao ser cursada impede a outra (curriculumInId) de ser cursada';


--
-- Name: COLUMN acdcurriculumconcurrence.curriculuminid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurriculumconcurrence.curriculuminid IS 'Disciplina que nao podera ser cursada se a outra (curriculumOutId) for cursada';


--
-- Name: acdcurriculumlink; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcurriculumlink (
    curriculumid integer NOT NULL,
    curriculumlinkid integer NOT NULL,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acdcurriculumlink OWNER TO postgres;

--
-- Name: TABLE acdcurriculumlink; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdcurriculumlink IS 'ligaã§ã£o de uma disciplina que deixou o currã­culo com a(s) sua(s) substituta(s)';


--
-- Name: COLUMN acdcurriculumlink.curriculumid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurriculumlink.curriculumid IS 'Disciplina que deixou de existir';


--
-- Name: COLUMN acdcurriculumlink.curriculumlinkid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurriculumlink.curriculumlinkid IS 'Disciplina(s) que entraram';


--
-- Name: seq_curriculumtypeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_curriculumtypeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_curriculumtypeid OWNER TO postgres;

--
-- Name: acdcurriculumtype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdcurriculumtype (
    curriculumtypeid integer DEFAULT nextval('seq_curriculumtypeid'::regclass) NOT NULL,
    description text NOT NULL,
    shortdescription character varying(10) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdcurriculumtype OWNER TO postgres;

--
-- Name: TABLE acdcurriculumtype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdcurriculumtype IS 'tipos de currã­culo - mã­nimo, complementar, optativa, ativid. complementar, proficiencia, ...';


--
-- Name: COLUMN acdcurriculumtype.curriculumtypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurriculumtype.curriculumtypeid IS 'Codigo do tipo de curriculo - antigo Grupos de Disciplinas';


--
-- Name: COLUMN acdcurriculumtype.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurriculumtype.description IS 'Descricao';


--
-- Name: COLUMN acdcurriculumtype.shortdescription; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdcurriculumtype.shortdescription IS 'Descricao suscinta';


--
-- Name: acddegreecurricularcomponentgroup; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acddegreecurricularcomponentgroup (
    degreecurricularcomponentgroupid integer NOT NULL,
    learningperiodid integer NOT NULL,
    contractid integer NOT NULL,
    curricularcomponentgroupid integer NOT NULL,
    note double precision,
    concept character varying(15),
    description text,
    enrollstatusid integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acddegreecurricularcomponentgroup OWNER TO postgres;

--
-- Name: TABLE acddegreecurricularcomponentgroup; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acddegreecurricularcomponentgroup IS 'Tabela responsável por armazenar as notas dos alunos por grupo de disciplinas';


--
-- Name: COLUMN acddegreecurricularcomponentgroup.degreecurricularcomponentgroupid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddegreecurricularcomponentgroup.degreecurricularcomponentgroupid IS 'Código identificador';


--
-- Name: COLUMN acddegreecurricularcomponentgroup.learningperiodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddegreecurricularcomponentgroup.learningperiodid IS 'Código identificador do período letivo';


--
-- Name: COLUMN acddegreecurricularcomponentgroup.contractid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddegreecurricularcomponentgroup.contractid IS 'Código identificador do contrato do aluno';


--
-- Name: COLUMN acddegreecurricularcomponentgroup.curricularcomponentgroupid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddegreecurricularcomponentgroup.curricularcomponentgroupid IS 'Código identificador do grupo de disciplinas';


--
-- Name: COLUMN acddegreecurricularcomponentgroup.note; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddegreecurricularcomponentgroup.note IS 'Nota do aluno';


--
-- Name: COLUMN acddegreecurricularcomponentgroup.concept; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddegreecurricularcomponentgroup.concept IS 'Conceito do aluno';


--
-- Name: COLUMN acddegreecurricularcomponentgroup.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddegreecurricularcomponentgroup.description IS 'Descrição da nota';


--
-- Name: COLUMN acddegreecurricularcomponentgroup.enrollstatusid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddegreecurricularcomponentgroup.enrollstatusid IS 'Estado atual do aluno no grupo de disciplinas';


--
-- Name: acddegreecurricularcomponentg_degreecurricularcomponentgrou_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acddegreecurricularcomponentg_degreecurricularcomponentgrou_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acddegreecurricularcomponentg_degreecurricularcomponentgrou_seq OWNER TO postgres;

--
-- Name: acddegreecurricularcomponentg_degreecurricularcomponentgrou_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acddegreecurricularcomponentg_degreecurricularcomponentgrou_seq OWNED BY acddegreecurricularcomponentgroup.degreecurricularcomponentgroupid;


--
-- Name: seq_degreeenrollid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_degreeenrollid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_degreeenrollid OWNER TO postgres;

--
-- Name: acddegreeenroll; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acddegreeenroll (
    degreeid integer NOT NULL,
    enrollid integer NOT NULL,
    note double precision,
    concept character varying(15),
    description text,
    degreeenrollid integer DEFAULT nextval('seq_degreeenrollid'::regclass) NOT NULL,
    recorddate timestamp without time zone DEFAULT now() NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acddegreeenroll OWNER TO postgres;

--
-- Name: TABLE acddegreeenroll; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acddegreeenroll IS 'notas dos graus para cada matricula';


--
-- Name: COLUMN acddegreeenroll.degreeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddegreeenroll.degreeid IS 'Codigo do grau';


--
-- Name: COLUMN acddegreeenroll.enrollid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddegreeenroll.enrollid IS 'Codigo da matricula';


--
-- Name: COLUMN acddegreeenroll.note; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddegreeenroll.note IS 'Nota';


--
-- Name: COLUMN acddegreeenroll.concept; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddegreeenroll.concept IS 'Conceito';


--
-- Name: COLUMN acddegreeenroll.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddegreeenroll.description IS 'Descritivo';


--
-- Name: acddetailenrollstatus; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acddetailenrollstatus (
    detailenrollstatusid integer NOT NULL,
    shortdescription character varying NOT NULL,
    description character varying NOT NULL,
    parentstatus integer NOT NULL,
    isexam boolean DEFAULT false,
    defaultstatus boolean
)
INHERITS (baslog);


ALTER TABLE public.acddetailenrollstatus OWNER TO postgres;

--
-- Name: acddetailenrollstatus_detailenrollstatusid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acddetailenrollstatus_detailenrollstatusid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acddetailenrollstatus_detailenrollstatusid_seq OWNER TO postgres;

--
-- Name: acddetailenrollstatus_detailenrollstatusid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acddetailenrollstatus_detailenrollstatusid_seq OWNED BY acddetailenrollstatus.detailenrollstatusid;


--
-- Name: acddiploma; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acddiploma (
    registernumber integer NOT NULL,
    contractid integer NOT NULL,
    sheet integer NOT NULL,
    book character varying(20) NOT NULL,
    protocolid character varying(20),
    emissiondate date DEFAULT date(now()) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acddiploma OWNER TO postgres;

--
-- Name: TABLE acddiploma; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acddiploma IS 'emissao de diplomas';


--
-- Name: COLUMN acddiploma.registernumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddiploma.registernumber IS 'Numero de registro';


--
-- Name: COLUMN acddiploma.contractid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddiploma.contractid IS 'Contrato';


--
-- Name: COLUMN acddiploma.sheet; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddiploma.sheet IS 'Folha';


--
-- Name: COLUMN acddiploma.book; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddiploma.book IS 'Livro';


--
-- Name: COLUMN acddiploma.protocolid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddiploma.protocolid IS 'Numero do processo';


--
-- Name: COLUMN acddiploma.emissiondate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acddiploma.emissiondate IS 'Data de emissão';


--
-- Name: seq_educationareaid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_educationareaid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_educationareaid OWNER TO postgres;

--
-- Name: acdeducationarea; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdeducationarea (
    educationareaid integer DEFAULT nextval('seq_educationareaid'::regclass) NOT NULL,
    description text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdeducationarea OWNER TO postgres;

--
-- Name: TABLE acdeducationarea; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdeducationarea IS 'areas de ensino';


--
-- Name: COLUMN acdeducationarea.educationareaid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdeducationarea.educationareaid IS 'Codigo da area de ensino';


--
-- Name: COLUMN acdeducationarea.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdeducationarea.description IS 'Descricao';


--
-- Name: acdelection; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdelection (
    electiondate date NOT NULL,
    description text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdelection OWNER TO postgres;

--
-- Name: TABLE acdelection; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdelection IS 'eleiã§ãµes';


--
-- Name: COLUMN acdelection.electiondate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdelection.electiondate IS 'Data da eleicao';


--
-- Name: COLUMN acdelection.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdelection.description IS 'Descricao';


--
-- Name: seq_enadestatusid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_enadestatusid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_enadestatusid OWNER TO postgres;

--
-- Name: acdenadestatus; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdenadestatus (
    enadestatusid integer DEFAULT nextval('seq_enadestatusid'::regclass) NOT NULL,
    description character varying(30)
)
INHERITS (baslog);


ALTER TABLE public.acdenadestatus OWNER TO postgres;

--
-- Name: TABLE acdenadestatus; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdenadestatus IS 'Situações possíveis para status de ENADE para os alunos';


--
-- Name: seq_enrollid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_enrollid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_enrollid OWNER TO postgres;

--
-- Name: acdenroll; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdenroll (
    enrollid integer DEFAULT nextval('seq_enrollid'::regclass) NOT NULL,
    contractid integer NOT NULL,
    groupid integer,
    curriculumid integer,
    dateenroll date,
    hourenroll time without time zone,
    datecancellation date,
    hourcancellation time without time zone,
    reasoncancellationid integer,
    note double precision,
    examnote double precision,
    finalnote double precision,
    concept text,
    textevaluation text,
    frequency double precision,
    obsexploitation text,
    exploitationinstitutionid integer,
    numberhourexploitation double precision,
    creditsexploitation double precision,
    isshowdocumentendcourse boolean DEFAULT false NOT NULL,
    statusid integer NOT NULL,
    frequencyalertemail character(1) DEFAULT '0'::bpchar,
    isinternet boolean DEFAULT false NOT NULL,
    ip inet,
    isconfirm boolean DEFAULT false NOT NULL,
    issetfree boolean DEFAULT false NOT NULL,
    complement text,
    exploitationtype character(1),
    process text,
    isexploitation boolean DEFAULT false NOT NULL,
    learningperiodid integer,
    subclassid character varying(20),
    finalexaminationtheme text,
    detailenrollstatusid integer,
    preenrollconsumevacant boolean,
    unitid integer,
    examiningboard date
)
INHERITS (baslog);


ALTER TABLE public.acdenroll OWNER TO postgres;

--
-- Name: TABLE acdenroll; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdenroll IS 'matriculas';


--
-- Name: COLUMN acdenroll.enrollid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.enrollid IS 'Codigo da matricula';


--
-- Name: COLUMN acdenroll.contractid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.contractid IS 'Codigo do contrato';


--
-- Name: COLUMN acdenroll.groupid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.groupid IS 'Codigo da turma';


--
-- Name: COLUMN acdenroll.curriculumid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.curriculumid IS 'Codigo da disciplina do curriculo';


--
-- Name: COLUMN acdenroll.dateenroll; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.dateenroll IS 'Data da matricula';


--
-- Name: COLUMN acdenroll.hourenroll; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.hourenroll IS 'Hora da matricula';


--
-- Name: COLUMN acdenroll.datecancellation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.datecancellation IS 'Data de cancelamento';


--
-- Name: COLUMN acdenroll.hourcancellation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.hourcancellation IS 'Hora de cancelamento';


--
-- Name: COLUMN acdenroll.reasoncancellationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.reasoncancellationid IS 'Motivo do cancelamento da matricula';


--
-- Name: COLUMN acdenroll.note; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.note IS 'Nota - media dos graus';


--
-- Name: COLUMN acdenroll.examnote; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.examnote IS 'Nota do exame';


--
-- Name: COLUMN acdenroll.finalnote; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.finalnote IS 'Nota final';


--
-- Name: COLUMN acdenroll.concept; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.concept IS 'Conceito';


--
-- Name: COLUMN acdenroll.textevaluation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.textevaluation IS 'Parecer - Texto de Avaliação';


--
-- Name: COLUMN acdenroll.frequency; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.frequency IS 'Total de frequência do aluno nesta disciplina até o momento (em horas).';


--
-- Name: COLUMN acdenroll.obsexploitation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.obsexploitation IS 'Aproveitamento';


--
-- Name: COLUMN acdenroll.exploitationinstitutionid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.exploitationinstitutionid IS 'Instituicao da disciplina aproveitada';


--
-- Name: COLUMN acdenroll.numberhourexploitation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.numberhourexploitation IS 'Carga horaria aproveitada';


--
-- Name: COLUMN acdenroll.creditsexploitation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.creditsexploitation IS 'Creditos aproveitados';


--
-- Name: COLUMN acdenroll.isshowdocumentendcourse; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.isshowdocumentendcourse IS 'Aparece no documento final do curso';


--
-- Name: COLUMN acdenroll.statusid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.statusid IS 'Estado atual nesta disciplina: Matriculado, dispensado, reprovado, aprovado ou desistente';


--
-- Name: COLUMN acdenroll.frequencyalertemail; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.frequencyalertemail IS 'Email de alerta de frequencia: 0 - Não teve aviso; 1 - Teve um aviso (alerta) que está chegando no limite de faltas; 2 - Aviso de limite de faltas';


--
-- Name: COLUMN acdenroll.isinternet; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.isinternet IS 'Matricula feita pela internet (true)';


--
-- Name: COLUMN acdenroll.ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.ip IS 'Ip da maquina que o aluno fez a matricula - pode ser diferente do ip da baslog pois aquele é sempre o ultimo.';


--
-- Name: COLUMN acdenroll.isconfirm; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.isconfirm IS 'Confirmação de Matricula';


--
-- Name: COLUMN acdenroll.issetfree; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.issetfree IS 'Marcar as disciplinas que foram desbloqueadas como true';


--
-- Name: COLUMN acdenroll.complement; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.complement IS 'Complemento da disciplina oferecida. É o foco da disciplina no semestre.';


--
-- Name: COLUMN acdenroll.exploitationtype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.exploitationtype IS 'Flag de aproveitamos I (In) = Interno ou E (external) = Externo';


--
-- Name: COLUMN acdenroll.process; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.process IS 'campo para futuramente ser substituido pelo protocolId. receberá as observações de provas especiais etc';


--
-- Name: COLUMN acdenroll.isexploitation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.isexploitation IS 'Indica se o registro atual eh (TRUE) ou nao (FALSE) um aproveitamento, isto eh, possui registros na acdExploitation.';


--
-- Name: COLUMN acdenroll.learningperiodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.learningperiodid IS 'Informa o periodo letivo ao qual o aproveitamento pertence. Nos registros que nao forem aproveitamento, este campo eh nulo.';


--
-- Name: COLUMN acdenroll.finalexaminationtheme; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.finalexaminationtheme IS 'Tema do exame final (TCC), utilizado no Detalhamento do TCC';


--
-- Name: COLUMN acdenroll.preenrollconsumevacant; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.preenrollconsumevacant IS 'Define se esta matricula deve consumir vaga ou nao. Isto e utilizado APENAS como uma flag para auxiliar na identificacao na trigger/funcao PLPGSQL setTotalEnrolled(), afim de otimizar consultas.';


--
-- Name: COLUMN acdenroll.examiningboard; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenroll.examiningboard IS 'Data da banca examinadora';


--
-- Name: acdenrollbookdata; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdenrollbookdata (
    personid bigint NOT NULL,
    courseid character varying(10) NOT NULL,
    courseversion integer NOT NULL,
    unitid integer NOT NULL,
    turnid integer NOT NULL,
    prevcourseid character varying(10),
    prevcourseversion integer,
    prevunitid integer,
    prevturnid integer,
    stateenrollbookid integer NOT NULL,
    periodid character varying(10) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdenrollbookdata OWNER TO postgres;

--
-- Name: TABLE acdenrollbookdata; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdenrollbookdata IS 'tabela para armazenar os dados do livro matrã­cula';


--
-- Name: COLUMN acdenrollbookdata.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollbookdata.personid IS 'Codigo da pessoa';


--
-- Name: COLUMN acdenrollbookdata.courseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollbookdata.courseid IS 'Codigo do curso';


--
-- Name: COLUMN acdenrollbookdata.courseversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollbookdata.courseversion IS 'Versao do curso';


--
-- Name: COLUMN acdenrollbookdata.unitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollbookdata.unitid IS 'Codigo da unidade';


--
-- Name: COLUMN acdenrollbookdata.turnid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollbookdata.turnid IS 'Codigo do turno';


--
-- Name: COLUMN acdenrollbookdata.prevcourseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollbookdata.prevcourseid IS 'Referencia o curso anterior (para os casos de transferência interna)';


--
-- Name: COLUMN acdenrollbookdata.prevcourseversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollbookdata.prevcourseversion IS 'Referencia a versão de curso anterior';


--
-- Name: COLUMN acdenrollbookdata.prevunitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollbookdata.prevunitid IS 'Referencia a unidade anterior';


--
-- Name: COLUMN acdenrollbookdata.prevturnid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollbookdata.prevturnid IS 'Referencia o turno anterior';


--
-- Name: COLUMN acdenrollbookdata.stateenrollbookid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollbookdata.stateenrollbookid IS 'Estado do livro matricula: rematricula, vestibulando, transferencia interna, trancamento, reingresso, etc.';


--
-- Name: COLUMN acdenrollbookdata.periodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollbookdata.periodid IS 'Codigo do periodo';


--
-- Name: seq_enrollconfigid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_enrollconfigid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_enrollconfigid OWNER TO postgres;

--
-- Name: acdenrollconfig; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdenrollconfig (
    enrollconfigid integer DEFAULT nextval('seq_enrollconfigid'::regclass) NOT NULL,
    courseid character varying(10),
    courseversion integer,
    turnid integer,
    unitid integer,
    freeincourseconditions boolean DEFAULT true NOT NULL,
    timetocoursedisapproved integer DEFAULT 0 NOT NULL,
    showelectives boolean DEFAULT true NOT NULL,
    showoptionals boolean DEFAULT true NOT NULL,
    blockdebt boolean DEFAULT true NOT NULL,
    sendconfirmationemail boolean DEFAULT false NOT NULL,
    confirmationemailid integer,
    showothercoursesgroups boolean DEFAULT true NOT NULL,
    showotherunitsgroups boolean DEFAULT true NOT NULL,
    showotherturnsgroups boolean DEFAULT true NOT NULL,
    showspecialregimengroups boolean DEFAULT true NOT NULL,
    showotherclassesgroups boolean DEFAULT false NOT NULL,
    freeotherperiodgroups boolean DEFAULT true NOT NULL,
    disapprovementstoblock integer DEFAULT 0 NOT NULL,
    maychoosegroups boolean DEFAULT false NOT NULL,
    checkscheduleshock boolean DEFAULT true NOT NULL,
    blockdocsmissing boolean DEFAULT false NOT NULL,
    blockrequirementmissing boolean DEFAULT true NOT NULL,
    showothergroupsfield boolean DEFAULT true NOT NULL,
    scheduledisplaymode character(1) DEFAULT 'B'::bpchar NOT NULL,
    checkdebits boolean DEFAULT false,
    disapprovementstoblocktimetocoursedisapproved integer,
    showelectivesexternal boolean DEFAULT false,
    showoptionalsexternal boolean DEFAULT false,
    showoothercoursesgroupsexternal boolean DEFAULT true,
    showootherunitsgroupsexternal boolean DEFAULT false,
    showotherturnsgroupsexternal boolean DEFAULT false,
    showotherclassesgroupsexternal boolean DEFAULT true,
    freeotherperiodgroupsexternal boolean DEFAULT false,
    checkscheduleshockexternal boolean DEFAULT true,
    blockdocsmissingexternal boolean DEFAULT true,
    blockdebtexternal boolean DEFAULT false,
    checkdebitsexternal boolean DEFAULT true,
    scheduledisplaymodeexternal boolean DEFAULT true,
    sendconfirmationemailexternal boolean DEFAULT false,
    minimumandmaxlimitcreditsblockenroll boolean DEFAULT true,
    minimumcreditsturncourse integer,
    maxcreditsturncourse integer,
    minimumcreditsotherturn integer,
    maxcreditsotherturn integer,
    enableselectcurricularcomponentpending boolean DEFAULT true,
    enableselectcurricularcomponentoffutureperiods boolean DEFAULT true,
    enableenrollweb boolean DEFAULT false,
    minimumandmaxlimitcreditsblockenrollexternal boolean DEFAULT true,
    minimumcreditsturncourseexternal integer,
    maxcreditsturncourseexternal integer,
    minimumcreditsotherturncourseexternal integer,
    maxcreditsotherturncourseexternal integer,
    enableselectcurricularcomponentoffutureperiodsexternal boolean DEFAULT false,
    enableselectcurricularcomponentpendingexternal boolean DEFAULT true,
    configurablemessagestep1 text,
    configurablemessagestep2 text,
    configurablemessagestep3 text,
    avaliablecontract boolean DEFAULT true,
    avaliableaddendum boolean DEFAULT true,
    avaliableenrollconfirmation boolean DEFAULT true,
    begindate date,
    enddate date,
    enablepreenroll boolean,
    preenrollconsumevacant boolean,
    preenrollchecksignature character(1),
    preenrollcheckfirstpayment character(1),
    preenrollwebconfirmation character(1),
    ativaprematriculapara character(1) DEFAULT 'A'::bpchar,
    pendenciasgnuteca character(1) DEFAULT 'S'::bpchar,
    bloqueioemprestimos boolean DEFAULT true,
    bloqueiomultas boolean DEFAULT true,
    bloqueiopenalidades boolean DEFAULT true,
    bloqueiomensagem text,
    diasprazoconfirmacao integer,
    cancelamentostatecontractid integer,
    cancelamentoreasonid integer
)
INHERITS (baslog);


ALTER TABLE public.acdenrollconfig OWNER TO postgres;

--
-- Name: COLUMN acdenrollconfig.enablepreenroll; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollconfig.enablepreenroll IS 'Ativar pré-matrícula';


--
-- Name: COLUMN acdenrollconfig.preenrollconsumevacant; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollconfig.preenrollconsumevacant IS 'Aluno pré matriculado consome vaga (valores possíveis "t", "f")';


--
-- Name: COLUMN acdenrollconfig.preenrollchecksignature; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollconfig.preenrollchecksignature IS 'Verifica assinatura do contrato pré matricula (valores possíveis ("C", "V", "A", "N"))';


--
-- Name: COLUMN acdenrollconfig.preenrollcheckfirstpayment; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollconfig.preenrollcheckfirstpayment IS 'Verifica pagamento da primeira parcela pré matricula (valores possíveis ("C", "V", "A", "N"))';


--
-- Name: COLUMN acdenrollconfig.preenrollwebconfirmation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollconfig.preenrollwebconfirmation IS 'Confirmação pelo portal do aluno (valores possíveis ("C", "V", "A", "N"))';


--
-- Name: acdenrollconfirm; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdenrollconfirm (
    enrollconfirmid integer NOT NULL,
    contractid integer NOT NULL,
    learningperiodid integer,
    contractsigned boolean,
    confirmationstudent boolean
)
INHERITS (baslog);


ALTER TABLE public.acdenrollconfirm OWNER TO postgres;

--
-- Name: TABLE acdenrollconfirm; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdenrollconfirm IS 'Tabela de confirmação de matrícula (pre-matricula)';


--
-- Name: acdenrollconfirm_enrollconfirmid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acdenrollconfirm_enrollconfirmid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acdenrollconfirm_enrollconfirmid_seq OWNER TO postgres;

--
-- Name: acdenrollconfirm_enrollconfirmid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acdenrollconfirm_enrollconfirmid_seq OWNED BY acdenrollconfirm.enrollconfirmid;


--
-- Name: seq_statusid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_statusid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_statusid OWNER TO postgres;

--
-- Name: acdenrollstatus; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdenrollstatus (
    statusid integer DEFAULT nextval('seq_statusid'::regclass) NOT NULL,
    description text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdenrollstatus OWNER TO postgres;

--
-- Name: TABLE acdenrollstatus; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdenrollstatus IS 'estados possiveis da matricula. matriculado, reprovado, desistente, aprovado, dispensado';


--
-- Name: COLUMN acdenrollstatus.statusid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollstatus.statusid IS 'Codigo do estado';


--
-- Name: COLUMN acdenrollstatus.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollstatus.description IS 'Descricao';


--
-- Name: seq_enrollsummaryid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_enrollsummaryid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_enrollsummaryid OWNER TO postgres;

--
-- Name: acdenrollsummary; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdenrollsummary (
    enrollsummaryid integer DEFAULT nextval('seq_enrollsummaryid'::regclass) NOT NULL,
    contractid integer NOT NULL,
    learningperiodid integer NOT NULL,
    recorddate date NOT NULL,
    multiplier numeric(14,8) NOT NULL,
    isvalue boolean DEFAULT false NOT NULL,
    parcelsnumber integer NOT NULL,
    isprocessed boolean DEFAULT false NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdenrollsummary OWNER TO postgres;

--
-- Name: TABLE acdenrollsummary; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdenrollsummary IS 'contem um resumo da matricula do contrato por periodo. esta tabela e varrida para gerar as previsoes da pessoa quando ja houver preco definido para o periodo. vide campo multiplicador.';


--
-- Name: COLUMN acdenrollsummary.enrollsummaryid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollsummary.enrollsummaryid IS 'Codigo do resumo de matricula';


--
-- Name: COLUMN acdenrollsummary.contractid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollsummary.contractid IS 'Codigo do contrato';


--
-- Name: COLUMN acdenrollsummary.learningperiodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollsummary.learningperiodid IS 'Codigo do periodo letivo';


--
-- Name: COLUMN acdenrollsummary.recorddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollsummary.recorddate IS 'Data da criacao do registro.';


--
-- Name: COLUMN acdenrollsummary.multiplier; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollsummary.multiplier IS 'Quantidade pela qual o preco deverá ser multiplicado para gerar a previsão.';


--
-- Name: COLUMN acdenrollsummary.isvalue; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollsummary.isvalue IS 'TRUE se o campo multiplier é um valor moeda. FALSE se o campo multiplier e um multiplicador. Utilizado para incentivos que nao sao em percentual (sao em valor).';


--
-- Name: COLUMN acdenrollsummary.parcelsnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollsummary.parcelsnumber IS 'Quantidade de parcelas na qual o valor sera dividido.';


--
-- Name: COLUMN acdenrollsummary.isprocessed; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdenrollsummary.isprocessed IS 'TRUE se o registro foi passado para a tabela de previsoes (finIncomeForecast); FALSE caso contrario.';


--
-- Name: seq_evaluationid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_evaluationid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_evaluationid OWNER TO postgres;

--
-- Name: acdevaluation; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdevaluation (
    evaluationid integer DEFAULT nextval('seq_evaluationid'::regclass) NOT NULL,
    degreeid integer NOT NULL,
    description text NOT NULL,
    dateforecast date,
    weight double precision DEFAULT 1 NOT NULL,
    professorid bigint NOT NULL,
    groupid integer NOT NULL,
    moodleevaluationid integer,
    maxpoints numeric,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acdevaluation OWNER TO postgres;

--
-- Name: TABLE acdevaluation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdevaluation IS 'avaliaã§ãµes';


--
-- Name: COLUMN acdevaluation.evaluationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdevaluation.evaluationid IS 'Codigo da avaliacao';


--
-- Name: COLUMN acdevaluation.degreeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdevaluation.degreeid IS 'Codigo do grau do qual a avaliacao faz parte (compondo, assim, a nota deste grau)';


--
-- Name: COLUMN acdevaluation.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdevaluation.description IS 'Descricao';


--
-- Name: COLUMN acdevaluation.dateforecast; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdevaluation.dateforecast IS 'Data prevista para a avaliacao ser aplicada';


--
-- Name: COLUMN acdevaluation.weight; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdevaluation.weight IS 'Peso para calculo de media ponderada';


--
-- Name: COLUMN acdevaluation.moodleevaluationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdevaluation.moodleevaluationid IS 'Código da tarefa no moodle';


--
-- Name: acdevaluationcontrolmethod; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdevaluationcontrolmethod (
    evaluationcontrolmethodid integer NOT NULL,
    description character varying(255) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdevaluationcontrolmethod OWNER TO postgres;

--
-- Name: TABLE acdevaluationcontrolmethod; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdevaluationcontrolmethod IS 'Tabela responsável por armazenar os métodos de controle de avaliação';


--
-- Name: COLUMN acdevaluationcontrolmethod.evaluationcontrolmethodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdevaluationcontrolmethod.evaluationcontrolmethodid IS 'Chave primária da tabela acdEvaluationControlMethod';


--
-- Name: COLUMN acdevaluationcontrolmethod.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdevaluationcontrolmethod.description IS 'Descrição do método de controle de avaliação';


--
-- Name: acdevaluationcontrolmethod_evaluationcontrolmethodid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acdevaluationcontrolmethod_evaluationcontrolmethodid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acdevaluationcontrolmethod_evaluationcontrolmethodid_seq OWNER TO postgres;

--
-- Name: acdevaluationcontrolmethod_evaluationcontrolmethodid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acdevaluationcontrolmethod_evaluationcontrolmethodid_seq OWNED BY acdevaluationcontrolmethod.evaluationcontrolmethodid;


--
-- Name: seq_evaluationenrollid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_evaluationenrollid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_evaluationenrollid OWNER TO postgres;

--
-- Name: acdevaluationenroll; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdevaluationenroll (
    evaluationid integer NOT NULL,
    enrollid integer NOT NULL,
    note double precision,
    concept character varying(15),
    description text,
    isnotappear boolean DEFAULT false NOT NULL,
    evaluationenrollid integer DEFAULT nextval('seq_evaluationenrollid'::regclass) NOT NULL,
    recorddate timestamp without time zone DEFAULT now() NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdevaluationenroll OWNER TO postgres;

--
-- Name: TABLE acdevaluationenroll; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdevaluationenroll IS 'nota das avaliacoes para cada matricula';


--
-- Name: COLUMN acdevaluationenroll.evaluationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdevaluationenroll.evaluationid IS 'Codigo da avaliacao';


--
-- Name: COLUMN acdevaluationenroll.enrollid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdevaluationenroll.enrollid IS 'Codigo da matricula';


--
-- Name: COLUMN acdevaluationenroll.note; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdevaluationenroll.note IS 'Nota';


--
-- Name: COLUMN acdevaluationenroll.concept; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdevaluationenroll.concept IS 'Conceito';


--
-- Name: COLUMN acdevaluationenroll.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdevaluationenroll.description IS 'Descritivo';


--
-- Name: COLUMN acdevaluationenroll.isnotappear; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdevaluationenroll.isnotappear IS 'TRUE se o aluno nao compareceu para fazer a avaliacao. Caso contrario, FALSE';


--
-- Name: acdevaluationtype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdevaluationtype (
    evaluationtypeid integer NOT NULL,
    description character varying(40) NOT NULL
);


ALTER TABLE public.acdevaluationtype OWNER TO postgres;

--
-- Name: TABLE acdevaluationtype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdevaluationtype IS 'Possíveis formas de avaliação de uma disciplina.';


--
-- Name: COLUMN acdevaluationtype.evaluationtypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdevaluationtype.evaluationtypeid IS 'Identificador único de registro.';


--
-- Name: COLUMN acdevaluationtype.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdevaluationtype.description IS 'Descrição da forma de avaliação.';


--
-- Name: acdevaluationtype_evaluationtypeid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acdevaluationtype_evaluationtypeid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acdevaluationtype_evaluationtypeid_seq OWNER TO postgres;

--
-- Name: acdevaluationtype_evaluationtypeid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acdevaluationtype_evaluationtypeid_seq OWNED BY acdevaluationtype.evaluationtypeid;


--
-- Name: seq_eventid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_eventid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_eventid OWNER TO postgres;

--
-- Name: acdevent; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdevent (
    eventid integer DEFAULT nextval('seq_eventid'::regclass) NOT NULL,
    description text NOT NULL,
    begindate date NOT NULL,
    enddate date NOT NULL,
    accountschemeid character varying(30),
    costcenterid character varying(30),
    policyid integer,
    incomesourceid integer,
    inscriptionfee double precision,
    numberhours double precision,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acdevent OWNER TO postgres;

--
-- Name: TABLE acdevent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdevent IS 'eventos';


--
-- Name: COLUMN acdevent.eventid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdevent.eventid IS 'Codigo do evento';


--
-- Name: COLUMN acdevent.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdevent.description IS 'Descricao';


--
-- Name: COLUMN acdevent.begindate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdevent.begindate IS 'Data de inicio';


--
-- Name: COLUMN acdevent.enddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdevent.enddate IS 'Data de termino';


--
-- Name: COLUMN acdevent.accountschemeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdevent.accountschemeid IS 'Codigo do esquema de contabilizacao para cobranca de taxa de inscricao, por exemplo (caso o modulo contabil esteja sendo utilizado, este campo devera ser obrigatorio no formulario). ';


--
-- Name: COLUMN acdevent.costcenterid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdevent.costcenterid IS 'Codigo do centro de custo (caso o modulo contabil esteja sendo utilizado, este campo devera ser obrigatorio no formulario)';


--
-- Name: COLUMN acdevent.policyid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdevent.policyid IS 'Codigo da politica financeira (caso o modulo financeiro esteja sendo utilizado, este campo devera ser obrigatorio no formulario)';


--
-- Name: COLUMN acdevent.incomesourceid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdevent.incomesourceid IS 'Codigo da origem (caso o modulo financeiro esteja sendo utilizado, este campo devera ser obrigatorio no formulario)';


--
-- Name: COLUMN acdevent.inscriptionfee; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdevent.inscriptionfee IS 'Taxa de inscricao';


--
-- Name: acdeventparticipation; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdeventparticipation (
    eventid integer NOT NULL,
    personid bigint NOT NULL,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acdeventparticipation OWNER TO postgres;

--
-- Name: TABLE acdeventparticipation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdeventparticipation IS 'participaã§ã£o no evento';


--
-- Name: COLUMN acdeventparticipation.eventid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdeventparticipation.eventid IS 'Codigo do evento';


--
-- Name: COLUMN acdeventparticipation.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdeventparticipation.personid IS 'Codigo da pessoa';


--
-- Name: acdexamdate; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdexamdate (
    learningperiodid integer NOT NULL,
    weekdayid integer NOT NULL,
    examdate date NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdexamdate OWNER TO postgres;

--
-- Name: TABLE acdexamdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdexamdate IS 'datas de exame';


--
-- Name: COLUMN acdexamdate.learningperiodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdexamdate.learningperiodid IS 'Codigo do periodo letivo';


--
-- Name: COLUMN acdexamdate.weekdayid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdexamdate.weekdayid IS 'Codigo do dia da semana';


--
-- Name: COLUMN acdexamdate.examdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdexamdate.examdate IS 'Data do exame';


--
-- Name: seq_exploitationid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_exploitationid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_exploitationid OWNER TO postgres;

--
-- Name: acdexploitation; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdexploitation (
    exploitationid integer DEFAULT nextval('seq_exploitationid'::regclass) NOT NULL,
    enrollid integer NOT NULL,
    exploitationtype character(1) NOT NULL,
    exploitationenrollid integer,
    exploitationnumberhours double precision NOT NULL,
    exploitationcredits double precision,
    institutionid integer,
    coursename text,
    curricularcomponentname text,
    finalnote text,
    numberhours double precision,
    credits double precision,
    period text,
    unitid integer,
    electivecurriculumid integer
)
INHERITS (baslog);


ALTER TABLE public.acdexploitation OWNER TO postgres;

--
-- Name: TABLE acdexploitation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdexploitation IS 'dados dos aproveitamentos';


--
-- Name: COLUMN acdexploitation.exploitationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdexploitation.exploitationid IS 'Sequencia para identificar o aproveitamento (chave primaria)';


--
-- Name: COLUMN acdexploitation.enrollid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdexploitation.enrollid IS 'Chave estrangeira para a tabela acdEnroll. Corresponde a matricula do curso atual do aluno.';


--
-- Name: COLUMN acdexploitation.exploitationtype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdexploitation.exploitationtype IS 'Identificador do tipo de aproveitamento (I = Interno e E = Externo).';


--
-- Name: COLUMN acdexploitation.exploitationenrollid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdexploitation.exploitationenrollid IS 'Quando for aproveitamento interno, este campo sera a chave estrangeira correspondente a disciplina cursada pelo aluno no curso anterior. Quando for aproveitamento externo, este campo sera NULL.';


--
-- Name: COLUMN acdexploitation.exploitationnumberhours; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdexploitation.exploitationnumberhours IS 'Numero de horas aproveitadas';


--
-- Name: COLUMN acdexploitation.exploitationcredits; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdexploitation.exploitationcredits IS 'Numero de creditos aproveitados';


--
-- Name: COLUMN acdexploitation.institutionid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdexploitation.institutionid IS 'Instituicao onde a disciplina foi cursada';


--
-- Name: COLUMN acdexploitation.coursename; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdexploitation.coursename IS 'Curso da pessoa na instituicao onde a disciplina foi cursada.';


--
-- Name: COLUMN acdexploitation.curricularcomponentname; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdexploitation.curricularcomponentname IS 'Nome da disciplina na instituicao onde foi cursada.';


--
-- Name: COLUMN acdexploitation.finalnote; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdexploitation.finalnote IS 'Nota ou conceito final obtido pelo aluno na disciplina.';


--
-- Name: COLUMN acdexploitation.numberhours; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdexploitation.numberhours IS 'Numero de horas que a disciplina possuia na instituicao onde foi cursada.';


--
-- Name: COLUMN acdexploitation.credits; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdexploitation.credits IS 'Numero de creditos que a disciplina possuia na instituicao onde foi cursada.';


--
-- Name: COLUMN acdexploitation.period; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdexploitation.period IS 'Periodo em que a disciplina foi cursada.';


--
-- Name: COLUMN acdexploitation.electivecurriculumid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdexploitation.electivecurriculumid IS 'Código do componente curricular de uma disciplina eletiva, esse campo é opcional e será mostrado na interface somente quando for aproveitamento de uma disciplina eletiva.';


--
-- Name: seq_externalcourseid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_externalcourseid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_externalcourseid OWNER TO postgres;

--
-- Name: acdexternalcourse; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdexternalcourse (
    externalcourseid integer DEFAULT nextval('seq_externalcourseid'::regclass) NOT NULL,
    name text NOT NULL,
    shortname character varying(40) NOT NULL,
    obs text,
    knowledgeareaid integer
)
INHERITS (baslog);


ALTER TABLE public.acdexternalcourse OWNER TO postgres;

--
-- Name: TABLE acdexternalcourse; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdexternalcourse IS 'cursos externos';


--
-- Name: COLUMN acdexternalcourse.externalcourseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdexternalcourse.externalcourseid IS 'Codigo do curso externo';


--
-- Name: COLUMN acdexternalcourse.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdexternalcourse.name IS 'Nome';


--
-- Name: COLUMN acdexternalcourse.shortname; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdexternalcourse.shortname IS 'Nome suscinto';


--
-- Name: COLUMN acdexternalcourse.obs; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdexternalcourse.obs IS 'Observacao';


--
-- Name: COLUMN acdexternalcourse.knowledgeareaid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdexternalcourse.knowledgeareaid IS 'Área de conhecimento - Ex: Ciencias Exatas e da Terra, Ciencias Humanas';


--
-- Name: acdfinalexaminationdirectors; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdfinalexaminationdirectors (
    enrollid integer NOT NULL,
    personid bigint NOT NULL,
    directionworkload double precision
)
INHERITS (baslog);


ALTER TABLE public.acdfinalexaminationdirectors OWNER TO postgres;

--
-- Name: acdfinalexaminationexaminingboard; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdfinalexaminationexaminingboard (
    enrollid integer NOT NULL,
    personid bigint NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdfinalexaminationexaminingboard OWNER TO postgres;

--
-- Name: acdfinalexaminationknowledgearea; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdfinalexaminationknowledgearea (
    enrollid integer NOT NULL,
    knowledgeareaid integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdfinalexaminationknowledgearea OWNER TO postgres;

--
-- Name: seq_formationlevelid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_formationlevelid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_formationlevelid OWNER TO postgres;

--
-- Name: acdformationlevel; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdformationlevel (
    formationlevelid integer DEFAULT nextval('seq_formationlevelid'::regclass) NOT NULL,
    description character varying(30) NOT NULL,
    shortdescription character varying(3) NOT NULL,
    reportname character varying(255)
)
INHERITS (baslog);


ALTER TABLE public.acdformationlevel OWNER TO postgres;

--
-- Name: TABLE acdformationlevel; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdformationlevel IS 'nã­vel de formaã§ã£o - graduacao, tecico, pos, etc.';


--
-- Name: COLUMN acdformationlevel.formationlevelid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdformationlevel.formationlevelid IS 'Codigo do nivel de formacao';


--
-- Name: COLUMN acdformationlevel.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdformationlevel.description IS 'Descrição (Graduação, Técnico, Sequencial)';


--
-- Name: COLUMN acdformationlevel.shortdescription; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdformationlevel.shortdescription IS 'Abreviatura (Gra, Téc, Seq)';


--
-- Name: COLUMN acdformationlevel.reportname; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdformationlevel.reportname IS 'Nome do relatorio que deve ser utilizado para geracao de contrato';


--
-- Name: acdfrequenceenroll; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdfrequenceenroll (
    enrollid integer NOT NULL,
    scheduleid integer NOT NULL,
    frequencydate date NOT NULL,
    frequency double precision NOT NULL,
    iscancellation boolean DEFAULT false NOT NULL,
    reasoncancellation text,
    justifiedabsence boolean DEFAULT false NOT NULL,
    cancelledabsence boolean DEFAULT false NOT NULL,
    timeid integer NOT NULL,
    justification text,
    justifiedabsense boolean DEFAULT false,
    CONSTRAINT chk_acdfrequenceenroll_frequency CHECK ((frequency = ANY (ARRAY[(0)::double precision, (0.5)::double precision, (1)::double precision])))
)
INHERITS (baslog);


ALTER TABLE public.acdfrequenceenroll OWNER TO postgres;

--
-- Name: TABLE acdfrequenceenroll; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdfrequenceenroll IS 'registros de frequencia para cada matricula';


--
-- Name: COLUMN acdfrequenceenroll.enrollid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdfrequenceenroll.enrollid IS 'Codigo da matricula';


--
-- Name: COLUMN acdfrequenceenroll.scheduleid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdfrequenceenroll.scheduleid IS 'Codigo do horario da turma';


--
-- Name: COLUMN acdfrequenceenroll.frequencydate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdfrequenceenroll.frequencydate IS 'Data do registro de frequencia';


--
-- Name: COLUMN acdfrequenceenroll.frequency; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdfrequenceenroll.frequency IS 'Frequencia';


--
-- Name: COLUMN acdfrequenceenroll.iscancellation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdfrequenceenroll.iscancellation IS 'Se a aula foi cancelada';


--
-- Name: COLUMN acdfrequenceenroll.reasoncancellation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdfrequenceenroll.reasoncancellation IS 'Motivo do cancelamento';


--
-- Name: COLUMN acdfrequenceenroll.justifiedabsence; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdfrequenceenroll.justifiedabsence IS 'Falta justificada';


--
-- Name: COLUMN acdfrequenceenroll.cancelledabsence; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdfrequenceenroll.cancelledabsence IS 'Falta abonada (cancelada)';


--
-- Name: COLUMN acdfrequenceenroll.timeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdfrequenceenroll.timeid IS 'Código do horário que será registrado a frequencia';


--
-- Name: seq_groupid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_groupid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_groupid OWNER TO postgres;

--
-- Name: acdgroup; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdgroup (
    groupid integer DEFAULT nextval('seq_groupid'::regclass) NOT NULL,
    learningperiodid integer NOT NULL,
    curriculumid integer NOT NULL,
    complement text,
    vacant integer,
    iscancellation boolean DEFAULT false NOT NULL,
    objectives text,
    content text,
    methodology text,
    evaluation text,
    basicbibliography text[],
    complementarybibliography text[],
    observation text,
    regimenid integer NOT NULL,
    isusewebdaily boolean DEFAULT true NOT NULL,
    isclosed boolean DEFAULT false NOT NULL,
    totalenrolled integer,
    iscontentprogrammarian boolean DEFAULT false NOT NULL,
    basicbibliographydescription text,
    classid character varying(20) NOT NULL,
    useconcept boolean DEFAULT false NOT NULL,
    leaderid integer,
    subleaderid integer,
    financecredits double precision NOT NULL,
    professorresponsible integer,
    evaluationtypeid integer NOT NULL,
    frequenceregisternotification boolean DEFAULT false NOT NULL,
    conceptgroupid integer,
    gradestypingfinished boolean DEFAULT false NOT NULL,
    complementarybibliographydescription text,
    unitid integer,
    creationdate date DEFAULT now(),
    CONSTRAINT chk_evaluation_control_method CHECK (chk_evaluation_control_method(learningperiodid, useconcept, curriculumid))
)
INHERITS (baslog);


ALTER TABLE public.acdgroup OWNER TO postgres;

--
-- Name: TABLE acdgroup; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdgroup IS 'turma';


--
-- Name: COLUMN acdgroup.groupid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.groupid IS 'Codigo do grupo';


--
-- Name: COLUMN acdgroup.learningperiodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.learningperiodid IS 'Codigo do periodo letivo no qual a turma e oferecida';


--
-- Name: COLUMN acdgroup.curriculumid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.curriculumid IS 'Codigo da disciplina do curriculo';


--
-- Name: COLUMN acdgroup.complement; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.complement IS 'Complemento da disciplina oferecida. É o foco da disciplina no semestre.';


--
-- Name: COLUMN acdgroup.vacant; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.vacant IS 'Vagas disponiveis';


--
-- Name: COLUMN acdgroup.iscancellation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.iscancellation IS 'Se foi cancelada';


--
-- Name: COLUMN acdgroup.objectives; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.objectives IS 'Objetivos ';


--
-- Name: COLUMN acdgroup.content; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.content IS 'Conteudo a ser trabalhado ';


--
-- Name: COLUMN acdgroup.methodology; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.methodology IS 'Metodologia de ensino';


--
-- Name: COLUMN acdgroup.evaluation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.evaluation IS 'Metodos de avaliacao';


--
-- Name: COLUMN acdgroup.basicbibliography; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.basicbibliography IS 'Bibliografia basica';


--
-- Name: COLUMN acdgroup.complementarybibliography; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.complementarybibliography IS 'Bibliografia complementar';


--
-- Name: COLUMN acdgroup.observation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.observation IS 'Observacao';


--
-- Name: COLUMN acdgroup.regimenid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.regimenid IS 'Codigo do regime';


--
-- Name: COLUMN acdgroup.isusewebdaily; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.isusewebdaily IS 'Usa webDiário';


--
-- Name: COLUMN acdgroup.isclosed; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.isclosed IS 'Está encerrada a turma';


--
-- Name: COLUMN acdgroup.totalenrolled; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.totalenrolled IS 'Total de matriculados';


--
-- Name: COLUMN acdgroup.iscontentprogrammarian; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.iscontentprogrammarian IS 'Possui conteudo programatico';


--
-- Name: COLUMN acdgroup.basicbibliographydescription; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.basicbibliographydescription IS 'Descrição de bibliografias';


--
-- Name: COLUMN acdgroup.classid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.classid IS 'Código da classe para a qual a disciplina está sendo oferecida';


--
-- Name: COLUMN acdgroup.leaderid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.leaderid IS 'Lider de turma';


--
-- Name: COLUMN acdgroup.subleaderid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.subleaderid IS 'Vice-lider';


--
-- Name: COLUMN acdgroup.financecredits; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.financecredits IS 'Número de créditos da oferecida para o financeiro utilizar quando for gerar as previsões de lançamento.';


--
-- Name: COLUMN acdgroup.professorresponsible; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.professorresponsible IS 'Professor responsável';


--
-- Name: COLUMN acdgroup.evaluationtypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.evaluationtypeid IS 'Indica a forma como esta disciplina oferecida será avaliada para determinar aprovação/reprovação do aluno.';


--
-- Name: COLUMN acdgroup.frequenceregisternotification; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.frequenceregisternotification IS 'Informa se  a disciplina deverá  ou não gerar notificações a professores que não registram a frequência das disciplinas dentro do prazo estipulado';


--
-- Name: COLUMN acdgroup.conceptgroupid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.conceptgroupid IS 'Grupo de conceitos';


--
-- Name: COLUMN acdgroup.gradestypingfinished; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.gradestypingfinished IS 'Digitação de notas foi declarada finalizada pelo professor';


--
-- Name: COLUMN acdgroup.complementarybibliographydescription; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroup.complementarybibliographydescription IS 'Bibliografia complementar';


--
-- Name: acdgroupunblock; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdgroupunblock (
    groupunblockid integer NOT NULL,
    groupid integer NOT NULL,
    limitdate date NOT NULL,
    registerdate timestamp without time zone DEFAULT now() NOT NULL,
    observation text
)
INHERITS (baslog);


ALTER TABLE public.acdgroupunblock OWNER TO postgres;

--
-- Name: COLUMN acdgroupunblock.groupunblockid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroupunblock.groupunblockid IS 'Código';


--
-- Name: COLUMN acdgroupunblock.groupid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroupunblock.groupid IS 'Disciplina oferecida';


--
-- Name: COLUMN acdgroupunblock.limitdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroupunblock.limitdate IS 'Data limite para liberar a digitação de notas ou frequências';


--
-- Name: COLUMN acdgroupunblock.registerdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroupunblock.registerdate IS 'Data do registro no sistema. Irá valer o último registro feito para a disciplina';


--
-- Name: COLUMN acdgroupunblock.observation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdgroupunblock.observation IS 'Justificativa';


--
-- Name: acdgroupunblock_groupunblockid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acdgroupunblock_groupunblockid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acdgroupunblock_groupunblockid_seq OWNER TO postgres;

--
-- Name: acdgroupunblock_groupunblockid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acdgroupunblock_groupunblockid_seq OWNED BY acdgroupunblock.groupunblockid;


--
-- Name: seq_learningperiodid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_learningperiodid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_learningperiodid OWNER TO postgres;

--
-- Name: acdlearningperiod; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdlearningperiod (
    learningperiodid integer DEFAULT nextval('seq_learningperiodid'::regclass) NOT NULL,
    periodid character varying(10) NOT NULL,
    courseid character varying(10) NOT NULL,
    courseversion integer NOT NULL,
    turnid integer NOT NULL,
    unitid integer NOT NULL,
    description text NOT NULL,
    formationlevelid integer NOT NULL,
    previouslearningperiodid integer,
    begindate date NOT NULL,
    enddate date NOT NULL,
    begindatelessons date,
    weekendexamsbegin date,
    finalaverage double precision,
    minimumfrequency double precision NOT NULL,
    sagu1periodid character varying(10),
    minimumcredits integer NOT NULL,
    minimumcreditsfreshman integer NOT NULL,
    minimumcreditsturn integer NOT NULL,
    sagu1previousperiodid character varying(10),
    parcelsnumber integer,
    isfinancegenerate boolean DEFAULT false NOT NULL,
    disapprovementstodisapproveperiod integer DEFAULT 0 NOT NULL,
    isclosed boolean DEFAULT false NOT NULL,
    maximumdisapprovals integer DEFAULT 0 NOT NULL,
    maximumperiods integer DEFAULT 0 NOT NULL,
    isnumberhours boolean DEFAULT false,
    maximumcredits integer DEFAULT 0 NOT NULL,
    maximumcreditsfreshman integer DEFAULT 0 NOT NULL,
    gradesbyconcept boolean,
    evaluationcontrolmethodid integer DEFAULT 1 NOT NULL,
    justifydisapprovals boolean DEFAULT false,
    maximumfinalaverage double precision,
    enrollacceptedterm text,
    limitregisterdate date,
    CONSTRAINT chk_evaluation_control_method_learning_period CHECK (chk_evaluation_control_method_learning_period(learningperiodid, evaluationcontrolmethodid))
)
INHERITS (baslog);


ALTER TABLE public.acdlearningperiod OWNER TO postgres;

--
-- Name: TABLE acdlearningperiod; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdlearningperiod IS 'periodos letivos';


--
-- Name: COLUMN acdlearningperiod.learningperiodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.learningperiodid IS 'Codigo do periodo letivo';


--
-- Name: COLUMN acdlearningperiod.periodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.periodid IS 'Codigo do periodo';


--
-- Name: COLUMN acdlearningperiod.courseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.courseid IS 'Codigo do curso';


--
-- Name: COLUMN acdlearningperiod.courseversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.courseversion IS 'Versao do curso';


--
-- Name: COLUMN acdlearningperiod.turnid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.turnid IS 'Codigo do turno';


--
-- Name: COLUMN acdlearningperiod.unitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.unitid IS 'Codigo da unidade';


--
-- Name: COLUMN acdlearningperiod.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.description IS 'Descricao';


--
-- Name: COLUMN acdlearningperiod.formationlevelid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.formationlevelid IS 'Codigo do nivel de formacao';


--
-- Name: COLUMN acdlearningperiod.previouslearningperiodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.previouslearningperiodid IS 'Codigo do periodo letivo anterior';


--
-- Name: COLUMN acdlearningperiod.begindate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.begindate IS 'Data de inicio';


--
-- Name: COLUMN acdlearningperiod.enddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.enddate IS 'Data de termino';


--
-- Name: COLUMN acdlearningperiod.begindatelessons; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.begindatelessons IS 'Data de inicio das aulas';


--
-- Name: COLUMN acdlearningperiod.weekendexamsbegin; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.weekendexamsbegin IS 'Data de inicio da semana de exames';


--
-- Name: COLUMN acdlearningperiod.finalaverage; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.finalaverage IS 'Media final para aprovacao';


--
-- Name: COLUMN acdlearningperiod.minimumfrequency; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.minimumfrequency IS 'Frequencia minima para aprovacao, indicado em percentual (0 a 100)';


--
-- Name: COLUMN acdlearningperiod.sagu1periodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.sagu1periodid IS 'Informacao antiga de codigos dos periodos';


--
-- Name: COLUMN acdlearningperiod.minimumcredits; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.minimumcredits IS 'O aluno poderá se matricular 1 vez em um numero menor de creditos que esse';


--
-- Name: COLUMN acdlearningperiod.minimumcreditsfreshman; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.minimumcreditsfreshman IS 'Numero minimo de creditos que os vestibulandos podem se matricular';


--
-- Name: COLUMN acdlearningperiod.minimumcreditsturn; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.minimumcreditsturn IS 'Numero minimo de créditos para poder cursar disciplinas em outro turno';


--
-- Name: COLUMN acdlearningperiod.sagu1previousperiodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.sagu1previousperiodid IS 'Codigo do periodo anterior do sagu1';


--
-- Name: COLUMN acdlearningperiod.parcelsnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.parcelsnumber IS 'Numero de parcelas padrao';


--
-- Name: COLUMN acdlearningperiod.isfinancegenerate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.isfinancegenerate IS 'Campo que indica se no momento da matricula sera gerado financeiro na tabela de previsoes';


--
-- Name: COLUMN acdlearningperiod.isnumberhours; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.isnumberhours IS 'Flag que define o tipo dos valores academicos no período letivo podendo ser c?edito(false) ou horas(true)';


--
-- Name: COLUMN acdlearningperiod.maximumcredits; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.maximumcredits IS 'Número máximo de creditos/horas que um aluno é obrigado a cursar em disciplinas';


--
-- Name: COLUMN acdlearningperiod.maximumcreditsfreshman; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.maximumcreditsfreshman IS 'Número máximo de creditos/horas que um calouro é obrigado a cursar em disciplinas';


--
-- Name: COLUMN acdlearningperiod.gradesbyconcept; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.gradesbyconcept IS 'Indica se a digitação de notas por grupo de disciplina será feita por conceito ou por um valor numérico.';


--
-- Name: COLUMN acdlearningperiod.evaluationcontrolmethodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.evaluationcontrolmethodid IS 'Chave estrangeira para a tabela acdEvaluationControlMethod. Relaciona a ocorrencia de curso com um método de controle de avaliação';


--
-- Name: COLUMN acdlearningperiod.justifydisapprovals; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.justifydisapprovals IS 'Indica se é necessário informar uma justificativa na digitação de notas para alunos que ficarem com conceito final de reprovação.';


--
-- Name: COLUMN acdlearningperiod.limitregisterdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdlearningperiod.limitregisterdate IS 'Data limite para registro de digitação de notas ou frequências via portal';


--
-- Name: seq_reasoncancellationid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_reasoncancellationid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_reasoncancellationid OWNER TO postgres;

--
-- Name: acdreasoncancellation; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdreasoncancellation (
    reasoncancellationid integer DEFAULT nextval('seq_reasoncancellationid'::regclass) NOT NULL,
    description text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdreasoncancellation OWNER TO postgres;

--
-- Name: TABLE acdreasoncancellation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdreasoncancellation IS 'motivos de cancelamento de matricula';


--
-- Name: COLUMN acdreasoncancellation.reasoncancellationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdreasoncancellation.reasoncancellationid IS 'Codigo do motivo de cancelamento';


--
-- Name: COLUMN acdreasoncancellation.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdreasoncancellation.description IS 'Descricao';


--
-- Name: seq_scheduleid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_scheduleid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_scheduleid OWNER TO postgres;

--
-- Name: acdschedule; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdschedule (
    scheduleid integer DEFAULT nextval('seq_scheduleid'::regclass) NOT NULL,
    groupid integer NOT NULL,
    unitid integer NOT NULL,
    weekdayid integer,
    physicalresourceid integer,
    physicalresourceversion integer,
    occurrencedates date[],
    timeids integer[]
)
INHERITS (baslog);


ALTER TABLE public.acdschedule OWNER TO postgres;

--
-- Name: TABLE acdschedule; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdschedule IS 'horarios';


--
-- Name: COLUMN acdschedule.scheduleid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdschedule.scheduleid IS 'Codigo do horario';


--
-- Name: COLUMN acdschedule.groupid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdschedule.groupid IS 'Codigo da turma a qual o horario se refere';


--
-- Name: COLUMN acdschedule.unitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdschedule.unitid IS 'Codigo da unidade onde a turma ocorre';


--
-- Name: COLUMN acdschedule.weekdayid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdschedule.weekdayid IS 'Codigo do dia da semana';


--
-- Name: COLUMN acdschedule.physicalresourceid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdschedule.physicalresourceid IS 'Codigo do recurso fisico';


--
-- Name: COLUMN acdschedule.physicalresourceversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdschedule.physicalresourceversion IS 'Versao do recurso fisico';


--
-- Name: seq_scheduleprofessorid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_scheduleprofessorid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_scheduleprofessorid OWNER TO postgres;

--
-- Name: acdscheduleprofessor; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdscheduleprofessor (
    scheduleprofessorid bigint DEFAULT nextval('seq_scheduleprofessorid'::regclass) NOT NULL,
    scheduleid integer NOT NULL,
    professorid bigint,
    isinstitutionalevaluation boolean DEFAULT true NOT NULL,
    weight double precision DEFAULT 1 NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdscheduleprofessor OWNER TO postgres;

--
-- Name: TABLE acdscheduleprofessor; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdscheduleprofessor IS 'professores por horã¡rio';


--
-- Name: COLUMN acdscheduleprofessor.scheduleprofessorid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdscheduleprofessor.scheduleprofessorid IS 'Codigo do professor de horario';


--
-- Name: COLUMN acdscheduleprofessor.scheduleid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdscheduleprofessor.scheduleid IS 'Codigo do horario';


--
-- Name: COLUMN acdscheduleprofessor.professorid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdscheduleprofessor.professorid IS 'Codigo do professor';


--
-- Name: COLUMN acdscheduleprofessor.isinstitutionalevaluation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdscheduleprofessor.isinstitutionalevaluation IS 'E avaliado na Avaliacao Instituicional';


--
-- Name: COLUMN acdscheduleprofessor.weight; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdscheduleprofessor.weight IS 'Peso da nota do professor no horário (sempre base 100%) se tem um professor no horário e 100% se tiver mais a soma deles deve ser 100%';


--
-- Name: acdscheduleprofessorcontent; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdscheduleprofessorcontent (
    scheduleprofessorcontentid integer NOT NULL,
    scheduleprofessorid bigint NOT NULL,
    timeid integer,
    date date NOT NULL,
    description text NOT NULL,
    visitingprofessorid bigint,
    classoccurred boolean NOT NULL,
    isinternal boolean,
    realstartdate timestamp without time zone,
    realenddate timestamp without time zone,
    substituteprofessorid bigint,
    curricularcomponentcategoryid character varying(10)
)
INHERITS (baslog);


ALTER TABLE public.acdscheduleprofessorcontent OWNER TO postgres;

--
-- Name: TABLE acdscheduleprofessorcontent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdscheduleprofessorcontent IS 'Tabela responsábel por armazenar o conteúdo ministrado em um determinado dia de aula';


--
-- Name: COLUMN acdscheduleprofessorcontent.scheduleprofessorcontentid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdscheduleprofessorcontent.scheduleprofessorcontentid IS 'Código do conteúdo';


--
-- Name: COLUMN acdscheduleprofessorcontent.scheduleprofessorid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdscheduleprofessorcontent.scheduleprofessorid IS 'Código do horário do professor';


--
-- Name: COLUMN acdscheduleprofessorcontent.timeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdscheduleprofessorcontent.timeid IS 'Código do horário';


--
-- Name: COLUMN acdscheduleprofessorcontent.date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdscheduleprofessorcontent.date IS 'Data em que foi ministrado o conteúdo';


--
-- Name: COLUMN acdscheduleprofessorcontent.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdscheduleprofessorcontent.description IS 'Descrição do conteúdo que foi ministrado em aula';


--
-- Name: COLUMN acdscheduleprofessorcontent.visitingprofessorid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdscheduleprofessorcontent.visitingprofessorid IS 'Código do professor visitante';


--
-- Name: COLUMN acdscheduleprofessorcontent.classoccurred; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdscheduleprofessorcontent.classoccurred IS 'Indica se ocorreu aula no dia';


--
-- Name: COLUMN acdscheduleprofessorcontent.isinternal; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdscheduleprofessorcontent.isinternal IS 'Indica se a atividade realizada foi interna (TRUE) ou externa (FALSE)';


--
-- Name: COLUMN acdscheduleprofessorcontent.realstartdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdscheduleprofessorcontent.realstartdate IS 'Representa a data e a hora em que a aula realmente começou';


--
-- Name: COLUMN acdscheduleprofessorcontent.realenddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdscheduleprofessorcontent.realenddate IS 'Representando a data e a hora em que a aula realmente terminou';


--
-- Name: seq_cityid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_cityid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_cityid OWNER TO postgres;

--
-- Name: bascity; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE bascity (
    cityid integer DEFAULT nextval('seq_cityid'::regclass) NOT NULL,
    name text NOT NULL,
    zipcode character varying(9),
    stateid character varying(2) NOT NULL,
    countryid character varying(3) NOT NULL,
    ibgeid integer
)
INHERITS (baslog);


ALTER TABLE public.bascity OWNER TO postgres;

--
-- Name: TABLE bascity; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE bascity IS 'Cidade';


--
-- Name: COLUMN bascity.cityid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascity.cityid IS 'Código da cidade';


--
-- Name: COLUMN bascity.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascity.name IS 'Nome da cidade.';


--
-- Name: COLUMN bascity.zipcode; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascity.zipcode IS 'CEP - Código de Endereçamento Postal';


--
-- Name: COLUMN bascity.stateid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascity.stateid IS 'Código do estado.';


--
-- Name: COLUMN bascity.countryid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascity.countryid IS 'código do pais';


--
-- Name: COLUMN bascity.ibgeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascity.ibgeid IS 'Código do ibge';


--
-- Name: basphysicalpersonemployee; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basphysicalpersonemployee (
)
INHERITS (basphysicalperson);


ALTER TABLE public.basphysicalpersonemployee OWNER TO postgres;

--
-- Name: basphysicalpersonprofessor; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basphysicalpersonprofessor (
    etemporario boolean DEFAULT false,
    escolaridade integer,
    posgraduacao integer,
    situacao integer,
    regimetrabalho integer,
    substituto boolean,
    visitante boolean,
    tipovinculo integer
)
INHERITS (basphysicalperson);


ALTER TABLE public.basphysicalpersonprofessor OWNER TO postgres;

--
-- Name: basphysicalpersonstudent; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basphysicalpersonstudent (
    externalcourseidhs integer,
    institutionidhs integer,
    cityidhs integer,
    yearhs integer,
    isinsured boolean DEFAULT false NOT NULL,
    passive character varying(20)
)
INHERITS (basphysicalperson);


ALTER TABLE public.basphysicalpersonstudent OWNER TO postgres;

--
-- Name: miolo_user_iduser_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE miolo_user_iduser_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.miolo_user_iduser_seq OWNER TO postgres;

--
-- Name: miolo_user; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE miolo_user (
    iduser integer DEFAULT nextval('miolo_user_iduser_seq'::regclass) NOT NULL,
    login character varying NOT NULL,
    name character varying,
    nickname character varying,
    m_password character varying,
    confirm_hash character varying,
    theme character varying,
    idmodule character varying(40),
    CONSTRAINT chk_miolo_user_login_size CHECK (((length((login)::text) > 0) AND (strpos((login)::text, ' '::text) = 0)))
);


ALTER TABLE public.miolo_user OWNER TO postgres;

--
-- Name: user_sagu; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW user_sagu AS
    SELECT DISTINCT x.login, x.password, x.personid, x.name, x.mail, x.city, x.isstudent, x.isprofessor, x.isemployee, x.iscoordinator, x.cpf, (((true = (x.isstudent AND (EXISTS (SELECT 1 FROM acdcontract c WHERE ((x.personid = c.personid) AND (iscontractclosed(c.contractid) IS FALSE)))))) OR (true = (x.isprofessor AND isprofessoractive(x.personid)))) OR (true = (x.isemployee AND isemployeeactive(x.personid)))) AS isactive FROM (SELECT m.login, (m.m_password)::text AS password, p.personid, p.name, lower((p.email)::text) AS mail, c.name AS city, (EXISTS (SELECT 1 FROM basphysicalpersonstudent WHERE (basphysicalpersonstudent.personid = p.personid))) AS isstudent, (EXISTS (SELECT 1 FROM basphysicalpersonprofessor WHERE (basphysicalpersonprofessor.personid = p.personid))) AS isprofessor, (EXISTS (SELECT 1 FROM basphysicalpersonemployee WHERE (basphysicalpersonemployee.personid = p.personid))) AS isemployee, (EXISTS (SELECT 1 FROM acdcoursecoordinator WHERE (acdcoursecoordinator.coordinatorid = p.personid))) AS iscoordinator, getpersondocument(p.personid, (getparameter('BASIC'::character varying, 'DEFAULT_DOCUMENT_TYPE_ID_CPF'::character varying))::integer) AS cpf FROM ((miolo_user m JOIN ONLY basphysicalperson p ON (((m.login)::text = (p.miolousername)::text))) JOIN bascity c ON ((c.cityid = p.cityid))) WHERE (((COALESCE(p.email, ''::character varying))::text <> ''::text) AND (COALESCE(c.name, ''::text) <> ''::text))) x;


ALTER TABLE public.user_sagu OWNER TO solis;

--
-- Name: acdinformations; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW acdinformations AS
    SELECT g.isclosed, co.name AS coursename, cu.courseid, cu.courseversion, cu.turnid, cu.unitid, fl.description AS formationlevel, lp.periodid, lp.learningperiodid, lp.description AS learningperiod, sp.professorid, uprof.login AS professorlogin, uprof.name AS professorname, sp.scheduleprofessorid, spc.scheduleprofessorcontentid, spc.timeid AS spc_timeid, spc.date AS spc_date, spc.description AS spc_description, spc.visitingprofessorid AS spc_visitingprofessorid, spc.classoccurred AS spc_classoccurred, spc.isinternal AS spc_isinternal, spc.realstartdate AS spc_realstartdate, spc.realenddate AS spc_realenddate, spc.substituteprofessorid AS spc_substituteprofessorid, spc.curricularcomponentcategoryid AS spc_curricularcomponentcategoryid, s.scheduleid, s.occurrencedates, s.timeids, g.groupid, cc.curricularcomponentid, cc.curricularcomponentversion, cc.name AS curricularcomponentname, cu.curriculumid, cu.semester AS curriculumsemester, e.enrollid, es.statusid AS enrollstatusid, es.description AS enrollstatus, ((e.dateenroll || ' '::text) || e.hourenroll) AS enrolldate, e.datetime AS enrolldatetime, ((e.datecancellation || ' '::text) || e.hourcancellation) AS datetimecancellation, e.reasoncancellationid, e.finalnote, rc.description AS reasoncancellation, e.contractid, us.personid, us.login AS personlogin, us.name AS personname, de.degreeid, de.degreeenrollid, de.note, de.concept, fe.frequencydate, fe.frequency, ((de.note IS NOT NULL) OR (de.concept IS NOT NULL)) AS hasnoteorconcept, ((fe.frequencydate IS NOT NULL) AND (fe.frequency IS NOT NULL)) AS hasfrequency, (round((((e.frequency * (100)::double precision) / cc.academicnumberhours))::numeric, 2) || '%'::text) AS frequencypercent, g.classid FROM ((((((((((((((((acdgroup g JOIN acdlearningperiod lp USING (learningperiodid)) JOIN acdcurriculum cu USING (curriculumid)) JOIN acdcurricularcomponent cc USING (curricularcomponentid)) LEFT JOIN acdschedule s USING (groupid)) LEFT JOIN acdscheduleprofessor sp USING (scheduleid)) LEFT JOIN acdscheduleprofessorcontent spc USING (scheduleprofessorid)) LEFT JOIN user_sagu uprof ON ((sp.professorid = uprof.personid))) LEFT JOIN acdenroll e USING (groupid)) LEFT JOIN acdenrollstatus es USING (statusid)) LEFT JOIN acddegreeenroll de USING (enrollid)) LEFT JOIN acdfrequenceenroll fe USING (enrollid)) LEFT JOIN acdreasoncancellation rc USING (reasoncancellationid)) LEFT JOIN acdcontract USING (contractid)) LEFT JOIN acdcourse co ON (((acdcontract.courseid)::text = (co.courseid)::text))) LEFT JOIN acdformationlevel fl ON ((fl.formationlevelid = co.formationlevelid))) LEFT JOIN user_sagu us ON ((acdcontract.personid = us.personid)));


ALTER TABLE public.acdinformations OWNER TO solis;

--
-- Name: seq_interchangeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_interchangeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_interchangeid OWNER TO postgres;

--
-- Name: acdinterchange; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdinterchange (
    interchangeid integer DEFAULT nextval('seq_interchangeid'::regclass) NOT NULL,
    personid bigint NOT NULL,
    contractid integer,
    interchangetypeid integer NOT NULL,
    interchangetypecomplement text,
    activity text,
    begindate date NOT NULL,
    enddate date NOT NULL,
    origincountryid character varying(3) NOT NULL,
    origininstitutionid integer,
    destinationcountryid character varying(3) NOT NULL,
    destinationinstitutionid integer NOT NULL,
    isremunerated boolean DEFAULT false NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdinterchange OWNER TO postgres;

--
-- Name: TABLE acdinterchange; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdinterchange IS 'tabela de intercambio';


--
-- Name: COLUMN acdinterchange.interchangeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdinterchange.interchangeid IS 'Codigo do intercambio';


--
-- Name: COLUMN acdinterchange.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdinterchange.personid IS 'Codigo da pessoa';


--
-- Name: COLUMN acdinterchange.contractid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdinterchange.contractid IS 'Codigo do contrato';


--
-- Name: COLUMN acdinterchange.interchangetypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdinterchange.interchangetypeid IS 'Codigo do tipo de intercambio';


--
-- Name: COLUMN acdinterchange.interchangetypecomplement; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdinterchange.interchangetypecomplement IS 'Complemento descrevendo o tipo de intercâmbio daquela pessoa específica';


--
-- Name: COLUMN acdinterchange.activity; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdinterchange.activity IS 'Descrição da atividade realizada durante o intercambio';


--
-- Name: COLUMN acdinterchange.begindate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdinterchange.begindate IS 'Data de inicio do intercambio';


--
-- Name: COLUMN acdinterchange.enddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdinterchange.enddate IS 'Data de termino do intercambio';


--
-- Name: COLUMN acdinterchange.origincountryid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdinterchange.origincountryid IS 'Codigo do pais de origem';


--
-- Name: COLUMN acdinterchange.origininstitutionid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdinterchange.origininstitutionid IS 'Codigo da instituicao de origem';


--
-- Name: COLUMN acdinterchange.destinationcountryid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdinterchange.destinationcountryid IS 'Codigo do pais de destino';


--
-- Name: COLUMN acdinterchange.destinationinstitutionid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdinterchange.destinationinstitutionid IS 'Codigo da instituicao de destino';


--
-- Name: COLUMN acdinterchange.isremunerated; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdinterchange.isremunerated IS 'Se e remunerado ou nao';


--
-- Name: seq_interchangetypeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_interchangetypeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_interchangetypeid OWNER TO postgres;

--
-- Name: acdinterchangetype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdinterchangetype (
    interchangetypeid integer DEFAULT nextval('seq_interchangetypeid'::regclass) NOT NULL,
    description text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdinterchangetype OWNER TO postgres;

--
-- Name: TABLE acdinterchangetype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdinterchangetype IS 'tipos de intercambio - estagio, missao, palestra, etc';


--
-- Name: COLUMN acdinterchangetype.interchangetypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdinterchangetype.interchangetypeid IS 'Codigo do tipo de intercambio';


--
-- Name: COLUMN acdinterchangetype.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdinterchangetype.description IS 'Descricao';


--
-- Name: seq_knowledgeareaid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_knowledgeareaid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_knowledgeareaid OWNER TO postgres;

--
-- Name: acdknowledgearea; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdknowledgearea (
    knowledgeareaid integer DEFAULT nextval('seq_knowledgeareaid'::regclass) NOT NULL,
    name text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdknowledgearea OWNER TO postgres;

--
-- Name: TABLE acdknowledgearea; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdknowledgearea IS 'areas de conhecimento';


--
-- Name: COLUMN acdknowledgearea.knowledgeareaid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdknowledgearea.knowledgeareaid IS 'Codigo da area de intercambio';


--
-- Name: COLUMN acdknowledgearea.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdknowledgearea.name IS 'Nome';


--
-- Name: seq_messagecontractrenewalid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_messagecontractrenewalid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_messagecontractrenewalid OWNER TO postgres;

--
-- Name: acdmessagecontractrenewal; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdmessagecontractrenewal (
    messagecontractrenewalid integer DEFAULT nextval('seq_messagecontractrenewalid'::regclass) NOT NULL,
    learningperiodid integer NOT NULL,
    message text NOT NULL,
    font text NOT NULL,
    sequence integer NOT NULL,
    length integer NOT NULL,
    islistener boolean DEFAULT false NOT NULL,
    status character(1) NOT NULL,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acdmessagecontractrenewal OWNER TO postgres;

--
-- Name: TABLE acdmessagecontractrenewal; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdmessagecontractrenewal IS 'tabela de mensagens a serem exibidas na renovacao contratual';


--
-- Name: COLUMN acdmessagecontractrenewal.messagecontractrenewalid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdmessagecontractrenewal.messagecontractrenewalid IS 'Codigo da mensagem';


--
-- Name: COLUMN acdmessagecontractrenewal.learningperiodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdmessagecontractrenewal.learningperiodid IS 'Codigo do periodo letivo';


--
-- Name: COLUMN acdmessagecontractrenewal.message; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdmessagecontractrenewal.message IS 'Mensagem';


--
-- Name: COLUMN acdmessagecontractrenewal.font; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdmessagecontractrenewal.font IS 'Fonte da mensagem';


--
-- Name: COLUMN acdmessagecontractrenewal.sequence; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdmessagecontractrenewal.sequence IS 'Sequencia na qual a mensagem deve aparecer';


--
-- Name: COLUMN acdmessagecontractrenewal.length; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdmessagecontractrenewal.length IS 'Tamanho (em caracteres)';


--
-- Name: COLUMN acdmessagecontractrenewal.islistener; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdmessagecontractrenewal.islistener IS 'Se e para ouvintes';


--
-- Name: COLUMN acdmessagecontractrenewal.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdmessagecontractrenewal.status IS 'Identificador do tipo de vinculo';


--
-- Name: acdmoodlesubscription; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdmoodlesubscription (
    personid bigint NOT NULL,
    groupid integer NOT NULL,
    login character varying,
    isteacher boolean DEFAULT false,
    processed boolean DEFAULT false
)
INHERITS (baslog);


ALTER TABLE public.acdmoodlesubscription OWNER TO postgres;

--
-- Name: COLUMN acdmoodlesubscription.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdmoodlesubscription.personid IS 'Código da pessoa';


--
-- Name: COLUMN acdmoodlesubscription.groupid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdmoodlesubscription.groupid IS 'Código do grupo';


--
-- Name: COLUMN acdmoodlesubscription.login; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdmoodlesubscription.login IS 'Login do usuário que eh inserido automaticamente na base de dados do miolo para acesso ao módulo de serviços';


--
-- Name: COLUMN acdmoodlesubscription.isteacher; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdmoodlesubscription.isteacher IS 'Identifica se o usuário é professor vem como default false';


--
-- Name: COLUMN acdmoodlesubscription.processed; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdmoodlesubscription.processed IS 'Identifica se o usuário já está inscrito no moodle vem como default false';


--
-- Name: acdmovementcontract; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdmovementcontract (
    contractid integer NOT NULL,
    statecontractid integer NOT NULL,
    statetime timestamp without time zone NOT NULL,
    reasonid integer,
    learningperiodid integer,
    CONSTRAINT chk_validaregistrodemovimentacaocontratual CHECK (validaregistrodemovimentacaocontratual(contractid, statecontractid, learningperiodid))
)
INHERITS (baslog);


ALTER TABLE public.acdmovementcontract OWNER TO postgres;

--
-- Name: TABLE acdmovementcontract; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdmovementcontract IS 'movimentacao do contrato';


--
-- Name: COLUMN acdmovementcontract.contractid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdmovementcontract.contractid IS 'Codigo do contrato';


--
-- Name: COLUMN acdmovementcontract.statecontractid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdmovementcontract.statecontractid IS 'Codigo do estado contratual';


--
-- Name: COLUMN acdmovementcontract.statetime; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdmovementcontract.statetime IS 'Momento de ocorrencia da movimentacao';


--
-- Name: COLUMN acdmovementcontract.reasonid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdmovementcontract.reasonid IS 'Motivo da movimentacao';


--
-- Name: COLUMN acdmovementcontract.learningperiodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdmovementcontract.learningperiodid IS 'Codigo do periodo letivo no qual a movimentacao ocorreu';


--
-- Name: acdmovementcontractcomplement; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdmovementcontractcomplement (
    contractid integer NOT NULL,
    statecontractid integer NOT NULL,
    statetime timestamp without time zone NOT NULL,
    statecontractfieldid integer NOT NULL,
    value text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdmovementcontractcomplement OWNER TO postgres;

--
-- Name: TABLE acdmovementcontractcomplement; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdmovementcontractcomplement IS 'complemento da movimentacao de contrato';


--
-- Name: COLUMN acdmovementcontractcomplement.contractid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdmovementcontractcomplement.contractid IS 'Codigo do contrato';


--
-- Name: COLUMN acdmovementcontractcomplement.statecontractid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdmovementcontractcomplement.statecontractid IS 'Codigo do estado contratual';


--
-- Name: COLUMN acdmovementcontractcomplement.statetime; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdmovementcontractcomplement.statetime IS 'Momento da ocorrencia da movimentacao';


--
-- Name: COLUMN acdmovementcontractcomplement.statecontractfieldid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdmovementcontractcomplement.statecontractfieldid IS 'Codigo do campo de estado contratual';


--
-- Name: COLUMN acdmovementcontractcomplement.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdmovementcontractcomplement.value IS 'Valor';


--
-- Name: acdperiod; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdperiod (
    periodid character varying(10) NOT NULL,
    description text NOT NULL,
    enrollbookdate date
)
INHERITS (baslog);


ALTER TABLE public.acdperiod OWNER TO postgres;

--
-- Name: TABLE acdperiod; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdperiod IS 'periodos';


--
-- Name: COLUMN acdperiod.periodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdperiod.periodid IS 'Codigo do periodo';


--
-- Name: COLUMN acdperiod.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdperiod.description IS 'Descricao';


--
-- Name: COLUMN acdperiod.enrollbookdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdperiod.enrollbookdate IS 'Campo para armazenar a data de geração do livro matrícula';


--
-- Name: seq_periodenrolldateid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_periodenrolldateid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_periodenrolldateid OWNER TO postgres;

--
-- Name: acdperiodenrolldate; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdperiodenrolldate (
    periodenrolldateid integer DEFAULT nextval('seq_periodenrolldateid'::regclass) NOT NULL,
    learningperiodid integer NOT NULL,
    description text NOT NULL,
    begindate date NOT NULL,
    enddate date NOT NULL,
    isinternet boolean DEFAULT false NOT NULL,
    isadjustment boolean DEFAULT false NOT NULL,
    isselectiveproc boolean DEFAULT false NOT NULL,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acdperiodenrolldate OWNER TO postgres;

--
-- Name: TABLE acdperiodenrolldate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdperiodenrolldate IS 'datas de matricula/ajustes por periodo';


--
-- Name: COLUMN acdperiodenrolldate.periodenrolldateid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdperiodenrolldate.periodenrolldateid IS 'Codigo da data de matricula/ajustes';


--
-- Name: COLUMN acdperiodenrolldate.learningperiodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdperiodenrolldate.learningperiodid IS 'Codigo do periodo letivo';


--
-- Name: COLUMN acdperiodenrolldate.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdperiodenrolldate.description IS 'Descricao';


--
-- Name: COLUMN acdperiodenrolldate.begindate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdperiodenrolldate.begindate IS 'Data de inicio do periodo de matricula/ajustes';


--
-- Name: COLUMN acdperiodenrolldate.enddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdperiodenrolldate.enddate IS 'Data de termino do periodo de matricula/ajustes';


--
-- Name: COLUMN acdperiodenrolldate.isinternet; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdperiodenrolldate.isinternet IS 'Se a matricula estara liberada na Internet';


--
-- Name: COLUMN acdperiodenrolldate.isadjustment; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdperiodenrolldate.isadjustment IS 'Se e um periodo de ajustes';


--
-- Name: COLUMN acdperiodenrolldate.isselectiveproc; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdperiodenrolldate.isselectiveproc IS 'Se e matricula para vestibulandos (bixos)';


--
-- Name: acdprofessorcenter; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdprofessorcenter (
    professorid bigint NOT NULL,
    centerid integer NOT NULL,
    begindate date NOT NULL,
    enddate date
)
INHERITS (baslog);


ALTER TABLE public.acdprofessorcenter OWNER TO postgres;

--
-- Name: TABLE acdprofessorcenter; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdprofessorcenter IS 'centros dos professores';


--
-- Name: COLUMN acdprofessorcenter.professorid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdprofessorcenter.professorid IS 'Codigo do Professor';


--
-- Name: COLUMN acdprofessorcenter.centerid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdprofessorcenter.centerid IS 'Codigo do centro';


--
-- Name: COLUMN acdprofessorcenter.begindate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdprofessorcenter.begindate IS 'data de ingresso neste centro.';


--
-- Name: COLUMN acdprofessorcenter.enddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdprofessorcenter.enddate IS 'Data de desligamento deste Centro';


--
-- Name: seq_professorcurricularcomponentid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_professorcurricularcomponentid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_professorcurricularcomponentid OWNER TO postgres;

--
-- Name: acdprofessorcurricularcomponent; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdprofessorcurricularcomponent (
    professorcurricularcomponentid integer DEFAULT nextval('seq_professorcurricularcomponentid'::regclass) NOT NULL,
    professorid bigint NOT NULL,
    curricularcomponentid character varying NOT NULL,
    curricularcomponentversion integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdprofessorcurricularcomponent OWNER TO postgres;

--
-- Name: TABLE acdprofessorcurricularcomponent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdprofessorcurricularcomponent IS 'disciplinas que o professor esta apto a ministrar';


--
-- Name: COLUMN acdprofessorcurricularcomponent.professorcurricularcomponentid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdprofessorcurricularcomponent.professorcurricularcomponentid IS 'Campo chave primária';


--
-- Name: COLUMN acdprofessorcurricularcomponent.professorid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdprofessorcurricularcomponent.professorid IS 'Codigo do Professor';


--
-- Name: COLUMN acdprofessorcurricularcomponent.curricularcomponentid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdprofessorcurricularcomponent.curricularcomponentid IS 'Codigo da disciplina';


--
-- Name: COLUMN acdprofessorcurricularcomponent.curricularcomponentversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdprofessorcurricularcomponent.curricularcomponentversion IS 'Versao da disciplina';


--
-- Name: acdprofessorformation; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdprofessorformation (
    professorid bigint NOT NULL,
    formationlevelid integer NOT NULL,
    externalcourseid integer NOT NULL,
    begindate date NOT NULL,
    dateconclusion date NOT NULL,
    institutionid integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdprofessorformation OWNER TO postgres;

--
-- Name: TABLE acdprofessorformation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdprofessorformation IS 'formacao do professor';


--
-- Name: COLUMN acdprofessorformation.professorid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdprofessorformation.professorid IS 'Codigo do professor';


--
-- Name: COLUMN acdprofessorformation.formationlevelid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdprofessorformation.formationlevelid IS 'Codigo do nivel de formacao';


--
-- Name: COLUMN acdprofessorformation.externalcourseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdprofessorformation.externalcourseid IS 'Codigo do curso de formacao';


--
-- Name: COLUMN acdprofessorformation.begindate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdprofessorformation.begindate IS 'Data inicial';


--
-- Name: COLUMN acdprofessorformation.dateconclusion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdprofessorformation.dateconclusion IS 'Data de conclusao';


--
-- Name: COLUMN acdprofessorformation.institutionid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdprofessorformation.institutionid IS 'Codigo da instituicao da formacao';


--
-- Name: seq_projectid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_projectid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_projectid OWNER TO postgres;

--
-- Name: acdproject; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdproject (
    projectid integer DEFAULT nextval('seq_projectid'::regclass) NOT NULL,
    description text
)
INHERITS (baslog);


ALTER TABLE public.acdproject OWNER TO postgres;

--
-- Name: TABLE acdproject; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdproject IS 'projetos';


--
-- Name: COLUMN acdproject.projectid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdproject.projectid IS 'Codigo do projeto';


--
-- Name: COLUMN acdproject.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdproject.description IS 'Descricao';


--
-- Name: seq_reasonid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_reasonid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_reasonid OWNER TO postgres;

--
-- Name: acdreason; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdreason (
    reasonid integer DEFAULT nextval('seq_reasonid'::regclass) NOT NULL,
    description text NOT NULL,
    statecontractid integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdreason OWNER TO postgres;

--
-- Name: TABLE acdreason; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdreason IS 'motivos';


--
-- Name: COLUMN acdreason.reasonid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdreason.reasonid IS 'Codigo do motivo';


--
-- Name: COLUMN acdreason.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdreason.description IS 'Descricao';


--
-- Name: COLUMN acdreason.statecontractid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdreason.statecontractid IS 'Codigo do estado contratual';


--
-- Name: acdreconhecimentodecurso; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdreconhecimentodecurso (
    reconhecimentodecursoid integer NOT NULL,
    courseid character varying(10) NOT NULL,
    documentoreconhecimento text NOT NULL,
    datareconhecimento date,
    datainicial date,
    datafinal date,
    courseversion integer NOT NULL,
    turnid integer NOT NULL,
    unitid integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdreconhecimentodecurso OWNER TO postgres;

--
-- Name: COLUMN acdreconhecimentodecurso.documentoreconhecimento; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdreconhecimentodecurso.documentoreconhecimento IS 'Numero do documento de reconhecimento';


--
-- Name: COLUMN acdreconhecimentodecurso.datareconhecimento; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdreconhecimentodecurso.datareconhecimento IS 'Data do reconhecimento';


--
-- Name: acdreconhecimentodecurso_reconhecimentodecursoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acdreconhecimentodecurso_reconhecimentodecursoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acdreconhecimentodecurso_reconhecimentodecursoid_seq OWNER TO postgres;

--
-- Name: acdreconhecimentodecurso_reconhecimentodecursoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acdreconhecimentodecurso_reconhecimentodecursoid_seq OWNED BY acdreconhecimentodecurso.reconhecimentodecursoid;


--
-- Name: acdregimedomiciliar; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdregimedomiciliar (
    regimedomiciliarid integer NOT NULL,
    enrollid integer NOT NULL,
    datainicial date NOT NULL,
    datafinal date NOT NULL,
    justificativa text
)
INHERITS (baslog);


ALTER TABLE public.acdregimedomiciliar OWNER TO postgres;

--
-- Name: acdregimedomiciliar_regimedomiciliarid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acdregimedomiciliar_regimedomiciliarid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acdregimedomiciliar_regimedomiciliarid_seq OWNER TO postgres;

--
-- Name: acdregimedomiciliar_regimedomiciliarid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acdregimedomiciliar_regimedomiciliarid_seq OWNED BY acdregimedomiciliar.regimedomiciliarid;


--
-- Name: seq_regimenid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_regimenid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_regimenid OWNER TO postgres;

--
-- Name: acdregimen; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdregimen (
    regimenid integer DEFAULT nextval('seq_regimenid'::regclass) NOT NULL,
    description text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdregimen OWNER TO postgres;

--
-- Name: TABLE acdregimen; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdregimen IS 'regimes, ordens que regem as disciplinas - intensivo, especial, normal, ferias';


--
-- Name: COLUMN acdregimen.regimenid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdregimen.regimenid IS 'Codigo do regime';


--
-- Name: COLUMN acdregimen.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdregimen.description IS 'Descricao';


--
-- Name: seq_restricteddocumentid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_restricteddocumentid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_restricteddocumentid OWNER TO postgres;

--
-- Name: acdrestricteddocuments; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdrestricteddocuments (
    restricteddocumentid integer DEFAULT nextval('seq_restricteddocumentid'::regclass) NOT NULL,
    documenttypeid integer NOT NULL,
    formationlevelid integer,
    courseid character varying(10),
    courseversion integer,
    turnid integer,
    unitid integer,
    isin boolean DEFAULT false NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdrestricteddocuments OWNER TO postgres;

--
-- Name: TABLE acdrestricteddocuments; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdrestricteddocuments IS 'documentos restritos pertencentes ou nao, a um curso: 1) todas as pessoas; (sem registro) 2) todas as pessoas de determinado tipo de curso; (formation level) 3) todas as pessoas de determinado curso (formation level e course) ';


--
-- Name: COLUMN acdrestricteddocuments.restricteddocumentid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdrestricteddocuments.restricteddocumentid IS 'Codigo do documento restrito';


--
-- Name: COLUMN acdrestricteddocuments.documenttypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdrestricteddocuments.documenttypeid IS 'Codigo do tipo de documento';


--
-- Name: COLUMN acdrestricteddocuments.formationlevelid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdrestricteddocuments.formationlevelid IS 'Codigo do nivel de formacao';


--
-- Name: COLUMN acdrestricteddocuments.courseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdrestricteddocuments.courseid IS 'Codigo do curso';


--
-- Name: COLUMN acdrestricteddocuments.courseversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdrestricteddocuments.courseversion IS 'Versao do curso';


--
-- Name: COLUMN acdrestricteddocuments.turnid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdrestricteddocuments.turnid IS 'Codigo do turno';


--
-- Name: COLUMN acdrestricteddocuments.unitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdrestricteddocuments.unitid IS 'Codigo da unidade';


--
-- Name: COLUMN acdrestricteddocuments.isin; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdrestricteddocuments.isin IS 'Indica se pertence ou nao a uma determinada condicao';


--
-- Name: acdscheduleprofessorcontent_scheduleprofessorcontentid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acdscheduleprofessorcontent_scheduleprofessorcontentid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acdscheduleprofessorcontent_scheduleprofessorcontentid_seq OWNER TO postgres;

--
-- Name: acdscheduleprofessorcontent_scheduleprofessorcontentid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acdscheduleprofessorcontent_scheduleprofessorcontentid_seq OWNED BY acdscheduleprofessorcontent.scheduleprofessorcontentid;


--
-- Name: acdsemestercontractperiod; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdsemestercontractperiod (
    semestercontractperiodid integer NOT NULL,
    contractid integer NOT NULL,
    periodid character varying,
    semester integer NOT NULL
);


ALTER TABLE public.acdsemestercontractperiod OWNER TO postgres;

--
-- Name: acdsemestercontractperiod_semestercontractperiodid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acdsemestercontractperiod_semestercontractperiodid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acdsemestercontractperiod_semestercontractperiodid_seq OWNER TO postgres;

--
-- Name: acdsemestercontractperiod_semestercontractperiodid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acdsemestercontractperiod_semestercontractperiodid_seq OWNED BY acdsemestercontractperiod.semestercontractperiodid;


--
-- Name: seq_statecontractid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_statecontractid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_statecontractid OWNER TO postgres;

--
-- Name: acdstatecontract; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdstatecontract (
    statecontractid integer DEFAULT nextval('seq_statecontractid'::regclass) NOT NULL,
    description text NOT NULL,
    inouttransition character(1) NOT NULL,
    needsreason boolean DEFAULT false NOT NULL,
    isclosecontract boolean DEFAULT false NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdstatecontract OWNER TO postgres;

--
-- Name: TABLE acdstatecontract; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdstatecontract IS 'estados da movimentacao contratual';


--
-- Name: COLUMN acdstatecontract.statecontractid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdstatecontract.statecontractid IS 'Codigo do estado';


--
-- Name: COLUMN acdstatecontract.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdstatecontract.description IS 'Descricao';


--
-- Name: COLUMN acdstatecontract.inouttransition; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdstatecontract.inouttransition IS 'Estado Inicial, final ou de transicao';


--
-- Name: COLUMN acdstatecontract.needsreason; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdstatecontract.needsreason IS 'Necessita de motivo';


--
-- Name: COLUMN acdstatecontract.isclosecontract; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdstatecontract.isclosecontract IS 'Se fecha o contrato';


--
-- Name: seq_statecontractfieldid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_statecontractfieldid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_statecontractfieldid OWNER TO postgres;

--
-- Name: acdstatecontractfield; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdstatecontractfield (
    statecontractfieldid integer DEFAULT nextval('seq_statecontractfieldid'::regclass) NOT NULL,
    statecontractid integer NOT NULL,
    description text NOT NULL,
    rows integer,
    columns integer DEFAULT 20,
    islookup boolean DEFAULT false NOT NULL,
    lookupname text,
    lookupmodule text,
    fieldvalidator character varying(50),
    isrequired boolean DEFAULT false NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdstatecontractfield OWNER TO postgres;

--
-- Name: TABLE acdstatecontractfield; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdstatecontractfield IS 'campos dos estados';


--
-- Name: COLUMN acdstatecontractfield.statecontractfieldid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdstatecontractfield.statecontractfieldid IS 'Codigo do campo';


--
-- Name: COLUMN acdstatecontractfield.statecontractid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdstatecontractfield.statecontractid IS 'Codigo do estado';


--
-- Name: COLUMN acdstatecontractfield.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdstatecontractfield.description IS 'Descricao';


--
-- Name: COLUMN acdstatecontractfield.rows; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdstatecontractfield.rows IS 'Numero de linhas';


--
-- Name: COLUMN acdstatecontractfield.columns; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdstatecontractfield.columns IS 'Numero de colunas';


--
-- Name: COLUMN acdstatecontractfield.islookup; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdstatecontractfield.islookup IS 'Tipo de campo no formulario';


--
-- Name: COLUMN acdstatecontractfield.lookupname; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdstatecontractfield.lookupname IS 'Nome do metodo do lookup';


--
-- Name: COLUMN acdstatecontractfield.lookupmodule; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdstatecontractfield.lookupmodule IS 'Nome do modulo onde devera ser buscado o lookup';


--
-- Name: COLUMN acdstatecontractfield.fieldvalidator; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdstatecontractfield.fieldvalidator IS 'Validador de campos do Miolo';


--
-- Name: COLUMN acdstatecontractfield.isrequired; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdstatecontractfield.isrequired IS 'Se o campo e obrigatohrio';


--
-- Name: seq_stateenrollbookid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_stateenrollbookid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_stateenrollbookid OWNER TO postgres;

--
-- Name: acdstateenrollbook; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdstateenrollbook (
    stateenrollbookid integer DEFAULT nextval('seq_stateenrollbookid'::regclass) NOT NULL,
    description text NOT NULL,
    issumtototal boolean NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdstateenrollbook OWNER TO postgres;

--
-- Name: TABLE acdstateenrollbook; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdstateenrollbook IS 'estados para geracao dos dados do livro matricula';


--
-- Name: COLUMN acdstateenrollbook.stateenrollbookid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdstateenrollbook.stateenrollbookid IS 'Codigo do estado';


--
-- Name: COLUMN acdstateenrollbook.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdstateenrollbook.description IS 'Descricao';


--
-- Name: COLUMN acdstateenrollbook.issumtototal; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdstateenrollbook.issumtototal IS 'Campo que informa se os alunos neste estado são considerados para o cálculo do numero total de alunos do curso.';


--
-- Name: seq_stateenrollbookrulesid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_stateenrollbookrulesid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_stateenrollbookrulesid OWNER TO postgres;

--
-- Name: acdstateenrollbookrules; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdstateenrollbookrules (
    stateenrollbookrulesid integer DEFAULT nextval('seq_stateenrollbookrulesid'::regclass) NOT NULL,
    stateenrollbookid integer NOT NULL,
    stateidrules integer[] NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdstateenrollbookrules OWNER TO postgres;

--
-- Name: TABLE acdstateenrollbookrules; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdstateenrollbookrules IS 'regras das movimentacoes contratuais para geracao dos dados do livro matricula';


--
-- Name: COLUMN acdstateenrollbookrules.stateenrollbookrulesid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdstateenrollbookrules.stateenrollbookrulesid IS 'Codigo da regra';


--
-- Name: COLUMN acdstateenrollbookrules.stateenrollbookid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdstateenrollbookrules.stateenrollbookid IS 'Codigo do estado do livro matricula';


--
-- Name: COLUMN acdstateenrollbookrules.stateidrules; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdstateenrollbookrules.stateidrules IS 'Sequencia(em ordem) de estados a serem encontrados na tabela de movimentacao contratual, nos registros mais recentes';


--
-- Name: acdstatetransition; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdstatetransition (
    beginstateid integer NOT NULL,
    endstateid integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdstatetransition OWNER TO postgres;

--
-- Name: TABLE acdstatetransition; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdstatetransition IS 'transicao de estados';


--
-- Name: COLUMN acdstatetransition.beginstateid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdstatetransition.beginstateid IS 'Estado inicial';


--
-- Name: COLUMN acdstatetransition.endstateid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdstatetransition.endstateid IS 'Estado final';


--
-- Name: acdsubclass; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdsubclass (
    subclassid character varying(20) NOT NULL,
    classid character varying(20) NOT NULL,
    description text NOT NULL,
    personid bigint,
    groupid integer,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acdsubclass OWNER TO postgres;

--
-- Name: TABLE acdsubclass; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdsubclass IS 'Cadastro das Subturmas dos alunos';


--
-- Name: COLUMN acdsubclass.subclassid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdsubclass.subclassid IS 'Código da Subturma';


--
-- Name: COLUMN acdsubclass.classid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdsubclass.classid IS 'Código da turma mãe';


--
-- Name: COLUMN acdsubclass.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdsubclass.description IS 'Descricao mais extensa para a Subturma';


--
-- Name: COLUMN acdsubclass.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdsubclass.personid IS 'Código da pessoa responsável pela Subturma';


--
-- Name: COLUMN acdsubclass.groupid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdsubclass.groupid IS 'Código da oferecida';


--
-- Name: acdtestendcoursecontract; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdtestendcoursecontract (
    testendcoursetypeid integer NOT NULL,
    contractid integer NOT NULL,
    testendcoursedate date NOT NULL,
    excused boolean DEFAULT false NOT NULL,
    ispresent boolean DEFAULT true NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdtestendcoursecontract OWNER TO postgres;

--
-- Name: TABLE acdtestendcoursecontract; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdtestendcoursecontract IS 'provas de curso por contrato (enade e provao) - somente os obrigados a fazer a prova';


--
-- Name: COLUMN acdtestendcoursecontract.testendcoursetypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdtestendcoursecontract.testendcoursetypeid IS 'Tipo do teste de final de curso (enade, provao, etc.)';


--
-- Name: COLUMN acdtestendcoursecontract.contractid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdtestendcoursecontract.contractid IS 'Codigo do contrato';


--
-- Name: COLUMN acdtestendcoursecontract.testendcoursedate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdtestendcoursecontract.testendcoursedate IS 'Data de aplicacao do teste';


--
-- Name: COLUMN acdtestendcoursecontract.excused; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdtestendcoursecontract.excused IS 'Se foi dispensado';


--
-- Name: COLUMN acdtestendcoursecontract.ispresent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdtestendcoursecontract.ispresent IS 'Se o aluno compareceu a prova ';


--
-- Name: seq_testendcoursetypeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_testendcoursetypeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_testendcoursetypeid OWNER TO postgres;

--
-- Name: acdtestendcoursetype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdtestendcoursetype (
    testendcoursetypeid integer DEFAULT nextval('seq_testendcoursetypeid'::regclass) NOT NULL,
    description text NOT NULL,
    begindate date,
    enddate date,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acdtestendcoursetype OWNER TO postgres;

--
-- Name: TABLE acdtestendcoursetype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE acdtestendcoursetype IS 'tipos de teste de final de curso (provao, enade)';


--
-- Name: COLUMN acdtestendcoursetype.testendcoursetypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdtestendcoursetype.testendcoursetypeid IS 'Codigo do tipo de teste';


--
-- Name: COLUMN acdtestendcoursetype.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdtestendcoursetype.description IS 'Descricao';


--
-- Name: COLUMN acdtestendcoursetype.begindate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdtestendcoursetype.begindate IS 'Data Inicial';


--
-- Name: COLUMN acdtestendcoursetype.enddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdtestendcoursetype.enddate IS 'Data Final';


--
-- Name: seq_acdtime_timeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_acdtime_timeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_acdtime_timeid OWNER TO postgres;

--
-- Name: acdtime; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdtime (
    timeid integer DEFAULT nextval('seq_acdtime_timeid'::regclass) NOT NULL,
    timesheetid integer NOT NULL,
    turnid integer NOT NULL,
    beginhour time without time zone NOT NULL,
    endhour time without time zone NOT NULL,
    numberminutes interval NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acdtime OWNER TO postgres;

--
-- Name: seq_acdtimesheet_timesheetid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_acdtimesheet_timesheetid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_acdtimesheet_timesheetid OWNER TO postgres;

--
-- Name: acdtimesheet; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdtimesheet (
    timesheetid integer DEFAULT nextval('seq_acdtimesheet_timesheetid'::regclass) NOT NULL,
    description text NOT NULL,
    begindate date NOT NULL,
    enddate date,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acdtimesheet OWNER TO postgres;

--
-- Name: acdtrainingdetail; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdtrainingdetail (
    trainingdetailid integer NOT NULL,
    trainingemphasisid integer NOT NULL,
    enrollid integer NOT NULL,
    responsibleid integer,
    realizedactivities text,
    place character varying(100),
    startdate date,
    enddate date,
    duration double precision
)
INHERITS (baslog);


ALTER TABLE public.acdtrainingdetail OWNER TO postgres;

--
-- Name: COLUMN acdtrainingdetail.trainingdetailid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdtrainingdetail.trainingdetailid IS 'Código identificador do detalhamento da ênfase';


--
-- Name: COLUMN acdtrainingdetail.trainingemphasisid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdtrainingdetail.trainingemphasisid IS 'Código identificador da ênfase';


--
-- Name: COLUMN acdtrainingdetail.enrollid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdtrainingdetail.enrollid IS 'Código da matricula';


--
-- Name: COLUMN acdtrainingdetail.responsibleid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdtrainingdetail.responsibleid IS 'Código do responsável pelo estágio';


--
-- Name: COLUMN acdtrainingdetail.realizedactivities; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdtrainingdetail.realizedactivities IS 'Atividades realizadas no estágio';


--
-- Name: COLUMN acdtrainingdetail.place; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdtrainingdetail.place IS 'Local do estágio';


--
-- Name: COLUMN acdtrainingdetail.startdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdtrainingdetail.startdate IS 'Data de início do estágio';


--
-- Name: COLUMN acdtrainingdetail.enddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdtrainingdetail.enddate IS 'Data de fim do estágio';


--
-- Name: COLUMN acdtrainingdetail.duration; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdtrainingdetail.duration IS 'Duração do estágio, em horas.';


--
-- Name: acdtrainingdetail_trainingdetailid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acdtrainingdetail_trainingdetailid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acdtrainingdetail_trainingdetailid_seq OWNER TO postgres;

--
-- Name: acdtrainingdetail_trainingdetailid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acdtrainingdetail_trainingdetailid_seq OWNED BY acdtrainingdetail.trainingdetailid;


--
-- Name: acdtrainingemphasis; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acdtrainingemphasis (
    trainingemphasisid integer NOT NULL,
    groupid integer NOT NULL,
    description character varying(255) NOT NULL,
    responsibleid integer,
    summary character varying(255),
    place character varying(255),
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acdtrainingemphasis OWNER TO postgres;

--
-- Name: COLUMN acdtrainingemphasis.trainingemphasisid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdtrainingemphasis.trainingemphasisid IS 'Código indentificador da ênfase do estágio';


--
-- Name: COLUMN acdtrainingemphasis.groupid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdtrainingemphasis.groupid IS 'Código da disciplina oferecida';


--
-- Name: COLUMN acdtrainingemphasis.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdtrainingemphasis.description IS 'Descrição da ênfase do estágio';


--
-- Name: COLUMN acdtrainingemphasis.responsibleid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdtrainingemphasis.responsibleid IS 'Código da pessoa responsável pelo estágio';


--
-- Name: COLUMN acdtrainingemphasis.summary; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdtrainingemphasis.summary IS 'Ementa do estágio';


--
-- Name: COLUMN acdtrainingemphasis.place; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acdtrainingemphasis.place IS 'Local do estágio';


--
-- Name: acdtrainingemphasis_trainingemphasisid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acdtrainingemphasis_trainingemphasisid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acdtrainingemphasis_trainingemphasisid_seq OWNER TO postgres;

--
-- Name: acdtrainingemphasis_trainingemphasisid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acdtrainingemphasis_trainingemphasisid_seq OWNED BY acdtrainingemphasis.trainingemphasisid;


--
-- Name: acdviewmoodlesubscription; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW acdviewmoodlesubscription AS
    SELECT DISTINCT m.login, ((u.name || ' - REF'::text) || ((g.groupid)::character varying)::text) AS course, CASE WHEN m.isteacher THEN 'editingteacher'::text ELSE 'student'::text END AS perfil FROM (((acdmoodlesubscription m JOIN acdgroup g ON ((m.groupid = g.groupid))) JOIN acdcurriculum r ON ((r.curriculumid = g.curriculumid))) JOIN acdcurricularcomponent u ON ((((u.curricularcomponentid)::text = (r.curricularcomponentid)::text) AND (u.curricularcomponentversion = r.curricularcomponentversion)))) WHERE ((m.processed IS FALSE) AND (m.login IS NOT NULL));


ALTER TABLE public.acdviewmoodlesubscription OWNER TO postgres;

--
-- Name: acompanhamentodedisciplina; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acompanhamentodedisciplina (
    acompanhamentodedisciplinaid integer NOT NULL,
    observacao text NOT NULL,
    data date NOT NULL,
    personid integer,
    enrollid integer
)
INHERITS (baslog);


ALTER TABLE public.acompanhamentodedisciplina OWNER TO postgres;

--
-- Name: acompanhamentodedisciplina_acompanhamentodedisciplinaid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acompanhamentodedisciplina_acompanhamentodedisciplinaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acompanhamentodedisciplina_acompanhamentodedisciplinaid_seq OWNER TO postgres;

--
-- Name: acompanhamentodedisciplina_acompanhamentodedisciplinaid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acompanhamentodedisciplina_acompanhamentodedisciplinaid_seq OWNED BY acompanhamentodedisciplina.acompanhamentodedisciplinaid;


--
-- Name: acpareaconhecimento; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpareaconhecimento (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    areadeconhecimentoid integer NOT NULL,
    descricao character varying(255) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acpareaconhecimento OWNER TO postgres;

--
-- Name: acpareaconhecimento_areadeconhecimentoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpareaconhecimento_areadeconhecimentoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpareaconhecimento_areadeconhecimentoid_seq OWNER TO postgres;

--
-- Name: acpareaconhecimento_areadeconhecimentoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpareaconhecimento_areadeconhecimentoid_seq OWNED BY acpareaconhecimento.areadeconhecimentoid;


--
-- Name: acpatoregulatorio; Type: TABLE; Schema: public; Owner: solis; Tablespace: 
--

CREATE TABLE acpatoregulatorio (
    atoregulatorioid integer NOT NULL,
    ocorrenciacursoid integer,
    documento text NOT NULL,
    datadocumento date,
    datainicial date NOT NULL,
    datafinal date
);


ALTER TABLE public.acpatoregulatorio OWNER TO solis;

--
-- Name: acpatoregulatorio_atoregulatorioid_seq; Type: SEQUENCE; Schema: public; Owner: solis
--

CREATE SEQUENCE acpatoregulatorio_atoregulatorioid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpatoregulatorio_atoregulatorioid_seq OWNER TO solis;

--
-- Name: acpatoregulatorio_atoregulatorioid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: solis
--

ALTER SEQUENCE acpatoregulatorio_atoregulatorioid_seq OWNED BY acpatoregulatorio.atoregulatorioid;


--
-- Name: acpavaliacao; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpavaliacao (
    avaliacaoid integer NOT NULL,
    matriculaid integer,
    nota numeric(7,2),
    dataaula date,
    datalancamento date NOT NULL,
    conceitodeavaliacaoid integer,
    componentedeavaliacaoid integer,
    unitid integer,
    conceito character(1)
);


ALTER TABLE public.acpavaliacao OWNER TO postgres;

--
-- Name: acpavaliacao_avaliacaoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpavaliacao_avaliacaoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpavaliacao_avaliacaoid_seq OWNER TO postgres;

--
-- Name: acpavaliacao_avaliacaoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpavaliacao_avaliacaoid_seq OWNED BY acpavaliacao.avaliacaoid;


--
-- Name: acpcamposadicionaiscurso; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpcamposadicionaiscurso (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    camposadicionaiscursoid integer NOT NULL,
    perfilcursocamposadicionaisid integer,
    cursoid integer,
    dados text NOT NULL,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acpcamposadicionaiscurso OWNER TO postgres;

--
-- Name: acpcamposadicionaiscurso_camposadicionaiscursoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpcamposadicionaiscurso_camposadicionaiscursoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpcamposadicionaiscurso_camposadicionaiscursoid_seq OWNER TO postgres;

--
-- Name: acpcamposadicionaiscurso_camposadicionaiscursoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpcamposadicionaiscurso_camposadicionaiscursoid_seq OWNED BY acpcamposadicionaiscurso.camposadicionaiscursoid;


--
-- Name: acpcomponentecurricular; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpcomponentecurricular (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    componentecurricularid integer NOT NULL,
    matrizcurricularid integer,
    matrizcurriculargrupoid integer,
    codigo character varying(255) NOT NULL,
    nome character varying(255) NOT NULL,
    descricao character varying(255) NOT NULL,
    conteudo character varying(255) NOT NULL,
    tipocomponentecurricularid integer NOT NULL,
    professorresponsavelid integer,
    unitid integer,
    ementa text,
    objetivos text,
    componentecurricularbibliografiaid integer,
    numerodeaulas integer,
    ordem integer
)
INHERITS (baslog);


ALTER TABLE public.acpcomponentecurricular OWNER TO postgres;

--
-- Name: acpcomponentecurricular_componentecurricularid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpcomponentecurricular_componentecurricularid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpcomponentecurricular_componentecurricularid_seq OWNER TO postgres;

--
-- Name: acpcomponentecurricular_componentecurricularid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpcomponentecurricular_componentecurricularid_seq OWNED BY acpcomponentecurricular.componentecurricularid;


--
-- Name: acpcomponentecurricularbibliografia; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpcomponentecurricularbibliografia (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    componentecurricularbibliografiaid integer NOT NULL,
    componentecurricularid integer NOT NULL,
    descricao character varying(255) NOT NULL,
    bibliografiaid integer,
    tipobibliografia character(1) NOT NULL,
    unitid integer,
    ofertacomponentecurricularid integer
)
INHERITS (baslog);


ALTER TABLE public.acpcomponentecurricularbibliografia OWNER TO postgres;

--
-- Name: acpcomponentecurricularbiblio_componentecurricularbibliogra_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpcomponentecurricularbiblio_componentecurricularbibliogra_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpcomponentecurricularbiblio_componentecurricularbibliogra_seq OWNER TO postgres;

--
-- Name: acpcomponentecurricularbiblio_componentecurricularbibliogra_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpcomponentecurricularbiblio_componentecurricularbibliogra_seq OWNED BY acpcomponentecurricularbibliografia.componentecurricularbibliografiaid;


--
-- Name: acpcomponentecurriculardisciplina; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpcomponentecurriculardisciplina (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    componentecurriculardisciplinaid integer NOT NULL,
    componentecurricularid integer,
    cargahoraria numeric(19,0),
    cargahorariapresencial numeric(19,0),
    cargahorariaextraclasse numeric(19,0),
    cargahorariaead numeric(19,0),
    creditosfinanceiros numeric(19,0),
    creditosacademicos numeric(19,0),
    creditos numeric(19,0),
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acpcomponentecurriculardisciplina OWNER TO postgres;

--
-- Name: acpcomponentecurriculardiscip_componentecurriculardisciplin_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpcomponentecurriculardiscip_componentecurriculardisciplin_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpcomponentecurriculardiscip_componentecurriculardisciplin_seq OWNER TO postgres;

--
-- Name: acpcomponentecurriculardiscip_componentecurriculardisciplin_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpcomponentecurriculardiscip_componentecurriculardisciplin_seq OWNED BY acpcomponentecurriculardisciplina.componentecurriculardisciplinaid;


--
-- Name: acpcomponentecurricularmatriz; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpcomponentecurricularmatriz (
    componentecurricularmatrizid integer NOT NULL,
    matrizcurriculargrupoid integer NOT NULL,
    componentecurricularid integer NOT NULL,
    serie integer,
    obrigatorio boolean NOT NULL,
    situacao boolean NOT NULL,
    ordem integer
);


ALTER TABLE public.acpcomponentecurricularmatriz OWNER TO postgres;

--
-- Name: acpcomponentecurricularmatriz_componentecurricularmatrizid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpcomponentecurricularmatriz_componentecurricularmatrizid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpcomponentecurricularmatriz_componentecurricularmatrizid_seq OWNER TO postgres;

--
-- Name: acpcomponentecurricularmatriz_componentecurricularmatrizid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpcomponentecurricularmatriz_componentecurricularmatrizid_seq OWNED BY acpcomponentecurricularmatriz.componentecurricularmatrizid;


--
-- Name: acpcomponentecurriculartrabalhoconclusao; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpcomponentecurriculartrabalhoconclusao (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    componentecurriculartrabalhoconclusaoid integer NOT NULL,
    componentecurricularid integer,
    cargahoraria numeric(19,0),
    creditosfinanceiros numeric(19,0),
    creditosacademicos numeric(19,0),
    creditos numeric(19,0),
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acpcomponentecurriculartrabalhoconclusao OWNER TO postgres;

--
-- Name: acpcomponentecurriculartrabal_componentecurriculartrabalhoc_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpcomponentecurriculartrabal_componentecurriculartrabalhoc_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpcomponentecurriculartrabal_componentecurriculartrabalhoc_seq OWNER TO postgres;

--
-- Name: acpcomponentecurriculartrabal_componentecurriculartrabalhoc_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpcomponentecurriculartrabal_componentecurriculartrabalhoc_seq OWNED BY acpcomponentecurriculartrabalhoconclusao.componentecurriculartrabalhoconclusaoid;


--
-- Name: acpcomponentedeavaliacao; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpcomponentedeavaliacao (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    componentedeavaliacaoid integer NOT NULL,
    modelodeavaliacaoid integer NOT NULL,
    descricao character varying(255) NOT NULL,
    detalhes character varying(255) NOT NULL,
    exigeavaliacoesparciais boolean DEFAULT false NOT NULL,
    permitealteracoes boolean DEFAULT false NOT NULL,
    classedecomponente character(1) NOT NULL,
    ordem integer NOT NULL,
    habilitacor boolean DEFAULT true,
    coraprovado character varying(255) DEFAULT 'lightgreen'::character varying,
    correprovado character varying(255) DEFAULT 'red'::character varying
)
INHERITS (baslog);


ALTER TABLE public.acpcomponentedeavaliacao OWNER TO postgres;

--
-- Name: COLUMN acpcomponentedeavaliacao.habilitacor; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acpcomponentedeavaliacao.habilitacor IS 'Habilita a exibição de cores nas notas/conceitos dependendo do status (APROVADO, REPROVADO) no registro de notas.';


--
-- Name: acpcomponentedeavaliacao_componentedeavaliacaoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpcomponentedeavaliacao_componentedeavaliacaoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpcomponentedeavaliacao_componentedeavaliacaoid_seq OWNER TO postgres;

--
-- Name: acpcomponentedeavaliacao_componentedeavaliacaoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpcomponentedeavaliacao_componentedeavaliacaoid_seq OWNED BY acpcomponentedeavaliacao.componentedeavaliacaoid;


--
-- Name: acpcomponentedeavaliacaoconceito; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpcomponentedeavaliacaoconceito (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    componentedeavaliacaoconceitoid integer NOT NULL,
    conjuntodeconceitosid integer,
    componentedeavaliacaoid integer NOT NULL,
    formadecalculo character(1)
)
INHERITS (baslog);


ALTER TABLE public.acpcomponentedeavaliacaoconceito OWNER TO postgres;

--
-- Name: acpcomponentedeavaliacaoconce_componentedeavaliacaoconceito_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpcomponentedeavaliacaoconce_componentedeavaliacaoconceito_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpcomponentedeavaliacaoconce_componentedeavaliacaoconceito_seq OWNER TO postgres;

--
-- Name: acpcomponentedeavaliacaoconce_componentedeavaliacaoconceito_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpcomponentedeavaliacaoconce_componentedeavaliacaoconceito_seq OWNED BY acpcomponentedeavaliacaoconceito.componentedeavaliacaoconceitoid;


--
-- Name: acpcomponentedeavaliacaonota; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpcomponentedeavaliacaonota (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    componentedeavaliacaonotaid integer NOT NULL,
    componentedeavaliacaoid integer NOT NULL,
    peso integer,
    formadecalculo character(1) NOT NULL,
    valorminimo integer,
    valormaximo integer,
    valorminimoaprovacao integer,
    graudeprecisao integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acpcomponentedeavaliacaonota OWNER TO postgres;

--
-- Name: acpcomponentedeavaliacaonota_componentedeavaliacaonotaid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpcomponentedeavaliacaonota_componentedeavaliacaonotaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpcomponentedeavaliacaonota_componentedeavaliacaonotaid_seq OWNER TO postgres;

--
-- Name: acpcomponentedeavaliacaonota_componentedeavaliacaonotaid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpcomponentedeavaliacaonota_componentedeavaliacaonotaid_seq OWNED BY acpcomponentedeavaliacaonota.componentedeavaliacaonotaid;


--
-- Name: acpcomponentedeavaliacaonotarecuperacao; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpcomponentedeavaliacaonotarecuperacao (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    componentedeavaliacaonotarecuperacaoid integer NOT NULL,
    componentedeavaliacaonotaid integer,
    notadedispensa integer,
    pesodocomponente integer,
    pesodarecuperacao integer
)
INHERITS (baslog);


ALTER TABLE public.acpcomponentedeavaliacaonotarecuperacao OWNER TO postgres;

--
-- Name: acpcomponentedeavaliacaonotar_componentedeavaliacaonotarecu_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpcomponentedeavaliacaonotar_componentedeavaliacaonotarecu_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpcomponentedeavaliacaonotar_componentedeavaliacaonotarecu_seq OWNER TO postgres;

--
-- Name: acpcomponentedeavaliacaonotar_componentedeavaliacaonotarecu_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpcomponentedeavaliacaonotar_componentedeavaliacaonotarecu_seq OWNED BY acpcomponentedeavaliacaonotarecuperacao.componentedeavaliacaonotarecuperacaoid;


--
-- Name: acpconceitosdeavaliacao; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpconceitosdeavaliacao (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    conceitodeavaliacaoid integer NOT NULL,
    conjuntodeconceitosid integer,
    descricao character varying(255) NOT NULL,
    detalhes character varying(255),
    resultado character varying(2) NOT NULL,
    aprova boolean NOT NULL,
    ima integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acpconceitosdeavaliacao OWNER TO postgres;

--
-- Name: COLUMN acpconceitosdeavaliacao.descricao; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acpconceitosdeavaliacao.descricao IS 'Descrição sucinta do conceito, será exibida na tela de registro de avaliação de alunos.';


--
-- Name: COLUMN acpconceitosdeavaliacao.detalhes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acpconceitosdeavaliacao.detalhes IS 'Descrição detalhada do conceito, é informativo.';


--
-- Name: COLUMN acpconceitosdeavaliacao.resultado; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN acpconceitosdeavaliacao.resultado IS 'Representação do conceito, em até dois caracteres, para documentos.';


--
-- Name: acpconceitosdeavaliacao_conceitodeavaliacaoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpconceitosdeavaliacao_conceitodeavaliacaoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpconceitosdeavaliacao_conceitodeavaliacaoid_seq OWNER TO postgres;

--
-- Name: acpconceitosdeavaliacao_conceitodeavaliacaoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpconceitosdeavaliacao_conceitodeavaliacaoid_seq OWNED BY acpconceitosdeavaliacao.conceitodeavaliacaoid;


--
-- Name: acpconjuntodeconceitos; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpconjuntodeconceitos (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    conjuntodeconceitosid integer NOT NULL,
    descricao character varying(255) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acpconjuntodeconceitos OWNER TO postgres;

--
-- Name: acpconjuntodeconceitos_conjuntodeconceitosid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpconjuntodeconceitos_conjuntodeconceitosid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpconjuntodeconceitos_conjuntodeconceitosid_seq OWNER TO postgres;

--
-- Name: acpconjuntodeconceitos_conjuntodeconceitosid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpconjuntodeconceitos_conjuntodeconceitosid_seq OWNED BY acpconjuntodeconceitos.conjuntodeconceitosid;


--
-- Name: acpcontroledefrequencia; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpcontroledefrequencia (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    controledefrequenciaid integer NOT NULL,
    estadodematriculaid integer,
    modelodeavaliacaoid integer,
    estadodereprovacao integer,
    permitejustificativa boolean DEFAULT false NOT NULL,
    permiterecuperacao boolean DEFAULT false NOT NULL,
    tipodelimite character(1) NOT NULL,
    limitedefrequencia integer NOT NULL,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acpcontroledefrequencia OWNER TO postgres;

--
-- Name: acpcontroledefrequencia_controledefrequenciaid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpcontroledefrequencia_controledefrequenciaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpcontroledefrequencia_controledefrequenciaid_seq OWNER TO postgres;

--
-- Name: acpcontroledefrequencia_controledefrequenciaid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpcontroledefrequencia_controledefrequenciaid_seq OWNED BY acpcontroledefrequencia.controledefrequenciaid;


--
-- Name: acpcoordenadores; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpcoordenadores (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    coordenadorcursoid integer NOT NULL,
    personid integer NOT NULL,
    enddate date,
    ocorrenciacursoid integer NOT NULL,
    unitid integer,
    cursoid integer
)
INHERITS (baslog);


ALTER TABLE public.acpcoordenadores OWNER TO postgres;

--
-- Name: acpcoordenadores_coordenadorcursoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpcoordenadores_coordenadorcursoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpcoordenadores_coordenadorcursoid_seq OWNER TO postgres;

--
-- Name: acpcoordenadores_coordenadorcursoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpcoordenadores_coordenadorcursoid_seq OWNED BY acpcoordenadores.coordenadorcursoid;


--
-- Name: acpcurso; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpcurso (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    cursoid integer NOT NULL,
    cursorepresentanteid integer,
    grauacademicoid integer,
    perfilcursoid integer NOT NULL,
    codigo character varying(255),
    nome character varying(255) NOT NULL,
    nomeparadocumentos character varying(255),
    descricao text,
    modalidade character(1) NOT NULL,
    disciplinasadistancia boolean DEFAULT false NOT NULL,
    percentualcargahorariadistancia integer NOT NULL,
    titulacao character varying(255),
    numeroformalvagas integer NOT NULL,
    situacao character(1) NOT NULL,
    datainicio date NOT NULL,
    datafim date NOT NULL,
    gratuito boolean NOT NULL,
    percentualmultadesistencia numeric(5,2)
)
INHERITS (baslog);


ALTER TABLE public.acpcurso OWNER TO postgres;

--
-- Name: acpcurso_cursoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpcurso_cursoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpcurso_cursoid_seq OWNER TO postgres;

--
-- Name: acpcurso_cursoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpcurso_cursoid_seq OWNED BY acpcurso.cursoid;


--
-- Name: acpcursodocente; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpcursodocente (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    cursodocenteid integer NOT NULL,
    personid integer NOT NULL,
    cursoid integer NOT NULL,
    ativo boolean NOT NULL,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acpcursodocente OWNER TO postgres;

--
-- Name: acpcursodocente_cursodocenteid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpcursodocente_cursodocenteid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpcursodocente_cursodocenteid_seq OWNER TO postgres;

--
-- Name: acpcursodocente_cursodocenteid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpcursodocente_cursodocenteid_seq OWNED BY acpcursodocente.cursodocenteid;


--
-- Name: acpestadodematricula; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpestadodematricula (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    estadodematriculaid integer NOT NULL,
    descricao character varying(255) NOT NULL,
    aprovado boolean DEFAULT true NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acpestadodematricula OWNER TO postgres;

--
-- Name: acpestadodematricula_estadodematriculaid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpestadodematricula_estadodematriculaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpestadodematricula_estadodematriculaid_seq OWNER TO postgres;

--
-- Name: acpestadodematricula_estadodematriculaid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpestadodematricula_estadodematriculaid_seq OWNED BY acpestadodematricula.estadodematriculaid;


--
-- Name: acpfrequencia; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpfrequencia (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    frequenciaid integer NOT NULL,
    horarioofertacomponentecurricularid integer NOT NULL,
    matriculaid integer NOT NULL,
    datalancamento date NOT NULL,
    justificativa text,
    ocorrenciahorarioofertaid integer,
    frequencia character(1),
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acpfrequencia OWNER TO postgres;

--
-- Name: acpfrequencia_frequenciaid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpfrequencia_frequenciaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpfrequencia_frequenciaid_seq OWNER TO postgres;

--
-- Name: acpfrequencia_frequenciaid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpfrequencia_frequenciaid_seq OWNED BY acpfrequencia.frequenciaid;


--
-- Name: acpgradehorario; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpgradehorario (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    gradehorarioid integer NOT NULL,
    descricao character varying(255) NOT NULL,
    detalhes text,
    ativo boolean NOT NULL,
    periodicidade character(1)
)
INHERITS (baslog);


ALTER TABLE public.acpgradehorario OWNER TO postgres;

--
-- Name: acpgradehorario_gradehorarioid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpgradehorario_gradehorarioid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpgradehorario_gradehorarioid_seq OWNER TO postgres;

--
-- Name: acpgradehorario_gradehorarioid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpgradehorario_gradehorarioid_seq OWNED BY acpgradehorario.gradehorarioid;


--
-- Name: acpgrauacademico; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpgrauacademico (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    grauacademicoid integer NOT NULL,
    nome character varying(255) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acpgrauacademico OWNER TO postgres;

--
-- Name: acpgrauacademico_grauacademicoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpgrauacademico_grauacademicoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpgrauacademico_grauacademicoid_seq OWNER TO postgres;

--
-- Name: acpgrauacademico_grauacademicoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpgrauacademico_grauacademicoid_seq OWNED BY acpgrauacademico.grauacademicoid;


--
-- Name: acphorario; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acphorario (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    horarioid integer NOT NULL,
    gradehorarioid integer,
    horainicio time(6) without time zone NOT NULL,
    horafim time(6) without time zone NOT NULL,
    minutosfrequencia integer NOT NULL,
    diasemana integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acphorario OWNER TO postgres;

--
-- Name: acphorario_horarioid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acphorario_horarioid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acphorario_horarioid_seq OWNER TO postgres;

--
-- Name: acphorario_horarioid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acphorario_horarioid_seq OWNED BY acphorario.horarioid;


--
-- Name: acphorarioofertacomponentecurricular; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acphorarioofertacomponentecurricular (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    numerodeaulas integer DEFAULT 1 NOT NULL,
    personid integer,
    horarioid integer,
    physicalresourceid integer,
    physicalresourceversion integer,
    ofertacomponentecurricularid integer,
    horarioofertacomponentecurricularid integer NOT NULL,
    diasemana integer,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acphorarioofertacomponentecurricular OWNER TO postgres;

--
-- Name: acphorarioofertacomponentecur_horarioofertacomponentecurric_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acphorarioofertacomponentecur_horarioofertacomponentecurric_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acphorarioofertacomponentecur_horarioofertacomponentecurric_seq OWNER TO postgres;

--
-- Name: acphorarioofertacomponentecur_horarioofertacomponentecurric_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acphorarioofertacomponentecur_horarioofertacomponentecurric_seq OWNED BY acphorarioofertacomponentecurricular.horarioofertacomponentecurricularid;


--
-- Name: acpinscricao; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpinscricao (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    inscricaoid integer NOT NULL,
    personid integer,
    situacao character(1) NOT NULL,
    datasituacao timestamp without time zone NOT NULL,
    origem character(1) NOT NULL,
    diadevencimentoid integer,
    unitid integer,
    precocondicaoinscricaoid integer,
    ofertacursoid integer,
    notafinal numeric(10,2),
    conceitofinal character(1),
    parecerfinal text,
    convenantid integer
)
INHERITS (baslog);


ALTER TABLE public.acpinscricao OWNER TO postgres;

--
-- Name: acpinscricao_inscricaoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpinscricao_inscricaoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpinscricao_inscricaoid_seq OWNER TO postgres;

--
-- Name: acpinscricao_inscricaoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpinscricao_inscricaoid_seq OWNED BY acpinscricao.inscricaoid;


--
-- Name: acpinscricaoturmagrupo; Type: TABLE; Schema: public; Owner: solis; Tablespace: 
--

CREATE TABLE acpinscricaoturmagrupo (
    inscricaoturmagrupoid integer NOT NULL,
    matrizcurriculargrupoid integer,
    inscricaoid integer NOT NULL,
    ofertaturmaid integer NOT NULL,
    unitid integer,
    precocondicaomatriculaid integer,
    notafinal numeric(10,2),
    conceitofinal character(1),
    parecerfinal text
);


ALTER TABLE public.acpinscricaoturmagrupo OWNER TO solis;

--
-- Name: acpinscricaoturmagrupo_inscricaoturmagrupoid_seq; Type: SEQUENCE; Schema: public; Owner: solis
--

CREATE SEQUENCE acpinscricaoturmagrupo_inscricaoturmagrupoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpinscricaoturmagrupo_inscricaoturmagrupoid_seq OWNER TO solis;

--
-- Name: acpinscricaoturmagrupo_inscricaoturmagrupoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: solis
--

ALTER SEQUENCE acpinscricaoturmagrupo_inscricaoturmagrupoid_seq OWNED BY acpinscricaoturmagrupo.inscricaoturmagrupoid;


--
-- Name: acpmatricula; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpmatricula (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    matriculaid integer NOT NULL,
    ofertacomponentecurricularid integer,
    personid integer,
    situacao character(1) NOT NULL,
    datamatricula date NOT NULL,
    unitid integer,
    notafinal integer,
    conceitofinal integer,
    parecerfinal text,
    faltas integer,
    estadodematriculaid integer,
    inscricaoturmagrupoid integer NOT NULL,
    aproveitamento boolean DEFAULT false,
    precocondicaoid integer,
    aproveitamento_interno boolean DEFAULT false,
    obs_aproveitamento text,
    frequencia numeric(10,2)
)
INHERITS (baslog);


ALTER TABLE public.acpmatricula OWNER TO postgres;

--
-- Name: acpmatricula_matriculaid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpmatricula_matriculaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpmatricula_matriculaid_seq OWNER TO postgres;

--
-- Name: acpmatricula_matriculaid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpmatricula_matriculaid_seq OWNED BY acpmatricula.matriculaid;


--
-- Name: acpmatrizcurricular; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpmatrizcurricular (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    matrizcurricularid integer NOT NULL,
    cursoid integer,
    descricao character varying(255) NOT NULL,
    series integer DEFAULT 0,
    situacao character(1) NOT NULL,
    datainicial date NOT NULL,
    datafinal date NOT NULL,
    unitid integer,
    componentecurricularid integer
)
INHERITS (baslog);


ALTER TABLE public.acpmatrizcurricular OWNER TO postgres;

--
-- Name: acpmatrizcurricular_matrizcurricularid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpmatrizcurricular_matrizcurricularid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpmatrizcurricular_matrizcurricularid_seq OWNER TO postgres;

--
-- Name: acpmatrizcurricular_matrizcurricularid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpmatrizcurricular_matrizcurricularid_seq OWNED BY acpmatrizcurricular.matrizcurricularid;


--
-- Name: acpmatrizcurriculargrupo; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpmatrizcurriculargrupo (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    matrizcurriculargrupoid integer NOT NULL,
    matrizcurricularid integer,
    descricao character varying(255) NOT NULL,
    serie integer NOT NULL,
    ordem integer NOT NULL,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acpmatrizcurriculargrupo OWNER TO postgres;

--
-- Name: acpmatrizcurriculargrupo_matrizcurriculargrupoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpmatrizcurriculargrupo_matrizcurriculargrupoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpmatrizcurriculargrupo_matrizcurriculargrupoid_seq OWNER TO postgres;

--
-- Name: acpmatrizcurriculargrupo_matrizcurriculargrupoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpmatrizcurriculargrupo_matrizcurriculargrupoid_seq OWNED BY acpmatrizcurriculargrupo.matrizcurriculargrupoid;


--
-- Name: acpmodelodeavaliacao; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpmodelodeavaliacao (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    modelodeavaliacaoid integer NOT NULL,
    descricao character varying(255) NOT NULL,
    tipodedados character(1) NOT NULL,
    aplicacao character(1) NOT NULL,
    ativo boolean DEFAULT true NOT NULL,
    detalhesdoresultadofinal character varying(255),
    habilitacontroledefrequencia boolean DEFAULT false NOT NULL,
    habilitacomponentesdeavaliacao boolean DEFAULT false NOT NULL,
    habilitarrecuperacoes boolean DEFAULT false NOT NULL,
    estadodematriculareprovacaoid integer,
    estadodematriculaaprovacaorecuperacaoid integer,
    estadodematriculaaprovacaoid integer,
    estadodematriculareprovacaorecuperacaoid integer
)
INHERITS (baslog);


ALTER TABLE public.acpmodelodeavaliacao OWNER TO postgres;

--
-- Name: acpmodelodeavaliacao_modelodeavaliacaoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpmodelodeavaliacao_modelodeavaliacaoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpmodelodeavaliacao_modelodeavaliacaoid_seq OWNER TO postgres;

--
-- Name: acpmodelodeavaliacao_modelodeavaliacaoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpmodelodeavaliacao_modelodeavaliacaoid_seq OWNED BY acpmodelodeavaliacao.modelodeavaliacaoid;


--
-- Name: acpmovimentoinscricao; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpmovimentoinscricao (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    movimentoinscricaoid integer NOT NULL,
    inscricaoid integer NOT NULL,
    situacao character(1) NOT NULL,
    datasituacao timestamp without time zone NOT NULL,
    personid integer NOT NULL,
    ofertaturmaid integer,
    datamovimento timestamp without time zone NOT NULL,
    usuario character varying(255) NOT NULL,
    evento character varying(255) NOT NULL,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acpmovimentoinscricao OWNER TO postgres;

--
-- Name: acpmovimentoinscricao_movimentoinscricaoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpmovimentoinscricao_movimentoinscricaoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpmovimentoinscricao_movimentoinscricaoid_seq OWNER TO postgres;

--
-- Name: acpmovimentoinscricao_movimentoinscricaoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpmovimentoinscricao_movimentoinscricaoid_seq OWNED BY acpmovimentoinscricao.movimentoinscricaoid;


--
-- Name: acpmovimentomatricula; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpmovimentomatricula (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    movimentomatriculaid integer NOT NULL,
    datamovimento timestamp without time zone,
    usuario character varying(255),
    evento character varying(255),
    situacao character(1),
    matriculaid integer,
    personid integer,
    inscricaoid integer,
    datamatricula date,
    ofertacomponentecurricularid integer NOT NULL,
    unitid integer,
    notafinal numeric(10,2),
    conceitofinal character(1),
    parecerfinal text,
    faltas numeric(10,2),
    estadodematriculaid integer
)
INHERITS (baslog);


ALTER TABLE public.acpmovimentomatricula OWNER TO postgres;

--
-- Name: acpmovimentomatricula_movimentomatriculaid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpmovimentomatricula_movimentomatriculaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpmovimentomatricula_movimentomatriculaid_seq OWNER TO postgres;

--
-- Name: acpmovimentomatricula_movimentomatriculaid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpmovimentomatricula_movimentomatriculaid_seq OWNED BY acpmovimentomatricula.movimentomatriculaid;


--
-- Name: acpocorrenciacurso; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpocorrenciacurso (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    ocorrenciacursoid integer NOT NULL,
    unitid integer NOT NULL,
    situacao character(1) NOT NULL,
    cursoid integer NOT NULL,
    turnid integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acpocorrenciacurso OWNER TO postgres;

--
-- Name: acpocorrenciacurso_ocorrenciacursoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpocorrenciacurso_ocorrenciacursoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpocorrenciacurso_ocorrenciacursoid_seq OWNER TO postgres;

--
-- Name: acpocorrenciacurso_ocorrenciacursoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpocorrenciacurso_ocorrenciacursoid_seq OWNED BY acpocorrenciacurso.ocorrenciacursoid;


--
-- Name: seq_ocorrenciaid; Type: SEQUENCE; Schema: public; Owner: solis
--

CREATE SEQUENCE seq_ocorrenciaid
    START WITH 1000
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_ocorrenciaid OWNER TO solis;

--
-- Name: acpocorrenciahorariooferta; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpocorrenciahorariooferta (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    ocorrenciahorarioofertaid integer NOT NULL,
    dataaula date NOT NULL,
    possuifrequencia boolean DEFAULT false NOT NULL,
    cancelada boolean DEFAULT false,
    motivo_cancelamento text,
    horarioid integer,
    ofertacomponentecurricularid integer,
    professorid integer,
    physicalresourceid integer,
    physicalresourceversion integer,
    conteudo text,
    unitid integer,
    repete boolean DEFAULT false NOT NULL,
    ocorrenciaid integer DEFAULT nextval('seq_ocorrenciaid'::regclass)
)
INHERITS (baslog);


ALTER TABLE public.acpocorrenciahorariooferta OWNER TO postgres;

--
-- Name: acpocorrenciahorariooferta_ocorrenciahorarioofertaid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpocorrenciahorariooferta_ocorrenciahorarioofertaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpocorrenciahorariooferta_ocorrenciahorarioofertaid_seq OWNER TO postgres;

--
-- Name: acpocorrenciahorariooferta_ocorrenciahorarioofertaid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpocorrenciahorariooferta_ocorrenciahorarioofertaid_seq OWNED BY acpocorrenciahorariooferta.ocorrenciahorarioofertaid;


--
-- Name: acpofertacomponentecurricular; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpofertacomponentecurricular (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    ofertacomponentecurricularid integer NOT NULL,
    ofertaturmaid integer NOT NULL,
    datainicio date,
    componentecurricularmatrizid integer,
    datafechamento date,
    unitid integer,
    planoaulas text,
    metodologia text,
    avaliacao text
)
INHERITS (baslog);


ALTER TABLE public.acpofertacomponentecurricular OWNER TO postgres;

--
-- Name: acpofertacomponentecurricular_ofertacomponentecurricularid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpofertacomponentecurricular_ofertacomponentecurricularid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpofertacomponentecurricular_ofertacomponentecurricularid_seq OWNER TO postgres;

--
-- Name: acpofertacomponentecurricular_ofertacomponentecurricularid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpofertacomponentecurricular_ofertacomponentecurricularid_seq OWNED BY acpofertacomponentecurricular.ofertacomponentecurricularid;


--
-- Name: acpofertacurso; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpofertacurso (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    ofertacursoid integer NOT NULL,
    ocorrenciacursoid integer,
    descricao character varying(255) NOT NULL,
    dataencerramento date,
    situacao character(1) NOT NULL,
    unitid integer,
    taxainscricao boolean
)
INHERITS (baslog);


ALTER TABLE public.acpofertacurso OWNER TO postgres;

--
-- Name: acpofertacurso_ofertacursoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpofertacurso_ofertacursoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpofertacurso_ofertacursoid_seq OWNER TO postgres;

--
-- Name: acpofertacurso_ofertacursoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpofertacurso_ofertacursoid_seq OWNED BY acpofertacurso.ofertacursoid;


--
-- Name: acpofertaturma; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpofertaturma (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    situacao boolean NOT NULL,
    codigo character varying(255) NOT NULL,
    ofertaturmaid integer NOT NULL,
    ofertaturmaanteriorid integer,
    ofertacursoid integer NOT NULL,
    descricao character varying(255) NOT NULL,
    minimoalunos integer,
    maximoalunos integer,
    unitid integer,
    datainicialoferta date,
    datafinaloferta date,
    dataencerramento date,
    datainicialaulas date,
    datafinalaulas date,
    datainicialinscricao date,
    datafinalinscricao date,
    datainicialmatricula date,
    datafinalmatricula date,
    gradehorarioid integer
)
INHERITS (baslog);


ALTER TABLE public.acpofertaturma OWNER TO postgres;

--
-- Name: acpofertaturma_ofertaturmaid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpofertaturma_ofertaturmaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpofertaturma_ofertaturmaid_seq OWNER TO postgres;

--
-- Name: acpofertaturma_ofertaturmaid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpofertaturma_ofertaturmaid_seq OWNED BY acpofertaturma.ofertaturmaid;


--
-- Name: acpperfilcurso; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpperfilcurso (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    perfilcursoid integer NOT NULL,
    modelodeavaliacaogeral integer,
    modelodeavaliacaoseriado integer,
    descricao character varying(255),
    formadeoferta character(1) NOT NULL,
    ativo boolean DEFAULT true NOT NULL,
    organizacao character(1) NOT NULL,
    percentualconclusaoingressante integer,
    percentualconclusaoconcluinte integer,
    cadastrocorpodocente boolean DEFAULT true NOT NULL,
    cadastrocoordenadores boolean DEFAULT true NOT NULL,
    cadastromatrizcurricular boolean DEFAULT true NOT NULL,
    unitid integer,
    permiteinscricaoporgrupo boolean DEFAULT false NOT NULL,
    mensageminscricaogrupo text
)
INHERITS (baslog);


ALTER TABLE public.acpperfilcurso OWNER TO postgres;

--
-- Name: acpperfilcurso_perfilcursoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpperfilcurso_perfilcursoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpperfilcurso_perfilcursoid_seq OWNER TO postgres;

--
-- Name: acpperfilcurso_perfilcursoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpperfilcurso_perfilcursoid_seq OWNED BY acpperfilcurso.perfilcursoid;


--
-- Name: acpperfilcursocamposadicionais; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpperfilcursocamposadicionais (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    perfilcursocamposadicionaisid integer NOT NULL,
    perfilcursoid integer,
    nomecampo character varying(255) NOT NULL,
    detalhes integer NOT NULL,
    habilitado boolean NOT NULL,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acpperfilcursocamposadicionais OWNER TO postgres;

--
-- Name: acpperfilcursocamposadicionai_perfilcursocamposadicionaisid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpperfilcursocamposadicionai_perfilcursocamposadicionaisid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpperfilcursocamposadicionai_perfilcursocamposadicionaisid_seq OWNER TO postgres;

--
-- Name: acpperfilcursocamposadicionai_perfilcursocamposadicionaisid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpperfilcursocamposadicionai_perfilcursocamposadicionaisid_seq OWNED BY acpperfilcursocamposadicionais.perfilcursocamposadicionaisid;


--
-- Name: acpperfilcursocomponentecurricular; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpperfilcursocomponentecurricular (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    perfilcursocomponentecurricularid integer NOT NULL,
    perfilcursoid integer,
    tipocomponentecurricularid integer,
    modelodeavaliacaoid integer,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acpperfilcursocomponentecurricular OWNER TO postgres;

--
-- Name: acpperfilcursocomponentecurricular_pcccid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpperfilcursocomponentecurricular_pcccid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpperfilcursocomponentecurricular_pcccid_seq OWNER TO postgres;

--
-- Name: acpperfilcursocomponentecurricular_pcccid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpperfilcursocomponentecurricular_pcccid_seq OWNED BY acpperfilcursocomponentecurricular.perfilcursocomponentecurricularid;


--
-- Name: acprecuperacao; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acprecuperacao (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    recuperacaoid integer NOT NULL,
    componentedeavaliacaoid integer NOT NULL,
    aplicacao character(1) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acprecuperacao OWNER TO postgres;

--
-- Name: acprecuperacao_recuperacaoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acprecuperacao_recuperacaoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acprecuperacao_recuperacaoid_seq OWNER TO postgres;

--
-- Name: acprecuperacao_recuperacaoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acprecuperacao_recuperacaoid_seq OWNED BY acprecuperacao.recuperacaoid;


--
-- Name: acpregrasmatriculaperfilcurso; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acpregrasmatriculaperfilcurso (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    regrasmatriculaperfilcursoid integer NOT NULL,
    perfilcursoid integer,
    tipoinscricao character(1) NOT NULL,
    formadeconfirmacaoinscricao character(1) NOT NULL,
    tipomatricula character(1) NOT NULL,
    formadeconfirmacaomatricula character(1) NOT NULL,
    carenciaparapendencias integer,
    numerodependencias integer,
    checardebitosavencer boolean,
    checardebitosvencidos boolean,
    checarnegociacoesabertas boolean,
    checarmultasbiblioteca boolean,
    checardevolucoesbiblioteca boolean,
    tipodecontrolerequisitos character(1),
    quantidademinimatotal integer,
    quantidademaximatotal integer,
    quantidademinimaoutroscursos integer,
    quantidademaximaoutroscursos integer,
    quantidademinimaoutrasunidades integer,
    quantidademaximaoutrasunidades integer,
    quantidademinimaoutrosturnos integer,
    quantidademaximaoutrosturnos integer,
    mensageminicial text,
    mensagemfinal text,
    termoinscricao text,
    termomatricula text,
    utilizarmensageminicial boolean DEFAULT false,
    utilizarmensagemfinal boolean DEFAULT false,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.acpregrasmatriculaperfilcurso OWNER TO postgres;

--
-- Name: acpregrasmatriculaperfilcurso_regrasmatriculaperfilcursoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acpregrasmatriculaperfilcurso_regrasmatriculaperfilcursoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acpregrasmatriculaperfilcurso_regrasmatriculaperfilcursoid_seq OWNER TO postgres;

--
-- Name: acpregrasmatriculaperfilcurso_regrasmatriculaperfilcursoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acpregrasmatriculaperfilcurso_regrasmatriculaperfilcursoid_seq OWNED BY acpregrasmatriculaperfilcurso.regrasmatriculaperfilcursoid;


--
-- Name: acprelacionamentodecomponentes; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acprelacionamentodecomponentes (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    componentedeavaliacaopai integer NOT NULL,
    componentedeavaliacaofilho integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acprelacionamentodecomponentes OWNER TO postgres;

--
-- Name: acptipocomponentecurricular; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acptipocomponentecurricular (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    tipocomponentecurricularid integer NOT NULL,
    descricao character varying(255),
    tipo character(1) NOT NULL,
    habilitado boolean NOT NULL,
    permitemodelodeavaliacao boolean NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acptipocomponentecurricular OWNER TO postgres;

--
-- Name: acptipocomponentecurricular_componentecurricularid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acptipocomponentecurricular_componentecurricularid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acptipocomponentecurricular_componentecurricularid_seq OWNER TO postgres;

--
-- Name: acptipocomponentecurricular_componentecurricularid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acptipocomponentecurricular_componentecurricularid_seq OWNED BY acptipocomponentecurricular.tipocomponentecurricularid;


--
-- Name: acptipodocumento; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE acptipodocumento (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    perfilcursotipodocumentoid integer NOT NULL,
    perfilcursoid integer,
    documenttypeid integer,
    exigido boolean NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.acptipodocumento OWNER TO postgres;

--
-- Name: acptipodocumento_perfilcursotipodocumentoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE acptipodocumento_perfilcursotipodocumentoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.acptipodocumento_perfilcursotipodocumentoid_seq OWNER TO postgres;

--
-- Name: acptipodocumento_perfilcursotipodocumentoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE acptipodocumento_perfilcursotipodocumentoid_seq OWNED BY acptipodocumento.perfilcursotipodocumentoid;


--
-- Name: seq_turnid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_turnid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_turnid OWNER TO postgres;

--
-- Name: basturn; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basturn (
    turnid integer DEFAULT nextval('seq_turnid'::regclass) NOT NULL,
    description character varying(30) NOT NULL,
    shortdescription character varying(3) NOT NULL,
    beginhour time without time zone,
    endhour time without time zone,
    charid character(1) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.basturn OWNER TO postgres;

--
-- Name: TABLE basturn; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basturn IS 'turnos';


--
-- Name: COLUMN basturn.turnid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basturn.turnid IS 'Codigo do turno';


--
-- Name: COLUMN basturn.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basturn.description IS 'Descricao';


--
-- Name: COLUMN basturn.shortdescription; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basturn.shortdescription IS 'Descricao suscinta';


--
-- Name: COLUMN basturn.beginhour; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basturn.beginhour IS 'Horario de inicio';


--
-- Name: COLUMN basturn.endhour; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basturn.endhour IS 'Horario de termino';


--
-- Name: COLUMN basturn.charid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basturn.charid IS 'Codigo de unificacao de turnos';


--
-- Name: seq_unitid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_unitid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_unitid OWNER TO postgres;

--
-- Name: basunit; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basunit (
    unitid integer DEFAULT nextval('seq_unitid'::regclass) NOT NULL,
    description text NOT NULL,
    accountingcode character varying(2) DEFAULT '00'::character varying,
    locationid integer NOT NULL,
    personid bigint
)
INHERITS (baslog);


ALTER TABLE public.basunit OWNER TO postgres;

--
-- Name: TABLE basunit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basunit IS 'unidades (campus)';


--
-- Name: COLUMN basunit.unitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basunit.unitid IS 'Codigo da unidade';


--
-- Name: COLUMN basunit.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basunit.description IS 'Descricao';


--
-- Name: COLUMN basunit.accountingcode; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basunit.accountingcode IS 'Codigo contabil';


--
-- Name: alunos_matriculados_por_periodo; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW alunos_matriculados_por_periodo AS
    SELECT a.contractid AS contrato, x.description AS unidade, x.unitid, a.courseid, e.name AS curso, a.courseversion, f.description AS turno, f.turnid, d.personid AS codigo_pessoa, d.name AS nome, d.email, d.residentialphone AS telefone_residencial, d.workphone AS telefone_trabalho, CASE WHEN (l.contractid IS NOT NULL) THEN 'Nï¿½o renovados'::text WHEN (m.contractid IS NOT NULL) THEN 'Cancelamentos'::text WHEN (k.contractid IS NOT NULL) THEN 'Trancamentos'::text WHEN (j.contractid IS NOT NULL) THEN 'Tranferidos (S)'::text WHEN (i.contractid IS NOT NULL) THEN 'Tranferidos (E)'::text WHEN (h.contractid IS NOT NULL) THEN 'Reingressos'::text WHEN (c.contractid IS NOT NULL) THEN 'Renovados'::text WHEN (n.contractid IS NOT NULL) THEN 'Prï¿½-matriculados'::text WHEN (b.contractid IS NOT NULL) THEN 'Matriculados'::text ELSE NULL::text END AS status, g.periodid FROM ((((((((((((((acdcontract a JOIN ONLY basphysicalperson d ON ((d.personid = a.personid))) JOIN acdcourse e ON (((e.courseid)::text = (a.courseid)::text))) JOIN basturn f ON ((f.turnid = a.turnid))) JOIN acdlearningperiod g ON ((((((g.courseid)::text = (a.courseid)::text) AND (g.courseversion = a.courseversion)) AND (g.turnid = a.turnid)) AND (g.unitid = a.unitid)))) LEFT JOIN basunit x ON ((a.unitid = x.unitid))) LEFT JOIN acdcontract b ON (((((a.contractid = b.contractid) AND (SELECT (count(ssm.*) <= 1) FROM (SELECT sm.learningperiodid FROM acdmovementcontract sm WHERE (((sm.contractid IN (SELECT acdcontract.contractid FROM acdcontract WHERE ((acdcontract.personid = a.personid) AND ((acdcontract.courseid)::text = (a.courseid)::text)))) AND (sm.statecontractid <> (getparameter('BASIC'::character varying, 'WRITING_STATE_CONTRACT'::character varying))::integer)) AND CASE WHEN (SELECT (count(*) > 1) FROM acdcontract WHERE ((acdcontract.personid = a.personid) AND ((acdcontract.courseid)::text = (a.courseid)::text))) THEN (sm.statecontractid = (getparameter('BASIC'::character varying, 'STATE_CONTRACT_ID_ENROLLED'::character varying))::integer) ELSE true END) GROUP BY sm.learningperiodid) ssm)) AND isacademicenrolledinperiod(a.contractid, g.periodid)) AND isfinanceenrolledinperiod(a.contractid, g.periodid)))) LEFT JOIN acdcontract n ON (((a.contractid = n.contractid) AND (getcontractstatebyperiod(a.contractid, g.periodid) = (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_PRE_ENROLL'::character varying))::integer)))) LEFT JOIN acdcontract c ON (((((a.contractid = c.contractid) AND (SELECT (count(ssr.*) > 1) FROM (SELECT sr.learningperiodid FROM acdmovementcontract sr WHERE ((sr.contractid = a.contractid) AND (sr.statecontractid <> (getparameter('BASIC'::character varying, 'WRITING_STATE_CONTRACT'::character varying))::integer)) GROUP BY sr.learningperiodid) ssr)) AND isacademicenrolledinperiod(a.contractid, g.periodid)) AND isfinanceenrolledinperiod(a.contractid, g.periodid)))) LEFT JOIN acdcontract h ON (((((a.contractid = h.contractid) AND (SELECT (count(ssi.*) >= 1) FROM (SELECT si.learningperiodid FROM acdmovementcontract si WHERE (((si.contractid = a.contractid) AND (si.statecontractid = (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_UNLOCKED'::character varying))::integer)) AND (((si.statetime >= g.begindate) AND (si.statetime <= g.enddate)) OR (si.learningperiodid = g.learningperiodid))) GROUP BY si.learningperiodid) ssi)) AND isacademicenrolledinperiod(a.contractid, g.periodid)) AND isfinanceenrolledinperiod(a.contractid, g.periodid)))) LEFT JOIN acdcontract i ON (((((a.contractid = i.contractid) AND (SELECT (count(sse.*) >= 1) FROM (SELECT se.learningperiodid FROM acdmovementcontract se WHERE (((se.contractid = a.contractid) AND (se.statecontractid = (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_EXTERNAL_TRANSFER_FROM'::character varying))::integer)) AND (((se.statetime >= g.begindate) AND (se.statetime <= g.enddate)) OR (se.learningperiodid = g.learningperiodid))) GROUP BY se.learningperiodid) sse)) AND isacademicenrolledinperiod(a.contractid, g.periodid)) AND isfinanceenrolledinperiod(a.contractid, g.periodid)))) LEFT JOIN acdcontract j ON (((a.contractid = j.contractid) AND (getcontractstatebyperiod(j.contractid, g.periodid) = (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_EXTERNAL_TRANSFER_TO'::character varying))::integer)))) LEFT JOIN acdcontract k ON (((a.contractid = k.contractid) AND (getcontractstatebyperiod(k.contractid, g.periodid) = (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_LOCKED'::character varying))::integer)))) LEFT JOIN acdcontract m ON ((((a.contractid = m.contractid) AND (getcontractstatebyperiod(m.contractid, g.periodid) = (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_LOCKED'::character varying))::integer)) AND (SELECT (count(ssm.*) > 0) FROM (SELECT sm.learningperiodid FROM acdmovementcontract sm WHERE (((sm.contractid = a.contractid) AND (sm.statecontractid = (getparameter('BASIC'::character varying, 'WRITING_STATE_CONTRACT'::character varying))::integer)) AND ((sm.learningperiodid = g.learningperiodid) OR ((sm.statetime >= g.begindate) AND (sm.statetime <= g.enddate)))) GROUP BY sm.learningperiodid) ssm)))) LEFT JOIN acdcontract l ON ((((((a.contractid = l.contractid) AND (getcontractstatebyperiod(l.contractid, g.periodid) IS NULL)) AND ((isfinanceenrolledinperiod(l.contractid, g.periodid) IS FALSE) OR (isacademicenrolledinperiod(l.contractid, g.periodid) IS FALSE))) AND (isacademicenrolledinperiod(a.contractid, (SELECT DISTINCT acdlearningperiod.periodid FROM acdlearningperiod WHERE ((acdlearningperiod.periodid)::text < (g.periodid)::text) ORDER BY acdlearningperiod.periodid DESC LIMIT 1)) IS TRUE)) AND (getcontractstate(a.contractid) IN (SELECT acdstatecontract.statecontractid FROM acdstatecontract WHERE (acdstatecontract.isclosecontract IS FALSE)))))) WHERE (((((((((b.contractid IS NOT NULL) OR (c.contractid IS NOT NULL)) OR (h.contractid IS NOT NULL)) OR (i.contractid IS NOT NULL)) OR (j.contractid IS NOT NULL)) OR (k.contractid IS NOT NULL)) OR (l.contractid IS NOT NULL)) OR (m.contractid IS NOT NULL)) OR (n.contractid IS NOT NULL)) GROUP BY a.contractid, x.description, x.unitid, a.courseid, e.name, a.courseversion, f.description, f.turnid, d.personid, d.name, d.email, d.residentialphone, d.workphone, CASE WHEN (l.contractid IS NOT NULL) THEN 'Nï¿½o renovados'::text WHEN (m.contractid IS NOT NULL) THEN 'Cancelamentos'::text WHEN (k.contractid IS NOT NULL) THEN 'Trancamentos'::text WHEN (j.contractid IS NOT NULL) THEN 'Tranferidos (S)'::text WHEN (i.contractid IS NOT NULL) THEN 'Tranferidos (E)'::text WHEN (h.contractid IS NOT NULL) THEN 'Reingressos'::text WHEN (c.contractid IS NOT NULL) THEN 'Renovados'::text WHEN (n.contractid IS NOT NULL) THEN 'Prï¿½-matriculados'::text WHEN (b.contractid IS NOT NULL) THEN 'Matriculados'::text ELSE NULL::text END, g.periodid ORDER BY x.description, e.name, f.description, CASE WHEN (l.contractid IS NOT NULL) THEN 'Nï¿½o renovados'::text WHEN (m.contractid IS NOT NULL) THEN 'Cancelamentos'::text WHEN (k.contractid IS NOT NULL) THEN 'Trancamentos'::text WHEN (j.contractid IS NOT NULL) THEN 'Tranferidos (S)'::text WHEN (i.contractid IS NOT NULL) THEN 'Tranferidos (E)'::text WHEN (h.contractid IS NOT NULL) THEN 'Reingressos'::text WHEN (c.contractid IS NOT NULL) THEN 'Renovados'::text WHEN (n.contractid IS NOT NULL) THEN 'Prï¿½-matriculados'::text WHEN (b.contractid IS NOT NULL) THEN 'Matriculados'::text ELSE NULL::text END, d.name;


ALTER TABLE public.alunos_matriculados_por_periodo OWNER TO solis;

--
-- Name: ava_atributos; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ava_atributos (
    id_atributos integer NOT NULL,
    ref_resposta integer NOT NULL,
    chave character varying NOT NULL,
    valor text
);


ALTER TABLE public.ava_atributos OWNER TO postgres;

--
-- Name: ava_atributos_id_atributos_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ava_atributos_id_atributos_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ava_atributos_id_atributos_seq OWNER TO postgres;

--
-- Name: ava_atributos_id_atributos_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ava_atributos_id_atributos_seq OWNED BY ava_atributos.id_atributos;


--
-- Name: ava_avaliacao; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ava_avaliacao (
    id_avaliacao integer NOT NULL,
    nome text NOT NULL,
    dt_inicio date NOT NULL,
    dt_fim date,
    tipo_processo integer DEFAULT 1 NOT NULL,
    descritivo text,
    dt_fim_relatorio date
);


ALTER TABLE public.ava_avaliacao OWNER TO postgres;

--
-- Name: ava_avaliacao_id_avaliacao_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ava_avaliacao_id_avaliacao_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ava_avaliacao_id_avaliacao_seq OWNER TO postgres;

--
-- Name: ava_avaliacao_id_avaliacao_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ava_avaliacao_id_avaliacao_seq OWNED BY ava_avaliacao.id_avaliacao;


--
-- Name: ava_avaliacao_perfil_widget_id_avaliacao_perfil_widget_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ava_avaliacao_perfil_widget_id_avaliacao_perfil_widget_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ava_avaliacao_perfil_widget_id_avaliacao_perfil_widget_seq OWNER TO postgres;

--
-- Name: ava_avaliacao_perfil_widget; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ava_avaliacao_perfil_widget (
    id_avaliacao_perfil_widget integer DEFAULT nextval('ava_avaliacao_perfil_widget_id_avaliacao_perfil_widget_seq'::regclass) NOT NULL,
    ref_avaliacao integer NOT NULL,
    ref_perfil_widget integer,
    altura character varying,
    largura character varying,
    linha integer,
    coluna integer
);


ALTER TABLE public.ava_avaliacao_perfil_widget OWNER TO postgres;

--
-- Name: ava_avaliacao_widget; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ava_avaliacao_widget (
    id_avaliacao_widget integer NOT NULL,
    ref_avaliacao integer NOT NULL,
    ref_widget character varying NOT NULL,
    opcoes text
);


ALTER TABLE public.ava_avaliacao_widget OWNER TO postgres;

--
-- Name: ava_avaliacao_widget_id_avaliacao_widget_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ava_avaliacao_widget_id_avaliacao_widget_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ava_avaliacao_widget_id_avaliacao_widget_seq OWNER TO postgres;

--
-- Name: ava_avaliacao_widget_id_avaliacao_widget_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ava_avaliacao_widget_id_avaliacao_widget_seq OWNED BY ava_avaliacao_widget.id_avaliacao_widget;


--
-- Name: ava_bloco; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ava_bloco (
    id_bloco integer NOT NULL,
    nome text NOT NULL,
    ref_formulario integer NOT NULL,
    ref_granularidade integer NOT NULL,
    ordem integer
);


ALTER TABLE public.ava_bloco OWNER TO postgres;

--
-- Name: ava_bloco_id_bloco_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ava_bloco_id_bloco_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ava_bloco_id_bloco_seq OWNER TO postgres;

--
-- Name: ava_bloco_id_bloco_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ava_bloco_id_bloco_seq OWNED BY ava_bloco.id_bloco;


--
-- Name: ava_bloco_questoes; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ava_bloco_questoes (
    id_bloco_questoes integer NOT NULL,
    ref_bloco integer NOT NULL,
    ref_questao integer NOT NULL,
    ordem integer,
    obrigatorio boolean,
    ativo boolean
);


ALTER TABLE public.ava_bloco_questoes OWNER TO postgres;

--
-- Name: ava_bloco_questoes_id_bloco_questoes_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ava_bloco_questoes_id_bloco_questoes_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ava_bloco_questoes_id_bloco_questoes_seq OWNER TO postgres;

--
-- Name: ava_bloco_questoes_id_bloco_questoes_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ava_bloco_questoes_id_bloco_questoes_seq OWNED BY ava_bloco_questoes.id_bloco_questoes;


--
-- Name: ava_config; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ava_config (
    chave text NOT NULL,
    valor text
);


ALTER TABLE public.ava_config OWNER TO postgres;

--
-- Name: ava_totalizadores_atributos; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ava_totalizadores_atributos (
    id_totalizador_atributo integer NOT NULL,
    ref_totalizador integer NOT NULL,
    chave text NOT NULL,
    valor text NOT NULL
);


ALTER TABLE public.ava_totalizadores_atributos OWNER TO postgres;

--
-- Name: ava_estatisticas_atributos_id_estatistica_atributo_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ava_estatisticas_atributos_id_estatistica_atributo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ava_estatisticas_atributos_id_estatistica_atributo_seq OWNER TO postgres;

--
-- Name: ava_estatisticas_atributos_id_estatistica_atributo_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ava_estatisticas_atributos_id_estatistica_atributo_seq OWNED BY ava_totalizadores_atributos.id_totalizador_atributo;


--
-- Name: ava_totalizadores; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ava_totalizadores (
    id_totalizador integer NOT NULL,
    ref_avaliacao integer NOT NULL,
    ref_granularidade integer NOT NULL,
    codigo text NOT NULL,
    descricao text,
    count integer NOT NULL
);


ALTER TABLE public.ava_totalizadores OWNER TO postgres;

--
-- Name: ava_estatisticas_id_estatistica_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ava_estatisticas_id_estatistica_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ava_estatisticas_id_estatistica_seq OWNER TO postgres;

--
-- Name: ava_estatisticas_id_estatistica_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ava_estatisticas_id_estatistica_seq OWNED BY ava_totalizadores.id_totalizador;


--
-- Name: ava_form_log_id_form_log_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ava_form_log_id_form_log_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ava_form_log_id_form_log_seq OWNER TO postgres;

--
-- Name: ava_form_log; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ava_form_log (
    id_form_log integer DEFAULT nextval('ava_form_log_id_form_log_seq'::regclass) NOT NULL,
    ref_avaliador character varying NOT NULL,
    ref_formulario integer NOT NULL,
    tipo_acao integer NOT NULL,
    data timestamp without time zone DEFAULT now(),
    sessao character varying,
    tentativa character varying
);


ALTER TABLE public.ava_form_log OWNER TO postgres;

--
-- Name: ava_formulario; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ava_formulario (
    id_formulario integer NOT NULL,
    ref_avaliacao integer NOT NULL,
    ref_perfil integer NOT NULL,
    nome text NOT NULL,
    ref_servico integer NOT NULL,
    descritivo text,
    ref_servico_email integer
);


ALTER TABLE public.ava_formulario OWNER TO postgres;

--
-- Name: ava_formulario_id_formulario_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ava_formulario_id_formulario_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ava_formulario_id_formulario_seq OWNER TO postgres;

--
-- Name: ava_formulario_id_formulario_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ava_formulario_id_formulario_seq OWNED BY ava_formulario.id_formulario;


--
-- Name: ava_granularidade; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ava_granularidade (
    id_granularidade integer NOT NULL,
    descricao text NOT NULL,
    ref_servico integer NOT NULL,
    tipo integer,
    opcoes text
);


ALTER TABLE public.ava_granularidade OWNER TO postgres;

--
-- Name: ava_granularidade_id_granularidade_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ava_granularidade_id_granularidade_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ava_granularidade_id_granularidade_seq OWNER TO postgres;

--
-- Name: ava_granularidade_id_granularidade_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ava_granularidade_id_granularidade_seq OWNED BY ava_granularidade.id_granularidade;


--
-- Name: ava_mail; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ava_mail (
    id_mail integer NOT NULL,
    ref_avaliacao integer NOT NULL,
    ref_perfil integer NOT NULL,
    ref_formulario integer,
    datahora timestamp without time zone NOT NULL,
    assunto text NOT NULL,
    conteudo text NOT NULL,
    tipo_envio integer NOT NULL,
    grupo_envio integer NOT NULL,
    processo integer,
    cco text
);


ALTER TABLE public.ava_mail OWNER TO postgres;

--
-- Name: ava_mail_id_mail_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ava_mail_id_mail_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ava_mail_id_mail_seq OWNER TO postgres;

--
-- Name: ava_mail_id_mail_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ava_mail_id_mail_seq OWNED BY ava_mail.id_mail;


--
-- Name: ava_mail_log; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ava_mail_log (
    id_mail_log integer NOT NULL,
    ref_mail integer NOT NULL,
    ref_destinatario integer NOT NULL,
    destinatario text NOT NULL,
    envio boolean,
    datahora timestamp without time zone
);


ALTER TABLE public.ava_mail_log OWNER TO postgres;

--
-- Name: ava_mail_log_id_mail_log_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ava_mail_log_id_mail_log_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ava_mail_log_id_mail_log_seq OWNER TO postgres;

--
-- Name: ava_mail_log_id_mail_log_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ava_mail_log_id_mail_log_seq OWNED BY ava_mail_log.id_mail_log;


--
-- Name: ava_matriculados; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ava_matriculados (
    ref_campus integer NOT NULL,
    nome_campus text,
    ref_curso integer NOT NULL,
    nome_curso text,
    ref_projeto_pedagogico integer NOT NULL,
    nome_projeto_pedagogico text,
    ref_curriculo integer NOT NULL,
    nome_curriculo text,
    ref_disciplina integer NOT NULL,
    nome_disciplina text,
    dia integer NOT NULL,
    turno character(1),
    ref_professor integer NOT NULL,
    nome_professor text,
    matriculados integer NOT NULL
);


ALTER TABLE public.ava_matriculados OWNER TO postgres;

--
-- Name: ava_opcoes_questoes; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ava_opcoes_questoes (
    opcoesquestoesid integer NOT NULL,
    valor character varying(80),
    opcao text,
    questao character varying(80)
);


ALTER TABLE public.ava_opcoes_questoes OWNER TO postgres;

--
-- Name: ava_opcoes_questoes_opcoesquestoesid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ava_opcoes_questoes_opcoesquestoesid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ava_opcoes_questoes_opcoesquestoesid_seq OWNER TO postgres;

--
-- Name: ava_opcoes_questoes_opcoesquestoesid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ava_opcoes_questoes_opcoesquestoesid_seq OWNED BY ava_opcoes_questoes.opcoesquestoesid;


--
-- Name: ava_perfil; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ava_perfil (
    id_perfil integer NOT NULL,
    descricao text NOT NULL,
    tipo text NOT NULL,
    avaliavel boolean NOT NULL,
    posicao integer
);


ALTER TABLE public.ava_perfil OWNER TO postgres;

--
-- Name: ava_perfil_id_perfil_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ava_perfil_id_perfil_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ava_perfil_id_perfil_seq OWNER TO postgres;

--
-- Name: ava_perfil_id_perfil_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ava_perfil_id_perfil_seq OWNED BY ava_perfil.id_perfil;


--
-- Name: ava_perfil_widget; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ava_perfil_widget (
    id_perfil_widget integer NOT NULL,
    ref_perfil integer NOT NULL,
    ref_widget character varying NOT NULL
);


ALTER TABLE public.ava_perfil_widget OWNER TO postgres;

--
-- Name: ava_perfil_widget_id_perfil_widget_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ava_perfil_widget_id_perfil_widget_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ava_perfil_widget_id_perfil_widget_seq OWNER TO postgres;

--
-- Name: ava_perfil_widget_id_perfil_widget_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ava_perfil_widget_id_perfil_widget_seq OWNED BY ava_perfil_widget.id_perfil_widget;


--
-- Name: ava_questoes; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ava_questoes (
    id_questoes integer NOT NULL,
    descricao text NOT NULL,
    opcoes text,
    tipo integer
);


ALTER TABLE public.ava_questoes OWNER TO postgres;

--
-- Name: ava_questoes_id_questoes_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ava_questoes_id_questoes_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ava_questoes_id_questoes_seq OWNER TO postgres;

--
-- Name: ava_questoes_id_questoes_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ava_questoes_id_questoes_seq OWNED BY ava_questoes.id_questoes;


--
-- Name: ava_respostas; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ava_respostas (
    id_respostas integer NOT NULL,
    ref_bloco_questoes integer NOT NULL,
    ref_avaliado integer,
    ref_avaliador character varying NOT NULL,
    valor text,
    questao character varying
);


ALTER TABLE public.ava_respostas OWNER TO postgres;

--
-- Name: ava_respostas_id_respostas_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ava_respostas_id_respostas_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ava_respostas_id_respostas_seq OWNER TO postgres;

--
-- Name: ava_respostas_id_respostas_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ava_respostas_id_respostas_seq OWNED BY ava_respostas.id_respostas;


--
-- Name: ava_servico; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ava_servico (
    id_servico integer NOT NULL,
    descricao text NOT NULL,
    localizacao text NOT NULL,
    metodo text NOT NULL,
    parametros text,
    atributos text
);


ALTER TABLE public.ava_servico OWNER TO postgres;

--
-- Name: ava_servico_id_servico_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ava_servico_id_servico_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ava_servico_id_servico_seq OWNER TO postgres;

--
-- Name: ava_servico_id_servico_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ava_servico_id_servico_seq OWNED BY ava_servico.id_servico;


--
-- Name: ava_widget; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ava_widget (
    id_widget character varying NOT NULL,
    versao character varying NOT NULL,
    nome character varying NOT NULL,
    opcoes_padrao text
);


ALTER TABLE public.ava_widget OWNER TO postgres;

--
-- Name: basaccess; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basaccess (
    login text NOT NULL,
    moduleaccess text NOT NULL,
    label text NOT NULL,
    image text NOT NULL,
    handler text NOT NULL,
    isbookmark boolean DEFAULT false NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.basaccess OWNER TO postgres;

--
-- Name: TABLE basaccess; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basaccess IS 'tabela que guarda os links que os usuarios acessaram';


--
-- Name: COLUMN basaccess.login; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basaccess.login IS 'Nome do usuario que efetuou o acesso';


--
-- Name: COLUMN basaccess.moduleaccess; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basaccess.moduleaccess IS 'Modulo que o usuario acessou';


--
-- Name: COLUMN basaccess.label; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basaccess.label IS 'Rotulo';


--
-- Name: COLUMN basaccess.image; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basaccess.image IS 'Imagem';


--
-- Name: COLUMN basaccess.handler; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basaccess.handler IS 'Handler acessado';


--
-- Name: COLUMN basaccess.isbookmark; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basaccess.isbookmark IS 'Se o registro e um registro dos favoritos do usuario';


--
-- Name: basatuacaoprofessor; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basatuacaoprofessor (
    atuacaoprofessorid integer NOT NULL,
    tipoatuacaoprofessorid integer NOT NULL,
    personid bigint
)
INHERITS (baslog);


ALTER TABLE public.basatuacaoprofessor OWNER TO postgres;

--
-- Name: basatuacaoprofessor_atuacaoprofessorid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE basatuacaoprofessor_atuacaoprofessorid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.basatuacaoprofessor_atuacaoprofessorid_seq OWNER TO postgres;

--
-- Name: basatuacaoprofessor_atuacaoprofessorid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE basatuacaoprofessor_atuacaoprofessorid_seq OWNED BY basatuacaoprofessor.atuacaoprofessorid;


--
-- Name: basbadge; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basbadge (
    badgeid character varying(15) NOT NULL,
    badgestatusid integer NOT NULL,
    description character varying(255) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.basbadge OWNER TO postgres;

--
-- Name: COLUMN basbadge.badgeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basbadge.badgeid IS 'Código do crachá.';


--
-- Name: COLUMN basbadge.badgestatusid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basbadge.badgestatusid IS 'Código do status do crachá.';


--
-- Name: COLUMN basbadge.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basbadge.description IS 'Descrição do crachá.';


--
-- Name: basbadgeloan; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basbadgeloan (
    loanid integer NOT NULL,
    personid bigint NOT NULL,
    badgeid character varying(15) NOT NULL,
    loandate timestamp without time zone NOT NULL,
    expectedreturndate date NOT NULL,
    comments character varying(255),
    returndate timestamp without time zone
)
INHERITS (baslog);


ALTER TABLE public.basbadgeloan OWNER TO postgres;

--
-- Name: COLUMN basbadgeloan.loanid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basbadgeloan.loanid IS 'Código do empréstimo de crachá.';


--
-- Name: COLUMN basbadgeloan.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basbadgeloan.personid IS 'Código da pessoa a quem o crachá foi emprestado.';


--
-- Name: COLUMN basbadgeloan.badgeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basbadgeloan.badgeid IS 'Código do crachá que foi emprestado.';


--
-- Name: COLUMN basbadgeloan.loandate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basbadgeloan.loandate IS 'Data do empréstimo do crachá.';


--
-- Name: COLUMN basbadgeloan.expectedreturndate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basbadgeloan.expectedreturndate IS 'Data esperada da devolução do crachá.';


--
-- Name: COLUMN basbadgeloan.comments; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basbadgeloan.comments IS 'Comentários sobre o empréstimo do crachá.';


--
-- Name: COLUMN basbadgeloan.returndate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basbadgeloan.returndate IS 'Data da devolução do crachá.';


--
-- Name: basbadgeloan_loanid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE basbadgeloan_loanid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.basbadgeloan_loanid_seq OWNER TO postgres;

--
-- Name: basbadgeloan_loanid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE basbadgeloan_loanid_seq OWNED BY basbadgeloan.loanid;


--
-- Name: basbadgestatus; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basbadgestatus (
    badgestatusid integer NOT NULL,
    description character varying(255) NOT NULL,
    allowloan boolean NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.basbadgestatus OWNER TO postgres;

--
-- Name: COLUMN basbadgestatus.badgestatusid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basbadgestatus.badgestatusid IS 'Código do status do crachá.';


--
-- Name: COLUMN basbadgestatus.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basbadgestatus.description IS 'Descrição do status do crachá.';


--
-- Name: COLUMN basbadgestatus.allowloan; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basbadgestatus.allowloan IS '"Flag" que informa se é possível emprestar o crachá.';


--
-- Name: basbadgestatus_badgestatusid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE basbadgestatus_badgestatusid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.basbadgestatus_badgestatusid_seq OWNER TO postgres;

--
-- Name: basbadgestatus_badgestatusid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE basbadgestatus_badgestatusid_seq OWNED BY basbadgestatus.badgestatusid;


--
-- Name: basbuscadinamica; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basbuscadinamica (
    codigo integer NOT NULL,
    identificador character varying(50) NOT NULL,
    tipo character varying(30),
    nome character varying(100) NOT NULL,
    valorespossiveis text,
    posicao integer,
    valorpadrao text,
    editavel boolean DEFAULT true NOT NULL,
    visivel boolean DEFAULT true NOT NULL,
    referencia text NOT NULL,
    filtravel boolean DEFAULT true NOT NULL,
    exibirnagrid boolean DEFAULT true NOT NULL,
    parametros text,
    chave boolean,
    modulo character varying(20) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.basbuscadinamica OWNER TO postgres;

--
-- Name: basbuscadinamica_codigo_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE basbuscadinamica_codigo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.basbuscadinamica_codigo_seq OWNER TO postgres;

--
-- Name: basbuscadinamica_codigo_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE basbuscadinamica_codigo_seq OWNED BY basbuscadinamica.codigo;


--
-- Name: bascadastrodinamico; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE bascadastrodinamico (
    codigo integer NOT NULL,
    identificador character varying(50) NOT NULL,
    referencia text NOT NULL,
    modulo character varying(20) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.bascadastrodinamico OWNER TO postgres;

--
-- Name: bascadastrodinamico_codigo_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE bascadastrodinamico_codigo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.bascadastrodinamico_codigo_seq OWNER TO postgres;

--
-- Name: bascadastrodinamico_codigo_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE bascadastrodinamico_codigo_seq OWNED BY bascadastrodinamico.codigo;


--
-- Name: bascitysquare; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE bascitysquare (
    cityid integer NOT NULL,
    square character varying(6) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.bascitysquare OWNER TO postgres;

--
-- Name: TABLE bascitysquare; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE bascitysquare IS 'pracas das cidades para o banco';


--
-- Name: COLUMN bascitysquare.cityid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascitysquare.cityid IS 'Codigo da cidade';


--
-- Name: COLUMN bascitysquare.square; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascitysquare.square IS 'Praca';


--
-- Name: seq_companyid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_companyid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_companyid OWNER TO postgres;

--
-- Name: bascompanyconf; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE bascompanyconf (
    companyid integer DEFAULT nextval('seq_companyid'::regclass) NOT NULL,
    personid bigint NOT NULL,
    name text NOT NULL,
    acronym character varying(10) NOT NULL,
    companytypedescription text,
    legalresponsableid integer
)
INHERITS (baslog);


ALTER TABLE public.bascompanyconf OWNER TO postgres;

--
-- Name: TABLE bascompanyconf; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE bascompanyconf IS 'cadastro da empresa que utiliza o sistema. pode-se cadastrar mais de uma empresa, pois o sistema e multi-empresa.';


--
-- Name: COLUMN bascompanyconf.companyid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascompanyconf.companyid IS 'Codigo da empresa';


--
-- Name: COLUMN bascompanyconf.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascompanyconf.personid IS 'Codigo da pessoa para buscar os dados da pessoa jurídica da Instituicão';


--
-- Name: COLUMN bascompanyconf.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascompanyconf.name IS 'Nome da empresa';


--
-- Name: COLUMN bascompanyconf.acronym; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascompanyconf.acronym IS 'Sigla da empresa';


--
-- Name: COLUMN bascompanyconf.companytypedescription; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascompanyconf.companytypedescription IS 'Descrição do tipo de instituicao. Ex: Centro universitario, universidade, faculdade';


--
-- Name: COLUMN bascompanyconf.legalresponsableid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascompanyconf.legalresponsableid IS 'Responsavel legal pela instituição';


--
-- Name: basconfig; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basconfig (
    moduleconfig text NOT NULL,
    parameter text NOT NULL,
    value text,
    description text NOT NULL,
    type character varying(50) NOT NULL,
    label character varying,
    groupby character varying(50),
    orderby integer,
    isgeneralparameter boolean DEFAULT false NOT NULL,
    validatevalue text,
    validatemsg text,
    CONSTRAINT chk_basconfig_groupby CHECK (bas_chk_domain('ABAS_PREFERENCIA'::character varying, groupby))
)
INHERITS (baslog);


ALTER TABLE public.basconfig OWNER TO postgres;

--
-- Name: TABLE basconfig; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basconfig IS 'configuracoes do sistema';


--
-- Name: COLUMN basconfig.moduleconfig; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basconfig.moduleconfig IS 'Modulo do parametro';


--
-- Name: COLUMN basconfig.parameter; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basconfig.parameter IS 'Parametro';


--
-- Name: COLUMN basconfig.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basconfig.value IS 'Valor';


--
-- Name: COLUMN basconfig.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basconfig.description IS 'Descricao do parametro';


--
-- Name: COLUMN basconfig.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basconfig.type IS 'Tipo do parametro';


--
-- Name: basconfiguracaodatelainicial; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basconfiguracaodatelainicial (
    configuracaoid integer NOT NULL,
    login character varying,
    widget character varying,
    posicao character(1),
    ordem integer
)
INHERITS (baslog);


ALTER TABLE public.basconfiguracaodatelainicial OWNER TO postgres;

--
-- Name: basconfiguracaodatelainicial_configuracaoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE basconfiguracaodatelainicial_configuracaoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.basconfiguracaodatelainicial_configuracaoid_seq OWNER TO postgres;

--
-- Name: basconfiguracaodatelainicial_configuracaoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE basconfiguracaodatelainicial_configuracaoid_seq OWNED BY basconfiguracaodatelainicial.configuracaoid;


--
-- Name: basconfiguracaotrocadesenha; Type: TABLE; Schema: public; Owner: solis; Tablespace: 
--

CREATE TABLE basconfiguracaotrocadesenha (
    configuracaotrocadesenhaid integer NOT NULL,
    descricao character varying NOT NULL,
    datainicial date NOT NULL,
    datafinal date,
    mensagem character varying NOT NULL,
    concordarparaprosseguir boolean
)
INHERITS (baslog);


ALTER TABLE public.basconfiguracaotrocadesenha OWNER TO solis;

--
-- Name: basconfiguracaotrocadesenha_configuracaotrocadesenhaid_seq; Type: SEQUENCE; Schema: public; Owner: solis
--

CREATE SEQUENCE basconfiguracaotrocadesenha_configuracaotrocadesenhaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.basconfiguracaotrocadesenha_configuracaotrocadesenhaid_seq OWNER TO solis;

--
-- Name: basconfiguracaotrocadesenha_configuracaotrocadesenhaid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: solis
--

ALTER SEQUENCE basconfiguracaotrocadesenha_configuracaotrocadesenhaid_seq OWNED BY basconfiguracaotrocadesenha.configuracaotrocadesenhaid;


--
-- Name: bascountry; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE bascountry (
    countryid character varying(3) NOT NULL,
    name character varying(50) NOT NULL,
    nationality character varying(30) NOT NULL,
    currency character varying(20),
    pluralcurrency character varying(20),
    decimaldescription character varying(20),
    pluraldecimaldescription character varying(20),
    currencysymbol character varying(20)
)
INHERITS (baslog);


ALTER TABLE public.bascountry OWNER TO postgres;

--
-- Name: TABLE bascountry; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE bascountry IS 'País';


--
-- Name: COLUMN bascountry.countryid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascountry.countryid IS 'Código do país';


--
-- Name: COLUMN bascountry.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascountry.name IS 'nome';


--
-- Name: COLUMN bascountry.nationality; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascountry.nationality IS 'nacionalidade';


--
-- Name: COLUMN bascountry.currency; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascountry.currency IS 'Moeda Ex. Real';


--
-- Name: COLUMN bascountry.pluralcurrency; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascountry.pluralcurrency IS 'moeda no plural (Ex. Reais)';


--
-- Name: COLUMN bascountry.decimaldescription; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascountry.decimaldescription IS 'Descrição decimal (Ex. centavo)';


--
-- Name: COLUMN bascountry.pluraldecimaldescription; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascountry.pluraldecimaldescription IS 'Descrição decimal no plural (Ex. centavos)';


--
-- Name: COLUMN bascountry.currencysymbol; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascountry.currencysymbol IS 'Simbolo da moeda Ex. R$';


--
-- Name: bascrontablog; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE bascrontablog (
)
INHERITS (baslog);


ALTER TABLE public.bascrontablog OWNER TO postgres;

--
-- Name: bascsvimportation; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE bascsvimportation (
    csvimportationid integer NOT NULL,
    type character(1) NOT NULL,
    layout character varying(255) NOT NULL,
    date timestamp without time zone DEFAULT now() NOT NULL,
    observation character varying(255),
    unitid integer,
    fileid integer
)
INHERITS (baslog);


ALTER TABLE public.bascsvimportation OWNER TO postgres;

--
-- Name: bascsvimportation_csvimportationid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE bascsvimportation_csvimportationid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.bascsvimportation_csvimportationid_seq OWNER TO postgres;

--
-- Name: bascsvimportation_csvimportationid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE bascsvimportation_csvimportationid_seq OWNED BY bascsvimportation.csvimportationid;


--
-- Name: bascsvlog; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE bascsvlog (
    bascsvlogid integer NOT NULL,
    importdate timestamp without time zone NOT NULL,
    line integer NOT NULL,
    type integer,
    colname character varying(255),
    information text,
    error text,
    csvimportationid integer
)
INHERITS (baslog);


ALTER TABLE public.bascsvlog OWNER TO postgres;

--
-- Name: bascsvlog_bascsvlogid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE bascsvlog_bascsvlogid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.bascsvlog_bascsvlogid_seq OWNER TO postgres;

--
-- Name: bascsvlog_bascsvlogid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE bascsvlog_bascsvlogid_seq OWNED BY bascsvlog.bascsvlogid;


--
-- Name: seq_cvslogid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_cvslogid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_cvslogid OWNER TO postgres;

--
-- Name: bascvslog; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE bascvslog (
    cvslogid integer DEFAULT nextval('seq_cvslogid'::regclass) NOT NULL,
    tablename text NOT NULL,
    fieldname text NOT NULL,
    oldvalue text,
    tablepkey text NOT NULL,
    tablepkeyvalue text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.bascvslog OWNER TO postgres;

--
-- Name: TABLE bascvslog; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE bascvslog IS 'tabela de log de alteracoes na base atraves dos processos on-line';


--
-- Name: COLUMN bascvslog.cvslogid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascvslog.cvslogid IS 'Codigo do log';


--
-- Name: COLUMN bascvslog.tablename; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascvslog.tablename IS 'Nome da tabela alterada';


--
-- Name: COLUMN bascvslog.fieldname; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascvslog.fieldname IS 'Nome do campo alterado';


--
-- Name: COLUMN bascvslog.oldvalue; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascvslog.oldvalue IS 'Valor antigo';


--
-- Name: COLUMN bascvslog.tablepkey; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascvslog.tablepkey IS 'Chave primaria da tabela';


--
-- Name: COLUMN bascvslog.tablepkeyvalue; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bascvslog.tablepkeyvalue IS 'Valor da chave primaria da tabela';


--
-- Name: basdocument; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basdocument (
    personid bigint NOT NULL,
    documenttypeid integer NOT NULL,
    content text,
    isdelivered boolean DEFAULT false NOT NULL,
    cityid integer,
    organ character varying(15),
    dateexpedition date,
    obs text,
    isexcused boolean DEFAULT false NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.basdocument OWNER TO postgres;

--
-- Name: TABLE basdocument; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basdocument IS 'documentos dos alunos';


--
-- Name: COLUMN basdocument.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basdocument.personid IS 'Codigo da pessoa';


--
-- Name: COLUMN basdocument.documenttypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basdocument.documenttypeid IS 'Codigo do tipo do documento';


--
-- Name: COLUMN basdocument.content; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basdocument.content IS 'numero, texto ou valor do documento';


--
-- Name: COLUMN basdocument.isdelivered; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basdocument.isdelivered IS 'se o documento foi entregue ou nao';


--
-- Name: COLUMN basdocument.cityid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basdocument.cityid IS 'Cidade de expedição do documento, se for necessario';


--
-- Name: COLUMN basdocument.organ; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basdocument.organ IS 'Orgao Expedidor do documento, se for necessario';


--
-- Name: COLUMN basdocument.dateexpedition; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basdocument.dateexpedition IS 'Data de expedicao do documento, se for necessario';


--
-- Name: COLUMN basdocument.obs; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basdocument.obs IS 'Eventual observacao';


--
-- Name: COLUMN basdocument.isexcused; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basdocument.isexcused IS 'Campo para setar se determinada pessoa está dispensada de apresentar este documento';


--
-- Name: basdocumentogerado; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basdocumentogerado (
    documentogeradoid integer NOT NULL,
    codigoverificador character varying NOT NULL,
    datageracao timestamp without time zone DEFAULT now() NOT NULL,
    usuario character varying NOT NULL,
    nomedocumento character varying NOT NULL,
    titulo character varying,
    modulo character varying NOT NULL,
    fileid integer,
    personiddocumento bigint,
    numeroregistro integer,
    parametros text
)
INHERITS (baslog);


ALTER TABLE public.basdocumentogerado OWNER TO postgres;

--
-- Name: COLUMN basdocumentogerado.personiddocumento; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basdocumentogerado.personiddocumento IS 'Indica para quem o documento foi gerado, caso ele se refira a uma pessoa';


--
-- Name: basdocumentogerado_documentogeradoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE basdocumentogerado_documentogeradoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.basdocumentogerado_documentogeradoid_seq OWNER TO postgres;

--
-- Name: basdocumentogerado_documentogeradoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE basdocumentogerado_documentogeradoid_seq OWNED BY basdocumentogerado.documentogeradoid;


--
-- Name: seq_documenttypeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_documenttypeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_documenttypeid OWNER TO postgres;

--
-- Name: basdocumenttype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basdocumenttype (
    documenttypeid integer DEFAULT nextval('seq_documenttypeid'::regclass) NOT NULL,
    name text NOT NULL,
    mask text,
    sex character(1),
    persontype character(1) NOT NULL,
    minage integer,
    maxage integer,
    needdeliver boolean DEFAULT true NOT NULL,
    isblockenroll boolean DEFAULT false NOT NULL,
    fillhint text,
    exigepreenchimento boolean DEFAULT true NOT NULL,
    validaconteudo boolean DEFAULT true NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.basdocumenttype OWNER TO postgres;

--
-- Name: TABLE basdocumenttype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basdocumenttype IS 'Tipo de documento ';


--
-- Name: COLUMN basdocumenttype.documenttypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basdocumenttype.documenttypeid IS 'código do tipo de documento.';


--
-- Name: COLUMN basdocumenttype.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basdocumenttype.name IS 'Nome do tipo de documento.';


--
-- Name: COLUMN basdocumenttype.mask; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basdocumenttype.mask IS 'Máscara';


--
-- Name: COLUMN basdocumenttype.sex; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basdocumenttype.sex IS 'sexo que deve ter este documento.';


--
-- Name: COLUMN basdocumenttype.persontype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basdocumenttype.persontype IS 'Tipo de pessoa';


--
-- Name: COLUMN basdocumenttype.minage; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basdocumenttype.minage IS 'idade mínima';


--
-- Name: COLUMN basdocumenttype.maxage; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basdocumenttype.maxage IS 'idade máxima';


--
-- Name: COLUMN basdocumenttype.needdeliver; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basdocumenttype.needdeliver IS 'precisa de entrega';


--
-- Name: COLUMN basdocumenttype.isblockenroll; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basdocumenttype.isblockenroll IS 'bloqueia matricula';


--
-- Name: COLUMN basdocumenttype.fillhint; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basdocumenttype.fillhint IS 'dica de preenchimento';


--
-- Name: COLUMN basdocumenttype.validaconteudo; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basdocumenttype.validaconteudo IS 'Define se o conteúdo do documento deve ser único';


--
-- Name: basdomain; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basdomain (
    domainid character varying(100) NOT NULL,
    sequence integer NOT NULL,
    key character varying(100) NOT NULL,
    abbreviated character varying(100) NOT NULL,
    label character varying(255) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.basdomain OWNER TO postgres;

--
-- Name: seq_emailid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_emailid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_emailid OWNER TO postgres;

--
-- Name: basemail; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basemail (
    emailid integer DEFAULT nextval('seq_emailid'::regclass) NOT NULL,
    description text NOT NULL,
    "from" text NOT NULL,
    bcc text,
    subject text NOT NULL,
    body text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.basemail OWNER TO postgres;

--
-- Name: TABLE basemail; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basemail IS 'tabela que grava o template dos emails a serem enviados e suas configuracoes';


--
-- Name: COLUMN basemail.emailid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemail.emailid IS 'Codigo do email';


--
-- Name: COLUMN basemail.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemail.description IS 'Descricao do que e este email';


--
-- Name: COLUMN basemail."from"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemail."from" IS 'Remetente';


--
-- Name: COLUMN basemail.bcc; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemail.bcc IS 'Copia oculta';


--
-- Name: COLUMN basemail.subject; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemail.subject IS 'Assunto do email';


--
-- Name: COLUMN basemail.body; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemail.body IS 'Corpo do email';


--
-- Name: seq_employeeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_employeeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_employeeid OWNER TO postgres;

--
-- Name: basemployee; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basemployee (
    employeeid integer DEFAULT nextval('seq_employeeid'::regclass) NOT NULL,
    personid bigint NOT NULL,
    externalid character varying(10),
    sectorid integer,
    salary numeric(14,2),
    valuehour boolean DEFAULT false,
    weeklyhours double precision,
    begindate date,
    enddate date,
    employeetypeid integer NOT NULL,
    bankid character varying(3),
    branchnumber character varying(20),
    branchnumberdigit character varying(2),
    accountnumber character varying(20),
    accountnumberdigit character varying(2),
    isactiveaccount boolean DEFAULT false NOT NULL,
    accounttype character varying(2),
    clearinghouse integer,
    especialidade text,
    classe text,
    nivel text,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.basemployee OWNER TO postgres;

--
-- Name: TABLE basemployee; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basemployee IS 'pessoa fisica - funcionario - quantas horas em cada codigo externo, salario e por mes ou por hora, um salario por contrato? dois contratos para o mesmo setor? data de ingresso...';


--
-- Name: COLUMN basemployee.employeeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemployee.employeeid IS 'Codigo do funcionario';


--
-- Name: COLUMN basemployee.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemployee.personid IS 'Codigo da pessoa';


--
-- Name: COLUMN basemployee.externalid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemployee.externalid IS 'Codigo no Siga';


--
-- Name: COLUMN basemployee.sectorid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemployee.sectorid IS 'Codigo do setor';


--
-- Name: COLUMN basemployee.salary; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemployee.salary IS 'Salario';


--
-- Name: COLUMN basemployee.valuehour; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemployee.valuehour IS 'se o salário equivale ao valor da hora?';


--
-- Name: COLUMN basemployee.weeklyhours; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemployee.weeklyhours IS 'Quantas horas semanais';


--
-- Name: COLUMN basemployee.begindate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemployee.begindate IS 'Data inicial deste vinculo';


--
-- Name: COLUMN basemployee.enddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemployee.enddate IS 'Data final deste vinculo';


--
-- Name: COLUMN basemployee.employeetypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemployee.employeetypeid IS 'Tipo de funcionario. Ex: Estagiario, funcionario, bolsista';


--
-- Name: COLUMN basemployee.bankid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemployee.bankid IS 'Banco da conta do funcionario';


--
-- Name: COLUMN basemployee.branchnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemployee.branchnumber IS 'Numero da agencia';


--
-- Name: COLUMN basemployee.branchnumberdigit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemployee.branchnumberdigit IS 'Digito da agencia';


--
-- Name: COLUMN basemployee.accountnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemployee.accountnumber IS 'Numero da conta';


--
-- Name: COLUMN basemployee.accountnumberdigit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemployee.accountnumberdigit IS 'Digito da conta';


--
-- Name: COLUMN basemployee.isactiveaccount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemployee.isactiveaccount IS 'Se a conta esta ativa ou nao';


--
-- Name: COLUMN basemployee.accounttype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemployee.accounttype IS 'Tipo da conta - 01: Conta Corrente 05: Conta Poupança';


--
-- Name: COLUMN basemployee.clearinghouse; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemployee.clearinghouse IS 'Camera de Compensação: Informação utilizada no arquivo de abertura de contas';


--
-- Name: seq_employeetypeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_employeetypeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_employeetypeid OWNER TO postgres;

--
-- Name: basemployeetype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basemployeetype (
    employeetypeid integer DEFAULT nextval('seq_employeetypeid'::regclass) NOT NULL,
    description text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.basemployeetype OWNER TO postgres;

--
-- Name: TABLE basemployeetype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basemployeetype IS 'tipo de funcionario: estagiario, bolsista, funcionario';


--
-- Name: COLUMN basemployeetype.employeetypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemployeetype.employeetypeid IS 'Tipo de funcionario';


--
-- Name: COLUMN basemployeetype.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basemployeetype.description IS 'Descricao';


--
-- Name: seq_ethnicoriginid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_ethnicoriginid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_ethnicoriginid OWNER TO postgres;

--
-- Name: basethnicorigin; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basethnicorigin (
    ethnicoriginid integer DEFAULT nextval('seq_ethnicoriginid'::regclass) NOT NULL,
    description text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.basethnicorigin OWNER TO postgres;

--
-- Name: TABLE basethnicorigin; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basethnicorigin IS 'origem etnica - raã§as';


--
-- Name: COLUMN basethnicorigin.ethnicoriginid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basethnicorigin.ethnicoriginid IS 'Codigo da origem etnica';


--
-- Name: COLUMN basethnicorigin.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basethnicorigin.description IS 'Descricao';


--
-- Name: basetiquetadatabela; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basetiquetadatabela (
    etiquetadatabelaid integer NOT NULL,
    tabela character varying(255),
    esquema character varying(255),
    etiqueta character varying(255)
)
INHERITS (baslog);


ALTER TABLE public.basetiquetadatabela OWNER TO postgres;

--
-- Name: basetiquetadatabela_etiquetadatabelaid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE basetiquetadatabela_etiquetadatabelaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.basetiquetadatabela_etiquetadatabelaid_seq OWNER TO postgres;

--
-- Name: basetiquetadatabela_etiquetadatabelaid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE basetiquetadatabela_etiquetadatabelaid_seq OWNED BY basetiquetadatabela.etiquetadatabelaid;


--
-- Name: seq_fileid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_fileid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_fileid OWNER TO postgres;

--
-- Name: basfile; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basfile (
    fileid integer DEFAULT nextval('seq_fileid'::regclass) NOT NULL,
    uploadfilename text NOT NULL,
    contenttype text NOT NULL,
    filepath text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.basfile OWNER TO postgres;

--
-- Name: TABLE basfile; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basfile IS 'tabela que grava os arquivos de upload';


--
-- Name: COLUMN basfile.fileid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basfile.fileid IS 'Codigo do arquivo';


--
-- Name: COLUMN basfile.uploadfilename; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basfile.uploadfilename IS 'Nome original do arquivo';


--
-- Name: COLUMN basfile.contenttype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basfile.contenttype IS 'Tipo de conteúdo do arquivo';


--
-- Name: COLUMN basfile.filepath; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basfile.filepath IS 'Caminho do aquivo no sagu';


--
-- Name: basgrupotrocadesenha; Type: TABLE; Schema: public; Owner: solis; Tablespace: 
--

CREATE TABLE basgrupotrocadesenha (
    grupostrocadesenhaid integer NOT NULL,
    configuracaotrocadesenhaid integer NOT NULL,
    idgroup integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.basgrupotrocadesenha OWNER TO solis;

--
-- Name: basgrupotrocadesenha_grupostrocadesenhaid_seq; Type: SEQUENCE; Schema: public; Owner: solis
--

CREATE SEQUENCE basgrupotrocadesenha_grupostrocadesenhaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.basgrupotrocadesenha_grupostrocadesenhaid_seq OWNER TO solis;

--
-- Name: basgrupotrocadesenha_grupostrocadesenhaid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: solis
--

ALTER SEQUENCE basgrupotrocadesenha_grupostrocadesenhaid_seq OWNED BY basgrupotrocadesenha.grupostrocadesenhaid;


--
-- Name: bashistoricoferias; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE bashistoricoferias (
    historicoferiasid integer NOT NULL,
    personid integer NOT NULL,
    data date NOT NULL,
    inicioaquisicao date NOT NULL,
    fimaquisicao date NOT NULL,
    inicioconcessao date NOT NULL,
    fimconcessao date NOT NULL,
    observacao text
)
INHERITS (baslog);


ALTER TABLE public.bashistoricoferias OWNER TO postgres;

--
-- Name: bashistoricoferias_historicoferiasid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE bashistoricoferias_historicoferiasid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.bashistoricoferias_historicoferiasid_seq OWNER TO postgres;

--
-- Name: bashistoricoferias_historicoferiasid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE bashistoricoferias_historicoferiasid_seq OWNED BY bashistoricoferias.historicoferiasid;


--
-- Name: bashistoricofuncional; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE bashistoricofuncional (
    historicofuncionalid integer NOT NULL,
    personid bigint NOT NULL,
    portaria character varying,
    data date NOT NULL,
    assunto text NOT NULL,
    inicio date NOT NULL,
    fim date,
    observacao text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.bashistoricofuncional OWNER TO postgres;

--
-- Name: bashistoricofuncional_historicofuncionalid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE bashistoricofuncional_historicofuncionalid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.bashistoricofuncional_historicofuncionalid_seq OWNER TO postgres;

--
-- Name: bashistoricofuncional_historicofuncionalid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE bashistoricofuncional_historicofuncionalid_seq OWNED BY bashistoricofuncional.historicofuncionalid;


--
-- Name: baskinship; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE baskinship (
    kinshipid integer NOT NULL,
    description character varying(40) NOT NULL,
    required boolean DEFAULT false NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.baskinship OWNER TO postgres;

--
-- Name: TABLE baskinship; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE baskinship IS 'Tipos de parentesco';


--
-- Name: COLUMN baskinship.kinshipid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baskinship.kinshipid IS 'Identificador do tipo de parentesco.';


--
-- Name: COLUMN baskinship.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baskinship.description IS 'Descrição do tipo de parentesco, tal como "pai", "mãe", "irmão", etc.';


--
-- Name: COLUMN baskinship.required; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baskinship.required IS 'Indica se o tipo de parentesco é de cadastro obrigatório (TRUE) ou não (FALSE) no momento em que uma pessoa física é cadastrada.';


--
-- Name: baskinship_kinshipid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE baskinship_kinshipid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.baskinship_kinshipid_seq OWNER TO postgres;

--
-- Name: baskinship_kinshipid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE baskinship_kinshipid_seq OWNED BY baskinship.kinshipid;


--
-- Name: baslegalperson; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE baslegalperson (
    fakename character varying(100),
    cnpj character varying(20),
    stateregistration character varying(20),
    cityregistration character varying(20),
    legalpersontypeid integer,
    phone character varying(50),
    fax character varying(50),
    ispublic boolean
)
INHERITS (basperson);


ALTER TABLE public.baslegalperson OWNER TO postgres;

--
-- Name: TABLE baslegalperson; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE baslegalperson IS 'pessoas juridicas';


--
-- Name: COLUMN baslegalperson.fakename; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baslegalperson.fakename IS 'Nome fantasia';


--
-- Name: COLUMN baslegalperson.cnpj; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baslegalperson.cnpj IS 'CNPJ';


--
-- Name: COLUMN baslegalperson.stateregistration; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baslegalperson.stateregistration IS 'Inscricao estadual';


--
-- Name: COLUMN baslegalperson.cityregistration; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baslegalperson.cityregistration IS 'Inscricao municipal';


--
-- Name: COLUMN baslegalperson.legalpersontypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baslegalperson.legalpersontypeid IS 'Tipo de pessoa juridica';


--
-- Name: COLUMN baslegalperson.phone; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baslegalperson.phone IS 'Telefone';


--
-- Name: COLUMN baslegalperson.fax; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baslegalperson.fax IS 'Fax';


--
-- Name: COLUMN baslegalperson.ispublic; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baslegalperson.ispublic IS 'Indica se a pessoa jurídica que está sendo cadastrada é publica ou privada.';


--
-- Name: seq_legalpersontypeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_legalpersontypeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_legalpersontypeid OWNER TO postgres;

--
-- Name: baslegalpersontype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE baslegalpersontype (
    legalpersontypeid integer DEFAULT nextval('seq_legalpersontypeid'::regclass) NOT NULL,
    description text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.baslegalpersontype OWNER TO postgres;

--
-- Name: TABLE baslegalpersontype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE baslegalpersontype IS 'tipos de pessoa juridica';


--
-- Name: COLUMN baslegalpersontype.legalpersontypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baslegalpersontype.legalpersontypeid IS 'Codigo do tipo de pessoa juridica';


--
-- Name: COLUMN baslegalpersontype.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baslegalpersontype.description IS 'Descricao';


--
-- Name: seq_linkid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_linkid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_linkid OWNER TO postgres;

--
-- Name: baslink; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE baslink (
    linkid integer DEFAULT nextval('seq_linkid'::regclass) NOT NULL,
    description text NOT NULL,
    level integer NOT NULL,
    isvisibletoperson boolean DEFAULT false,
    isoperator boolean DEFAULT false
)
INHERITS (baslog);


ALTER TABLE public.baslink OWNER TO postgres;

--
-- Name: TABLE baslink; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE baslink IS 'vinculos';


--
-- Name: COLUMN baslink.linkid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baslink.linkid IS 'Codigo do vinculo';


--
-- Name: COLUMN baslink.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baslink.description IS 'Descricao';


--
-- Name: COLUMN baslink.level; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baslink.level IS 'Define o nível de prioridade de dada grupo. O valor mais baixo representa uma proiridade maior';


--
-- Name: seq_locationid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_locationid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_locationid OWNER TO postgres;

--
-- Name: baslocation; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE baslocation (
    locationid integer DEFAULT nextval('seq_locationid'::regclass) NOT NULL,
    name text NOT NULL,
    cityid integer NOT NULL,
    zipcode character varying(9) NOT NULL,
    neighborhoodid integer
)
INHERITS (baslog);


ALTER TABLE public.baslocation OWNER TO postgres;

--
-- Name: TABLE baslocation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE baslocation IS 'logradouros';


--
-- Name: COLUMN baslocation.locationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baslocation.locationid IS 'Codigo do logradouro';


--
-- Name: COLUMN baslocation.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baslocation.name IS 'Nome';


--
-- Name: COLUMN baslocation.cityid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baslocation.cityid IS 'Codigo da cidade';


--
-- Name: COLUMN baslocation.zipcode; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baslocation.zipcode IS 'CEP';


--
-- Name: COLUMN baslocation.neighborhoodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baslocation.neighborhoodid IS 'Codigo do bairro';


--
-- Name: seq_locationtypeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_locationtypeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_locationtypeid OWNER TO postgres;

--
-- Name: baslocationtype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE baslocationtype (
    locationtypeid integer DEFAULT nextval('seq_locationtypeid'::regclass) NOT NULL,
    name character varying(100) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.baslocationtype OWNER TO postgres;

--
-- Name: TABLE baslocationtype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE baslocationtype IS 'tipo de Local';


--
-- Name: COLUMN baslocationtype.locationtypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baslocationtype.locationtypeid IS 'código do tipo de locação';


--
-- Name: COLUMN baslocationtype.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baslocationtype.name IS 'nome do tipo do locação';


--
-- Name: basmailserver; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basmailserver (
    host text NOT NULL,
    port integer NOT NULL,
    smtpuser character varying(255),
    smtppassword character varying(255),
    enableauth boolean DEFAULT false,
    secureauth character varying(3)
)
INHERITS (baslog);


ALTER TABLE public.basmailserver OWNER TO postgres;

--
-- Name: TABLE basmailserver; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basmailserver IS 'Tabela responsável por armazenar as configurações do servidor de envio de e-mail';


--
-- Name: COLUMN basmailserver.host; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basmailserver.host IS 'Endereço do servidor SMTP';


--
-- Name: COLUMN basmailserver.port; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basmailserver.port IS 'Porta do servidor SMTP';


--
-- Name: COLUMN basmailserver.smtpuser; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basmailserver.smtpuser IS 'Nome de usuário';


--
-- Name: COLUMN basmailserver.smtppassword; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basmailserver.smtppassword IS 'Senha';


--
-- Name: basmaritalstatus; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basmaritalstatus (
    maritalstatusid character(1) NOT NULL,
    description text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.basmaritalstatus OWNER TO postgres;

--
-- Name: TABLE basmaritalstatus; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basmaritalstatus IS 'estado civil';


--
-- Name: COLUMN basmaritalstatus.maritalstatusid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basmaritalstatus.maritalstatusid IS 'Codigo do estado civil';


--
-- Name: COLUMN basmaritalstatus.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basmaritalstatus.description IS 'Descricao';


--
-- Name: seq_neighborhoodid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_neighborhoodid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_neighborhoodid OWNER TO postgres;

--
-- Name: basneighborhood; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basneighborhood (
    neighborhoodid integer DEFAULT nextval('seq_neighborhoodid'::regclass) NOT NULL,
    name text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.basneighborhood OWNER TO postgres;

--
-- Name: TABLE basneighborhood; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basneighborhood IS 'bairros';


--
-- Name: COLUMN basneighborhood.neighborhoodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basneighborhood.neighborhoodid IS 'Codigo do bairro';


--
-- Name: COLUMN basneighborhood.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basneighborhood.name IS 'Nome';


--
-- Name: baspersonlink; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE baspersonlink (
    personid bigint NOT NULL,
    linkid integer NOT NULL,
    datevalidate date
)
INHERITS (baslog);


ALTER TABLE public.baspersonlink OWNER TO postgres;

--
-- Name: TABLE baspersonlink; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE baspersonlink IS 'vinculos das pessoas';


--
-- Name: COLUMN baspersonlink.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baspersonlink.personid IS 'Codigo da pessoa';


--
-- Name: COLUMN baspersonlink.linkid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baspersonlink.linkid IS 'Codigo do vinculo';


--
-- Name: COLUMN baspersonlink.datevalidate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baspersonlink.datevalidate IS 'Data de validade';


--
-- Name: seq_persontitleid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_persontitleid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_persontitleid OWNER TO postgres;

--
-- Name: baspersontitle; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE baspersontitle (
    persontitleid integer DEFAULT nextval('seq_persontitleid'::regclass) NOT NULL,
    description character varying(15) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.baspersontitle OWNER TO postgres;

--
-- Name: TABLE baspersontitle; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE baspersontitle IS 'Titulos das pessoas, como Sr. Sra. Dr. Dra. etc';


--
-- Name: COLUMN baspersontitle.persontitleid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baspersontitle.persontitleid IS 'Codigo do titulo da pessoa';


--
-- Name: COLUMN baspersontitle.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN baspersontitle.description IS 'Descricao do titulo';


--
-- Name: basphone; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basphone (
    phoneid integer NOT NULL,
    personid bigint NOT NULL,
    type character varying(100) NOT NULL,
    phone character varying(50) NOT NULL,
    CONSTRAINT chk_basphone_type CHECK (bas_chk_domain('TIPO_DE_TELEFONE'::character varying, type))
)
INHERITS (baslog);


ALTER TABLE public.basphone OWNER TO postgres;

--
-- Name: basphone_phoneid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE basphone_phoneid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.basphone_phoneid_seq OWNER TO postgres;

--
-- Name: basphone_phoneid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE basphone_phoneid_seq OWNED BY basphone.phoneid;


--
-- Name: basphysicalpersonkinship; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basphysicalpersonkinship (
    personid bigint NOT NULL,
    kinshipid integer NOT NULL,
    relativepersonid bigint NOT NULL,
    obs text
)
INHERITS (baslog);


ALTER TABLE public.basphysicalpersonkinship OWNER TO postgres;

--
-- Name: TABLE basphysicalpersonkinship; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basphysicalpersonkinship IS 'Armazena os parentescos das pessoas físicas.';


--
-- Name: COLUMN basphysicalpersonkinship.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalpersonkinship.personid IS 'Pessoa cujo parentesco será armazenado.';


--
-- Name: COLUMN basphysicalpersonkinship.kinshipid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalpersonkinship.kinshipid IS 'Tipo de parentesco a armazenar.';


--
-- Name: COLUMN basphysicalpersonkinship.relativepersonid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalpersonkinship.relativepersonid IS 'Código da pessoa que tem o parentesco especificado com a pessoa principal. Exemplo: relativePersionId = 7, kinshipId = 1, personId = 2 significa dizer que 7 é pai de 2.';


--
-- Name: COLUMN basphysicalpersonkinship.obs; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basphysicalpersonkinship.obs IS 'Observações complementares para o parentesco que está sendo cadastrado.';


--
-- Name: seq_professionalactivityid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_professionalactivityid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_professionalactivityid OWNER TO postgres;

--
-- Name: basprofessionalactivity; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basprofessionalactivity (
    professionalactivityid integer DEFAULT nextval('seq_professionalactivityid'::regclass) NOT NULL,
    description text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.basprofessionalactivity OWNER TO postgres;

--
-- Name: TABLE basprofessionalactivity; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basprofessionalactivity IS 'atividades profissionais';


--
-- Name: COLUMN basprofessionalactivity.professionalactivityid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basprofessionalactivity.professionalactivityid IS 'Codigo da atividade profissional';


--
-- Name: COLUMN basprofessionalactivity.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basprofessionalactivity.description IS 'Descricao';


--
-- Name: seq_professionalactivityagentid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_professionalactivityagentid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_professionalactivityagentid OWNER TO postgres;

--
-- Name: basprofessionalactivityagent; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basprofessionalactivityagent (
    professionalactivityagentid integer DEFAULT nextval('seq_professionalactivityagentid'::regclass) NOT NULL,
    description text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.basprofessionalactivityagent OWNER TO postgres;

--
-- Name: TABLE basprofessionalactivityagent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basprofessionalactivityagent IS 'agente da atividade profissional - para estagios (ciee, pie, etc.)';


--
-- Name: COLUMN basprofessionalactivityagent.professionalactivityagentid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basprofessionalactivityagent.professionalactivityagentid IS 'Codigo do agente da atividade profissional';


--
-- Name: COLUMN basprofessionalactivityagent.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basprofessionalactivityagent.description IS 'Descricao';


--
-- Name: seq_professionalactivitylinktypeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_professionalactivitylinktypeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_professionalactivitylinktypeid OWNER TO postgres;

--
-- Name: basprofessionalactivitylinktype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basprofessionalactivitylinktype (
    professionalactivitylinktypeid integer DEFAULT nextval('seq_professionalactivitylinktypeid'::regclass) NOT NULL,
    description text NOT NULL,
    notifycompany boolean DEFAULT false NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.basprofessionalactivitylinktype OWNER TO postgres;

--
-- Name: TABLE basprofessionalactivitylinktype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basprofessionalactivitylinktype IS 'tipos de vã­nculos nas atividades profissionais (estagio, clt)';


--
-- Name: COLUMN basprofessionalactivitylinktype.professionalactivitylinktypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basprofessionalactivitylinktype.professionalactivitylinktypeid IS 'Codigo do tipo de vinculo das atividades profissionais';


--
-- Name: COLUMN basprofessionalactivitylinktype.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basprofessionalactivitylinktype.description IS 'Descricao';


--
-- Name: COLUMN basprofessionalactivitylinktype.notifycompany; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basprofessionalactivitylinktype.notifycompany IS 'Notificar a empresa no caso de fim do vinculo com a IES (estagio)';


--
-- Name: seq_professionalactivitypeopleid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_professionalactivitypeopleid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_professionalactivitypeopleid OWNER TO postgres;

--
-- Name: basprofessionalactivitypeople; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basprofessionalactivitypeople (
    professionalactivitypeopleid integer DEFAULT nextval('seq_professionalactivitypeopleid'::regclass) NOT NULL,
    professionalactivityid integer NOT NULL,
    personid bigint NOT NULL,
    legalpersonid bigint NOT NULL,
    begindate date NOT NULL,
    enddate date,
    professionalactivitylinktypeid integer NOT NULL,
    professionalactivityagentid integer
)
INHERITS (baslog);


ALTER TABLE public.basprofessionalactivitypeople OWNER TO postgres;

--
-- Name: TABLE basprofessionalactivitypeople; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basprofessionalactivitypeople IS 'atividades profissionais das pessoas';


--
-- Name: COLUMN basprofessionalactivitypeople.professionalactivitypeopleid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basprofessionalactivitypeople.professionalactivitypeopleid IS 'Codigo da atividade profissional da pessoa';


--
-- Name: COLUMN basprofessionalactivitypeople.professionalactivityid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basprofessionalactivitypeople.professionalactivityid IS 'Codigo da atividade profissional';


--
-- Name: COLUMN basprofessionalactivitypeople.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basprofessionalactivitypeople.personid IS 'Codigo da pessoa';


--
-- Name: COLUMN basprofessionalactivitypeople.legalpersonid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basprofessionalactivitypeople.legalpersonid IS 'Codigo da pessoa juridica';


--
-- Name: COLUMN basprofessionalactivitypeople.begindate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basprofessionalactivitypeople.begindate IS 'Data de inicio';


--
-- Name: COLUMN basprofessionalactivitypeople.enddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basprofessionalactivitypeople.enddate IS 'Data de termino';


--
-- Name: COLUMN basprofessionalactivitypeople.professionalactivitylinktypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basprofessionalactivitypeople.professionalactivitylinktypeid IS 'Codigo do tipo de vinculo da atividade profissional';


--
-- Name: COLUMN basprofessionalactivitypeople.professionalactivityagentid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basprofessionalactivitypeople.professionalactivityagentid IS 'Codigo do agente da atividade profissional (estagio)';


--
-- Name: seq_reportid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_reportid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_reportid OWNER TO postgres;

--
-- Name: basreport; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basreport (
    reportid integer DEFAULT nextval('seq_reportid'::regclass) NOT NULL,
    name text NOT NULL,
    description text,
    modules character varying[] NOT NULL,
    enabled boolean DEFAULT false NOT NULL,
    sql text NOT NULL,
    hasgrouping boolean DEFAULT false,
    fileid integer
)
INHERITS (baslog);


ALTER TABLE public.basreport OWNER TO postgres;

--
-- Name: TABLE basreport; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basreport IS 'Cadastro de relatorios definidos pelo usuario.';


--
-- Name: COLUMN basreport.reportid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basreport.reportid IS 'Identificador unico do relatorio customizado.';


--
-- Name: COLUMN basreport.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basreport.name IS 'Nome do relatorio. Sera utilizado como link na opcao "Relatorio" de cada modulo.';


--
-- Name: COLUMN basreport.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basreport.description IS 'Descricao detalhada do que o relatorio faz.';


--
-- Name: COLUMN basreport.modules; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basreport.modules IS 'Contem uma lista de modulos nos quais o relatorio estara visivel.';


--
-- Name: COLUMN basreport.enabled; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basreport.enabled IS 'Indica se o relatorio esta ou nao habilitado (se nao estiver, nao ficara visivel em nenhum modulo)';


--
-- Name: COLUMN basreport.sql; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basreport.sql IS 'Consulta SQL contendo caracteres "?" que indicam os parametros.';


--
-- Name: COLUMN basreport.fileid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basreport.fileid IS 'Arquivo JasperReport de template que deve ser utilizado para exportacao PDF (caso nao seja informado, sera utilizado os padroes relatorio_generico_retrato.jrxml ou relatorio_generico_paisagem.jrxml)';


--
-- Name: seq_reportparameterid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_reportparameterid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_reportparameterid OWNER TO postgres;

--
-- Name: basreportparameter; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basreportparameter (
    reportparameterid integer DEFAULT nextval('seq_reportparameterid'::regclass) NOT NULL,
    reportid integer NOT NULL,
    label text NOT NULL,
    parameternumber integer NOT NULL,
    fieldtype character varying(50) NOT NULL,
    fixedoptions boolean DEFAULT false,
    options text,
    defaultvalue text,
    size integer,
    fieldcolumns integer,
    fieldrows integer,
    fieldvalidator text,
    hint text,
    help text
)
INHERITS (baslog);


ALTER TABLE public.basreportparameter OWNER TO postgres;

--
-- Name: TABLE basreportparameter; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basreportparameter IS 'Cadastro dos parametros que serao utilizados na consulta presente na tabela basReport.';


--
-- Name: COLUMN basreportparameter.reportparameterid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basreportparameter.reportparameterid IS 'Identificador unico do parametro de um relatorio.';


--
-- Name: COLUMN basreportparameter.reportid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basreportparameter.reportid IS 'Indica o relatorio ao qual este parametro pertence. Chave estrangeira para basReport.reportId.';


--
-- Name: COLUMN basreportparameter.label; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basreportparameter.label IS 'Texto para identificar o campo no momento da execucao do relatorio.';


--
-- Name: COLUMN basreportparameter.parameternumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basreportparameter.parameternumber IS 'Valor inteiro que indica o numero do parametro (para execucao correta do sql prepare) no SQL.';


--
-- Name: COLUMN basreportparameter.fieldtype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basreportparameter.fieldtype IS 'Indica o tipo de campo (MIOLO) a ser instanciado no momento da execucao.';


--
-- Name: COLUMN basreportparameter.fixedoptions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basreportparameter.fixedoptions IS 'Indica se o campo contera um (ou varios) valores fixos ou se suas opcoes serao obtidas de uma consulta SQL.';


--
-- Name: COLUMN basreportparameter.options; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basreportparameter.options IS 'Valor ou lista de valores, no caso de o campo ser de valores fixos.';


--
-- Name: COLUMN basreportparameter.defaultvalue; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basreportparameter.defaultvalue IS 'Valor padrao inicial que o campo assumira quando for instanciado.';


--
-- Name: COLUMN basreportparameter.size; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basreportparameter.size IS 'Tamanho do campo (para MTextFields, MMultiLineTextField, etc).';


--
-- Name: COLUMN basreportparameter.fieldcolumns; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basreportparameter.fieldcolumns IS 'Quantidade de colunas do campo (para MMultiLineTextField).';


--
-- Name: COLUMN basreportparameter.fieldrows; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basreportparameter.fieldrows IS 'Quantidade de linhas do campo (para MMultiLineTextField).';


--
-- Name: COLUMN basreportparameter.fieldvalidator; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basreportparameter.fieldvalidator IS 'Validador (ER) para o campo.';


--
-- Name: COLUMN basreportparameter.hint; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basreportparameter.hint IS 'Texto que sera exibido como dica, a direita do campo instanciado.';


--
-- Name: COLUMN basreportparameter.help; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basreportparameter.help IS 'Texto que sera exibido como tooltip help, quando se passa o mouse sobre o componente instanciado.';


--
-- Name: basresetpassword; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basresetpassword (
    resetpasswordid integer NOT NULL,
    confirmhash character varying(255) NOT NULL,
    requestdate timestamp without time zone NOT NULL,
    iduser integer NOT NULL,
    resetdate timestamp without time zone,
    expirationdate timestamp without time zone
)
INHERITS (baslog);


ALTER TABLE public.basresetpassword OWNER TO postgres;

--
-- Name: TABLE basresetpassword; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basresetpassword IS 'Armazena as solicitações de alteração de senha dos usuários, efetivando a alteração somente quando o usuário que solicitou confirmar a solicitação no email que receber. Desta forma, impede-se que um usuário consiga alterar a senha de outro.';


--
-- Name: COLUMN basresetpassword.resetpasswordid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basresetpassword.resetpasswordid IS 'Chave primária da tabela';


--
-- Name: COLUMN basresetpassword.confirmhash; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basresetpassword.confirmhash IS 'Hash único que será usado no link para a mudança de senha';


--
-- Name: COLUMN basresetpassword.requestdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basresetpassword.requestdate IS 'Data da geração do hash';


--
-- Name: COLUMN basresetpassword.iduser; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basresetpassword.iduser IS 'Código do usuário';


--
-- Name: COLUMN basresetpassword.resetdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basresetpassword.resetdate IS 'Data e horário que a senha foi alterada';


--
-- Name: COLUMN basresetpassword.expirationdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basresetpassword.expirationdate IS 'Data e horário que o hash expirou';


--
-- Name: basresetpassword_resetpasswordid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE basresetpassword_resetpasswordid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.basresetpassword_resetpasswordid_seq OWNER TO postgres;

--
-- Name: basresetpassword_resetpasswordid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE basresetpassword_resetpasswordid_seq OWNED BY basresetpassword.resetpasswordid;


--
-- Name: seq_sectorid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_sectorid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_sectorid OWNER TO postgres;

--
-- Name: bassector; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE bassector (
    sectorid integer DEFAULT nextval('seq_sectorid'::regclass) NOT NULL,
    description text NOT NULL,
    email character varying(60) NOT NULL,
    iscoordinatorssector boolean DEFAULT false NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.bassector OWNER TO postgres;

--
-- Name: TABLE bassector; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE bassector IS 'setores';


--
-- Name: COLUMN bassector.sectorid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bassector.sectorid IS 'Codigo do setor';


--
-- Name: COLUMN bassector.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bassector.description IS 'Descricao';


--
-- Name: COLUMN bassector.email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bassector.email IS 'Email do setor';


--
-- Name: COLUMN bassector.iscoordinatorssector; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bassector.iscoordinatorssector IS 'Se e um setor de coordenacao';


--
-- Name: seq_bossid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_bossid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_bossid OWNER TO postgres;

--
-- Name: bassectorboss; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE bassectorboss (
    bossid integer DEFAULT nextval('seq_bossid'::regclass) NOT NULL,
    sectorid integer NOT NULL,
    level integer,
    expirationlevel interval,
    issendemail boolean DEFAULT true NOT NULL,
    email character varying(60) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.bassectorboss OWNER TO postgres;

--
-- Name: TABLE bassectorboss; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE bassectorboss IS 'chefes de setores';


--
-- Name: COLUMN bassectorboss.bossid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bassectorboss.bossid IS 'Codigo do chefe de setor';


--
-- Name: COLUMN bassectorboss.sectorid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bassectorboss.sectorid IS 'Codigo do setor';


--
-- Name: COLUMN bassectorboss.level; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bassectorboss.level IS 'Nivel';


--
-- Name: COLUMN bassectorboss.expirationlevel; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bassectorboss.expirationlevel IS 'Nivel de expiracao';


--
-- Name: COLUMN bassectorboss.issendemail; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bassectorboss.issendemail IS 'Envia/recebe emails';


--
-- Name: COLUMN bassectorboss.email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bassectorboss.email IS 'Email';


--
-- Name: bassessao; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE bassessao (
    sessaoid integer NOT NULL,
    data timestamp without time zone DEFAULT now(),
    iduser integer,
    login character varying,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.bassessao OWNER TO postgres;

--
-- Name: bassessao_sessaoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE bassessao_sessaoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.bassessao_sessaoid_seq OWNER TO postgres;

--
-- Name: bassessao_sessaoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE bassessao_sessaoid_seq OWNED BY bassessao.sessaoid;


--
-- Name: bassolicitacaotrocadesenha; Type: TABLE; Schema: public; Owner: solis; Tablespace: 
--

CREATE TABLE bassolicitacaotrocadesenha (
    configuracaotrocadesenhaid integer NOT NULL,
    userid integer NOT NULL,
    concordo boolean
)
INHERITS (baslog);


ALTER TABLE public.bassolicitacaotrocadesenha OWNER TO solis;

--
-- Name: seq_specialnecessityid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_specialnecessityid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_specialnecessityid OWNER TO postgres;

--
-- Name: basspecialnecessity; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basspecialnecessity (
    specialnecessityid integer DEFAULT nextval('seq_specialnecessityid'::regclass) NOT NULL,
    description text NOT NULL,
    easyaccess boolean DEFAULT false NOT NULL,
    accompanimentneeds boolean DEFAULT false NOT NULL,
    ispermanent boolean DEFAULT false NOT NULL,
    howmuchweeks integer,
    begindate date
)
INHERITS (baslog);


ALTER TABLE public.basspecialnecessity OWNER TO postgres;

--
-- Name: TABLE basspecialnecessity; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basspecialnecessity IS 'necessidades especiais';


--
-- Name: COLUMN basspecialnecessity.specialnecessityid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basspecialnecessity.specialnecessityid IS 'Codigo da necessidade especial';


--
-- Name: COLUMN basspecialnecessity.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basspecialnecessity.description IS 'Descricao';


--
-- Name: COLUMN basspecialnecessity.easyaccess; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basspecialnecessity.easyaccess IS 'Precisa de facilidades de acesso';


--
-- Name: COLUMN basspecialnecessity.accompanimentneeds; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basspecialnecessity.accompanimentneeds IS 'Precisa de acompanhamento especial';


--
-- Name: COLUMN basspecialnecessity.ispermanent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basspecialnecessity.ispermanent IS 'E uma necessidade especial permanente';


--
-- Name: COLUMN basspecialnecessity.howmuchweeks; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basspecialnecessity.howmuchweeks IS 'Numero de semanas da necessidade especial (no caso de nao ser permanente)';


--
-- Name: COLUMN basspecialnecessity.begindate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basspecialnecessity.begindate IS 'Data inicial';


--
-- Name: seq_stampid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_stampid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_stampid OWNER TO postgres;

--
-- Name: basstamp; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basstamp (
    stampid integer DEFAULT nextval('seq_stampid'::regclass) NOT NULL,
    personid bigint NOT NULL,
    functiondescription text NOT NULL,
    register text
)
INHERITS (baslog);


ALTER TABLE public.basstamp OWNER TO postgres;

--
-- Name: TABLE basstamp; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basstamp IS 'carimbos';


--
-- Name: COLUMN basstamp.stampid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basstamp.stampid IS 'Codigo do carimbo';


--
-- Name: COLUMN basstamp.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basstamp.personid IS 'Codigo da pessoa';


--
-- Name: COLUMN basstamp.functiondescription; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basstamp.functiondescription IS 'Cargo';


--
-- Name: COLUMN basstamp.register; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basstamp.register IS 'Portaria';


--
-- Name: basstate; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basstate (
    stateid character varying(2) NOT NULL,
    countryid character varying(3) NOT NULL,
    name character varying(50) NOT NULL,
    ibgeid integer
)
INHERITS (baslog);


ALTER TABLE public.basstate OWNER TO postgres;

--
-- Name: TABLE basstate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basstate IS 'estado';


--
-- Name: COLUMN basstate.stateid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basstate.stateid IS 'código do estado';


--
-- Name: COLUMN basstate.countryid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basstate.countryid IS 'código do país';


--
-- Name: COLUMN basstate.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basstate.name IS 'nome do estado';


--
-- Name: COLUMN basstate.ibgeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basstate.ibgeid IS 'código do ibge';


--
-- Name: basstickynote; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basstickynote (
    stickynoteid integer NOT NULL,
    isgroup boolean DEFAULT false,
    code integer,
    description text,
    positionx integer,
    positiony integer,
    stickynotetype character varying(255),
    link character varying(255),
    pendencytype character varying(10)
);


ALTER TABLE public.basstickynote OWNER TO postgres;

--
-- Name: basstickynote_stickynoteid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE basstickynote_stickynoteid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.basstickynote_stickynoteid_seq OWNER TO postgres;

--
-- Name: basstickynote_stickynoteid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE basstickynote_stickynoteid_seq OWNED BY basstickynote.stickynoteid;


--
-- Name: bastaskhistory; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE bastaskhistory (
    taskhistoryid integer NOT NULL,
    taskid integer,
    updatedby character varying(255),
    taskstatusid integer NOT NULL,
    transitiondate timestamp without time zone NOT NULL,
    obs text
)
INHERITS (baslog);


ALTER TABLE public.bastaskhistory OWNER TO postgres;

--
-- Name: TABLE bastaskhistory; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE bastaskhistory IS 'Histórico das alterações das pendências';


--
-- Name: COLUMN bastaskhistory.taskhistoryid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bastaskhistory.taskhistoryid IS 'Código do histórico.';


--
-- Name: COLUMN bastaskhistory.taskid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bastaskhistory.taskid IS 'Código da pendência.';


--
-- Name: COLUMN bastaskhistory.updatedby; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bastaskhistory.updatedby IS 'Usuário que efetuou a alteração.';


--
-- Name: COLUMN bastaskhistory.taskstatusid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bastaskhistory.taskstatusid IS 'Código do status da pendência.';


--
-- Name: COLUMN bastaskhistory.transitiondate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bastaskhistory.transitiondate IS 'Data da alteração.';


--
-- Name: COLUMN bastaskhistory.obs; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bastaskhistory.obs IS 'Observações sobre a alteração.';


--
-- Name: bastaskhistory_taskhistoryid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE bastaskhistory_taskhistoryid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.bastaskhistory_taskhistoryid_seq OWNER TO postgres;

--
-- Name: bastaskhistory_taskhistoryid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE bastaskhistory_taskhistoryid_seq OWNED BY bastaskhistory.taskhistoryid;


--
-- Name: bastaskstatus; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE bastaskstatus (
    taskstatusid integer NOT NULL,
    description character varying(255) NOT NULL,
    closestask boolean NOT NULL,
    freeforassigning boolean NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.bastaskstatus OWNER TO postgres;

--
-- Name: TABLE bastaskstatus; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE bastaskstatus IS 'Status da pendência';


--
-- Name: COLUMN bastaskstatus.taskstatusid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bastaskstatus.taskstatusid IS 'Código do status da pendência.';


--
-- Name: COLUMN bastaskstatus.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bastaskstatus.description IS 'Descrição do status da pendência.';


--
-- Name: COLUMN bastaskstatus.closestask; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bastaskstatus.closestask IS 'Indica se o status fecha a pendência.';


--
-- Name: COLUMN bastaskstatus.freeforassigning; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN bastaskstatus.freeforassigning IS 'Define se a pendência pode ou nao ser reatribuida';


--
-- Name: bastaskstatus_taskstatusid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE bastaskstatus_taskstatusid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.bastaskstatus_taskstatusid_seq OWNER TO postgres;

--
-- Name: bastaskstatus_taskstatusid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE bastaskstatus_taskstatusid_seq OWNED BY bastaskstatus.taskstatusid;


--
-- Name: bastipoatuacaoprofessor; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE bastipoatuacaoprofessor (
    tipoatuacaoprofessorid integer NOT NULL,
    descricao character varying NOT NULL,
    detalhes character varying
)
INHERITS (baslog);


ALTER TABLE public.bastipoatuacaoprofessor OWNER TO postgres;

--
-- Name: bastipoatuacaoprofessor_tipoatuacaoprofessorid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE bastipoatuacaoprofessor_tipoatuacaoprofessorid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.bastipoatuacaoprofessor_tipoatuacaoprofessorid_seq OWNER TO postgres;

--
-- Name: bastipoatuacaoprofessor_tipoatuacaoprofessorid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE bastipoatuacaoprofessor_tipoatuacaoprofessorid_seq OWNED BY bastipoatuacaoprofessor.tipoatuacaoprofessorid;


--
-- Name: basunitconfig; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basunitconfig (
    unitconfigid integer NOT NULL,
    moduleconfig text NOT NULL,
    parameter text NOT NULL,
    value text,
    unitid integer NOT NULL,
    validatevalue text,
    validatemsg text
)
INHERITS (baslog);


ALTER TABLE public.basunitconfig OWNER TO postgres;

--
-- Name: basunitconfig_unitconfigid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE basunitconfig_unitconfigid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.basunitconfig_unitconfigid_seq OWNER TO postgres;

--
-- Name: basunitconfig_unitconfigid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE basunitconfig_unitconfigid_seq OWNED BY basunitconfig.unitconfigid;


--
-- Name: basupdate; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basupdate (
    updatetime timestamp without time zone NOT NULL,
    fromrevision integer,
    torevision integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.basupdate OWNER TO postgres;

--
-- Name: TABLE basupdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basupdate IS 'Armazena as atualizacoes efetuadas no svn para facilitar a replicacao de erros reportados.';


--
-- Name: COLUMN basupdate.updatetime; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basupdate.updatetime IS 'Data e horario em que a atualizacao foi concluida.';


--
-- Name: COLUMN basupdate.fromrevision; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basupdate.fromrevision IS 'Indica a revisao local antes do inicio da atualizacao.';


--
-- Name: COLUMN basupdate.torevision; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basupdate.torevision IS 'Indica a revisao local apos a atualizacao.';


--
-- Name: basuploadreportinfo; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basuploadreportinfo (
    uploadreportinfoid integer NOT NULL,
    report character varying(255) NOT NULL,
    authenticationrequired boolean DEFAULT false
)
INHERITS (baslog);


ALTER TABLE public.basuploadreportinfo OWNER TO postgres;

--
-- Name: basuploadreportinfo_uploadreportinfoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE basuploadreportinfo_uploadreportinfoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.basuploadreportinfo_uploadreportinfoid_seq OWNER TO postgres;

--
-- Name: basuploadreportinfo_uploadreportinfoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE basuploadreportinfo_uploadreportinfoid_seq OWNED BY basuploadreportinfo.uploadreportinfoid;


--
-- Name: basweekday; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE basweekday (
    weekdayid integer NOT NULL,
    description text NOT NULL,
    shortdescription character varying(3) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.basweekday OWNER TO postgres;

--
-- Name: TABLE basweekday; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE basweekday IS 'dias da semana';


--
-- Name: COLUMN basweekday.weekdayid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basweekday.weekdayid IS 'Codigo do dia da semana';


--
-- Name: COLUMN basweekday.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basweekday.description IS 'Descricao';


--
-- Name: COLUMN basweekday.shortdescription; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN basweekday.shortdescription IS 'Descricao suscinta';


--
-- Name: buscadinamica; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE buscadinamica (
    buscadinamicaid integer NOT NULL,
    identificador character varying(50) NOT NULL,
    modulo character varying(20) NOT NULL,
    ordenar text
);


ALTER TABLE public.buscadinamica OWNER TO postgres;

--
-- Name: buscadinamica_buscadinamicaid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE buscadinamica_buscadinamicaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.buscadinamica_buscadinamicaid_seq OWNER TO postgres;

--
-- Name: buscadinamica_buscadinamicaid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE buscadinamica_buscadinamicaid_seq OWNED BY buscadinamica.buscadinamicaid;


--
-- Name: cadastrodinamico; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE cadastrodinamico (
    cadastrodinamicoid integer NOT NULL,
    identificador character varying(50) NOT NULL,
    referencia text NOT NULL,
    modulo character varying(20) NOT NULL
);


ALTER TABLE public.cadastrodinamico OWNER TO postgres;

--
-- Name: cadastrodinamico_cadastrodinamicoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE cadastrodinamico_cadastrodinamicoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cadastrodinamico_cadastrodinamicoid_seq OWNER TO postgres;

--
-- Name: cadastrodinamico_cadastrodinamicoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE cadastrodinamico_cadastrodinamicoid_seq OWNED BY cadastrodinamico.cadastrodinamicoid;


--
-- Name: campobuscadinamica; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE campobuscadinamica (
    campobuscadinamicaid integer NOT NULL,
    buscadinamicaid integer NOT NULL,
    tipo character varying(30),
    nome character varying(100) NOT NULL,
    valorespossiveis text,
    posicao integer,
    valorpadrao text,
    editavel boolean DEFAULT true NOT NULL,
    visivel boolean DEFAULT true NOT NULL,
    referencia text,
    filtravel boolean DEFAULT true NOT NULL,
    exibirnagrid boolean DEFAULT true NOT NULL,
    parametros text,
    chave boolean NOT NULL,
    tabela text
);


ALTER TABLE public.campobuscadinamica OWNER TO postgres;

--
-- Name: campobuscadinamica_campobuscadinamicaid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE campobuscadinamica_campobuscadinamicaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.campobuscadinamica_campobuscadinamicaid_seq OWNER TO postgres;

--
-- Name: campobuscadinamica_campobuscadinamicaid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE campobuscadinamica_campobuscadinamicaid_seq OWNED BY campobuscadinamica.campobuscadinamicaid;


--
-- Name: capformadepagamento; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE capformadepagamento (
    formadepagamentoid integer NOT NULL,
    descricao character varying(255)
)
INHERITS (baslog);


ALTER TABLE public.capformadepagamento OWNER TO postgres;

--
-- Name: caphistorico; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE caphistorico (
    historicoid integer NOT NULL,
    solicitacaoid integer NOT NULL,
    solicitacaoestadoid integer NOT NULL,
    personid integer NOT NULL,
    data timestamp without time zone DEFAULT now() NOT NULL,
    justificativa character varying
)
INHERITS (baslog);


ALTER TABLE public.caphistorico OWNER TO postgres;

--
-- Name: TABLE caphistorico; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE caphistorico IS 'Histórico';


--
-- Name: COLUMN caphistorico.historicoid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN caphistorico.historicoid IS 'Código';


--
-- Name: COLUMN caphistorico.solicitacaoid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN caphistorico.solicitacaoid IS 'Solicitação';


--
-- Name: COLUMN caphistorico.solicitacaoestadoid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN caphistorico.solicitacaoestadoid IS 'Estado';


--
-- Name: COLUMN caphistorico.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN caphistorico.personid IS 'Pessoa';


--
-- Name: COLUMN caphistorico.data; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN caphistorico.data IS 'Data';


--
-- Name: COLUMN caphistorico.justificativa; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN caphistorico.justificativa IS 'Justificativa';


--
-- Name: caphistorico_historicoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE caphistorico_historicoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.caphistorico_historicoid_seq OWNER TO postgres;

--
-- Name: caphistorico_historicoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE caphistorico_historicoid_seq OWNED BY caphistorico.historicoid;


--
-- Name: caplancamento; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE caplancamento (
    lancamentoid integer NOT NULL,
    tituloid integer NOT NULL,
    valor numeric(12,2) NOT NULL,
    tipolancamento character(1),
    datalancamento timestamp without time zone DEFAULT now() NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.caplancamento OWNER TO postgres;

--
-- Name: TABLE caplancamento; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE caplancamento IS 'Lançamentos';


--
-- Name: COLUMN caplancamento.lancamentoid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN caplancamento.lancamentoid IS 'Código';


--
-- Name: COLUMN caplancamento.tipolancamento; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN caplancamento.tipolancamento IS 'Tipo de lançamento';


--
-- Name: COLUMN caplancamento.datalancamento; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN caplancamento.datalancamento IS 'Data';


--
-- Name: caplancamento_lancamentoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE caplancamento_lancamentoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.caplancamento_lancamentoid_seq OWNER TO postgres;

--
-- Name: caplancamento_lancamentoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE caplancamento_lancamentoid_seq OWNED BY caplancamento.lancamentoid;


--
-- Name: capsolicitacao; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE capsolicitacao (
    solicitacaoid integer NOT NULL,
    personid integer,
    solicitacaoestadoid integer,
    dadoscompra character varying(255),
    costcenterid character varying(255),
    justificativa text,
    fornecedorid integer NOT NULL,
    formadepagamentoid integer NOT NULL,
    datasolicitacao date DEFAULT now() NOT NULL
);


ALTER TABLE public.capsolicitacao OWNER TO postgres;

--
-- Name: TABLE capsolicitacao; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE capsolicitacao IS 'Solicitação';


--
-- Name: COLUMN capsolicitacao.solicitacaoid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN capsolicitacao.solicitacaoid IS 'Código';


--
-- Name: COLUMN capsolicitacao.justificativa; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN capsolicitacao.justificativa IS 'Justificativa de alteração da solicitação';


--
-- Name: COLUMN capsolicitacao.formadepagamentoid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN capsolicitacao.formadepagamentoid IS 'Forma de pagamento';


--
-- Name: capsolicitacao_solicitacaoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE capsolicitacao_solicitacaoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.capsolicitacao_solicitacaoid_seq OWNER TO postgres;

--
-- Name: capsolicitacao_solicitacaoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE capsolicitacao_solicitacaoid_seq OWNED BY capsolicitacao.solicitacaoid;


--
-- Name: capsolicitacaoestado; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE capsolicitacaoestado (
    solicitacaoestadoid integer NOT NULL,
    nome character varying(255) NOT NULL
);


ALTER TABLE public.capsolicitacaoestado OWNER TO postgres;

--
-- Name: capsolicitacaoestado_solicitacaoestadoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE capsolicitacaoestado_solicitacaoestadoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.capsolicitacaoestado_solicitacaoestadoid_seq OWNER TO postgres;

--
-- Name: capsolicitacaoestado_solicitacaoestadoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE capsolicitacaoestado_solicitacaoestadoid_seq OWNED BY capsolicitacaoestado.solicitacaoestadoid;


--
-- Name: capsolicitacaoparcela; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE capsolicitacaoparcela (
    solicitacaoparcelaid integer NOT NULL,
    solicitacaoid integer,
    parcela integer NOT NULL,
    valor numeric(12,2) NOT NULL,
    datavencimento date NOT NULL
);


ALTER TABLE public.capsolicitacaoparcela OWNER TO postgres;

--
-- Name: TABLE capsolicitacaoparcela; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE capsolicitacaoparcela IS 'Parcelas';


--
-- Name: COLUMN capsolicitacaoparcela.datavencimento; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN capsolicitacaoparcela.datavencimento IS 'Data de vencimento';


--
-- Name: capsolicitacaoparcela_solicitacaoparcelaid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE capsolicitacaoparcela_solicitacaoparcelaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.capsolicitacaoparcela_solicitacaoparcelaid_seq OWNER TO postgres;

--
-- Name: capsolicitacaoparcela_solicitacaoparcelaid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE capsolicitacaoparcela_solicitacaoparcelaid_seq OWNED BY capsolicitacaoparcela.solicitacaoparcelaid;


--
-- Name: captipolancamento; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE captipolancamento (
    tipolancamentoid character(1),
    nome character varying(255)
)
INHERITS (baslog);


ALTER TABLE public.captipolancamento OWNER TO postgres;

--
-- Name: captitulo; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE captitulo (
    tituloid integer NOT NULL,
    solicitacaoparcelaid integer NOT NULL,
    valor numeric(12,2) NOT NULL,
    vencimento date,
    numeroparcela integer,
    valoraberto numeric(12,2) DEFAULT 0 NOT NULL,
    tituloaberto boolean
)
INHERITS (baslog);


ALTER TABLE public.captitulo OWNER TO postgres;

--
-- Name: TABLE captitulo; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE captitulo IS 'Títulos';


--
-- Name: COLUMN captitulo.tituloid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN captitulo.tituloid IS 'Código';


--
-- Name: COLUMN captitulo.numeroparcela; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN captitulo.numeroparcela IS 'Parcela';


--
-- Name: COLUMN captitulo.valoraberto; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN captitulo.valoraberto IS 'Valor em aberto';


--
-- Name: COLUMN captitulo.tituloaberto; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN captitulo.tituloaberto IS 'Existe saldo em aberto para este titulo';


--
-- Name: captitulo_tituloid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE captitulo_tituloid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.captitulo_tituloid_seq OWNER TO postgres;

--
-- Name: captitulo_tituloid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE captitulo_tituloid_seq OWNED BY captitulo.tituloid;


--
-- Name: seq_copyid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_copyid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_copyid OWNER TO postgres;

--
-- Name: ccpcopy; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ccpcopy (
    copyid integer DEFAULT nextval('seq_copyid'::regclass) NOT NULL,
    periodid integer NOT NULL,
    "time" timestamp without time zone NOT NULL,
    copiesnumber integer NOT NULL,
    printerid integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.ccpcopy OWNER TO postgres;

--
-- Name: TABLE ccpcopy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE ccpcopy IS 'tabela abstrata de copias. ';


--
-- Name: COLUMN ccpcopy.copyid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccpcopy.copyid IS 'Codigo identificador da copia';


--
-- Name: COLUMN ccpcopy.periodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccpcopy.periodid IS 'Codigo identificador do periodo';


--
-- Name: COLUMN ccpcopy."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccpcopy."time" IS 'Data da copia';


--
-- Name: COLUMN ccpcopy.copiesnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccpcopy.copiesnumber IS 'Numero de copias';


--
-- Name: COLUMN ccpcopy.printerid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccpcopy.printerid IS 'Codigo da impressora';


--
-- Name: seq_payrolldiscountid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_payrolldiscountid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_payrolldiscountid OWNER TO postgres;

--
-- Name: ccppayrolldiscount; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ccppayrolldiscount (
    payrolldiscountid integer DEFAULT nextval('seq_payrolldiscountid'::regclass) NOT NULL,
    date timestamp without time zone,
    branch text,
    sectorid integer,
    serviceid integer,
    amount double precision,
    unitaryvalue numeric(14,4),
    personid bigint,
    operator text,
    operatorsectorid integer
)
INHERITS (baslog);


ALTER TABLE public.ccppayrolldiscount OWNER TO postgres;

--
-- Name: TABLE ccppayrolldiscount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE ccppayrolldiscount IS 'copia com desconto em folha';


--
-- Name: COLUMN ccppayrolldiscount.payrolldiscountid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccppayrolldiscount.payrolldiscountid IS 'Codigo identificador da copia com desconto em folha';


--
-- Name: COLUMN ccppayrolldiscount.date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccppayrolldiscount.date IS 'Data da copia';


--
-- Name: COLUMN ccppayrolldiscount.branch; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccppayrolldiscount.branch IS 'Agencia';


--
-- Name: COLUMN ccppayrolldiscount.sectorid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccppayrolldiscount.sectorid IS 'Codigo identificador do setor (basSector)';


--
-- Name: COLUMN ccppayrolldiscount.serviceid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccppayrolldiscount.serviceid IS 'Codigo do servico';


--
-- Name: COLUMN ccppayrolldiscount.amount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccppayrolldiscount.amount IS 'Quantidade';


--
-- Name: COLUMN ccppayrolldiscount.unitaryvalue; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccppayrolldiscount.unitaryvalue IS 'Valor unitario';


--
-- Name: COLUMN ccppayrolldiscount.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccppayrolldiscount.personid IS 'Codigo identificador da pessoa';


--
-- Name: COLUMN ccppayrolldiscount.operator; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccppayrolldiscount.operator IS 'Operador';


--
-- Name: COLUMN ccppayrolldiscount.operatorsectorid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccppayrolldiscount.operatorsectorid IS 'Codigo do setor do operador';


--
-- Name: seq_periodid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_periodid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_periodid OWNER TO postgres;

--
-- Name: ccpperiod; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ccpperiod (
    periodid integer DEFAULT nextval('seq_periodid'::regclass) NOT NULL,
    description text,
    begindate date NOT NULL,
    enddate date NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.ccpperiod OWNER TO postgres;

--
-- Name: TABLE ccpperiod; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE ccpperiod IS 'periodo. utilizado para definir a cada quanto tempo os contadores devem ser reiniciados.';


--
-- Name: COLUMN ccpperiod.periodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccpperiod.periodid IS 'Codigo identificador do per';


--
-- Name: COLUMN ccpperiod.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccpperiod.description IS 'Descricao do per';


--
-- Name: COLUMN ccpperiod.begindate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccpperiod.begindate IS 'Data de inicio do periodo';


--
-- Name: COLUMN ccpperiod.enddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccpperiod.enddate IS 'Data de termino do periodo';


--
-- Name: ccpperson; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ccpperson (
    canexceed boolean DEFAULT false NOT NULL
)
INHERITS (basphysicalperson);


ALTER TABLE public.ccpperson OWNER TO postgres;

--
-- Name: ccppersoncopy; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ccppersoncopy (
    personid bigint NOT NULL
)
INHERITS (ccpcopy);


ALTER TABLE public.ccppersoncopy OWNER TO postgres;

--
-- Name: TABLE ccppersoncopy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE ccppersoncopy IS 'faz o registro das copias das pessoas';


--
-- Name: COLUMN ccppersoncopy.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccppersoncopy.personid IS 'Codigo da pessoa';


--
-- Name: seq_personperiodid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_personperiodid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_personperiodid OWNER TO postgres;

--
-- Name: ccppersonperiod; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ccppersonperiod (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    personperiodid integer DEFAULT nextval('seq_personperiodid'::regclass) NOT NULL,
    personid bigint NOT NULL,
    periodid integer NOT NULL,
    prefersector boolean DEFAULT false NOT NULL,
    copiesnumber integer NOT NULL,
    availablecopies integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.ccppersonperiod OWNER TO postgres;

--
-- Name: TABLE ccppersonperiod; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE ccppersonperiod IS 'periodo da pessoa. usado para identificar a quantidade de copias disponivel para cada pessoa em determinado periodo';


--
-- Name: COLUMN ccppersonperiod.personperiodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccppersonperiod.personperiodid IS 'Codigo identificador do periodo da pessoa';


--
-- Name: COLUMN ccppersonperiod.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccppersonperiod.personid IS 'Codigo identificador da pessoa';


--
-- Name: COLUMN ccppersonperiod.periodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccppersonperiod.periodid IS 'Codigo identificador do periodo';


--
-- Name: COLUMN ccppersonperiod.prefersector; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccppersonperiod.prefersector IS 'Flag que identifica se as copias devem ser descontadas primeiramente do setor ou nao';


--
-- Name: COLUMN ccppersonperiod.copiesnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccppersonperiod.copiesnumber IS 'Numero de copias possiveis para determinado setor em determinado periodo';


--
-- Name: COLUMN ccppersonperiod.availablecopies; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccppersonperiod.availablecopies IS 'Numero de copias disponiveis para determinado setor em determinado periodo. -1 significa sem limite de copias.';


--
-- Name: seq_personprinterid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_personprinterid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_personprinterid OWNER TO postgres;

--
-- Name: ccppersonprinter; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ccppersonprinter (
    personprinterid integer DEFAULT nextval('seq_personprinterid'::regclass) NOT NULL,
    printerid integer NOT NULL,
    personid bigint NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.ccppersonprinter OWNER TO postgres;

--
-- Name: seq_sectorpersonid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_sectorpersonid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_sectorpersonid OWNER TO postgres;

--
-- Name: ccppersonsector; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ccppersonsector (
    sectorpersonid bigint DEFAULT nextval('seq_sectorpersonid'::regclass) NOT NULL,
    personid bigint NOT NULL,
    sectorid integer NOT NULL,
    begintime time without time zone,
    endtime time without time zone
)
INHERITS (baslog);


ALTER TABLE public.ccppersonsector OWNER TO postgres;

--
-- Name: seq_printerid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_printerid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_printerid OWNER TO postgres;

--
-- Name: ccpprinter; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ccpprinter (
    printerid integer DEFAULT nextval('seq_printerid'::regclass) NOT NULL,
    name character varying NOT NULL,
    physicalresourceid integer,
    physicalresourceversion integer
)
INHERITS (baslog);


ALTER TABLE public.ccpprinter OWNER TO postgres;

--
-- Name: seq_requestid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_requestid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_requestid OWNER TO postgres;

--
-- Name: ccprequest; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ccprequest (
    requestid integer DEFAULT nextval('seq_requestid'::regclass) NOT NULL,
    date timestamp without time zone,
    serviceid integer,
    amount double precision,
    sectorid integer,
    centerid integer,
    projectid integer,
    costcenterid integer,
    referring text,
    personid bigint,
    operator text,
    operatorsectorid integer,
    unitaryvalue numeric(14,4)
)
INHERITS (baslog);


ALTER TABLE public.ccprequest OWNER TO postgres;

--
-- Name: TABLE ccprequest; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE ccprequest IS 'requisicao de copia';


--
-- Name: COLUMN ccprequest.requestid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccprequest.requestid IS 'Codigo identificador da requisicao';


--
-- Name: COLUMN ccprequest.date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccprequest.date IS 'Data da requisicao';


--
-- Name: COLUMN ccprequest.serviceid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccprequest.serviceid IS 'Codigo identificador do servico';


--
-- Name: COLUMN ccprequest.amount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccprequest.amount IS 'Quantidade';


--
-- Name: COLUMN ccprequest.sectorid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccprequest.sectorid IS 'Codigo identificador do setor';


--
-- Name: COLUMN ccprequest.centerid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccprequest.centerid IS 'Codigo identificador do centro';


--
-- Name: COLUMN ccprequest.projectid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccprequest.projectid IS 'Codigo identificador do projeto';


--
-- Name: COLUMN ccprequest.costcenterid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccprequest.costcenterid IS 'Codigo identificador do centro de custo';


--
-- Name: COLUMN ccprequest.referring; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccprequest.referring IS 'Requerimento';


--
-- Name: COLUMN ccprequest.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccprequest.personid IS 'Requisitante (pessoa)';


--
-- Name: COLUMN ccprequest.operator; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccprequest.operator IS 'Operador';


--
-- Name: COLUMN ccprequest.operatorsectorid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccprequest.operatorsectorid IS 'Codigo identificador do setor do operador';


--
-- Name: COLUMN ccprequest.unitaryvalue; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccprequest.unitaryvalue IS 'Valor unitario';


--
-- Name: ccprequestfax; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ccprequestfax (
    requestid integer NOT NULL,
    telephone text,
    sended boolean,
    tariff text
)
INHERITS (baslog);


ALTER TABLE public.ccprequestfax OWNER TO postgres;

--
-- Name: TABLE ccprequestfax; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE ccprequestfax IS 'requisicao de fax';


--
-- Name: COLUMN ccprequestfax.requestid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccprequestfax.requestid IS 'Codigo identificador da requisicao';


--
-- Name: COLUMN ccprequestfax.telephone; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccprequestfax.telephone IS 'Numero de telefone';


--
-- Name: COLUMN ccprequestfax.sended; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccprequestfax.sended IS 'Se foi enviado ou nao';


--
-- Name: COLUMN ccprequestfax.tariff; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccprequestfax.tariff IS 'Tarifa';


--
-- Name: seq_ruleid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_ruleid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_ruleid OWNER TO postgres;

--
-- Name: ccprule; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ccprule (
    ruleid integer DEFAULT nextval('seq_ruleid'::regclass) NOT NULL,
    isprofessor boolean DEFAULT false NOT NULL,
    formationlevel integer NOT NULL,
    amount integer NOT NULL,
    copiesnumber integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.ccprule OWNER TO postgres;

--
-- Name: TABLE ccprule; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE ccprule IS 'regras com os numeros de copias por categoria';


--
-- Name: COLUMN ccprule.ruleid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccprule.ruleid IS 'Codigo identificador da regra';


--
-- Name: COLUMN ccprule.isprofessor; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccprule.isprofessor IS 'Define se e professor ou nao';


--
-- Name: COLUMN ccprule.formationlevel; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccprule.formationlevel IS 'Nivel de formacao';


--
-- Name: COLUMN ccprule.amount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccprule.amount IS 'Quantidade';


--
-- Name: COLUMN ccprule.copiesnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccprule.copiesnumber IS 'Numero de copias';


--
-- Name: ccpsector; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ccpsector (
    canexceed boolean DEFAULT false NOT NULL
)
INHERITS (bassector);


ALTER TABLE public.ccpsector OWNER TO postgres;

--
-- Name: TABLE ccpsector; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE ccpsector IS 'setor';


--
-- Name: COLUMN ccpsector.canexceed; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccpsector.canexceed IS 'Flag para identificar se setor pode imprimir mesmo que exceda sua quota';


--
-- Name: ccpsectorcopy; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ccpsectorcopy (
    sectorid integer NOT NULL
)
INHERITS (ccpcopy);


ALTER TABLE public.ccpsectorcopy OWNER TO postgres;

--
-- Name: TABLE ccpsectorcopy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE ccpsectorcopy IS 'faz o registro das copias dos setores';


--
-- Name: COLUMN ccpsectorcopy.sectorid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccpsectorcopy.sectorid IS 'Codigo do setor';


--
-- Name: seq_sectorperiodid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_sectorperiodid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_sectorperiodid OWNER TO postgres;

--
-- Name: ccpsectorperiod; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ccpsectorperiod (
    sectorperiodid integer DEFAULT nextval('seq_sectorperiodid'::regclass) NOT NULL,
    sectorid integer NOT NULL,
    periodid integer NOT NULL,
    copiesnumber integer NOT NULL,
    availablecopies integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.ccpsectorperiod OWNER TO postgres;

--
-- Name: TABLE ccpsectorperiod; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE ccpsectorperiod IS 'periodo do setor. usado para identificar a quantidade de copias disponivel para cada setor em determinado periodo';


--
-- Name: COLUMN ccpsectorperiod.sectorperiodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccpsectorperiod.sectorperiodid IS 'Codigo identificador do periodo do setor';


--
-- Name: COLUMN ccpsectorperiod.sectorid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccpsectorperiod.sectorid IS 'Codigo identificador do setor';


--
-- Name: COLUMN ccpsectorperiod.periodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccpsectorperiod.periodid IS 'Codigo identificador do periodo';


--
-- Name: COLUMN ccpsectorperiod.copiesnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccpsectorperiod.copiesnumber IS 'Numero de copias possiveis para determinado setor em determinado periodo';


--
-- Name: COLUMN ccpsectorperiod.availablecopies; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccpsectorperiod.availablecopies IS 'Numero de copias disponiveis para determinado setor em determinado periodo. -1 significa sem limite de copias.';


--
-- Name: seq_personsectorid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_personsectorid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_personsectorid OWNER TO postgres;

--
-- Name: ccpsectorprinter; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ccpsectorprinter (
    personsectorid integer DEFAULT nextval('seq_personsectorid'::regclass) NOT NULL,
    printerid integer NOT NULL,
    sectorid integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.ccpsectorprinter OWNER TO postgres;

--
-- Name: seq_serviceid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_serviceid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_serviceid OWNER TO postgres;

--
-- Name: ccpservice; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ccpservice (
    serviceid integer DEFAULT nextval('seq_serviceid'::regclass) NOT NULL,
    description text,
    unitaryvalue numeric(14,4),
    unit text
)
INHERITS (baslog);


ALTER TABLE public.ccpservice OWNER TO postgres;

--
-- Name: TABLE ccpservice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE ccpservice IS 'servico';


--
-- Name: COLUMN ccpservice.serviceid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccpservice.serviceid IS 'Codigo identificador do servico';


--
-- Name: COLUMN ccpservice.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccpservice.description IS 'Descricao do servico';


--
-- Name: COLUMN ccpservice.unitaryvalue; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccpservice.unitaryvalue IS 'Valor unitario';


--
-- Name: COLUMN ccpservice.unit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN ccpservice.unit IS 'Unidade';


--
-- Name: cmn_grupo; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW cmn_grupo AS
    SELECT baslink.linkid AS codigodogrupo, baslink.description AS descricao, baslink.linkid AS nivel FROM baslink;


ALTER TABLE public.cmn_grupo OWNER TO solis;

--
-- Name: pessoas; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW pessoas AS
    SELECT a.personid AS id, NULL::unknown AS identificacao, NULL::unknown AS titulo_academico, a.name AS nome, a.location AS rua, a.complement AS complemento, a.neighborhood AS bairro, a.zipcode AS cep, a.cityid AS ref_cidade, CASE WHEN (b.personid IS NOT NULL) THEN b.phone ELSE c.residentialphone END AS fone_particular, c.workphone AS fone_profissional, c.messagecontact AS fone_celular, c.cellphone AS fone_recado, a.email, a.emailalternative AS email_alt, c.maritalstatusid AS estado_civil, a.datein AS dt_cadastro, CASE WHEN (b.personid IS NOT NULL) THEN 'j'::text ELSE 'f'::text END AS tipo_pessoa, NULL::unknown AS obs, c.datebirth AS dt_nascimento, c.sex AS sexo, NULL::unknown AS credo, b.fakename AS nome_fantasia, b.stateregistration AS cod_inscricao_estadual, getpersondocument(a.personid, 1) AS rg_numero, getpersondocumentcity(a.personid, 1) AS rg_cidade, getpersondocumentdateexpedition(a.personid, 1) AS rg_data, a.personid AS ref_filiacao, NULL::unknown AS ref_cobranca, NULL::unknown AS ref_assistmed, c.cityidbirth AS ref_naturalidade, c.countryidbirth AS ref_nacionalidade, CASE WHEN (b.personid IS NOT NULL) THEN b.personid ELSE (c.responsablelegalid)::bigint END AS ref_segurado, CASE WHEN (b.personid IS NOT NULL) THEN b.cnpj ELSE getpersondocument(a.personid, 2) END AS cod_cpf_cgc, getpersondocument(a.personid, 4) AS titulo_eleitor, NULL::unknown AS conta_laboratorio, NULL::unknown AS conta_provedor, NULL::unknown AS regc_livro, NULL::unknown AS regc_folha, NULL::unknown AS regc_local, NULL::unknown AS regc_nasc_casam, NULL::unknown AS ano_1g, NULL::unknown AS cidade_1g, NULL::unknown AS ref_curso_1g, NULL::unknown AS escola_1g, d.yearhs AS ano_2g, d.cityidhs AS cidade_2g, d.externalcourseidhs AS ref_curso_2g, d.institutionidhs AS escola_2g, NULL::unknown AS graduacao, d.passive AS cod_passivo, m.m_password AS senha, NULL::unknown AS fl_dbfolha, NULL::unknown AS ref_pessoa_folha, d.isinsured AS fl_segurado, a.name AS nome2, NULL::unknown AS fl_cartao, c.specialnecessityid AS deficiencia, NULL::unknown AS cidade, NULL::unknown AS nacionalidade, NULL::unknown AS in_sagu, e.externalid AS cod_externo, c.specialnecessitydescription AS deficiencia_desc, NULL::unknown AS dt_responsavel, getpersondocumentorgan(a.personid, 1) AS rg_orgao, c.carplate AS placa_carro, a.isallowpersonaldata AS fl_dados_pessoais, NULL::unknown AS seguro_meses, replace((a.name)::text, ' '::text, '0'::text) AS nome3, CASE WHEN (c.datedeath IS NULL) THEN 'f'::text ELSE 't'::text END AS fl_obito, c.ethnicoriginid AS raca FROM (((((ONLY basperson a LEFT JOIN miolo_user m ON ((upper((m.login)::text) = upper((a.miolousername)::text)))) LEFT JOIN ONLY baslegalperson b USING (personid)) LEFT JOIN ONLY basphysicalperson c USING (personid)) LEFT JOIN ONLY basphysicalpersonstudent d USING (personid)) LEFT JOIN ONLY basemployee e USING (personid));


ALTER TABLE public.pessoas OWNER TO solis;

--
-- Name: cmn_pessoas; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW cmn_pessoas AS
    SELECT pessoas.id, pessoas.identificacao, pessoas.titulo_academico, pessoas.nome, pessoas.rua, pessoas.complemento, pessoas.bairro, pessoas.cep, pessoas.ref_cidade, pessoas.fone_particular, pessoas.fone_profissional, pessoas.fone_celular, pessoas.fone_recado, pessoas.email, pessoas.email_alt, pessoas.estado_civil, pessoas.dt_cadastro, pessoas.tipo_pessoa, pessoas.obs, pessoas.dt_nascimento, pessoas.sexo, pessoas.credo, pessoas.nome_fantasia, pessoas.cod_inscricao_estadual, pessoas.rg_numero, pessoas.rg_cidade, pessoas.rg_data, pessoas.ref_filiacao, pessoas.ref_cobranca, pessoas.ref_assistmed, pessoas.ref_naturalidade, pessoas.ref_nacionalidade, pessoas.ref_segurado, pessoas.cod_cpf_cgc, pessoas.titulo_eleitor, pessoas.conta_laboratorio, pessoas.conta_provedor, pessoas.regc_livro, pessoas.regc_folha, pessoas.regc_local, pessoas.regc_nasc_casam, pessoas.ano_1g, pessoas.cidade_1g, pessoas.ref_curso_1g, pessoas.escola_1g, pessoas.ano_2g, pessoas.cidade_2g, pessoas.ref_curso_2g, pessoas.escola_2g, pessoas.graduacao, pessoas.cod_passivo, pessoas.senha, pessoas.fl_dbfolha, pessoas.ref_pessoa_folha, pessoas.fl_segurado, pessoas.nome2, pessoas.fl_cartao, pessoas.deficiencia, pessoas.cidade, pessoas.nacionalidade, pessoas.in_sagu, pessoas.cod_externo, pessoas.deficiencia_desc, pessoas.dt_responsavel, pessoas.rg_orgao, pessoas.placa_carro, pessoas.fl_dados_pessoais, pessoas.seguro_meses, pessoas.nome3, pessoas.fl_obito, pessoas.raca, NULL::unknown AS profissao, NULL::unknown AS escola, NULL::unknown AS local_trabalho, NULL::unknown AS endereco_trabalho, NULL::unknown AS filiacao FROM pessoas;


ALTER TABLE public.cmn_pessoas OWNER TO solis;

--
-- Name: cmn_vinculo; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW cmn_vinculo AS
    SELECT baspersonlink.personid AS codigodapessoa, baspersonlink.linkid AS codigodogrupo, baspersonlink.datevalidate AS datavalidade FROM baspersonlink;


ALTER TABLE public.cmn_vinculo OWNER TO solis;

--
-- Name: seq_physicalresourceid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_physicalresourceid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_physicalresourceid OWNER TO postgres;

--
-- Name: insphysicalresource; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE insphysicalresource (
    physicalresourceid integer DEFAULT nextval('seq_physicalresourceid'::regclass) NOT NULL,
    physicalresourceversion integer NOT NULL,
    dateversion date NOT NULL,
    description text NOT NULL,
    grouptypeid integer NOT NULL,
    room character varying(50),
    building character varying(10),
    coord integer,
    aream2 double precision,
    costcenter integer,
    unitid integer NOT NULL,
    areatypeid integer
)
INHERITS (baslog);


ALTER TABLE public.insphysicalresource OWNER TO postgres;

--
-- Name: TABLE insphysicalresource; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE insphysicalresource IS 'recursos fisicos';


--
-- Name: COLUMN insphysicalresource.physicalresourceid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN insphysicalresource.physicalresourceid IS 'Codigo do recurso fisico';


--
-- Name: COLUMN insphysicalresource.physicalresourceversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN insphysicalresource.physicalresourceversion IS 'Versao do recurso fisico';


--
-- Name: COLUMN insphysicalresource.dateversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN insphysicalresource.dateversion IS 'Data da versao';


--
-- Name: COLUMN insphysicalresource.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN insphysicalresource.description IS 'Descricao';


--
-- Name: COLUMN insphysicalresource.grouptypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN insphysicalresource.grouptypeid IS 'Codigo do grupo';


--
-- Name: COLUMN insphysicalresource.room; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN insphysicalresource.room IS 'Sala';


--
-- Name: COLUMN insphysicalresource.building; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN insphysicalresource.building IS 'Predio';


--
-- Name: COLUMN insphysicalresource.coord; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN insphysicalresource.coord IS 'Coordenacao';


--
-- Name: COLUMN insphysicalresource.aream2; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN insphysicalresource.aream2 IS 'Area em metros quadrados';


--
-- Name: COLUMN insphysicalresource.costcenter; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN insphysicalresource.costcenter IS 'Centro de custo';


--
-- Name: COLUMN insphysicalresource.unitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN insphysicalresource.unitid IS 'Referencia para o campo unitId da tabela basUnit';


--
-- Name: COLUMN insphysicalresource.areatypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN insphysicalresource.areatypeid IS 'Codigo do tipo de area';


--
-- Name: confirmacao_matricula_detalhada; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW confirmacao_matricula_detalhada AS
    SELECT a.contractid AS contrato, b.miolousername AS login, b.personid AS cod_pessoa, b.name AS nome, b.location AS endereco, b.neighborhood AS bairro, b.complement AS complemento, c.name AS cidade, COALESCE(b.zipcode, c.zipcode) AS cep, b.number AS numero, a.courseid AS curso_id, d.name AS curso, a.courseversion AS curso_version, (SELECT aa.name FROM (acdclass aa JOIN acdclasspupil bb ON (((aa.classid)::text = (bb.classid)::text))) WHERE (bb.contractid = a.contractid) ORDER BY bb.begindate DESC LIMIT 1) AS turma, h.curricularcomponentid AS cod_disciplina, h.curricularcomponentversion AS version_disciplina, i.name AS disciplina, i.academiccredits AS creditos, i.academicnumberhours AS carga_horaria, COALESCE(o.description, '-'::text) AS sala, COALESCE(p.description, '-'::text) AS unidade, a.unitid AS unidade_id, a.turnid AS turno_id, q.learningperiodid, COALESCE(t.name, (SELECT bascity.name FROM bascity WHERE (bascity.cityid = r.cityid))) AS cidadeinstituicao, r.name AS nome_instituicao, dataporextenso((now())::date) AS data_extenso, replace(replace(replace((pg_catalog.array_agg(DISTINCT n.name))::text, '}'::text, ''::text), '{'::text, ''::text), '"'::text, ''::text) AS professor, (to_char((unnest(l.occurrencedates))::timestamp with time zone, (getparameter('BASIC'::character varying, 'MASK_DATE'::character varying))::text))::date AS dias_de_aula, array_to_string(ARRAY(SELECT (((timetouser(t.beginhour))::text || '-'::text) || (timetouser(t.endhour))::text) FROM acdtime t WHERE (t.timeid = ANY (l.timeids)) ORDER BY (((timetouser(t.beginhour))::text || '-'::text) || (timetouser(t.endhour))::text)), '   '::text) AS horarios FROM ((((((((((((((((acdcontract a JOIN ONLY basphysicalperson b ON ((a.personid = b.personid))) JOIN bascity c ON ((b.cityid = c.cityid))) JOIN acdcourse d ON (((a.courseid)::text = (d.courseid)::text))) JOIN acdenroll g ON ((a.contractid = g.contractid))) JOIN acdcurriculum h ON ((g.curriculumid = h.curriculumid))) JOIN acdcurricularcomponent i ON ((((h.curricularcomponentid)::text = (i.curricularcomponentid)::text) AND (h.curricularcomponentversion = i.curricularcomponentversion)))) JOIN acdgroup j ON ((g.groupid = j.groupid))) JOIN acdschedule l ON ((j.groupid = l.groupid))) LEFT JOIN acdscheduleprofessor m ON ((l.scheduleid = m.scheduleid))) LEFT JOIN ONLY basphysicalpersonprofessor n ON ((m.professorid = n.personid))) LEFT JOIN insphysicalresource o ON ((l.physicalresourceid = o.physicalresourceid))) LEFT JOIN basunit p ON ((a.unitid = p.unitid))) LEFT JOIN baslocation s ON ((p.locationid = s.locationid))) LEFT JOIN bascity t ON ((s.cityid = t.cityid))) JOIN acdlearningperiod q ON ((j.learningperiodid = q.learningperiodid))) LEFT JOIN baslegalperson r ON ((r.personid = (SELECT aa.personid FROM bascompanyconf aa WHERE (aa.companyid = (getparameter('BASIC'::character varying, 'DEFAULT_COMPANY_CONF'::character varying))::integer))))) WHERE ((g.statusid = (getparameter('ACADEMIC'::character varying, 'ENROLL_STATUS_PRE_ENROLLED'::character varying))::integer) OR ((g.statusid = (getparameter('ACADEMIC'::character varying, 'ENROLL_STATUS_ENROLLED'::character varying))::integer) AND (g.curriculumid = h.curriculumid))) GROUP BY a.contractid, b.miolousername, b.personid, b.name, b.location, b.neighborhood, b.complement, c.name, COALESCE(b.zipcode, c.zipcode), b.number, a.courseid, d.name, a.courseversion, (SELECT aa.name FROM (acdclass aa JOIN acdclasspupil bb ON (((aa.classid)::text = (bb.classid)::text))) WHERE (bb.contractid = a.contractid) ORDER BY bb.begindate DESC LIMIT 1), h.curricularcomponentid, h.curricularcomponentversion, i.name, i.academiccredits, i.academicnumberhours, COALESCE(o.description, '-'::text), COALESCE(p.description, '-'::text), a.unitid, a.turnid, q.learningperiodid, COALESCE(t.name, (SELECT bascity.name FROM bascity WHERE (bascity.cityid = r.cityid))), r.name, l.occurrencedates, l.timeids ORDER BY b.personid, i.name;


ALTER TABLE public.confirmacao_matricula_detalhada OWNER TO solis;

--
-- Name: dbchanges; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE dbchanges (
    changeid integer NOT NULL,
    change text NOT NULL,
    applied boolean DEFAULT false NOT NULL,
    applicationversion integer NOT NULL,
    orderchange integer,
    error text,
    applieddate timestamp without time zone
);


ALTER TABLE public.dbchanges OWNER TO postgres;

--
-- Name: dbchanges_changeid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE dbchanges_changeid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.dbchanges_changeid_seq OWNER TO postgres;

--
-- Name: dbchanges_changeid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE dbchanges_changeid_seq OWNED BY dbchanges.changeid;


--
-- Name: seq_agreementcommentsid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_agreementcommentsid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_agreementcommentsid OWNER TO postgres;

--
-- Name: finagreementcomments; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finagreementcomments (
    agreementcommentsid integer DEFAULT nextval('seq_agreementcommentsid'::regclass) NOT NULL,
    personid bigint NOT NULL,
    agreementtitle character varying(60),
    comments text
)
INHERITS (baslog);


ALTER TABLE public.finagreementcomments OWNER TO postgres;

--
-- Name: TABLE finagreementcomments; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finagreementcomments IS 'contem comentarios referentes a acordos';


--
-- Name: COLUMN finagreementcomments.agreementcommentsid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finagreementcomments.agreementcommentsid IS 'Chave primaria da tabela';


--
-- Name: COLUMN finagreementcomments.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finagreementcomments.personid IS 'Chave estrangeira da BasPerson';


--
-- Name: COLUMN finagreementcomments.agreementtitle; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finagreementcomments.agreementtitle IS 'Titulo do comentario';


--
-- Name: COLUMN finagreementcomments.comments; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finagreementcomments.comments IS 'Comentarios sobre titulos com acordos (acessado pela tela de acordos para pessoas - personAgreements)';


--
-- Name: finbank; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finbank (
    bankid character varying(3) NOT NULL,
    description text NOT NULL,
    bankidvd character(1),
    accordcode character varying,
    tamanhocampoagencia integer,
    tamanhodvagencia integer,
    mascaraagencia text,
    tamanhocampoconta integer,
    tamanhodvconta integer,
    mascaraconta text
)
INHERITS (baslog);


ALTER TABLE public.finbank OWNER TO postgres;

--
-- Name: TABLE finbank; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finbank IS 'bancos com as quais a instituicao trabalha';


--
-- Name: COLUMN finbank.bankid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbank.bankid IS 'Numero do banco fornecido pelo Banco Central para manipulacao de arquivos';


--
-- Name: COLUMN finbank.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbank.description IS 'Nome do banco';


--
-- Name: COLUMN finbank.bankidvd; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbank.bankidvd IS 'Digito verificador do numero do banco.';


--
-- Name: COLUMN finbank.accordcode; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbank.accordcode IS 'Codigo de convenio da empresa com o banco';


--
-- Name: seq_bankaccountid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_bankaccountid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_bankaccountid OWNER TO postgres;

--
-- Name: finbankaccount; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finbankaccount (
    bankaccountid integer DEFAULT nextval('seq_bankaccountid'::regclass) NOT NULL,
    description text NOT NULL,
    accountnumber character varying(30) NOT NULL,
    accountnumberdigit character varying(2),
    branchnumber character varying(30) NOT NULL,
    branchnumberdigit character varying(2),
    bankid character varying(3),
    shop character varying,
    url character varying,
    signature character varying,
    cip character varying,
    ournumber character varying,
    invoicetypeid integer,
    invoicemessage1 integer,
    invoicemessage2 integer,
    taxbankvalue numeric(6,2),
    taxbankcreditoperation integer,
    taxbankdebtoperation integer,
    responsibletaxbank character(1) DEFAULT 'C'::bpchar NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.finbankaccount OWNER TO postgres;

--
-- Name: TABLE finbankaccount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finbankaccount IS 'contas bancarias da instituicao';


--
-- Name: COLUMN finbankaccount.bankaccountid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccount.bankaccountid IS 'Codigo da conta bancaria no SAGU';


--
-- Name: COLUMN finbankaccount.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccount.description IS 'Descricao da conta bancaria';


--
-- Name: COLUMN finbankaccount.accountnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccount.accountnumber IS 'Numero da conta bancaria';


--
-- Name: COLUMN finbankaccount.accountnumberdigit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccount.accountnumberdigit IS 'Digito verificador do numero da conta';


--
-- Name: COLUMN finbankaccount.branchnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccount.branchnumber IS 'Numero da agencia';


--
-- Name: COLUMN finbankaccount.branchnumberdigit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccount.branchnumberdigit IS 'Digito verificador da agencia';


--
-- Name: COLUMN finbankaccount.bankid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccount.bankid IS 'Codigo do banco (finBank)';


--
-- Name: COLUMN finbankaccount.shop; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccount.shop IS 'Número da loja(MerchantID).';


--
-- Name: COLUMN finbankaccount.url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccount.url IS 'Link do SPS.';


--
-- Name: COLUMN finbankaccount.signature; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccount.signature IS 'Assinatura digital.';


--
-- Name: COLUMN finbankaccount.cip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccount.cip IS 'CIP.';


--
-- Name: COLUMN finbankaccount.ournumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccount.ournumber IS 'Mantém o osso número mais atual da conta bancária. Funciona como uma sequence, porém armazena um varchar.';


--
-- Name: COLUMN finbankaccount.invoicemessage1; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccount.invoicemessage1 IS 'Primeira instrução de cobrança utilizada pela conta bancária.';


--
-- Name: COLUMN finbankaccount.invoicemessage2; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccount.invoicemessage2 IS 'Segunda instrução de cobrança utilizada pela conta bancária.';


--
-- Name: finbankaccountinvoiceinfo; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finbankaccountinvoiceinfo (
    bankaccountid integer NOT NULL,
    invoicespecieid character varying(3),
    agreement character varying,
    wallet character varying(3),
    accepted character varying(1),
    transferorcode character varying,
    transferorcodedv character varying(5),
    bankremittancesequence character varying,
    sequence integer,
    gatheringcode character varying(100),
    referencenumber character varying(100),
    ugmanagementcode character varying(100),
    walletmodel character varying(6)
)
INHERITS (baslog);


ALTER TABLE public.finbankaccountinvoiceinfo OWNER TO postgres;

--
-- Name: TABLE finbankaccountinvoiceinfo; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finbankaccountinvoiceinfo IS 'Informações para gerar boletos';


--
-- Name: COLUMN finbankaccountinvoiceinfo.bankaccountid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccountinvoiceinfo.bankaccountid IS 'Codigo da conta bancaria no SAGU';


--
-- Name: COLUMN finbankaccountinvoiceinfo.agreement; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccountinvoiceinfo.agreement IS 'Convênio bancário';


--
-- Name: COLUMN finbankaccountinvoiceinfo.wallet; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccountinvoiceinfo.wallet IS 'Carteira na qual a conta faz parte';


--
-- Name: COLUMN finbankaccountinvoiceinfo.accepted; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccountinvoiceinfo.accepted IS 'Se o título bancário é aceito S ou não N';


--
-- Name: COLUMN finbankaccountinvoiceinfo.transferorcode; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccountinvoiceinfo.transferorcode IS 'Código do cedente que é fornecido pela agência';


--
-- Name: COLUMN finbankaccountinvoiceinfo.transferorcodedv; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccountinvoiceinfo.transferorcodedv IS 'Dígito verificador do código do cedente';


--
-- Name: COLUMN finbankaccountinvoiceinfo.bankremittancesequence; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccountinvoiceinfo.bankremittancesequence IS 'Seqüencial para remessa de arquivos';


--
-- Name: COLUMN finbankaccountinvoiceinfo.sequence; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccountinvoiceinfo.sequence IS 'Armazena o sequencial do complemento do nosso número';


--
-- Name: COLUMN finbankaccountinvoiceinfo.gatheringcode; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccountinvoiceinfo.gatheringcode IS 'Código de recolhimento (GRU)';


--
-- Name: COLUMN finbankaccountinvoiceinfo.referencenumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccountinvoiceinfo.referencenumber IS 'Número de referencia (GRU)';


--
-- Name: COLUMN finbankaccountinvoiceinfo.ugmanagementcode; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccountinvoiceinfo.ugmanagementcode IS 'Código UG/Gestão (GRU)';


--
-- Name: finbankaccountmovement; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finbankaccountmovement (
    bankaccountid integer NOT NULL,
    datemovement date NOT NULL,
    value numeric(14,4) NOT NULL,
    operation character(1) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.finbankaccountmovement OWNER TO postgres;

--
-- Name: TABLE finbankaccountmovement; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finbankaccountmovement IS 'movimentacao das contas correntes - arquivo ofc do banco (extrato da conta)';


--
-- Name: COLUMN finbankaccountmovement.bankaccountid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccountmovement.bankaccountid IS 'Codigo da conta bancaria (finBankAccount)';


--
-- Name: COLUMN finbankaccountmovement.datemovement; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccountmovement.datemovement IS 'Data de movimentacao do valor atual';


--
-- Name: COLUMN finbankaccountmovement.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccountmovement.value IS 'Valor da movimentacao';


--
-- Name: COLUMN finbankaccountmovement.operation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankaccountmovement.operation IS 'Credito (C) ou Debito (D)';


--
-- Name: finbankinvoiceinfo; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finbankinvoiceinfo (
    invoiceid integer NOT NULL,
    bankaccountid integer NOT NULL,
    ournumber character varying NOT NULL,
    barcodenumber character varying,
    digitablenumber character varying
)
INHERITS (baslog);


ALTER TABLE public.finbankinvoiceinfo OWNER TO postgres;

--
-- Name: TABLE finbankinvoiceinfo; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finbankinvoiceinfo IS 'Armazena o nosso número de cada banco';


--
-- Name: COLUMN finbankinvoiceinfo.invoiceid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankinvoiceinfo.invoiceid IS 'Identificador do boleto';


--
-- Name: COLUMN finbankinvoiceinfo.bankaccountid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankinvoiceinfo.bankaccountid IS 'Identificador do título';


--
-- Name: COLUMN finbankinvoiceinfo.ournumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbankinvoiceinfo.ournumber IS 'Valor do nosso número';


--
-- Name: finbankmovementnotfound; Type: TABLE; Schema: public; Owner: solis; Tablespace: 
--

CREATE TABLE finbankmovementnotfound (
    bankmovementnotfoundid integer NOT NULL,
    filediscount numeric,
    fileinterestfine numeric,
    otherdiscounts numeric,
    otheradditions numeric,
    expenditure numeric,
    value numeric,
    valuepaid numeric,
    ournumber character varying(255),
    branch character varying(255),
    branchnumber character varying(255),
    wallet character varying(255),
    occurrencedate character varying(255),
    creditdate character varying(255),
    filematuritydate character varying(255),
    bankid integer,
    fileid integer,
    occurrence character varying(255),
    bankreturnid integer,
    discountvalue numeric,
    convenantvalue numeric,
    interestvalue numeric,
    finevalue numeric,
    balance numeric,
    balancewithpolicies numeric,
    statusid integer
)
INHERITS (baslog);


ALTER TABLE public.finbankmovementnotfound OWNER TO solis;

--
-- Name: finbankmovementnotfound_bankmovementnotfoundid_seq; Type: SEQUENCE; Schema: public; Owner: solis
--

CREATE SEQUENCE finbankmovementnotfound_bankmovementnotfoundid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.finbankmovementnotfound_bankmovementnotfoundid_seq OWNER TO solis;

--
-- Name: finbankmovementnotfound_bankmovementnotfoundid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: solis
--

ALTER SEQUENCE finbankmovementnotfound_bankmovementnotfoundid_seq OWNED BY finbankmovementnotfound.bankmovementnotfoundid;


--
-- Name: fininvoicetarget; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE fininvoicetarget (
    contractid integer NOT NULL,
    isactive boolean DEFAULT true NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.fininvoicetarget OWNER TO postgres;

--
-- Name: TABLE fininvoicetarget; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE fininvoicetarget IS 'destino de cobranca';


--
-- Name: COLUMN fininvoicetarget.contractid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoicetarget.contractid IS 'Codigo do contrato para identificar a pessoa';


--
-- Name: COLUMN fininvoicetarget.isactive; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoicetarget.isactive IS 'Esta flag define se esta ou nao ativo o destino da cobranca para este contrato, a flag sera falsa quando um contrato for desativado';


--
-- Name: finbanktarget; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finbanktarget (
    bankid character varying(3) NOT NULL,
    branchnumber character varying(20) NOT NULL,
    branchnumberdigit character varying(10) NOT NULL,
    accountnumber character varying(20) NOT NULL,
    accountnumberdigit character varying(10) NOT NULL
)
INHERITS (fininvoicetarget);


ALTER TABLE public.finbanktarget OWNER TO postgres;

--
-- Name: TABLE finbanktarget; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finbanktarget IS 'debitos automaticos. herda a fininvoicetarget';


--
-- Name: COLUMN finbanktarget.bankid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbanktarget.bankid IS 'Codigo do banco (finBank)';


--
-- Name: COLUMN finbanktarget.branchnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbanktarget.branchnumber IS 'Numero da agencia';


--
-- Name: COLUMN finbanktarget.branchnumberdigit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbanktarget.branchnumberdigit IS 'Digito verificador da agencia';


--
-- Name: COLUMN finbanktarget.accountnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbanktarget.accountnumber IS 'Numero da conta corrente';


--
-- Name: COLUMN finbanktarget.accountnumberdigit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finbanktarget.accountnumberdigit IS 'Digito verificador da conta corrente';


--
-- Name: fincamporemessa; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE fincamporemessa (
    camporemessaid integer NOT NULL,
    tipovalorvariavelremessaid character varying,
    configuracaoremessaid integer NOT NULL,
    tiporegistro character(2) NOT NULL,
    linha integer NOT NULL,
    posicao integer NOT NULL,
    tamanho character varying(255) NOT NULL,
    alinhamento character(1) NOT NULL,
    completar character(1) NOT NULL,
    tipovalor character varying(3) NOT NULL,
    valor character varying(255)
)
INHERITS (baslog);


ALTER TABLE public.fincamporemessa OWNER TO postgres;

--
-- Name: fincamporemessa_camporemessaid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE fincamporemessa_camporemessaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.fincamporemessa_camporemessaid_seq OWNER TO postgres;

--
-- Name: fincamporemessa_camporemessaid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE fincamporemessa_camporemessaid_seq OWNED BY fincamporemessa.camporemessaid;


--
-- Name: fincheque; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE fincheque (
    chequeid integer NOT NULL,
    numerocheque character varying NOT NULL,
    data date,
    agencia character varying NOT NULL,
    eminente character varying NOT NULL,
    cpf character varying,
    cnpj character varying,
    valorcheque double precision NOT NULL,
    tipo integer NOT NULL,
    bankid character varying NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.fincheque OWNER TO postgres;

--
-- Name: fincheque_chequeid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE fincheque_chequeid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.fincheque_chequeid_seq OWNER TO postgres;

--
-- Name: fincheque_chequeid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE fincheque_chequeid_seq OWNED BY fincheque.chequeid;


--
-- Name: fincielomovement; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE fincielomovement (
    tid character varying NOT NULL,
    countermovementid integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.fincielomovement OWNER TO postgres;

--
-- Name: fincielostatus; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE fincielostatus (
    cielostatusid integer NOT NULL,
    description character varying(20) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.fincielostatus OWNER TO postgres;

--
-- Name: fincielotransaction; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE fincielotransaction (
    cielotransactionid integer NOT NULL,
    tid character varying NOT NULL,
    datetransaction timestamp without time zone DEFAULT now() NOT NULL,
    cielostatusid integer NOT NULL,
    numero integer,
    valor bigint,
    bandeira character varying(20),
    xml text
)
INHERITS (baslog);


ALTER TABLE public.fincielotransaction OWNER TO postgres;

--
-- Name: fincielotransaction_cielotransactionid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE fincielotransaction_cielotransactionid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.fincielotransaction_cielotransactionid_seq OWNER TO postgres;

--
-- Name: fincielotransaction_cielotransactionid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE fincielotransaction_cielotransactionid_seq OWNED BY fincielotransaction.cielotransactionid;


--
-- Name: seq_closecounterid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_closecounterid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_closecounterid OWNER TO postgres;

--
-- Name: finclosecounter; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finclosecounter (
    closecounterid integer DEFAULT nextval('seq_closecounterid'::regclass) NOT NULL,
    value numeric(14,2) NOT NULL,
    registerdate timestamp without time zone DEFAULT now(),
    operation character(1) NOT NULL,
    opencounterid integer NOT NULL,
    observation text,
    isconfirmed boolean DEFAULT true NOT NULL,
    determinedvalue numeric(14,2),
    saldofechamento numeric(14,2) DEFAULT 0,
    counterid integer
)
INHERITS (baslog);


ALTER TABLE public.finclosecounter OWNER TO postgres;

--
-- Name: TABLE finclosecounter; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finclosecounter IS 'fechamentos de caixa';


--
-- Name: COLUMN finclosecounter.closecounterid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finclosecounter.closecounterid IS 'Codigo do fechamento de caixa';


--
-- Name: COLUMN finclosecounter.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finclosecounter.value IS 'Valor de fechamento';


--
-- Name: COLUMN finclosecounter.registerdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finclosecounter.registerdate IS 'Data do registro do caixa';


--
-- Name: COLUMN finclosecounter.operation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finclosecounter.operation IS 'Credito (C) ou Debito (D)';


--
-- Name: COLUMN finclosecounter.opencounterid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finclosecounter.opencounterid IS 'Código da abertura de caixa';


--
-- Name: COLUMN finclosecounter.observation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finclosecounter.observation IS 'Observação para o fechamento de caixa';


--
-- Name: COLUMN finclosecounter.isconfirmed; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finclosecounter.isconfirmed IS 'Indica se o fechamento foi confirmado.';


--
-- Name: COLUMN finclosecounter.determinedvalue; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finclosecounter.determinedvalue IS 'Valor apurado na confirmação do fechamento do caixa.';


--
-- Name: fincobrancabancaria; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE fincobrancabancaria (
    cobrancabancariaid integer NOT NULL,
    descricao character varying(255) NOT NULL,
    leiaute character varying(255),
    bankaccountid integer NOT NULL,
    envio character(1) NOT NULL,
    formatodata character varying(255),
    codcedente character varying(255),
    carteira character varying(255),
    especie character varying(255)
)
INHERITS (baslog);


ALTER TABLE public.fincobrancabancaria OWNER TO postgres;

--
-- Name: fincobrancabancaria_cobrancabancariaid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE fincobrancabancaria_cobrancabancariaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.fincobrancabancaria_cobrancabancariaid_seq OWNER TO postgres;

--
-- Name: fincobrancabancaria_cobrancabancariaid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE fincobrancabancaria_cobrancabancariaid_seq OWNED BY fincobrancabancaria.cobrancabancariaid;


--
-- Name: seq_collectiontypeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_collectiontypeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_collectiontypeid OWNER TO postgres;

--
-- Name: fincollectiontype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE fincollectiontype (
    collectiontypeid integer DEFAULT nextval('seq_collectiontypeid'::regclass) NOT NULL,
    description text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.fincollectiontype OWNER TO postgres;

--
-- Name: TABLE fincollectiontype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE fincollectiontype IS 'tipos de cobrancas, podendo ser simples, com registro ou outro.';


--
-- Name: COLUMN fincollectiontype.collectiontypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fincollectiontype.collectiontypeid IS 'Codigo identificador do tipo de cobranca';


--
-- Name: COLUMN fincollectiontype.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fincollectiontype.description IS 'Texto descrevendo o tipo da cobranca (simples, com registro, etc).';


--
-- Name: finconfiguracaoremessa; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finconfiguracaoremessa (
    configuracaoremessaid integer NOT NULL,
    cobrancabancariaid integer NOT NULL,
    nomearquivo character varying(255) NOT NULL,
    sequencia character varying(255) NOT NULL,
    quebralinha character varying
)
INHERITS (baslog);


ALTER TABLE public.finconfiguracaoremessa OWNER TO postgres;

--
-- Name: finconfiguracaoremessa_configuracaoremessaid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE finconfiguracaoremessa_configuracaoremessaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.finconfiguracaoremessa_configuracaoremessaid_seq OWNER TO postgres;

--
-- Name: finconfiguracaoremessa_configuracaoremessaid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE finconfiguracaoremessa_configuracaoremessaid_seq OWNED BY finconfiguracaoremessa.configuracaoremessaid;


--
-- Name: finconvenant; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finconvenant (
    convenantid integer NOT NULL,
    description text NOT NULL,
    value double precision NOT NULL,
    ispercent boolean DEFAULT true NOT NULL,
    daystodiscount integer,
    beforeafter character(1) DEFAULT 'A'::bpchar NOT NULL,
    convenantoperation integer NOT NULL,
    personid bigint,
    aditarincentivo boolean DEFAULT false,
    percentrenovacao integer
)
INHERITS (baslog);


ALTER TABLE public.finconvenant OWNER TO postgres;

--
-- Name: TABLE finconvenant; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finconvenant IS 'Tabela de convênios';


--
-- Name: COLUMN finconvenant.convenantid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finconvenant.convenantid IS 'Chave primária da tabela de convênios.';


--
-- Name: COLUMN finconvenant.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finconvenant.description IS 'Descrição do convênio';


--
-- Name: COLUMN finconvenant.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finconvenant.value IS 'Valor de desconto do convênio';


--
-- Name: COLUMN finconvenant.ispercent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finconvenant.ispercent IS 'Se o valor é percentual ou não';


--
-- Name: COLUMN finconvenant.daystodiscount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finconvenant.daystodiscount IS 'Dias antes ou depois do vencimento até os quais o convênio será concedido';


--
-- Name: COLUMN finconvenant.beforeafter; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finconvenant.beforeafter IS 'Se os dias são antes (B) ou depois (A) do vencimento';


--
-- Name: finconvenant_convenantid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE finconvenant_convenantid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.finconvenant_convenantid_seq OWNER TO postgres;

--
-- Name: finconvenant_convenantid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE finconvenant_convenantid_seq OWNED BY finconvenant.convenantid;


--
-- Name: finconvenantperson; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finconvenantperson (
    convenantpersonid bigint NOT NULL,
    convenantid integer NOT NULL,
    personid bigint NOT NULL,
    begindate date DEFAULT now() NOT NULL,
    enddate date,
    contractid integer,
    observacao text
)
INHERITS (baslog);


ALTER TABLE public.finconvenantperson OWNER TO postgres;

--
-- Name: TABLE finconvenantperson; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finconvenantperson IS 'Tabela responsável por atribuir um convênio a uma pessoa';


--
-- Name: COLUMN finconvenantperson.convenantpersonid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finconvenantperson.convenantpersonid IS 'Código em sequencia que é a chave primária';


--
-- Name: COLUMN finconvenantperson.convenantid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finconvenantperson.convenantid IS 'Chave estrangeira pra os convênios';


--
-- Name: COLUMN finconvenantperson.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finconvenantperson.personid IS 'Chave estrangeira para as pessoas';


--
-- Name: COLUMN finconvenantperson.begindate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finconvenantperson.begindate IS 'Data de início da vigência do convênio para a pessoa';


--
-- Name: COLUMN finconvenantperson.enddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finconvenantperson.enddate IS 'Data de fim da vigência do convênio para a pessoa';


--
-- Name: COLUMN finconvenantperson.contractid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finconvenantperson.contractid IS 'Contrato especifico (opcional) em que este convenio da pessoa deve ser aplicado. Quando estiver definido, aplica apenas para um contrato da pessoa.';


--
-- Name: finconvenantperson_convenantpersonid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE finconvenantperson_convenantpersonid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.finconvenantperson_convenantpersonid_seq OWNER TO postgres;

--
-- Name: finconvenantperson_convenantpersonid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE finconvenantperson_convenantpersonid_seq OWNED BY finconvenantperson.convenantpersonid;


--
-- Name: seq_counterid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_counterid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_counterid OWNER TO postgres;

--
-- Name: fincounter; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE fincounter (
    counterid integer DEFAULT nextval('seq_counterid'::regclass) NOT NULL,
    unitid integer NOT NULL,
    isactive boolean DEFAULT true NOT NULL,
    description text,
    iscountertreasury boolean DEFAULT false
)
INHERITS (baslog);


ALTER TABLE public.fincounter OWNER TO postgres;

--
-- Name: TABLE fincounter; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE fincounter IS 'caixas (guiches)';


--
-- Name: COLUMN fincounter.counterid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fincounter.counterid IS 'Codigo que identifica o caixa';


--
-- Name: COLUMN fincounter.unitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fincounter.unitid IS 'Campus onde o caixa de encontra';


--
-- Name: COLUMN fincounter.isactive; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fincounter.isactive IS 'Define se o caixa esta ativo ou nao';


--
-- Name: COLUMN fincounter.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fincounter.description IS 'Descrição do caixa';


--
-- Name: seq_countermovementid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_countermovementid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_countermovementid OWNER TO postgres;

--
-- Name: fincountermovement; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE fincountermovement (
    countermovementid integer DEFAULT nextval('seq_countermovementid'::regclass) NOT NULL,
    value numeric(14,4) NOT NULL,
    movementdate timestamp without time zone DEFAULT now(),
    operation character(1) NOT NULL,
    speciesid integer NOT NULL,
    observation text,
    opencounterid integer NOT NULL,
    invoiceid integer,
    operationid integer,
    costcenterid character varying(30),
    fileid integer,
    voucher character varying,
    responsibleuser character varying,
    tituloid integer,
    bankaccountid integer,
    transferenciadecaixaid integer
)
INHERITS (baslog);


ALTER TABLE public.fincountermovement OWNER TO postgres;

--
-- Name: TABLE fincountermovement; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE fincountermovement IS 'movimentacao do caixa';


--
-- Name: COLUMN fincountermovement.countermovementid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fincountermovement.countermovementid IS 'Codigo identificador da movimentacao de caixa';


--
-- Name: COLUMN fincountermovement.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fincountermovement.value IS 'Valor da movimentacao';


--
-- Name: COLUMN fincountermovement.movementdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fincountermovement.movementdate IS 'Data e horario da movimentacao do caixa';


--
-- Name: COLUMN fincountermovement.operation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fincountermovement.operation IS 'Crédito (C) ou Débito (D)';


--
-- Name: COLUMN fincountermovement.speciesid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fincountermovement.speciesid IS 'Especie monetaria (finSpecies)';


--
-- Name: COLUMN fincountermovement.observation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fincountermovement.observation IS 'Campo para inserir uma observação na movimentação.';


--
-- Name: COLUMN fincountermovement.opencounterid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fincountermovement.opencounterid IS 'Código da abertura de caixa';


--
-- Name: COLUMN fincountermovement.invoiceid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fincountermovement.invoiceid IS 'Código do título';


--
-- Name: COLUMN fincountermovement.operationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fincountermovement.operationid IS 'Código da operação';


--
-- Name: COLUMN fincountermovement.costcenterid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fincountermovement.costcenterid IS 'Código do centro de custo';


--
-- Name: COLUMN fincountermovement.responsibleuser; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fincountermovement.responsibleuser IS 'Usuário responsável pela movimentação';


--
-- Name: COLUMN fincountermovement.tituloid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fincountermovement.tituloid IS 'Titulo do contas a pagar';


--
-- Name: fincountermovementcheque; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE fincountermovementcheque (
    movementchequeid integer NOT NULL,
    chequeid integer NOT NULL,
    countermovementid integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.fincountermovementcheque OWNER TO postgres;

--
-- Name: fincountermovementcheque_movementchequeid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE fincountermovementcheque_movementchequeid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.fincountermovementcheque_movementchequeid_seq OWNER TO postgres;

--
-- Name: fincountermovementcheque_movementchequeid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE fincountermovementcheque_movementchequeid_seq OWNED BY fincountermovementcheque.movementchequeid;


--
-- Name: findadosbancariosdapessoa; Type: TABLE; Schema: public; Owner: solis; Tablespace: 
--

CREATE TABLE findadosbancariosdapessoa (
    dadosbancariosdapessoa integer NOT NULL,
    personid bigint,
    bankid character varying,
    agencia character varying(255),
    digitodaagencia integer,
    conta character varying(255),
    digitodaconta integer,
    observacao text
)
INHERITS (baslog);


ALTER TABLE public.findadosbancariosdapessoa OWNER TO solis;

--
-- Name: findadosbancariosdapessoa_dadosbancariosdapessoa_seq; Type: SEQUENCE; Schema: public; Owner: solis
--

CREATE SEQUENCE findadosbancariosdapessoa_dadosbancariosdapessoa_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.findadosbancariosdapessoa_dadosbancariosdapessoa_seq OWNER TO solis;

--
-- Name: findadosbancariosdapessoa_dadosbancariosdapessoa_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: solis
--

ALTER SEQUENCE findadosbancariosdapessoa_dadosbancariosdapessoa_seq OWNED BY findadosbancariosdapessoa.dadosbancariosdapessoa;


--
-- Name: findefaultoperations; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE findefaultoperations (
    addcurricularcomponentoperation integer,
    cancelcurricularcomponentoperation integer,
    protocoloperation integer,
    interestoperation integer,
    discountoperation integer,
    libraryfineoperation integer,
    closeincomeforecastoperation integer,
    enrolloperation integer,
    paymentoperation integer,
    agreementoperation integer,
    banktaxoperation integer,
    selectiveprocesstaxoperation integer,
    bankclosingtaxoperation integer,
    renewaloperation integer,
    monthlyfeeoperation integer,
    otherdiscountsoperation integer,
    otheradditionsoperation integer,
    repaymentcurricularcomponentoperation integer,
    withdrawoperation integer,
    coursetransferoperation integer,
    transferoperation integer,
    reentryoperation integer,
    payrolldiscountoperation integer,
    transferenciadesaldooperation integer,
    reemissaodetitulooperation integer,
    negotiationoperation integer,
    opencounteroperation integer,
    counterwithdrawaloperation integer,
    transferenciadevalordecaixa integer,
    recebimentodevalordecaixa integer
)
INHERITS (baslog);


ALTER TABLE public.findefaultoperations OWNER TO postgres;

--
-- Name: TABLE findefaultoperations; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE findefaultoperations IS 'operacoes padrao';


--
-- Name: COLUMN findefaultoperations.addcurricularcomponentoperation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN findefaultoperations.addcurricularcomponentoperation IS 'Operacao para acrescimos de disciplina';


--
-- Name: COLUMN findefaultoperations.cancelcurricularcomponentoperation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN findefaultoperations.cancelcurricularcomponentoperation IS 'Operacao para retirada de disciplinas (Credito)';


--
-- Name: COLUMN findefaultoperations.protocoloperation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN findefaultoperations.protocoloperation IS 'Operacao para pagamento de protocolos';


--
-- Name: COLUMN findefaultoperations.interestoperation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN findefaultoperations.interestoperation IS 'Operacao para juros';


--
-- Name: COLUMN findefaultoperations.discountoperation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN findefaultoperations.discountoperation IS 'Operacao para descontos';


--
-- Name: COLUMN findefaultoperations.libraryfineoperation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN findefaultoperations.libraryfineoperation IS 'Operacao para multas da biblioteca';


--
-- Name: COLUMN findefaultoperations.closeincomeforecastoperation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN findefaultoperations.closeincomeforecastoperation IS 'Operacao para fechamento de previsoes';


--
-- Name: COLUMN findefaultoperations.enrolloperation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN findefaultoperations.enrolloperation IS 'Operacao para geracao de mensalidades';


--
-- Name: COLUMN findefaultoperations.paymentoperation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN findefaultoperations.paymentoperation IS 'Operacao para pagamento de titulos (fechamento)';


--
-- Name: COLUMN findefaultoperations.agreementoperation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN findefaultoperations.agreementoperation IS 'Operacao para acordos amigaveis';


--
-- Name: COLUMN findefaultoperations.banktaxoperation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN findefaultoperations.banktaxoperation IS 'Operacao para operacao de taxas bancarias.';


--
-- Name: COLUMN findefaultoperations.selectiveprocesstaxoperation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN findefaultoperations.selectiveprocesstaxoperation IS 'Operacao utilizada para cobranca de processos seletivos ';


--
-- Name: COLUMN findefaultoperations.bankclosingtaxoperation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN findefaultoperations.bankclosingtaxoperation IS 'Operacao para Fechamento de taxas bancarias.';


--
-- Name: COLUMN findefaultoperations.repaymentcurricularcomponentoperation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN findefaultoperations.repaymentcurricularcomponentoperation IS 'Operacao para reembolsos de disciplina';


--
-- Name: COLUMN findefaultoperations.withdrawoperation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN findefaultoperations.withdrawoperation IS 'Operacao para retirada de caixa';


--
-- Name: COLUMN findefaultoperations.coursetransferoperation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN findefaultoperations.coursetransferoperation IS 'Operacao para mudança de curso/turno';


--
-- Name: COLUMN findefaultoperations.transferoperation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN findefaultoperations.transferoperation IS 'Operacao para transferidos';


--
-- Name: COLUMN findefaultoperations.reentryoperation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN findefaultoperations.reentryoperation IS 'Operacao para reingressos';


--
-- Name: seq_emissiontype; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_emissiontype
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_emissiontype OWNER TO postgres;

--
-- Name: finemissiontype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finemissiontype (
    emissiontypeid integer DEFAULT nextval('seq_emissiontype'::regclass) NOT NULL,
    description character varying(20) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.finemissiontype OWNER TO postgres;

--
-- Name: TABLE finemissiontype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finemissiontype IS 'Identifica o responsável e a forma de emissão de boleto';


--
-- Name: COLUMN finemissiontype.emissiontypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finemissiontype.emissiontypeid IS 'Codigo identificador da forma de emissão de boleto';


--
-- Name: COLUMN finemissiontype.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finemissiontype.description IS 'Descrição do tipo de emissão';


--
-- Name: finenrollfee; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finenrollfee (
    learningperiodid integer NOT NULL,
    operationid integer NOT NULL,
    isfreshman boolean DEFAULT false NOT NULL,
    valueispercent boolean NOT NULL,
    value numeric(14,4) NOT NULL,
    parcelsnumber integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.finenrollfee OWNER TO postgres;

--
-- Name: TABLE finenrollfee; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finenrollfee IS 'taxas que podem ser cobradas no ato da matricula (taxa de dce, por exemplo).';


--
-- Name: COLUMN finenrollfee.learningperiodid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finenrollfee.learningperiodid IS 'Codigo identificador do periodo letivo.';


--
-- Name: COLUMN finenrollfee.operationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finenrollfee.operationid IS 'Operação que será utilizada para gerar o lançamento.';


--
-- Name: COLUMN finenrollfee.isfreshman; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finenrollfee.isfreshman IS 'Se o aluno e calouro ou nao';


--
-- Name: COLUMN finenrollfee.valueispercent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finenrollfee.valueispercent IS 'Indica se o campo Value corresponde a um valor fixo (FALSE) ou a um percentual (TRUE).';


--
-- Name: COLUMN finenrollfee.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finenrollfee.value IS 'Se for um valor fixo (ValueIsPercent = FALSE), corresponde ao valor da taxa. Caso contrario, e um percentual.';


--
-- Name: COLUMN finenrollfee.parcelsnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finenrollfee.parcelsnumber IS 'Numero de parcelas onde a taxa sera cobrada.';


--
-- Name: seq_entryid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_entryid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_entryid OWNER TO postgres;

--
-- Name: finentry; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finentry (
    entryid integer DEFAULT nextval('seq_entryid'::regclass) NOT NULL,
    invoiceid integer NOT NULL,
    operationid integer NOT NULL,
    entrydate date NOT NULL,
    value numeric(14,4) NOT NULL,
    costcenterid character varying(30) NOT NULL,
    comments text,
    bankreturncode character varying(50),
    isaccounted boolean DEFAULT false NOT NULL,
    creationtype character(1) DEFAULT 'A'::bpchar,
    contractid integer,
    learningperiodid integer,
    bankmovementid integer,
    incentivetypeid integer
)
INHERITS (baslog);


ALTER TABLE public.finentry OWNER TO postgres;

--
-- Name: TABLE finentry; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finentry IS 'contem os lancamentos dos titulos, tanto dos a receber quanto dos a pagar.';


--
-- Name: COLUMN finentry.entryid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finentry.entryid IS 'Codigo identificador do lancamento';


--
-- Name: COLUMN finentry.invoiceid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finentry.invoiceid IS 'Codigo identificador do titulo ao qual o lancamento pertence';


--
-- Name: COLUMN finentry.operationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finentry.operationid IS 'Codigo identificador da operacao (finOperation)';


--
-- Name: COLUMN finentry.entrydate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finentry.entrydate IS 'Data de criacao do lancamento';


--
-- Name: COLUMN finentry.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finentry.value IS 'Valor do lancamento. Somados, os valores dos lancamentos de um titulo resultam no valor liquido do titulo.';


--
-- Name: COLUMN finentry.costcenterid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finentry.costcenterid IS 'Codigo identificador do centro de custo ao qual o lancamento pertence. Este campo e necessario para casos onde a mensalidade e originada de um centro de custo e o desconto referente a sua bolsa de estudos vem de outro centro de custo.';


--
-- Name: COLUMN finentry.comments; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finentry.comments IS 'Informacao complementar que se deseja adicionar ao lancamento.';


--
-- Name: COLUMN finentry.bankreturncode; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finentry.bankreturncode IS 'Codigo fornecido pelo banco, geralmente identificando o lote pelo qual o lancamento veio.';


--
-- Name: COLUMN finentry.isaccounted; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finentry.isaccounted IS 'TRUE (FALSE) indica que o lancamento (nao) foi contabilizado.';


--
-- Name: COLUMN finentry.creationtype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finentry.creationtype IS 'Tipo de criacao: A - Automatica, M - Manual, P, S e V';


--
-- Name: COLUMN finentry.bankmovementid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finentry.bankmovementid IS 'Armazenar a movimentação bancária que originou o lançamento';


--
-- Name: COLUMN finentry.incentivetypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finentry.incentivetypeid IS 'Campo para identificar que tipo de incentivo gerou o lançamento (utilizado pela função generatecontractincentivesinperiod)';


--
-- Name: finfile; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finfile (
    fileid integer DEFAULT nextval('seq_fileid'::regclass),
    bankaccountid integer,
    filetype character(1) NOT NULL,
    inputoroutput character(1) NOT NULL,
    isprocessed boolean DEFAULT false NOT NULL,
    bankreturnid integer,
    referencedate date
)
INHERITS (basfile);


ALTER TABLE public.finfile OWNER TO postgres;

--
-- Name: TABLE finfile; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finfile IS 'registro de arquivos de retorno, remessa e outros arquivos que sã£o processados e enviados para o servidor, como por exemplo arquivo de irrf.';


--
-- Name: COLUMN finfile.fileid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finfile.fileid IS 'Codigo Identificador do arquivo ';


--
-- Name: COLUMN finfile.bankaccountid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finfile.bankaccountid IS 'Conta bancaria a qual esta ligada o arquivo (finBankAccount)';


--
-- Name: COLUMN finfile.filetype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finfile.filetype IS 'Define o tipo de arquivo de conversacao. I = invoice(titulo), A =Automatic debit, M = Messages, T = Tax ( IRRF )';


--
-- Name: COLUMN finfile.inputoroutput; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finfile.inputoroutput IS '(I) para INPUT - (Retorno), (O) para OUTPUT - (Remessa)';


--
-- Name: COLUMN finfile.isprocessed; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finfile.isprocessed IS 'Define se o arquivo foi processado ou nao';


--
-- Name: COLUMN finfile.bankreturnid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finfile.bankreturnid IS 'Armazenar a sequência do arquivo de retorno informado no arquivo de retorno';


--
-- Name: COLUMN finfile.referencedate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finfile.referencedate IS 'Armazenar a data de referência do arquivo de retorno';


--
-- Name: seq_incentivetypeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_incentivetypeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_incentivetypeid OWNER TO postgres;

--
-- Name: finincentivetype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finincentivetype (
    incentivetypeid integer DEFAULT nextval('seq_incentivetypeid'::regclass) NOT NULL,
    description text NOT NULL,
    operationid integer NOT NULL,
    needadjustauthorization boolean DEFAULT false NOT NULL,
    sendinvoices boolean DEFAULT true NOT NULL,
    isextinct boolean DEFAULT false NOT NULL,
    generatecredits boolean,
    paymentoperation integer,
    repaymentoperation integer,
    applydiscounts boolean DEFAULT true NOT NULL,
    aditarincentivo boolean DEFAULT false,
    percentrenovacao integer
)
INHERITS (baslog);


ALTER TABLE public.finincentivetype OWNER TO postgres;

--
-- Name: TABLE finincentivetype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finincentivetype IS 'tipos de incentivos que podem ser concedidos';


--
-- Name: COLUMN finincentivetype.incentivetypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincentivetype.incentivetypeid IS 'Codigo identificador do tipo de incentivo';


--
-- Name: COLUMN finincentivetype.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincentivetype.description IS 'Texto descrevendo o tipo de incentivo';


--
-- Name: COLUMN finincentivetype.operationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincentivetype.operationid IS 'Codigo identificador da operacao do incentivo (finOperation)';


--
-- Name: COLUMN finincentivetype.needadjustauthorization; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincentivetype.needadjustauthorization IS 'se o aluno precisa autorizacao da empresa pra fazer ajuste de matricula';


--
-- Name: COLUMN finincentivetype.sendinvoices; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincentivetype.sendinvoices IS 'Envia ou não títulos de pessoas que possuem este tipo de incentivo. (FAE)';


--
-- Name: COLUMN finincentivetype.isextinct; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincentivetype.isextinct IS 'Se um incentivo foi ou nao cancelado';


--
-- Name: COLUMN finincentivetype.paymentoperation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincentivetype.paymentoperation IS 'Indica a operação de acréscimo de incentivo';


--
-- Name: COLUMN finincentivetype.repaymentoperation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincentivetype.repaymentoperation IS 'Indica a operação de reembolso de incentivo';


--
-- Name: finfinancialaid; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finfinancialaid (
    requirecostcenter boolean DEFAULT false NOT NULL
)
INHERITS (finincentivetype);


ALTER TABLE public.finfinancialaid OWNER TO postgres;

--
-- Name: TABLE finfinancialaid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finfinancialaid IS 'incentivos do tipo bolsa de estudo (2o filho, bic, professor, ciee, fapergs, aeca, etc.). herda a finincentivetype';


--
-- Name: COLUMN finfinancialaid.requirecostcenter; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finfinancialaid.requirecostcenter IS 'obrigar o preenchimento de costCenter em finIncentive';


--
-- Name: finfluxoaprovacao; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finfluxoaprovacao (
    fluxoaprovacaoid integer NOT NULL,
    fluxosolicitacaoid integer NOT NULL,
    fluxoaprovacaonivelid integer NOT NULL,
    fluxoaprovacaostatusid integer NOT NULL,
    iduser integer NOT NULL,
    observacao text
)
INHERITS (baslog);


ALTER TABLE public.finfluxoaprovacao OWNER TO postgres;

--
-- Name: finfluxoaprovacao_fluxoaprovacaoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE finfluxoaprovacao_fluxoaprovacaoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.finfluxoaprovacao_fluxoaprovacaoid_seq OWNER TO postgres;

--
-- Name: finfluxoaprovacao_fluxoaprovacaoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE finfluxoaprovacao_fluxoaprovacaoid_seq OWNED BY finfluxoaprovacao.fluxoaprovacaoid;


--
-- Name: finfluxoaprovacaoconfiguracao; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finfluxoaprovacaoconfiguracao (
    fluxoaprovacaoconfiguracaoid integer NOT NULL,
    fluxoaprovacaoprocessoid integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.finfluxoaprovacaoconfiguracao OWNER TO postgres;

--
-- Name: finfluxoaprovacaoconfiguracao_fluxoaprovacaoconfiguracaoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE finfluxoaprovacaoconfiguracao_fluxoaprovacaoconfiguracaoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.finfluxoaprovacaoconfiguracao_fluxoaprovacaoconfiguracaoid_seq OWNER TO postgres;

--
-- Name: finfluxoaprovacaoconfiguracao_fluxoaprovacaoconfiguracaoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE finfluxoaprovacaoconfiguracao_fluxoaprovacaoconfiguracaoid_seq OWNED BY finfluxoaprovacaoconfiguracao.fluxoaprovacaoconfiguracaoid;


--
-- Name: finfluxoaprovacaonivel; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finfluxoaprovacaonivel (
    fluxoaprovacaonivelid integer NOT NULL,
    fluxoaprovacaoconfiguracaoid integer NOT NULL,
    nivel integer NOT NULL,
    iduser integer,
    idgroup integer
)
INHERITS (baslog);


ALTER TABLE public.finfluxoaprovacaonivel OWNER TO postgres;

--
-- Name: finfluxoaprovacaonivel_fluxoaprovacaonivelid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE finfluxoaprovacaonivel_fluxoaprovacaonivelid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.finfluxoaprovacaonivel_fluxoaprovacaonivelid_seq OWNER TO postgres;

--
-- Name: finfluxoaprovacaonivel_fluxoaprovacaonivelid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE finfluxoaprovacaonivel_fluxoaprovacaonivelid_seq OWNED BY finfluxoaprovacaonivel.fluxoaprovacaonivelid;


--
-- Name: finfluxoaprovacaoprocesso; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finfluxoaprovacaoprocesso (
    fluxoaprovacaoprocessoid integer NOT NULL,
    nomedoprocesso character varying(255) NOT NULL,
    descricao text,
    nomedatabela character varying(255) NOT NULL,
    nomedacolunachaveprimaria character varying(255) NOT NULL,
    metododosfiltros character varying(255) NOT NULL,
    idmodulelink character varying(255),
    actionlink character varying(255),
    functionlink character varying(255),
    metodododiff character varying(255)
)
INHERITS (baslog);


ALTER TABLE public.finfluxoaprovacaoprocesso OWNER TO postgres;

--
-- Name: finfluxoaprovacaoprocesso_fluxoaprovacaoprocessoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE finfluxoaprovacaoprocesso_fluxoaprovacaoprocessoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.finfluxoaprovacaoprocesso_fluxoaprovacaoprocessoid_seq OWNER TO postgres;

--
-- Name: finfluxoaprovacaoprocesso_fluxoaprovacaoprocessoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE finfluxoaprovacaoprocesso_fluxoaprovacaoprocessoid_seq OWNED BY finfluxoaprovacaoprocesso.fluxoaprovacaoprocessoid;


--
-- Name: finfluxoaprovacaostatus; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finfluxoaprovacaostatus (
    fluxoaprovacaostatusid integer NOT NULL,
    descricao character varying(255) NOT NULL
);


ALTER TABLE public.finfluxoaprovacaostatus OWNER TO postgres;

--
-- Name: finfluxoaprovacaostatus_fluxoaprovacaostatusid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE finfluxoaprovacaostatus_fluxoaprovacaostatusid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.finfluxoaprovacaostatus_fluxoaprovacaostatusid_seq OWNER TO postgres;

--
-- Name: finfluxoaprovacaostatus_fluxoaprovacaostatusid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE finfluxoaprovacaostatus_fluxoaprovacaostatusid_seq OWNED BY finfluxoaprovacaostatus.fluxoaprovacaostatusid;


--
-- Name: finfluxosolicitacao; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finfluxosolicitacao (
    fluxosolicitacaoid integer NOT NULL,
    fluxoaprovacaoprocessoid integer NOT NULL,
    fluxoaprovacaostatusid integer NOT NULL,
    iduser integer NOT NULL,
    codigodoregistro character varying(225) NOT NULL,
    observacao text
)
INHERITS (baslog);


ALTER TABLE public.finfluxosolicitacao OWNER TO postgres;

--
-- Name: finfluxosolicitacao_fluxosolicitacaoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE finfluxosolicitacao_fluxosolicitacaoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.finfluxosolicitacao_fluxosolicitacaoid_seq OWNER TO postgres;

--
-- Name: finfluxosolicitacao_fluxosolicitacaoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE finfluxosolicitacao_fluxosolicitacaoid_seq OWNED BY finfluxosolicitacao.fluxosolicitacaoid;


--
-- Name: finfluxosolicitacaoregistro; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finfluxosolicitacaoregistro (
    fluxosolicitacaoregistroid integer NOT NULL,
    fluxosolicitacaoid integer,
    registrodados text,
    registromodule character varying(255),
    registroaction character varying(255),
    registroevent character varying(255),
    registrofunction character varying(255),
    registroprocessado boolean DEFAULT false
)
INHERITS (baslog);


ALTER TABLE public.finfluxosolicitacaoregistro OWNER TO postgres;

--
-- Name: finfluxosolicitacaoregistro_fluxosolicitacaoregistroid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE finfluxosolicitacaoregistro_fluxosolicitacaoregistroid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.finfluxosolicitacaoregistro_fluxosolicitacaoregistroid_seq OWNER TO postgres;

--
-- Name: finfluxosolicitacaoregistro_fluxosolicitacaoregistroid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE finfluxosolicitacaoregistro_fluxosolicitacaoregistroid_seq OWNED BY finfluxosolicitacaoregistro.fluxosolicitacaoregistroid;


--
-- Name: finhistoricoremessa; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finhistoricoremessa (
    historicoremessaid integer NOT NULL,
    invoiceid integer NOT NULL,
    datageracao timestamp without time zone DEFAULT now() NOT NULL,
    sequencianoarquivo integer NOT NULL,
    fileid integer,
    pedidodebaixa boolean
)
INHERITS (baslog);


ALTER TABLE public.finhistoricoremessa OWNER TO postgres;

--
-- Name: COLUMN finhistoricoremessa.pedidodebaixa; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finhistoricoremessa.pedidodebaixa IS 'Indica se ja foi feito pedido de baixa para este titulo';


--
-- Name: finhistoricoremessa_historicoremessaid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE finhistoricoremessa_historicoremessaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.finhistoricoremessa_historicoremessaid_seq OWNER TO postgres;

--
-- Name: finhistoricoremessa_historicoremessaid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE finhistoricoremessa_historicoremessaid_seq OWNED BY finhistoricoremessa.historicoremessaid;


--
-- Name: seq_incentiveid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_incentiveid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_incentiveid OWNER TO postgres;

--
-- Name: finincentive; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finincentive (
    incentiveid integer DEFAULT nextval('seq_incentiveid'::regclass) NOT NULL,
    contractid integer NOT NULL,
    startdate date NOT NULL,
    enddate date NOT NULL,
    incentivetypeid integer NOT NULL,
    valueispercent boolean DEFAULT false NOT NULL,
    value numeric(14,4),
    supporterid integer,
    agglutinate boolean DEFAULT false NOT NULL,
    costcenterid character varying(30),
    cancellationdate date,
    incentivoaditado boolean DEFAULT false
)
INHERITS (baslog);


ALTER TABLE public.finincentive OWNER TO postgres;

--
-- Name: TABLE finincentive; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finincentive IS 'incentivos de estudo dados a alunos, como bolsas, financiamentos, patrocinios, etc. ';


--
-- Name: COLUMN finincentive.incentiveid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincentive.incentiveid IS 'Codigo identificador do incentivo';


--
-- Name: COLUMN finincentive.contractid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincentive.contractid IS 'Codigo identificador do contrato (pessoa) ao qual o incentivo sera concedido';


--
-- Name: COLUMN finincentive.startdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincentive.startdate IS 'Data a partir da qual o incentivo passa a valer';


--
-- Name: COLUMN finincentive.enddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincentive.enddate IS 'Data de expiracao do incentivo';


--
-- Name: COLUMN finincentive.incentivetypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincentive.incentivetypeid IS 'Codigo identificador do tipo de incentivo (finIncentiveType)';


--
-- Name: COLUMN finincentive.valueispercent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincentive.valueispercent IS 'TRUE (FALSE) se o campo Value representa um percentual (valor).';


--
-- Name: COLUMN finincentive.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincentive.value IS 'Representa o valor (ValueIsPercent = FALSE) ou o percentual (ValueIsPercent = TRUE) do desconto sobre os titulos de mensalidade emitidos.';


--
-- Name: COLUMN finincentive.supporterid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincentive.supporterid IS 'Codigo identificador da pessoa que sera o patrocinador do incentivo. So e preenchido se for um patrocinio.';


--
-- Name: COLUMN finincentive.agglutinate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincentive.agglutinate IS 'TRUE se o financiador recebera apenas um titulo com o valor total dos incentivos que financia ou FALSE se devera ser emitido um titulo para cada incentivo financiado.';


--
-- Name: COLUMN finincentive.costcenterid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincentive.costcenterid IS 'Codigo identificador do centro de custo ao qual o incentivo pertence.';


--
-- Name: COLUMN finincentive.cancellationdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincentive.cancellationdate IS 'Indica quando o incentivo foi cancelado (caso finalizado antes do previsto)';


--
-- Name: seq_incomeforecastid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_incomeforecastid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_incomeforecastid OWNER TO postgres;

--
-- Name: finincomeforecast; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finincomeforecast (
    incomeforecastid integer DEFAULT nextval('seq_incomeforecastid'::regclass) NOT NULL,
    contractid integer NOT NULL,
    operationid integer NOT NULL,
    accountschemeid character varying(30) NOT NULL,
    costcenterid character varying(30) NOT NULL,
    value numeric(14,4) NOT NULL,
    comments text,
    recorddate date DEFAULT date(now()),
    maturitydate date,
    isaccounted boolean DEFAULT false NOT NULL,
    isprocessed boolean DEFAULT false NOT NULL,
    isgenerated boolean DEFAULT false NOT NULL,
    incentiveid integer,
    issupressed boolean DEFAULT false NOT NULL,
    learningperiodid integer,
    invoiceid integer
)
INHERITS (baslog);


ALTER TABLE public.finincomeforecast OWNER TO postgres;

--
-- Name: TABLE finincomeforecast; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finincomeforecast IS 'contem as previsoes de lancamento necessarias para geracao automatica dos titulos de matriculas e processos cujo pagamento ocorre em mais de uma parcela.';


--
-- Name: COLUMN finincomeforecast.incomeforecastid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincomeforecast.incomeforecastid IS 'Codigo identificador da previsao de lancamento.';


--
-- Name: COLUMN finincomeforecast.contractid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincomeforecast.contractid IS 'Codigo identificador do contrato (pessoa) ao qual a previsao pertence.';


--
-- Name: COLUMN finincomeforecast.operationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincomeforecast.operationid IS 'Codigo identificador da operacao (finOperation)';


--
-- Name: COLUMN finincomeforecast.accountschemeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincomeforecast.accountschemeid IS 'Codigo identificador da conta contabil a qual a previsao pertence';


--
-- Name: COLUMN finincomeforecast.costcenterid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincomeforecast.costcenterid IS 'Codigo identificador do centro de custo ao qual a previsao pertence';


--
-- Name: COLUMN finincomeforecast.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincomeforecast.value IS 'Valor da previsao de lancamento';


--
-- Name: COLUMN finincomeforecast.comments; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincomeforecast.comments IS 'Informacao complementar da previsao de lancamento';


--
-- Name: COLUMN finincomeforecast.recorddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincomeforecast.recorddate IS 'Data da criacao da previsao';


--
-- Name: COLUMN finincomeforecast.maturitydate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincomeforecast.maturitydate IS 'Data em que a previsao devera se tornar titulo';


--
-- Name: COLUMN finincomeforecast.isaccounted; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincomeforecast.isaccounted IS 'TRUE (FALSE) indica que a previsao (nao) foi contabilizada.';


--
-- Name: COLUMN finincomeforecast.isprocessed; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincomeforecast.isprocessed IS 'TRUE (FALSE) indica que a previsao (nao) foi transformada em titulo.';


--
-- Name: COLUMN finincomeforecast.isgenerated; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincomeforecast.isgenerated IS 'TRUE gerado pelo sistema, FALSE gerado manual';


--
-- Name: COLUMN finincomeforecast.incentiveid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincomeforecast.incentiveid IS 'Campo indicando de qual incentivo foi gerado esta previsao';


--
-- Name: COLUMN finincomeforecast.issupressed; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincomeforecast.issupressed IS 'Marca se a previsao e suprimida (Tem que ser contabilizada mas nao e gerado lancamento desta)';


--
-- Name: COLUMN finincomeforecast.invoiceid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincomeforecast.invoiceid IS 'Relaciona a previsão de lancamento com o titulo gerado.';


--
-- Name: seq_incomesourceid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_incomesourceid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_incomesourceid OWNER TO postgres;

--
-- Name: finincomesource; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finincomesource (
    incomesourceid integer DEFAULT nextval('seq_incomesourceid'::regclass) NOT NULL,
    description text NOT NULL,
    isextinct boolean DEFAULT false NOT NULL,
    isagreement boolean DEFAULT false
)
INHERITS (baslog);


ALTER TABLE public.finincomesource OWNER TO postgres;

--
-- Name: TABLE finincomesource; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finincomesource IS 'origens de receita';


--
-- Name: COLUMN finincomesource.incomesourceid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincomesource.incomesourceid IS 'Codigo identificador da origem';


--
-- Name: COLUMN finincomesource.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincomesource.description IS 'Descricao da origem';


--
-- Name: COLUMN finincomesource.isextinct; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finincomesource.isextinct IS 'Define se a origem esta extinta ou nao';


--
-- Name: fininfotitulo; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE fininfotitulo (
    unidade character varying,
    curso character varying,
    turno character varying,
    periodo character varying,
    matricula integer,
    nome character varying,
    titulo integer NOT NULL,
    vencimento date,
    referencia date,
    cod_origem integer,
    origem text,
    valor_nominal numeric,
    valor_incentivos numeric,
    valor_descontos numeric,
    valor_pago numeric,
    valor_juros_multas numeric,
    valor_taxa numeric,
    inadimplencia numeric,
    envionaremessa text,
    periodo_letivo integer,
    contrato integer
)
INHERITS (baslog);


ALTER TABLE public.fininfotitulo OWNER TO postgres;

--
-- Name: seq_invoiceid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_invoiceid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_invoiceid OWNER TO postgres;

--
-- Name: fininvoice; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE fininvoice (
    invoiceid integer DEFAULT nextval('seq_invoiceid'::regclass) NOT NULL,
    personid bigint NOT NULL,
    accountschemeid character varying(30),
    costcenterid character varying(30) NOT NULL,
    parcelnumber integer NOT NULL,
    emissiondate date NOT NULL,
    maturitydate date NOT NULL,
    value numeric(14,4) NOT NULL,
    policyid integer,
    bankinvoiceid character varying(30),
    automaticdebit boolean DEFAULT false,
    comments text,
    incomesourceid integer,
    bankaccountid integer,
    sagu1invoiceid character varying(20),
    sectorid integer,
    emissiontypeid integer DEFAULT 4,
    iscanceled boolean DEFAULT false NOT NULL,
    reasoncancellationid integer,
    isimported boolean DEFAULT false,
    referencematuritydate date NOT NULL,
    invoiceiddependence integer,
    nominalvalue numeric,
    balance numeric DEFAULT 0,
    competencydate date
)
INHERITS (baslog);


ALTER TABLE public.fininvoice OWNER TO postgres;

--
-- Name: TABLE fininvoice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE fininvoice IS 'tabela principal dos titulos, contendo tanto titulos a pagar/pagos quanto titulos a receber/recebidos.';


--
-- Name: COLUMN fininvoice.invoiceid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoice.invoiceid IS 'Codigo identificador do titulo';


--
-- Name: COLUMN fininvoice.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoice.personid IS 'Codigo identificador da pessoa a qual o titulo pertence';


--
-- Name: COLUMN fininvoice.accountschemeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoice.accountschemeid IS 'Codigo identificador da conta contabil a qual o titulo pertence';


--
-- Name: COLUMN fininvoice.costcenterid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoice.costcenterid IS 'Codigo identificador do centro de custo ao qual o titulo pertence';


--
-- Name: COLUMN fininvoice.parcelnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoice.parcelnumber IS 'Codigo identificando qual parcela (do total de parcelas) este titulo representa';


--
-- Name: COLUMN fininvoice.emissiondate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoice.emissiondate IS 'Data de emissao do titulo';


--
-- Name: COLUMN fininvoice.maturitydate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoice.maturitydate IS 'Data de vencimento do titulo';


--
-- Name: COLUMN fininvoice.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoice.value IS 'Valor do titulo';


--
-- Name: COLUMN fininvoice.policyid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoice.policyid IS 'Codigo identificador da politica utilizada pelo titulo (finPolicy)';


--
-- Name: COLUMN fininvoice.bankinvoiceid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoice.bankinvoiceid IS 'Codigo fornecido pelo banco para identificacao do titulo';


--
-- Name: COLUMN fininvoice.automaticdebit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoice.automaticdebit IS 'TRUE (FALSE) indica que o titulo (nao) foi quitado via debito automatico em conta';


--
-- Name: COLUMN fininvoice.comments; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoice.comments IS 'Informacoes adicionais do titulo';


--
-- Name: COLUMN fininvoice.incomesourceid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoice.incomesourceid IS 'Origem de receitas';


--
-- Name: COLUMN fininvoice.bankaccountid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoice.bankaccountid IS 'Codigo da conta corrente (finBankAccount) que recebera o dinheiro deste pagamento';


--
-- Name: COLUMN fininvoice.sagu1invoiceid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoice.sagu1invoiceid IS 'Para nao perder a referencia a forma antiga de identificacao dos titulos (SAGU1)';


--
-- Name: COLUMN fininvoice.emissiontypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoice.emissiontypeid IS 'Codigo identificador da forma de emissão de boleto';


--
-- Name: COLUMN fininvoice.iscanceled; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoice.iscanceled IS 'Indica se um título foi cancelado ou nao.';


--
-- Name: COLUMN fininvoice.reasoncancellationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoice.reasoncancellationid IS 'Relaciona um motivo de cancelamento para o titulo.';


--
-- Name: COLUMN fininvoice.isimported; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoice.isimported IS 'Flag isImported. Necessario para a integração com o DOXA';


--
-- Name: COLUMN fininvoice.referencematuritydate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoice.referencematuritydate IS 'Data de vencimento de referência, para os casos em que o título seria gerado com uma data de vencimento que já passou. Ticket #7565. Salvo em casos onde a data de vencimento for diferente da data de vencimento de referência (títulos retroativos, por exemplo), este campo terá o mesmo valor do campo maturityDate.';


--
-- Name: COLUMN fininvoice.invoiceiddependence; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoice.invoiceiddependence IS 'Dependencia de títulos';


--
-- Name: COLUMN fininvoice.competencydate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoice.competencydate IS 'Recebe a mesma data de referência de vencimento, porém é inalterada.';


--
-- Name: fininvoicelog; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE fininvoicelog (
    month integer NOT NULL,
    year integer NOT NULL,
    generationdate date NOT NULL,
    generationtype character(1) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.fininvoicelog OWNER TO postgres;

--
-- Name: TABLE fininvoicelog; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE fininvoicelog IS 'log de titulos gerados pelo processo de geracao automatica de titulos';


--
-- Name: COLUMN fininvoicelog.month; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoicelog.month IS 'Mes de geracao';


--
-- Name: COLUMN fininvoicelog.year; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoicelog.year IS 'Ano de geracao';


--
-- Name: COLUMN fininvoicelog.generationdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoicelog.generationdate IS 'Data em que o processo de geracao de titulos foi disparado';


--
-- Name: COLUMN fininvoicelog.generationtype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoicelog.generationtype IS 'Indica qual o tipo de geracao do processo de titulos ';


--
-- Name: seq_invoicemessageid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_invoicemessageid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_invoicemessageid OWNER TO postgres;

--
-- Name: fininvoicemessage; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE fininvoicemessage (
    invoicemessagetypeid integer NOT NULL,
    bankid character varying(3) NOT NULL,
    description text NOT NULL,
    messageorder integer,
    invoicemessageid integer DEFAULT nextval('seq_invoicemessageid'::regclass) NOT NULL,
    invoicemessagebankvalue character varying(2),
    operationid integer
)
INHERITS (baslog);


ALTER TABLE public.fininvoicemessage OWNER TO postgres;

--
-- Name: TABLE fininvoicemessage; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE fininvoicemessage IS 'cadastro de mensagens que poderao compor os boletos bancarios, tais como "pagavel ate o dia x em qualquer agencia bancaria."';


--
-- Name: COLUMN fininvoicemessage.invoicemessagetypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoicemessage.invoicemessagetypeid IS 'Codigo identificador do tipo de mensagem financeira';


--
-- Name: COLUMN fininvoicemessage.bankid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoicemessage.bankid IS 'Código do banco';


--
-- Name: COLUMN fininvoicemessage.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoicemessage.description IS 'Descrição da mensagem financeira';


--
-- Name: COLUMN fininvoicemessage.messageorder; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoicemessage.messageorder IS 'É a ordem em que a mensagem será exibida';


--
-- Name: COLUMN fininvoicemessage.invoicemessagebankvalue; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoicemessage.invoicemessagebankvalue IS 'Referencia o código da instrução do banco com respectiva mensagem.';


--
-- Name: COLUMN fininvoicemessage.operationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoicemessage.operationid IS 'Indica a operação de origem que deve ser filtrada, para exibir esta mensagem apenas na geração de títulos com esta operação.';


--
-- Name: seq_invoicemessagetypeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_invoicemessagetypeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_invoicemessagetypeid OWNER TO postgres;

--
-- Name: fininvoicemessagetype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE fininvoicemessagetype (
    invoicemessagetypeid integer DEFAULT nextval('seq_invoicemessagetypeid'::regclass) NOT NULL,
    description character varying(20) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.fininvoicemessagetype OWNER TO postgres;

--
-- Name: TABLE fininvoicemessagetype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE fininvoicemessagetype IS 'Tipo de mensagens financeiras';


--
-- Name: COLUMN fininvoicemessagetype.invoicemessagetypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoicemessagetype.invoicemessagetypeid IS 'Codigo identificador do tipo de mensagem financeira';


--
-- Name: COLUMN fininvoicemessagetype.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoicemessagetype.description IS 'Descrição do tipo de mensagem financeira';


--
-- Name: fininvoicespecie; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE fininvoicespecie (
    invoicespecieid character varying(3) NOT NULL,
    description character varying
)
INHERITS (baslog);


ALTER TABLE public.fininvoicespecie OWNER TO postgres;

--
-- Name: fininvoicetype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE fininvoicetype (
    invoicetypeid integer NOT NULL,
    description character varying(255)
)
INHERITS (baslog);


ALTER TABLE public.fininvoicetype OWNER TO postgres;

--
-- Name: COLUMN fininvoicetype.invoicetypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoicetype.invoicetypeid IS 'Chave primaria finInvoiceTypeId';


--
-- Name: COLUMN fininvoicetype.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN fininvoicetype.description IS 'Descricao do tipo de boleto';


--
-- Name: fininvoicetype_invoicetypeid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE fininvoicetype_invoicetypeid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.fininvoicetype_invoicetypeid_seq OWNER TO postgres;

--
-- Name: fininvoicetype_invoicetypeid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE fininvoicetype_invoicetypeid_seq OWNED BY fininvoicetype.invoicetypeid;


--
-- Name: finloan; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finloan (
    accountschemeid character varying(30) NOT NULL,
    loanerid integer,
    rotative boolean DEFAULT false NOT NULL,
    groupinvoicesvalues boolean DEFAULT false NOT NULL,
    collectionoperationid integer NOT NULL
)
INHERITS (finincentivetype);


ALTER TABLE public.finloan OWNER TO postgres;

--
-- Name: TABLE finloan; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finloan IS 'incentivo do tipo financiamento. herda a finincentivetype';


--
-- Name: COLUMN finloan.accountschemeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finloan.accountschemeid IS 'Codigo identificador da conta a contabil qual o fincanciamento pertence';


--
-- Name: COLUMN finloan.loanerid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finloan.loanerid IS 'Codigo identificador da pessoa financiadora do incentivo.';


--
-- Name: COLUMN finloan.rotative; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finloan.rotative IS 'TRUE se o valor patrocinado ao aluno devera ser pago por ele proprio no futuro. Caso contrario, FALSE.';


--
-- Name: COLUMN finloan.groupinvoicesvalues; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finloan.groupinvoicesvalues IS 'TRUE se os valores devem ser agrupados em um unico titulo (caso do PROCRES, por exemplo) ou se devem ser gerados varios titulos (caso do PCR).';


--
-- Name: COLUMN finloan.collectionoperationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finloan.collectionoperationid IS 'Codigo identificador da operacao (finOperation) de cobranca';


--
-- Name: finmovimentacaocheque; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finmovimentacaocheque (
    movimentacaochequeid integer NOT NULL,
    chequeid integer NOT NULL,
    statuschequeid integer NOT NULL,
    data date NOT NULL,
    observacao text,
    valor double precision,
    foiexcluido boolean DEFAULT false
)
INHERITS (baslog);


ALTER TABLE public.finmovimentacaocheque OWNER TO postgres;

--
-- Name: finmovimentacaocheque_movimentacaochequeid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE finmovimentacaocheque_movimentacaochequeid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.finmovimentacaocheque_movimentacaochequeid_seq OWNER TO postgres;

--
-- Name: finmovimentacaocheque_movimentacaochequeid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE finmovimentacaocheque_movimentacaochequeid_seq OWNED BY finmovimentacaocheque.movimentacaochequeid;


--
-- Name: seq_occurrenceoperationid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_occurrenceoperationid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_occurrenceoperationid OWNER TO postgres;

--
-- Name: finoccurrenceoperation; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finoccurrenceoperation (
    occurrenceoperationid integer DEFAULT nextval('seq_occurrenceoperationid'::regclass) NOT NULL,
    occurrenceid character(2) NOT NULL,
    bankaccountid integer NOT NULL,
    operationid integer NOT NULL,
    levelsequenceid integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.finoccurrenceoperation OWNER TO postgres;

--
-- Name: TABLE finoccurrenceoperation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finoccurrenceoperation IS 'identifica uma operacao para um determinada ocorrencia, utilizado no arquivo de retorno bancario.';


--
-- Name: COLUMN finoccurrenceoperation.occurrenceoperationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finoccurrenceoperation.occurrenceoperationid IS 'Codigo identificador da ocorrencia de operacao';


--
-- Name: COLUMN finoccurrenceoperation.occurrenceid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finoccurrenceoperation.occurrenceid IS 'Codigo da ocorrencia, este dado e padrao bancario (FEBRABAN)';


--
-- Name: COLUMN finoccurrenceoperation.bankaccountid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finoccurrenceoperation.bankaccountid IS 'Codigo do conta bancaria (finBankAccount)';


--
-- Name: COLUMN finoccurrenceoperation.operationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finoccurrenceoperation.operationid IS 'Codigo identificador da operacao (finOperation)';


--
-- Name: COLUMN finoccurrenceoperation.levelsequenceid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finoccurrenceoperation.levelsequenceid IS 'Valor do nivel da sequancia, utilizado para adquirir uma determinada operacao.';


--
-- Name: finopencounter; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finopencounter (
    opencounterid integer NOT NULL,
    operatorid integer NOT NULL,
    counterid integer NOT NULL,
    value numeric(14,2) DEFAULT 0,
    operation character(1),
    date timestamp without time zone DEFAULT now() NOT NULL,
    observation text,
    maxbalance real
)
INHERITS (baslog);


ALTER TABLE public.finopencounter OWNER TO postgres;

--
-- Name: TABLE finopencounter; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finopencounter IS 'Tabela responsábel por armazenar a abertura de caixa';


--
-- Name: COLUMN finopencounter.opencounterid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finopencounter.opencounterid IS 'Código da abertura de caixa';


--
-- Name: COLUMN finopencounter.operatorid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finopencounter.operatorid IS 'Código do funcionário operador de caixa';


--
-- Name: COLUMN finopencounter.counterid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finopencounter.counterid IS 'Código do caixa que está sendo aberto';


--
-- Name: COLUMN finopencounter.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finopencounter.value IS 'Valor em caixa na abertura';


--
-- Name: COLUMN finopencounter.operation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finopencounter.operation IS 'Natureza do valor, débito ou crédito';


--
-- Name: COLUMN finopencounter.date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finopencounter.date IS 'Data de abertura do caixa';


--
-- Name: COLUMN finopencounter.observation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finopencounter.observation IS 'Observação da abertura';


--
-- Name: finopencounter_opencounterid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE finopencounter_opencounterid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.finopencounter_opencounterid_seq OWNER TO postgres;

--
-- Name: finopencounter_opencounterid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE finopencounter_opencounterid_seq OWNED BY finopencounter.opencounterid;


--
-- Name: seq_operationid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_operationid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_operationid OWNER TO postgres;

--
-- Name: finoperation; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finoperation (
    operationid integer DEFAULT nextval('seq_operationid'::regclass) NOT NULL,
    description text NOT NULL,
    operationtypeid character(1) NOT NULL,
    isextinct boolean DEFAULT false NOT NULL,
    iscountermovement boolean DEFAULT false NOT NULL,
    operationgroupid character(1) NOT NULL,
    receivableorpayable character(1) DEFAULT 'R'::bpchar NOT NULL,
    accountschemeid character varying(30),
    useindiscounts boolean DEFAULT true NOT NULL,
    useininterests boolean DEFAULT true NOT NULL,
    useinfines boolean DEFAULT true NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.finoperation OWNER TO postgres;

--
-- Name: TABLE finoperation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finoperation IS 'operacoes. identificam a natureza de um lanã§amento ou previsã£o (dã©bito ou crã©dito)';


--
-- Name: COLUMN finoperation.operationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finoperation.operationid IS 'Codigo identificador da operacao';


--
-- Name: COLUMN finoperation.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finoperation.description IS 'Texto descrevendo a operacao';


--
-- Name: COLUMN finoperation.operationtypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finoperation.operationtypeid IS 'Debito (D) ou credito (C)';


--
-- Name: COLUMN finoperation.isextinct; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finoperation.isextinct IS 'Define se uma operacao esta extinta ou nao';


--
-- Name: COLUMN finoperation.iscountermovement; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finoperation.iscountermovement IS 'Se essa operacao tera ou nao movimentacao de caixa';


--
-- Name: COLUMN finoperation.operationgroupid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finoperation.operationgroupid IS 'Codigo identificador do grupo da operacao';


--
-- Name: COLUMN finoperation.useindiscounts; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finoperation.useindiscounts IS 'Indica se a operação é utilizada em descontos';


--
-- Name: COLUMN finoperation.useininterests; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finoperation.useininterests IS 'Indica se a operação é utilizada em juros';


--
-- Name: COLUMN finoperation.useinfines; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finoperation.useinfines IS 'Indica se a operação é utilizada em multas';


--
-- Name: finoperationgroup; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finoperationgroup (
    operationgroupid character(1) NOT NULL,
    description text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.finoperationgroup OWNER TO postgres;

--
-- Name: TABLE finoperationgroup; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finoperationgroup IS 'defino o grupo de operacao (pagamento, incentivo, juros, descontos, normal)';


--
-- Name: COLUMN finoperationgroup.operationgroupid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finoperationgroup.operationgroupid IS 'Codigo identificador da grupo da operacao';


--
-- Name: COLUMN finoperationgroup.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finoperationgroup.description IS 'Texto descrevendo o grupo da operacao';


--
-- Name: finpayableinvoice; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finpayableinvoice (
    receivedate date,
    description text NOT NULL,
    documentnumber character varying(255) NOT NULL,
    statusid character(1) NOT NULL
)
INHERITS (fininvoice);


ALTER TABLE public.finpayableinvoice OWNER TO postgres;

--
-- Name: TABLE finpayableinvoice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finpayableinvoice IS 'contem as informacoes adicionais a tabela fininvoice sobre titulos a pagar ou ja pagos';


--
-- Name: COLUMN finpayableinvoice.receivedate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpayableinvoice.receivedate IS 'Data em que o titulo foi recebido pela instituicao para que a mesma efetuasse seu pagamento.';


--
-- Name: COLUMN finpayableinvoice.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpayableinvoice.description IS 'Pequeno texto para identificar a conta';


--
-- Name: COLUMN finpayableinvoice.documentnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpayableinvoice.documentnumber IS 'Número do documento físico da conta (NF, Fatura, RPA, etc.)';


--
-- Name: COLUMN finpayableinvoice.statusid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpayableinvoice.statusid IS 'Campo somente leitura. Se data de vencimento já passou, status é VENCIDA, senão é A VENCER. Se já foi paga, status é PAGA.';


--
-- Name: finpayableinvoicestatus; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finpayableinvoicestatus (
    status character(1) NOT NULL,
    description character varying(100) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.finpayableinvoicestatus OWNER TO postgres;

--
-- Name: TABLE finpayableinvoicestatus; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finpayableinvoicestatus IS 'Estados que um título poderá ter';


--
-- Name: COLUMN finpayableinvoicestatus.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpayableinvoicestatus.status IS 'Estado do título';


--
-- Name: COLUMN finpayableinvoicestatus.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpayableinvoicestatus.description IS 'Descrição do estado';


--
-- Name: finpayrolldiscounttarget; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finpayrolldiscounttarget (
    ispayrolldiscount boolean DEFAULT true NOT NULL,
    employeeid integer NOT NULL
)
INHERITS (fininvoicetarget);


ALTER TABLE public.finpayrolldiscounttarget OWNER TO postgres;

--
-- Name: TABLE finpayrolldiscounttarget; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finpayrolldiscounttarget IS 'debito em folha de pagamento (de funcionarios) a nivel de contrato. ';


--
-- Name: COLUMN finpayrolldiscounttarget.ispayrolldiscount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpayrolldiscounttarget.ispayrolldiscount IS 'Define se o pagamento é descontado em folha ou nao';


--
-- Name: COLUMN finpayrolldiscounttarget.employeeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpayrolldiscounttarget.employeeid IS 'Se tiver um codigo de funcionario (personid) neste campo, quer dizer que o dono deste contrato quer que sua mensalidade seja descontada na folha de pagamento deste funcionario. Se nao tiver nenhuma informacao neste campo o desconto sera feito na folha do titular do contrato.';


--
-- Name: finpersoninformation; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finpersoninformation (
    personid bigint NOT NULL,
    information text
)
INHERITS (baslog);


ALTER TABLE public.finpersoninformation OWNER TO postgres;

--
-- Name: TABLE finpersoninformation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finpersoninformation IS 'informacao financeira de pessoas fisicas e juridicas. (antigo campo obs da tabela pessoas do sagu1)';


--
-- Name: COLUMN finpersoninformation.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpersoninformation.personid IS 'Codigo identificador da pessoa as quais as informacoes pertencem';


--
-- Name: COLUMN finpersoninformation.information; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpersoninformation.information IS 'Informacao da pessoa';


--
-- Name: finphysicaltarget; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finphysicaltarget (
    cityid integer NOT NULL,
    zipcode character varying(9) NOT NULL,
    location character varying(100) NOT NULL,
    complement character varying(40),
    number character varying(10),
    neighborhood text,
    name character varying(100) NOT NULL,
    documentnumber character varying(11)
)
INHERITS (fininvoicetarget);


ALTER TABLE public.finphysicaltarget OWNER TO postgres;

--
-- Name: TABLE finphysicaltarget; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finphysicaltarget IS 'endereco de cobranca. herda a fininvoicetarget';


--
-- Name: COLUMN finphysicaltarget.cityid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finphysicaltarget.cityid IS 'Codigo identificador da cidade para cobranca';


--
-- Name: COLUMN finphysicaltarget.zipcode; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finphysicaltarget.zipcode IS 'CEP do endereco de cobranca';


--
-- Name: COLUMN finphysicaltarget.location; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finphysicaltarget.location IS 'Logradouro';


--
-- Name: COLUMN finphysicaltarget.complement; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finphysicaltarget.complement IS 'Complemento';


--
-- Name: COLUMN finphysicaltarget.number; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finphysicaltarget.number IS 'Numero';


--
-- Name: COLUMN finphysicaltarget.neighborhood; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finphysicaltarget.neighborhood IS 'Bairro';


--
-- Name: COLUMN finphysicaltarget.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finphysicaltarget.name IS 'Nome da pessoa que deve aparecer no boleto';


--
-- Name: COLUMN finphysicaltarget.documentnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finphysicaltarget.documentnumber IS 'Cpf do nome';


--
-- Name: seq_policyid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_policyid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_policyid OWNER TO postgres;

--
-- Name: finpolicy; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finpolicy (
    policyid integer DEFAULT nextval('seq_policyid'::regclass) NOT NULL,
    description text NOT NULL,
    operationid integer NOT NULL,
    collectiontypeid integer NOT NULL,
    monthlyinterestpercent double precision NOT NULL,
    finepercent double precision NOT NULL,
    daystointerest integer NOT NULL,
    daystofine integer NOT NULL,
    daystoprotest integer NOT NULL,
    banktaxvalue numeric(14,4) NOT NULL,
    isextinct boolean DEFAULT false NOT NULL,
    interesttype character(1) DEFAULT 'S'::bpchar,
    applyinterest boolean DEFAULT false,
    applyfine boolean DEFAULT false,
    emissiontypeid integer
)
INHERITS (baslog);


ALTER TABLE public.finpolicy OWNER TO postgres;

--
-- Name: TABLE finpolicy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finpolicy IS 'politicas., regras de negocio do financeiro. antiga tabela origens (sagu1).';


--
-- Name: COLUMN finpolicy.policyid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpolicy.policyid IS 'Codigo identificador da politica';


--
-- Name: COLUMN finpolicy.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpolicy.description IS 'Descricao da politica';


--
-- Name: COLUMN finpolicy.operationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpolicy.operationid IS 'Codigo identificador da operacao padrao para matriculas de cursos que seguem esta politica';


--
-- Name: COLUMN finpolicy.collectiontypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpolicy.collectiontypeid IS 'Codigo identificador do tipo de cobranca (finCollectionType)';


--
-- Name: COLUMN finpolicy.monthlyinterestpercent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpolicy.monthlyinterestpercent IS 'Percentual de juros a serem cobrados no mes';


--
-- Name: COLUMN finpolicy.finepercent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpolicy.finepercent IS 'Percentual cobrado em caso de multa';


--
-- Name: COLUMN finpolicy.daystointerest; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpolicy.daystointerest IS 'A partir de quantos dias sera cobrado juro';


--
-- Name: COLUMN finpolicy.daystofine; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpolicy.daystofine IS 'A partir de quantos dias sera cobrada multa';


--
-- Name: COLUMN finpolicy.daystoprotest; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpolicy.daystoprotest IS 'A partir de quantos dias sera protestado o titulo';


--
-- Name: COLUMN finpolicy.banktaxvalue; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpolicy.banktaxvalue IS 'Valor da taxa bancaria';


--
-- Name: COLUMN finpolicy.isextinct; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpolicy.isextinct IS 'Define se a politica esta ou nao ativa';


--
-- Name: COLUMN finpolicy.interesttype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpolicy.interesttype IS 'Tipo de juros "S: Simples", "C: Composto"';


--
-- Name: COLUMN finpolicy.applyinterest; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpolicy.applyinterest IS 'Aplicar regras dos juros mensais para esta política?';


--
-- Name: COLUMN finpolicy.applyfine; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpolicy.applyfine IS 'Aplicar regras de multas para esta política?';


--
-- Name: COLUMN finpolicy.emissiontypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpolicy.emissiontypeid IS 'Codigo identificador da forma de emissão de boleto';


--
-- Name: finpolicydiscount; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finpolicydiscount (
    discountid integer NOT NULL,
    policyid integer NOT NULL,
    daystodiscount integer NOT NULL,
    beforeafter character(1) NOT NULL,
    discountvalue double precision NOT NULL,
    ispercent boolean DEFAULT true NOT NULL,
    beginclassperiod integer,
    endclassperiod integer,
    parcelnumber integer,
    CONSTRAINT chk_insert_policy_discount CHECK (chk_insert_policy_discount(ispercent, discountvalue, beginclassperiod, endclassperiod))
)
INHERITS (baslog);


ALTER TABLE public.finpolicydiscount OWNER TO postgres;

--
-- Name: TABLE finpolicydiscount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finpolicydiscount IS 'Descontos progressivos';


--
-- Name: COLUMN finpolicydiscount.discountid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpolicydiscount.discountid IS 'Codigo do centro';


--
-- Name: COLUMN finpolicydiscount.policyid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpolicydiscount.policyid IS 'Codigo da politica a qual o desconto se refere';


--
-- Name: COLUMN finpolicydiscount.daystodiscount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpolicydiscount.daystodiscount IS 'Limite de dias antes ou depois do vencimento que o desconto e aplicado';


--
-- Name: COLUMN finpolicydiscount.beforeafter; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpolicydiscount.beforeafter IS 'Define se o numero de dias e antes (B) ou depois (A) do vencimento';


--
-- Name: COLUMN finpolicydiscount.discountvalue; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpolicydiscount.discountvalue IS 'Valor do desconto';


--
-- Name: COLUMN finpolicydiscount.ispercent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpolicydiscount.ispercent IS 'Define se o valor do desconto e percentual sobre o valor do titulo (true) ou fixo (false)';


--
-- Name: COLUMN finpolicydiscount.beginclassperiod; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpolicydiscount.beginclassperiod IS 'Periodo inicial do curso para aplicação do desconto';


--
-- Name: COLUMN finpolicydiscount.endclassperiod; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpolicydiscount.endclassperiod IS 'Periodo final do curso para aplicação do desconto';


--
-- Name: COLUMN finpolicydiscount.parcelnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finpolicydiscount.parcelnumber IS 'Parcela para a qual aplicar o desconto';


--
-- Name: finpolicydiscount_discountid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE finpolicydiscount_discountid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.finpolicydiscount_discountid_seq OWNER TO postgres;

--
-- Name: finpolicydiscount_discountid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE finpolicydiscount_discountid_seq OWNED BY finpolicydiscount.discountid;


--
-- Name: finprice; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finprice (
    startdate date NOT NULL,
    enddate date NOT NULL,
    value numeric(14,4) NOT NULL,
    valueisfixed boolean DEFAULT false NOT NULL,
    referencenumberhours double precision,
    firstparcelatsight boolean DEFAULT false NOT NULL,
    courseid character varying(10) NOT NULL,
    courseversion integer NOT NULL,
    turnid integer NOT NULL,
    unitid integer NOT NULL,
    bankaccountid integer NOT NULL,
    fixedvalue numeric,
    applychangesonfirstparcel boolean,
    parcelsnumber integer,
    maturityday integer,
    firstparcelatsightfreshman boolean DEFAULT false NOT NULL,
    valorcreditoferias double precision,
    parceltype character(1) DEFAULT 'C'::bpchar
)
INHERITS (baslog);


ALTER TABLE public.finprice OWNER TO postgres;

--
-- Name: TABLE finprice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finprice IS 'Armazena o valor de determinado curso durante um período especificado.';


--
-- Name: COLUMN finprice.startdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finprice.startdate IS 'Data de inicio';


--
-- Name: COLUMN finprice.enddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finprice.enddate IS 'Data final';


--
-- Name: COLUMN finprice.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finprice.value IS 'Preco do curso';


--
-- Name: COLUMN finprice.valueisfixed; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finprice.valueisfixed IS 'Indica se o valor declarado no preço é fixo ou deverá ser multiplicado pela quantidade de créditos na acdEnrollSummary.';


--
-- Name: COLUMN finprice.referencenumberhours; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finprice.referencenumberhours IS 'Carga horária de referência para cálculo de mensalidade de aluno que possui mais ou menos horas matriculadas do que o esperado para o período';


--
-- Name: COLUMN finprice.firstparcelatsight; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finprice.firstparcelatsight IS 'Indica se a primeira parcela será à vista ou não para veteranos.';


--
-- Name: COLUMN finprice.courseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finprice.courseid IS 'Curso da ocorrência.';


--
-- Name: COLUMN finprice.courseversion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finprice.courseversion IS 'Versão de curso da ocorrência.';


--
-- Name: COLUMN finprice.turnid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finprice.turnid IS 'Turno da ocorrência de curso.';


--
-- Name: COLUMN finprice.unitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finprice.unitid IS 'Unidade da ocorrência de curso.';


--
-- Name: COLUMN finprice.bankaccountid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finprice.bankaccountid IS 'Conta bancária que receberá os pagamentos';


--
-- Name: COLUMN finprice.firstparcelatsightfreshman; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finprice.firstparcelatsightfreshman IS 'Indica se a primeira parcela será a vista ou não para calouros.';


--
-- Name: finpricepolicy; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finpricepolicy (
    pricepolicyid integer NOT NULL,
    startdate date NOT NULL,
    courseid character varying(10) NOT NULL,
    courseversion integer NOT NULL,
    turnid integer NOT NULL,
    unitid integer NOT NULL,
    policyid integer NOT NULL,
    parcelnumber integer,
    semester integer
)
INHERITS (baslog);


ALTER TABLE public.finpricepolicy OWNER TO postgres;

--
-- Name: finpricepolicy_pricepolicyid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE finpricepolicy_pricepolicyid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.finpricepolicy_pricepolicyid_seq OWNER TO postgres;

--
-- Name: finpricepolicy_pricepolicyid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE finpricepolicy_pricepolicyid_seq OWNED BY finpricepolicy.pricepolicyid;


--
-- Name: finreasoncancellation; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finreasoncancellation (
    reasoncancellationid integer NOT NULL,
    description text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.finreasoncancellation OWNER TO postgres;

--
-- Name: TABLE finreasoncancellation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finreasoncancellation IS 'Tabela responsável por armazenar os motivos de cancelamento';


--
-- Name: COLUMN finreasoncancellation.reasoncancellationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finreasoncancellation.reasoncancellationid IS 'Código identificador da tabela finreasoncancellation';


--
-- Name: COLUMN finreasoncancellation.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finreasoncancellation.description IS 'Descricao do motivo de cancelamento';


--
-- Name: finreasoncancellation_reasoncancellationid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE finreasoncancellation_reasoncancellationid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.finreasoncancellation_reasoncancellationid_seq OWNER TO postgres;

--
-- Name: finreasoncancellation_reasoncancellationid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE finreasoncancellation_reasoncancellationid_seq OWNED BY finreasoncancellation.reasoncancellationid;


--
-- Name: finreceivableinvoice; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finreceivableinvoice (
    balance numeric DEFAULT 0,
    senddate date,
    returndate date,
    returnfileid integer,
    sem_descontos boolean DEFAULT false
)
INHERITS (fininvoice);


ALTER TABLE public.finreceivableinvoice OWNER TO postgres;

--
-- Name: TABLE finreceivableinvoice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finreceivableinvoice IS 'contem as informacoes adicionais a tabela fininvoice sobre titulos a receber ou ja recebidos.';


--
-- Name: COLUMN finreceivableinvoice.senddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finreceivableinvoice.senddate IS 'Data em que o titulo foi enviado para o banco';


--
-- Name: COLUMN finreceivableinvoice.returndate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finreceivableinvoice.returndate IS 'Data em que o titulo retornou do banco';


--
-- Name: COLUMN finreceivableinvoice.returnfileid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finreceivableinvoice.returnfileid IS 'Arquivo de retorno do banco';


--
-- Name: seq_receivableinvoicecommunicationid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_receivableinvoicecommunicationid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_receivableinvoicecommunicationid OWNER TO postgres;

--
-- Name: finreceivableinvoicecommunication; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finreceivableinvoicecommunication (
    receivableinvoicecommunicationid integer DEFAULT nextval('seq_receivableinvoicecommunicationid'::regclass) NOT NULL,
    invoiceid integer,
    fileid integer,
    commdate date
)
INHERITS (baslog);


ALTER TABLE public.finreceivableinvoicecommunication OWNER TO postgres;

--
-- Name: TABLE finreceivableinvoicecommunication; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finreceivableinvoicecommunication IS 'informaã§ãµes sobre comunicaã§ã£o de arquivos com bancos.';


--
-- Name: COLUMN finreceivableinvoicecommunication.receivableinvoicecommunicationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finreceivableinvoicecommunication.receivableinvoicecommunicationid IS 'Chave primaria da classe';


--
-- Name: COLUMN finreceivableinvoicecommunication.invoiceid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finreceivableinvoicecommunication.invoiceid IS 'Codigo do titulo referente a comunicacao';


--
-- Name: COLUMN finreceivableinvoicecommunication.fileid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finreceivableinvoicecommunication.fileid IS 'Codigo do arquivo ao qual foi efetuada a comunicacao';


--
-- Name: COLUMN finreceivableinvoicecommunication.commdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finreceivableinvoicecommunication.commdate IS 'Data da comunicacao do arquivo';


--
-- Name: finreemissaodetituloslog; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finreemissaodetituloslog (
    reemissaodetituloslogid integer NOT NULL,
    newinvoiceid integer,
    oldinvoiceid integer
)
INHERITS (baslog);


ALTER TABLE public.finreemissaodetituloslog OWNER TO postgres;

--
-- Name: finreemissaodetituloslog_reemissaodetituloslogid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE finreemissaodetituloslog_reemissaodetituloslogid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.finreemissaodetituloslog_reemissaodetituloslogid_seq OWNER TO postgres;

--
-- Name: finreemissaodetituloslog_reemissaodetituloslogid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE finreemissaodetituloslog_reemissaodetituloslogid_seq OWNED BY finreemissaodetituloslog.reemissaodetituloslogid;


--
-- Name: finrelease; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finrelease (
    releaseid integer NOT NULL,
    invoiceid integer NOT NULL,
    releaseinterest boolean DEFAULT true NOT NULL,
    applyconvenant boolean DEFAULT false NOT NULL,
    discountvalue double precision,
    ispercent boolean DEFAULT true NOT NULL,
    operationid integer,
    begindate date,
    enddate date
)
INHERITS (baslog);


ALTER TABLE public.finrelease OWNER TO postgres;

--
-- Name: TABLE finrelease; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finrelease IS 'Tabela para liberação de juros e multas.';


--
-- Name: COLUMN finrelease.releaseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finrelease.releaseid IS 'Chave primária da tabela finRelease.';


--
-- Name: COLUMN finrelease.invoiceid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finrelease.invoiceid IS 'Código do título.';


--
-- Name: COLUMN finrelease.releaseinterest; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finrelease.releaseinterest IS 'Liberar juros e multas.';


--
-- Name: COLUMN finrelease.applyconvenant; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finrelease.applyconvenant IS 'Conceder convênios.';


--
-- Name: COLUMN finrelease.discountvalue; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finrelease.discountvalue IS 'Valor de desconto.';


--
-- Name: COLUMN finrelease.ispercent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finrelease.ispercent IS 'Referente ao valor se é percentual ou nao.';


--
-- Name: COLUMN finrelease.operationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finrelease.operationid IS 'Indica a operação para o lançamento de desconto.';


--
-- Name: COLUMN finrelease.begindate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finrelease.begindate IS 'Data incial do período de liberação.';


--
-- Name: COLUMN finrelease.enddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finrelease.enddate IS 'Data final do período de liberação.';


--
-- Name: finrelease_releaseid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE finrelease_releaseid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.finrelease_releaseid_seq OWNER TO postgres;

--
-- Name: finrelease_releaseid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE finrelease_releaseid_seq OWNED BY finrelease.releaseid;


--
-- Name: finspc; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finspc (
    personid bigint NOT NULL,
    entrydate date NOT NULL,
    removaldate date
)
INHERITS (baslog);


ALTER TABLE public.finspc OWNER TO postgres;

--
-- Name: TABLE finspc; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finspc IS 'Tabela responsábel por armazenar os usuários que estão com um débito em aberto e cadastradas no SPC';


--
-- Name: COLUMN finspc.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finspc.personid IS 'Código da pessoa que está no SPC';


--
-- Name: COLUMN finspc.entrydate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finspc.entrydate IS 'Data em que a pessoa entrou no SPC';


--
-- Name: COLUMN finspc.removaldate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finspc.removaldate IS 'Data em que a pessoa saiu do SPC';


--
-- Name: finspcmovement; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finspcmovement (
    movementid integer NOT NULL,
    date date NOT NULL,
    reasonid integer NOT NULL,
    personid bigint NOT NULL,
    entrydate date NOT NULL,
    observation text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.finspcmovement OWNER TO postgres;

--
-- Name: TABLE finspcmovement; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finspcmovement IS 'Tabela responsábel por armazenar as movimentações dos usuários que possuem débito e estão no SPC';


--
-- Name: COLUMN finspcmovement.movementid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finspcmovement.movementid IS 'Código identificador da tabela finSPCMovement';


--
-- Name: COLUMN finspcmovement.date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finspcmovement.date IS 'Data e hora em que uma pessoa foi inserida na tabela de movimentação';


--
-- Name: COLUMN finspcmovement.reasonid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finspcmovement.reasonid IS 'Código identificador do razão em que se encontra no SPC';


--
-- Name: COLUMN finspcmovement.observation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finspcmovement.observation IS 'Campo texto onde é possível inserir observações';


--
-- Name: finspcmovement_movementid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE finspcmovement_movementid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.finspcmovement_movementid_seq OWNER TO postgres;

--
-- Name: finspcmovement_movementid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE finspcmovement_movementid_seq OWNED BY finspcmovement.movementid;


--
-- Name: finspcreason; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finspcreason (
    reasonid integer NOT NULL,
    description text
)
INHERITS (baslog);


ALTER TABLE public.finspcreason OWNER TO postgres;

--
-- Name: TABLE finspcreason; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finspcreason IS 'Tabela responsábel por armazenar os tipos de situação referente ao SPC';


--
-- Name: COLUMN finspcreason.reasonid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finspcreason.reasonid IS 'Código identificador do status no SPC';


--
-- Name: COLUMN finspcreason.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finspcreason.description IS 'Descrição do status no SPC';


--
-- Name: finspcreason_reasonid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE finspcreason_reasonid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.finspcreason_reasonid_seq OWNER TO postgres;

--
-- Name: finspcreason_reasonid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE finspcreason_reasonid_seq OWNED BY finspcreason.reasonid;


--
-- Name: seq_speciesid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_speciesid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_speciesid OWNER TO postgres;

--
-- Name: finspecies; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finspecies (
    speciesid integer DEFAULT nextval('seq_speciesid'::regclass) NOT NULL,
    description text NOT NULL,
    speciestypeid integer,
    bandeira character varying(20),
    modalidade character(1),
    numparcelas integer DEFAULT 1,
    isenabled boolean DEFAULT true NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.finspecies OWNER TO postgres;

--
-- Name: TABLE finspecies; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finspecies IS 'especies monetarias ex. cheque, dinheiro';


--
-- Name: COLUMN finspecies.speciesid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finspecies.speciesid IS 'Codigo identificador da especie';


--
-- Name: COLUMN finspecies.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finspecies.description IS 'Descricao da especie';


--
-- Name: finspeciestype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finspeciestype (
    speciestypeid integer NOT NULL,
    description character varying NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.finspeciestype OWNER TO postgres;

--
-- Name: finspeciestype_speciestypeid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE finspeciestype_speciestypeid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.finspeciestype_speciestypeid_seq OWNER TO postgres;

--
-- Name: finspeciestype_speciestypeid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE finspeciestype_speciestypeid_seq OWNED BY finspeciestype.speciestypeid;


--
-- Name: finstatuscheque; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finstatuscheque (
    statuschequeid integer NOT NULL,
    considerapago boolean DEFAULT false,
    descricao character varying NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.finstatuscheque OWNER TO postgres;

--
-- Name: finstatuscheque_statuschequeid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE finstatuscheque_statuschequeid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.finstatuscheque_statuschequeid_seq OWNER TO postgres;

--
-- Name: finstatuscheque_statuschequeid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE finstatuscheque_statuschequeid_seq OWNED BY finstatuscheque.statuschequeid;


--
-- Name: finstatusdotitulo; Type: TABLE; Schema: public; Owner: solis; Tablespace: 
--

CREATE TABLE finstatusdotitulo (
    statusdotituloid integer NOT NULL,
    description character varying(255)
)
INHERITS (baslog);


ALTER TABLE public.finstatusdotitulo OWNER TO solis;

--
-- Name: finstatusdotitulo_statusdotituloid_seq; Type: SEQUENCE; Schema: public; Owner: solis
--

CREATE SEQUENCE finstatusdotitulo_statusdotituloid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.finstatusdotitulo_statusdotituloid_seq OWNER TO solis;

--
-- Name: finstatusdotitulo_statusdotituloid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: solis
--

ALTER SEQUENCE finstatusdotitulo_statusdotituloid_seq OWNED BY finstatusdotitulo.statusdotituloid;


--
-- Name: finstatusdotitulolog; Type: TABLE; Schema: public; Owner: solis; Tablespace: 
--

CREATE TABLE finstatusdotitulolog (
    statusdotitulologid integer NOT NULL,
    invoiceid integer,
    statusdotituloid integer,
    data timestamp without time zone DEFAULT now()
)
INHERITS (baslog);


ALTER TABLE public.finstatusdotitulolog OWNER TO solis;

--
-- Name: finstatusdotitulolog_statusdotitulologid_seq; Type: SEQUENCE; Schema: public; Owner: solis
--

CREATE SEQUENCE finstatusdotitulolog_statusdotitulologid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.finstatusdotitulolog_statusdotitulologid_seq OWNER TO solis;

--
-- Name: finstatusdotitulolog_statusdotitulologid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: solis
--

ALTER SEQUENCE finstatusdotitulolog_statusdotitulologid_seq OWNED BY finstatusdotitulolog.statusdotitulologid;


--
-- Name: seq_studentfinancingid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_studentfinancingid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_studentfinancingid OWNER TO postgres;

--
-- Name: finstudentfinancing; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finstudentfinancing (
    studentfinancingid integer DEFAULT nextval('seq_studentfinancingid'::regclass) NOT NULL,
    contractid integer NOT NULL,
    initialvalue numeric(14,4) NOT NULL,
    currentvalue numeric(14,4) NOT NULL,
    comments text
)
INHERITS (baslog);


ALTER TABLE public.finstudentfinancing OWNER TO postgres;

--
-- Name: TABLE finstudentfinancing; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finstudentfinancing IS 'financiamento estudandil (fies)';


--
-- Name: COLUMN finstudentfinancing.studentfinancingid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finstudentfinancing.studentfinancingid IS 'Codigo identificador do financiamento estudantil';


--
-- Name: COLUMN finstudentfinancing.contractid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finstudentfinancing.contractid IS 'Contrato do aluno (acdContract)';


--
-- Name: COLUMN finstudentfinancing.initialvalue; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finstudentfinancing.initialvalue IS 'Valor inicial do financiamento';


--
-- Name: COLUMN finstudentfinancing.currentvalue; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finstudentfinancing.currentvalue IS 'Valor atual do financiamento';


--
-- Name: COLUMN finstudentfinancing.comments; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finstudentfinancing.comments IS 'Observacoes';


--
-- Name: finsupport; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finsupport (
    accountschemeid character varying(30) NOT NULL,
    collectionoperationid integer NOT NULL
)
INHERITS (finincentivetype);


ALTER TABLE public.finsupport OWNER TO postgres;

--
-- Name: TABLE finsupport; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finsupport IS 'incentivos do tipo patrocinio (empresas que custeiam os estudos dos funcionarios, por exemplo). herda a finincentivetype';


--
-- Name: COLUMN finsupport.accountschemeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finsupport.accountschemeid IS 'Codigo identificador da conta contavil a qual o patrocinio pertence';


--
-- Name: COLUMN finsupport.collectionoperationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finsupport.collectionoperationid IS 'Operacao para a cobranca para o patrocinador';


--
-- Name: fintipovalorvariavelremessa; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE fintipovalorvariavelremessa (
    tipovalorvariavelremessaid character varying NOT NULL,
    descricao character varying(255)
)
INHERITS (baslog);


ALTER TABLE public.fintipovalorvariavelremessa OWNER TO postgres;

--
-- Name: fintransferenciadecaixa; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE fintransferenciadecaixa (
    transferenciadecaixaid integer NOT NULL,
    caixaabertodeorigem integer NOT NULL,
    caixadedestino integer NOT NULL,
    valortransferido numeric NOT NULL,
    transferido boolean DEFAULT false
)
INHERITS (baslog);


ALTER TABLE public.fintransferenciadecaixa OWNER TO postgres;

--
-- Name: fintransferenciadecaixa_transferenciadecaixaid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE fintransferenciadecaixa_transferenciadecaixaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.fintransferenciadecaixa_transferenciadecaixaid_seq OWNER TO postgres;

--
-- Name: fintransferenciadecaixa_transferenciadecaixaid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE fintransferenciadecaixa_transferenciadecaixaid_seq OWNED BY fintransferenciadecaixa.transferenciadecaixaid;


--
-- Name: finvouchermessages; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE finvouchermessages (
    operationid integer NOT NULL,
    title text NOT NULL,
    message text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.finvouchermessages OWNER TO postgres;

--
-- Name: TABLE finvouchermessages; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE finvouchermessages IS 'mensagens para os demonstrativos financeiros, comprovantes genericos';


--
-- Name: COLUMN finvouchermessages.operationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finvouchermessages.operationid IS 'Codigo identificador da operacao';


--
-- Name: COLUMN finvouchermessages.title; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finvouchermessages.title IS 'Titulo do demostrativo';


--
-- Name: COLUMN finvouchermessages.message; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN finvouchermessages.message IS 'Mensagem do demostrativo';


--
-- Name: seq_analyticsid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_analyticsid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_analyticsid OWNER TO postgres;

--
-- Name: gtcanalytics; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcanalytics (
    analyticsid integer DEFAULT nextval('seq_analyticsid'::regclass) NOT NULL,
    query text,
    action text,
    event text,
    libraryunitid integer,
    operator character varying(30),
    personid bigint,
    "time" timestamp without time zone,
    ip text,
    browser text,
    loglevel integer NOT NULL,
    accesstype integer NOT NULL,
    menu text,
    timespent double precision
);


ALTER TABLE public.gtcanalytics OWNER TO postgres;

--
-- Name: TABLE gtcanalytics; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcanalytics IS 'Tabela que registra acessos (termos pesquisados e erros) ao sistemas.
Utilizada para estatísticas.';


--
-- Name: COLUMN gtcanalytics.analyticsid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcanalytics.analyticsid IS 'Código do registro.';


--
-- Name: COLUMN gtcanalytics.query; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcanalytics.query IS 'A intrução do navegador.';


--
-- Name: COLUMN gtcanalytics.action; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcanalytics.action IS 'Ação do miolo.';


--
-- Name: COLUMN gtcanalytics.event; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcanalytics.event IS 'Evento do miolo.';


--
-- Name: COLUMN gtcanalytics.libraryunitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcanalytics.libraryunitid IS 'Unidade de bibllioteca logada.';


--
-- Name: COLUMN gtcanalytics.operator; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcanalytics.operator IS 'Operador.';


--
-- Name: COLUMN gtcanalytics.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcanalytics.personid IS 'Código da pessoa.';


--
-- Name: COLUMN gtcanalytics."time"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcanalytics."time" IS 'Data e Hora de registro.';


--
-- Name: COLUMN gtcanalytics.ip; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcanalytics.ip IS 'Ip de acesso.';


--
-- Name: COLUMN gtcanalytics.browser; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcanalytics.browser IS 'Navegador.';


--
-- Name: COLUMN gtcanalytics.loglevel; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcanalytics.loglevel IS 'Nível de registro.';


--
-- Name: COLUMN gtcanalytics.accesstype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcanalytics.accesstype IS 'Tipo de acesso.';


--
-- Name: COLUMN gtcanalytics.menu; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcanalytics.menu IS 'Título do menu.';


--
-- Name: COLUMN gtcanalytics.timespent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcanalytics.timespent IS 'Tempo dispendido.';


--
-- Name: seq_associationid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_associationid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_associationid OWNER TO postgres;

--
-- Name: gtcassociation; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcassociation (
    associationid integer DEFAULT nextval('seq_associationid'::regclass) NOT NULL,
    description character varying
);


ALTER TABLE public.gtcassociation OWNER TO postgres;

--
-- Name: seq_backgroundtasklogid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_backgroundtasklogid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_backgroundtasklogid OWNER TO postgres;

--
-- Name: gtcbackgroundtasklog; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcbackgroundtasklog (
    backgroundtasklogid integer DEFAULT nextval('seq_backgroundtasklogid'::regclass) NOT NULL,
    begindate timestamp without time zone NOT NULL,
    enddate timestamp without time zone,
    task character varying NOT NULL,
    label character varying NOT NULL,
    status integer NOT NULL,
    message character varying,
    operator character varying NOT NULL,
    args character varying,
    libraryunitid integer,
    CONSTRAINT chk_gtcbackgroundtasklog_status CHECK (gtc_chk_domain('BACKGROUND_TASK_STATUS'::character varying, (status)::character varying))
);


ALTER TABLE public.gtcbackgroundtasklog OWNER TO postgres;

--
-- Name: TABLE gtcbackgroundtasklog; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcbackgroundtasklog IS 'armazena os logs executados pela tarefa de background';


--
-- Name: COLUMN gtcbackgroundtasklog.backgroundtasklogid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcbackgroundtasklog.backgroundtasklogid IS 'Codigo da tarefa ';


--
-- Name: gtcbackgroundtasklog_backgroundtasklogid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE gtcbackgroundtasklog_backgroundtasklogid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.gtcbackgroundtasklog_backgroundtasklogid_seq OWNER TO postgres;

--
-- Name: gtcbackgroundtasklog_backgroundtasklogid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE gtcbackgroundtasklog_backgroundtasklogid_seq OWNED BY gtcbackgroundtasklog.backgroundtasklogid;


--
-- Name: seq_cataloguingformatid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_cataloguingformatid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_cataloguingformatid OWNER TO postgres;

--
-- Name: gtccataloguingformat; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtccataloguingformat (
    cataloguingformatid integer DEFAULT nextval('seq_cataloguingformatid'::regclass) NOT NULL,
    description character varying NOT NULL,
    observation character varying
);


ALTER TABLE public.gtccataloguingformat OWNER TO postgres;

--
-- Name: TABLE gtccataloguingformat; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtccataloguingformat IS 'tabela para separadores';


--
-- Name: seq_classificationareaid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_classificationareaid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_classificationareaid OWNER TO postgres;

--
-- Name: gtcclassificationarea; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcclassificationarea (
    classificationareaid integer DEFAULT nextval('seq_classificationareaid'::regclass) NOT NULL,
    areaname character varying(50) NOT NULL,
    classification text,
    ignoreclassification text
);


ALTER TABLE public.gtcclassificationarea OWNER TO postgres;

--
-- Name: TABLE gtcclassificationarea; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcclassificationarea IS 'area de classificacao';


--
-- Name: COLUMN gtcclassificationarea.classificationareaid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcclassificationarea.classificationareaid IS 'Identificacao da classifica';


--
-- Name: COLUMN gtcclassificationarea.areaname; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcclassificationarea.areaname IS 'Nome da area de classificacao';


--
-- Name: COLUMN gtcclassificationarea.classification; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcclassificationarea.classification IS 'Classificacoess separadas por virgula e com percente para caracter de truncamento';


--
-- Name: COLUMN gtcclassificationarea.ignoreclassification; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcclassificationarea.ignoreclassification IS 'Ignorar classificacoes separadas por virgula e com percente para caracter de truncamento';


--
-- Name: seq_controlfielddetailid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_controlfielddetailid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_controlfielddetailid OWNER TO postgres;

--
-- Name: gtccontrolfielddetail; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtccontrolfielddetail (
    controlfielddetailid integer DEFAULT nextval('seq_controlfielddetailid'::regclass) NOT NULL,
    fieldid character varying(3) NOT NULL,
    subfieldid character varying(1) NOT NULL,
    beginposition integer NOT NULL,
    lenght integer NOT NULL,
    description character varying(100) NOT NULL,
    categoryid character varying(2) NOT NULL,
    marctaglistid character varying,
    isactive boolean,
    defaultvalue character varying,
    emptyvalue character varying(50)
);


ALTER TABLE public.gtccontrolfielddetail OWNER TO postgres;

--
-- Name: TABLE gtccontrolfielddetail; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtccontrolfielddetail IS 'Registra forma padrão de montagem de campos de controle Marc. Ex.:000 e 008';


--
-- Name: seq_costcenterid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_costcenterid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_costcenterid OWNER TO postgres;

--
-- Name: gtccostcenter; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtccostcenter (
    costcenterid integer DEFAULT nextval('seq_costcenterid'::regclass) NOT NULL,
    libraryunitid integer,
    description character varying(255) NOT NULL
);


ALTER TABLE public.gtccostcenter OWNER TO postgres;

--
-- Name: TABLE gtccostcenter; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtccostcenter IS 'centro de custo';


--
-- Name: gtccutter; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtccutter (
    abbreviation character varying NOT NULL,
    code integer NOT NULL
);


ALTER TABLE public.gtccutter OWNER TO postgres;

--
-- Name: TABLE gtccutter; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtccutter IS 'tabela cutter';


--
-- Name: seq_dictionaryid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_dictionaryid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_dictionaryid OWNER TO postgres;

--
-- Name: gtcdictionary; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcdictionary (
    dictionaryid integer DEFAULT nextval('seq_dictionaryid'::regclass) NOT NULL,
    description character varying NOT NULL,
    tags text,
    readonly boolean
);


ALTER TABLE public.gtcdictionary OWNER TO postgres;

--
-- Name: TABLE gtcdictionary; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcdictionary IS 'dicion';


--
-- Name: seq_dictionarycontentid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_dictionarycontentid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_dictionarycontentid OWNER TO postgres;

--
-- Name: gtcdictionarycontent; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcdictionarycontent (
    dictionarycontentid integer DEFAULT nextval('seq_dictionarycontentid'::regclass) NOT NULL,
    dictionaryid integer NOT NULL,
    dictionarycontent text NOT NULL
);


ALTER TABLE public.gtcdictionarycontent OWNER TO postgres;

--
-- Name: TABLE gtcdictionarycontent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcdictionarycontent IS 'dicion';


--
-- Name: seq_dictionaryrelatedcontentid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_dictionaryrelatedcontentid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_dictionaryrelatedcontentid OWNER TO postgres;

--
-- Name: gtcdictionaryrelatedcontent; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcdictionaryrelatedcontent (
    dictionaryrelatedcontentid integer DEFAULT nextval('seq_dictionaryrelatedcontentid'::regclass) NOT NULL,
    dictionarycontentid integer NOT NULL,
    relatedcontent character varying
);


ALTER TABLE public.gtcdictionaryrelatedcontent OWNER TO postgres;

--
-- Name: TABLE gtcdictionaryrelatedcontent; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcdictionaryrelatedcontent IS 'dicion';


--
-- Name: gtcemailcontroldelayedloan; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcemailcontroldelayedloan (
    loanid integer,
    lastsent timestamp without time zone NOT NULL,
    amountsent integer NOT NULL
);


ALTER TABLE public.gtcemailcontroldelayedloan OWNER TO postgres;

--
-- Name: gtcemailcontrolnotifyaquisition; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcemailcontrolnotifyaquisition (
    personid bigint,
    lastsent timestamp without time zone NOT NULL
);


ALTER TABLE public.gtcemailcontrolnotifyaquisition OWNER TO postgres;

--
-- Name: gtcexemplarycontrol; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcexemplarycontrol (
    controlnumber integer NOT NULL,
    itemnumber character varying(20) NOT NULL,
    originallibraryunitid integer NOT NULL,
    libraryunitid integer NOT NULL,
    acquisitiontype character varying(1) NOT NULL,
    exemplarystatusid integer NOT NULL,
    materialgenderid integer,
    materialtypeid integer,
    materialphysicaltypeid integer,
    entrancedate date,
    lowdate date,
    line integer,
    observation text
);


ALTER TABLE public.gtcexemplarycontrol OWNER TO postgres;

--
-- Name: TABLE gtcexemplarycontrol; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcexemplarycontrol IS 'armazena os exemplares';


--
-- Name: COLUMN gtcexemplarycontrol.controlnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcexemplarycontrol.controlnumber IS 'Identificador da obra';


--
-- Name: COLUMN gtcexemplarycontrol.itemnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcexemplarycontrol.itemnumber IS 'Descri';


--
-- Name: COLUMN gtcexemplarycontrol.libraryunitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcexemplarycontrol.libraryunitid IS 'Codigo da unidade';


--
-- Name: COLUMN gtcexemplarycontrol.acquisitiontype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcexemplarycontrol.acquisitiontype IS 'Tipo de aquisicao';


--
-- Name: COLUMN gtcexemplarycontrol.exemplarystatusid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcexemplarycontrol.exemplarystatusid IS 'C';


--
-- Name: seq_exemplaryfuturestatusdefinedid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_exemplaryfuturestatusdefinedid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_exemplaryfuturestatusdefinedid OWNER TO postgres;

--
-- Name: gtcexemplaryfuturestatusdefined; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcexemplaryfuturestatusdefined (
    exemplaryfuturestatusdefinedid integer DEFAULT nextval('seq_exemplaryfuturestatusdefinedid'::regclass) NOT NULL,
    exemplarystatusid integer,
    itemnumber character varying(20),
    applied boolean,
    date timestamp without time zone,
    operator character varying(30),
    observation text,
    cancelreserveemailobservation text
);


ALTER TABLE public.gtcexemplaryfuturestatusdefined OWNER TO postgres;

--
-- Name: TABLE gtcexemplaryfuturestatusdefined; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcexemplaryfuturestatusdefined IS '
';


--
-- Name: seq_exemplarystatusid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_exemplarystatusid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_exemplarystatusid OWNER TO postgres;

--
-- Name: gtcexemplarystatus; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcexemplarystatus (
    exemplarystatusid integer DEFAULT nextval('seq_exemplarystatusid'::regclass) NOT NULL,
    description character varying(40) NOT NULL,
    mask character varying(40),
    level integer,
    executeloan boolean,
    momentaryloan boolean,
    daysofmomentaryloan integer,
    executereserve boolean,
    executereserveininitiallevel boolean,
    meetreserve boolean,
    isreservestatus boolean,
    islowstatus boolean,
    observation text,
    schedulechangestatusforrequest boolean
);


ALTER TABLE public.gtcexemplarystatus OWNER TO postgres;

--
-- Name: TABLE gtcexemplarystatus; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcexemplarystatus IS 'estado dos exemplares';


--
-- Name: COLUMN gtcexemplarystatus.exemplarystatusid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcexemplarystatus.exemplarystatusid IS 'Identificador do status';


--
-- Name: COLUMN gtcexemplarystatus.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcexemplarystatus.description IS 'descri';


--
-- Name: COLUMN gtcexemplarystatus.level; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcexemplarystatus.level IS 'Nivel definido como: 1 - Inicial e 2 - Transicao';


--
-- Name: COLUMN gtcexemplarystatus.executeloan; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcexemplarystatus.executeloan IS 'Define se neste estado o material podera ser emprestado.';


--
-- Name: COLUMN gtcexemplarystatus.momentaryloan; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcexemplarystatus.momentaryloan IS 'Se permite que o estado seja emprestado para o Xerox, etc.';


--
-- Name: COLUMN gtcexemplarystatus.meetreserve; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcexemplarystatus.meetreserve IS 'Se for true e um livro for devolvido para este estado ele executara o processo de atender reserva';


--
-- Name: gtcexemplarystatushistory; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcexemplarystatushistory (
    itemnumber character varying(20) NOT NULL,
    exemplarystatusid integer NOT NULL,
    libraryunitid integer NOT NULL,
    date timestamp without time zone NOT NULL,
    operator character varying(30) NOT NULL
);


ALTER TABLE public.gtcexemplarystatushistory OWNER TO postgres;

--
-- Name: TABLE gtcexemplarystatushistory; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcexemplarystatushistory IS 'mantem o historico das trocas de estado';


--
-- Name: COLUMN gtcexemplarystatushistory.itemnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcexemplarystatushistory.itemnumber IS 'Identifica';


--
-- Name: COLUMN gtcexemplarystatushistory.exemplarystatusid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcexemplarystatushistory.exemplarystatusid IS 'Estado do exemplar';


--
-- Name: COLUMN gtcexemplarystatushistory.date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcexemplarystatushistory.date IS 'Cado o exemplar volta ela se torna confirmada';


--
-- Name: gtcfavorite; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcfavorite (
    personid bigint NOT NULL,
    controlnumber integer NOT NULL,
    entracedate timestamp without time zone
);


ALTER TABLE public.gtcfavorite OWNER TO postgres;

--
-- Name: TABLE gtcfavorite; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcfavorite IS 'materiais favoritos do usu';


--
-- Name: COLUMN gtcfavorite.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcfavorite.personid IS 'Id da pessoa';


--
-- Name: COLUMN gtcfavorite.controlnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcfavorite.controlnumber IS 'numero de controle';


--
-- Name: COLUMN gtcfavorite.entracedate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcfavorite.entracedate IS 'Data de entrada';


--
-- Name: seq_fineid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_fineid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_fineid OWNER TO postgres;

--
-- Name: gtcfine; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcfine (
    fineid integer DEFAULT nextval('seq_fineid'::regclass) NOT NULL,
    loanid integer NOT NULL,
    begindate timestamp without time zone NOT NULL,
    value numeric(10,2) NOT NULL,
    finestatusid integer NOT NULL,
    enddate timestamp without time zone,
    observation text
);


ALTER TABLE public.gtcfine OWNER TO postgres;

--
-- Name: TABLE gtcfine; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcfine IS 'multas';


--
-- Name: COLUMN gtcfine.fineid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcfine.fineid IS 'Identificador da multa';


--
-- Name: COLUMN gtcfine.loanid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcfine.loanid IS 'Identifica';


--
-- Name: COLUMN gtcfine.begindate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcfine.begindate IS 'Data do registor da multa';


--
-- Name: COLUMN gtcfine.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcfine.value IS 'Valor total da multa. Deve vir calculada.';


--
-- Name: COLUMN gtcfine.finestatusid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcfine.finestatusid IS 'Estado da multa. 1 - Em aberto. 2 - Abonada. 3 - Pago 4 - Pagamento via boleto';


--
-- Name: COLUMN gtcfine.enddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcfine.enddate IS 'Data do pagamento';


--
-- Name: seq_finestatusid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_finestatusid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_finestatusid OWNER TO postgres;

--
-- Name: gtcfinestatus; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcfinestatus (
    finestatusid integer DEFAULT nextval('seq_finestatusid'::regclass) NOT NULL,
    description character varying(40) NOT NULL
);


ALTER TABLE public.gtcfinestatus OWNER TO postgres;

--
-- Name: TABLE gtcfinestatus; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcfinestatus IS 'estado da multa';


--
-- Name: COLUMN gtcfinestatus.finestatusid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcfinestatus.finestatusid IS 'Identificador do estado da multa';


--
-- Name: COLUMN gtcfinestatus.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcfinestatus.description IS 'Descri';


--
-- Name: gtcfinestatushistory; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcfinestatushistory (
    fineid integer NOT NULL,
    finestatusid integer NOT NULL,
    date timestamp without time zone NOT NULL,
    operator character varying(30) NOT NULL,
    observation text
);


ALTER TABLE public.gtcfinestatushistory OWNER TO postgres;

--
-- Name: TABLE gtcfinestatushistory; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcfinestatushistory IS 'mantem o historico das trocas de estado';


--
-- Name: COLUMN gtcfinestatushistory.fineid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcfinestatushistory.fineid IS 'Identifica';


--
-- Name: COLUMN gtcfinestatushistory.finestatusid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcfinestatushistory.finestatusid IS 'Estado da reserva';


--
-- Name: COLUMN gtcfinestatushistory.date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcfinestatushistory.date IS 'Cado o exemplar volta ela se torna confirmada';


--
-- Name: seq_formatbackofbookid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_formatbackofbookid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_formatbackofbookid OWNER TO postgres;

--
-- Name: gtcformatbackofbook; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcformatbackofbook (
    formatbackofbookid integer DEFAULT nextval('seq_formatbackofbookid'::regclass) NOT NULL,
    description character varying(40) NOT NULL,
    format text NOT NULL,
    internalformat text
);


ALTER TABLE public.gtcformatbackofbook OWNER TO postgres;

--
-- Name: seq_formcontentid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_formcontentid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_formcontentid OWNER TO postgres;

--
-- Name: gtcformcontent; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcformcontent (
    formcontentid integer DEFAULT nextval('seq_formcontentid'::regclass) NOT NULL,
    operator character varying,
    form character varying NOT NULL,
    name character varying,
    description character varying,
    formcontenttype integer NOT NULL
);


ALTER TABLE public.gtcformcontent OWNER TO postgres;

--
-- Name: gtcformcontentdetail; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcformcontentdetail (
    formcontentid character varying NOT NULL,
    field character varying NOT NULL,
    value character varying
);


ALTER TABLE public.gtcformcontentdetail OWNER TO postgres;

--
-- Name: seq_formcontenttypeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_formcontenttypeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_formcontenttypeid OWNER TO postgres;

--
-- Name: gtcformcontenttype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcformcontenttype (
    formcontenttypeid integer DEFAULT nextval('seq_formcontenttypeid'::regclass) NOT NULL,
    description character varying(40) NOT NULL
);


ALTER TABLE public.gtcformcontenttype OWNER TO postgres;

--
-- Name: TABLE gtcformcontenttype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcformcontenttype IS 'identifica tipos de empr';


--
-- Name: COLUMN gtcformcontenttype.formcontenttypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcformcontenttype.formcontenttypeid IS 'Identificador do tipo de emprestimo';


--
-- Name: COLUMN gtcformcontenttype.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcformcontenttype.description IS 'Descri';


--
-- Name: gtcgeneralpolicy; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcgeneralpolicy (
    privilegegroupid integer NOT NULL,
    linkid integer NOT NULL,
    loangenerallimit integer,
    reservegenerallimit integer,
    reservegenerallimitininitiallevel integer
);


ALTER TABLE public.gtcgeneralpolicy OWNER TO postgres;

--
-- Name: gtchelp; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtchelp (
    helpid integer NOT NULL,
    form character varying(150) NOT NULL,
    subform character varying(150),
    help text NOT NULL,
    isactive boolean NOT NULL
);


ALTER TABLE public.gtchelp OWNER TO postgres;

--
-- Name: gtchelp_helpid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE gtchelp_helpid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.gtchelp_helpid_seq OWNER TO postgres;

--
-- Name: gtchelp_helpid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE gtchelp_helpid_seq OWNED BY gtchelp.helpid;


--
-- Name: seq_holidayid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_holidayid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_holidayid OWNER TO postgres;

--
-- Name: gtcholiday; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcholiday (
    holidayid integer DEFAULT nextval('seq_holidayid'::regclass) NOT NULL,
    date date,
    description character varying,
    occursallyear boolean,
    libraryunitid integer
);


ALTER TABLE public.gtcholiday OWNER TO postgres;

--
-- Name: TABLE gtcholiday; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcholiday IS 'especifica o feriado para uma unidade. se for null vale para todas as unidades';


--
-- Name: gtcinterchange; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcinterchange (
    interchangeid integer DEFAULT nextval('seq_interchangeid'::regclass) NOT NULL,
    type character(1),
    supplierid integer NOT NULL,
    description character varying,
    date timestamp without time zone NOT NULL,
    interchangestatusid integer,
    interchangetypeid integer,
    operator character varying(30),
    CONSTRAINT gtcinterchange_type_check CHECK ((type = ANY (ARRAY['p'::bpchar, 'd'::bpchar])))
);


ALTER TABLE public.gtcinterchange OWNER TO postgres;

--
-- Name: TABLE gtcinterchange; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcinterchange IS 'permuta';


--
-- Name: COLUMN gtcinterchange.interchangeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcinterchange.interchangeid IS 'Identifica';


--
-- Name: COLUMN gtcinterchange.interchangetypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcinterchange.interchangetypeid IS '1 - Envio; 2 - Recebimento';


--
-- Name: seq_interchangeitemid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_interchangeitemid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_interchangeitemid OWNER TO postgres;

--
-- Name: gtcinterchangeitem; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcinterchangeitem (
    interchangeitemid integer DEFAULT nextval('seq_interchangeitemid'::regclass) NOT NULL,
    interchangeid integer NOT NULL,
    controlnumber integer,
    content character varying
);


ALTER TABLE public.gtcinterchangeitem OWNER TO postgres;

--
-- Name: TABLE gtcinterchangeitem; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcinterchangeitem IS 'itens de permuta';


--
-- Name: COLUMN gtcinterchangeitem.interchangeitemid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcinterchangeitem.interchangeitemid IS 'Identifica';


--
-- Name: seq_interchangeobservationid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_interchangeobservationid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_interchangeobservationid OWNER TO postgres;

--
-- Name: gtcinterchangeobservation; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcinterchangeobservation (
    interchangeobservationid integer DEFAULT nextval('seq_interchangeobservationid'::regclass) NOT NULL,
    interchangeid integer NOT NULL,
    observation text,
    date timestamp without time zone,
    operator character varying(30)
);


ALTER TABLE public.gtcinterchangeobservation OWNER TO postgres;

--
-- Name: TABLE gtcinterchangeobservation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcinterchangeobservation IS 'observa';


--
-- Name: COLUMN gtcinterchangeobservation.interchangeobservationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcinterchangeobservation.interchangeobservationid IS 'Identifica';


--
-- Name: seq_interchangestatusid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_interchangestatusid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_interchangestatusid OWNER TO postgres;

--
-- Name: gtcinterchangestatus; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcinterchangestatus (
    interchangestatusid integer DEFAULT nextval('seq_interchangestatusid'::regclass) NOT NULL,
    description character varying(40) NOT NULL,
    interchangetypeid integer
);


ALTER TABLE public.gtcinterchangestatus OWNER TO postgres;

--
-- Name: TABLE gtcinterchangestatus; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcinterchangestatus IS 'estado da reserva';


--
-- Name: COLUMN gtcinterchangestatus.interchangestatusid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcinterchangestatus.interchangestatusid IS 'Identificador da situa';


--
-- Name: COLUMN gtcinterchangestatus.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcinterchangestatus.description IS 'Descri';


--
-- Name: gtcinterchangetype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcinterchangetype (
    interchangetypeid integer DEFAULT nextval('seq_interchangetypeid'::regclass) NOT NULL,
    description character varying(40) NOT NULL
);


ALTER TABLE public.gtcinterchangetype OWNER TO postgres;

--
-- Name: TABLE gtcinterchangetype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcinterchangetype IS 'estado da reserva';


--
-- Name: COLUMN gtcinterchangetype.interchangetypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcinterchangetype.interchangetypeid IS 'Identificador da situa';


--
-- Name: COLUMN gtcinterchangetype.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcinterchangetype.description IS 'Descri';


--
-- Name: gtcinterestsarea; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcinterestsarea (
    personid bigint NOT NULL,
    classificationareaid integer NOT NULL,
    bud_dia2sql_ignorar integer
);


ALTER TABLE public.gtcinterestsarea OWNER TO postgres;

--
-- Name: TABLE gtcinterestsarea; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcinterestsarea IS 'define as ';


--
-- Name: COLUMN gtcinterestsarea.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcinterestsarea.personid IS 'C';


--
-- Name: COLUMN gtcinterestsarea.classificationareaid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcinterestsarea.classificationareaid IS 'C';


--
-- Name: gtckardexcontrol; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtckardexcontrol (
    controlnumber integer NOT NULL,
    codigodeassinante character varying(40),
    libraryunitid integer NOT NULL,
    acquisitiontype character varying(1) NOT NULL,
    vencimentodaassinatura date,
    datadaassinatura date,
    entrancedate date,
    line integer
);


ALTER TABLE public.gtckardexcontrol OWNER TO postgres;

--
-- Name: TABLE gtckardexcontrol; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtckardexcontrol IS 'armazena dados da cole';


--
-- Name: COLUMN gtckardexcontrol.controlnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtckardexcontrol.controlnumber IS 'Identificador da obra';


--
-- Name: COLUMN gtckardexcontrol.libraryunitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtckardexcontrol.libraryunitid IS 'Codigo da unidade';


--
-- Name: COLUMN gtckardexcontrol.acquisitiontype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtckardexcontrol.acquisitiontype IS 'Tipo de aquisicao';


--
-- Name: seq_labellayoutid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_labellayoutid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_labellayoutid OWNER TO postgres;

--
-- Name: gtclabellayout; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtclabellayout (
    labellayoutid integer DEFAULT nextval('seq_labellayoutid'::regclass) NOT NULL,
    description character varying,
    topmargin double precision,
    leftmargin double precision,
    verticalspacing double precision,
    horizontalspacing double precision,
    height double precision,
    width double precision,
    lines double precision,
    columns double precision,
    pageformat character varying
);


ALTER TABLE public.gtclabellayout OWNER TO postgres;

--
-- Name: gtclibperson; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtclibperson (
    personid bigint NOT NULL,
    baseldap character varying(50),
    sex character(1),
    profession character varying(100),
    workplace character varying(100),
    school character varying(100),
    datebirth date,
    persongroup character varying(255),
    operationprocess timestamp without time zone
);


ALTER TABLE public.gtclibperson OWNER TO postgres;

--
-- Name: TABLE gtclibperson; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtclibperson IS 'Informação da pessoa, relacionadas a biblioteca';


--
-- Name: COLUMN gtclibperson.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclibperson.personid IS 'código da pessoa';


--
-- Name: COLUMN gtclibperson.baseldap; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclibperson.baseldap IS 'Determina a base ldap onde o login deve ser efetuado.';


--
-- Name: COLUMN gtclibperson.sex; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclibperson.sex IS 'Sexo, valores válidos M e F.';


--
-- Name: COLUMN gtclibperson.profession; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclibperson.profession IS 'Profissão';


--
-- Name: COLUMN gtclibperson.workplace; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclibperson.workplace IS 'Local de trabalho.';


--
-- Name: COLUMN gtclibperson.school; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclibperson.school IS 'Escola.';


--
-- Name: COLUMN gtclibperson.datebirth; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclibperson.datebirth IS 'Data de nascimento.';


--
-- Name: COLUMN gtclibperson.persongroup; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclibperson.persongroup IS 'Grupo da pessoa, utilizado para caracterizar uma pessoa em alguma situação, varia de acordo com o cliente.';


--
-- Name: COLUMN gtclibperson.operationprocess; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclibperson.operationprocess IS 'Processo de operação';


--
-- Name: gtclibraryassociation; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtclibraryassociation (
    associationid integer NOT NULL,
    libraryunitid integer NOT NULL
);


ALTER TABLE public.gtclibraryassociation OWNER TO postgres;

--
-- Name: seq_librarygroupid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_librarygroupid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_librarygroupid OWNER TO postgres;

--
-- Name: gtclibrarygroup; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtclibrarygroup (
    librarygroupid integer DEFAULT nextval('seq_librarygroupid'::regclass) NOT NULL,
    description character varying(100) NOT NULL,
    observation text
);


ALTER TABLE public.gtclibrarygroup OWNER TO postgres;

--
-- Name: TABLE gtclibrarygroup; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtclibrarygroup IS 'cadastra grupos para separar as unidades';


--
-- Name: COLUMN gtclibrarygroup.librarygroupid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclibrarygroup.librarygroupid IS 'C';


--
-- Name: COLUMN gtclibrarygroup.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclibrarygroup.description IS 'Nome do grupo';


--
-- Name: COLUMN gtclibrarygroup.observation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclibrarygroup.observation IS 'Observacoes';


--
-- Name: seq_level; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_level
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_level OWNER TO postgres;

--
-- Name: seq_libraryunitid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_libraryunitid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_libraryunitid OWNER TO postgres;

--
-- Name: gtclibraryunit; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtclibraryunit (
    libraryunitid integer DEFAULT nextval('seq_libraryunitid'::regclass) NOT NULL,
    libraryname character varying(100) NOT NULL,
    isrestricted boolean DEFAULT false,
    city character varying(50),
    zipcode character varying(9),
    location character varying(100),
    number character varying(10),
    complement character varying(60),
    email character varying(60),
    url character varying(60),
    librarygroupid integer,
    privilegegroupid integer NOT NULL,
    observation text,
    level integer DEFAULT nextval('seq_level'::regclass),
    acceptpurchaserequest boolean DEFAULT false NOT NULL
);


ALTER TABLE public.gtclibraryunit OWNER TO postgres;

--
-- Name: TABLE gtclibraryunit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtclibraryunit IS 'Unidade de biblioteca.';


--
-- Name: COLUMN gtclibraryunit.libraryunitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclibraryunit.libraryunitid IS 'C';


--
-- Name: COLUMN gtclibraryunit.libraryname; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclibraryunit.libraryname IS 'Nome da unidade';


--
-- Name: COLUMN gtclibraryunit.city; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclibraryunit.city IS 'Nome da cidade, por enquanto fica com nome direto';


--
-- Name: COLUMN gtclibraryunit.zipcode; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclibraryunit.zipcode IS 'CEP';


--
-- Name: COLUMN gtclibraryunit.location; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclibraryunit.location IS 'Logradouro';


--
-- Name: COLUMN gtclibraryunit.number; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclibraryunit.number IS 'N';


--
-- Name: COLUMN gtclibraryunit.complement; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclibraryunit.complement IS 'Complemento';


--
-- Name: COLUMN gtclibraryunit.email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclibraryunit.email IS 'Email da unidade';


--
-- Name: COLUMN gtclibraryunit.url; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclibraryunit.url IS 'Site da unidade';


--
-- Name: COLUMN gtclibraryunit.acceptpurchaserequest; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclibraryunit.acceptpurchaserequest IS 'Determina se aceita ou não solicitação de compras.';


--
-- Name: gtclibraryunitaccess; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtclibraryunitaccess (
    libraryunitid integer NOT NULL,
    linkid integer NOT NULL
);


ALTER TABLE public.gtclibraryunitaccess OWNER TO postgres;

--
-- Name: TABLE gtclibraryunitaccess; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtclibraryunitaccess IS 'identifica os grupos que ter';


--
-- Name: gtclibraryunitconfig; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtclibraryunitconfig (
    libraryunitid integer NOT NULL,
    parameter text NOT NULL,
    value text,
    CONSTRAINT chk_library_unit_parameter CHECK (gtc_chk_parameter(parameter))
);


ALTER TABLE public.gtclibraryunitconfig OWNER TO postgres;

--
-- Name: TABLE gtclibraryunitconfig; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtclibraryunitconfig IS 'Configuracoes do sistema relativas a unidade de biblioteca.';


--
-- Name: COLUMN gtclibraryunitconfig.libraryunitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclibraryunitconfig.libraryunitid IS 'Modulo do parametro';


--
-- Name: COLUMN gtclibraryunitconfig.parameter; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclibraryunitconfig.parameter IS 'Parametro';


--
-- Name: COLUMN gtclibraryunitconfig.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclibraryunitconfig.value IS 'Valor';


--
-- Name: gtclibraryunitisclosed; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtclibraryunitisclosed (
    libraryunitid integer NOT NULL,
    weekdayid integer NOT NULL
);


ALTER TABLE public.gtclibraryunitisclosed OWNER TO postgres;

--
-- Name: seq_linkoffieldsbetweenspreadsheetsid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_linkoffieldsbetweenspreadsheetsid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_linkoffieldsbetweenspreadsheetsid OWNER TO postgres;

--
-- Name: gtclinkoffieldsbetweenspreadsheets; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtclinkoffieldsbetweenspreadsheets (
    linkoffieldsbetweenspreadsheetsid integer DEFAULT nextval('seq_linkoffieldsbetweenspreadsheetsid'::regclass) NOT NULL,
    category character varying(2) NOT NULL,
    level character varying(1) NOT NULL,
    tag character varying NOT NULL,
    categoryson character varying(2) NOT NULL,
    levelson character varying(1) NOT NULL,
    tagson character varying NOT NULL,
    type integer
);


ALTER TABLE public.gtclinkoffieldsbetweenspreadsheets OWNER TO postgres;

--
-- Name: TABLE gtclinkoffieldsbetweenspreadsheets; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtclinkoffieldsbetweenspreadsheets IS 'liga';


--
-- Name: seq_loanid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_loanid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_loanid OWNER TO postgres;

--
-- Name: gtcloan; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcloan (
    loanid integer DEFAULT nextval('seq_loanid'::regclass) NOT NULL,
    loantypeid integer NOT NULL,
    personid bigint NOT NULL,
    linkid integer NOT NULL,
    privilegegroupid integer NOT NULL,
    itemnumber character varying(20) NOT NULL,
    libraryunitid integer,
    loandate timestamp without time zone NOT NULL,
    loanoperator character varying(30) NOT NULL,
    returnforecastdate timestamp without time zone NOT NULL,
    returndate timestamp without time zone,
    returnoperator character varying(30),
    renewalamount integer NOT NULL,
    renewalwebamount integer NOT NULL,
    renewalwebbonus boolean NOT NULL
);


ALTER TABLE public.gtcloan OWNER TO postgres;

--
-- Name: TABLE gtcloan; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcloan IS 'emprestimos';


--
-- Name: COLUMN gtcloan.loanid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcloan.loanid IS 'Identificador do emprestimo';


--
-- Name: COLUMN gtcloan.linkid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcloan.linkid IS 'Grupo que pertence o usu';


--
-- Name: COLUMN gtcloan.itemnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcloan.itemnumber IS 'N';


--
-- Name: COLUMN gtcloan.libraryunitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcloan.libraryunitid IS 'Unidade da biblioteca que emprestou';


--
-- Name: COLUMN gtcloan.loandate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcloan.loandate IS 'Data e hora do empr';


--
-- Name: COLUMN gtcloan.loanoperator; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcloan.loanoperator IS 'Login do miolo que emprestou o material';


--
-- Name: COLUMN gtcloan.returnforecastdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcloan.returnforecastdate IS 'Data prevista para devolu';


--
-- Name: COLUMN gtcloan.returndate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcloan.returndate IS 'Data da devolu';


--
-- Name: COLUMN gtcloan.returnoperator; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcloan.returnoperator IS 'Login do miolo que devolveu o material';


--
-- Name: COLUMN gtcloan.renewalamount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcloan.renewalamount IS 'Quantidade de renova';


--
-- Name: COLUMN gtcloan.renewalwebamount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcloan.renewalwebamount IS 'Valor das renova';


--
-- Name: COLUMN gtcloan.renewalwebbonus; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcloan.renewalwebbonus IS 'Se este campo for verdadeiro, reinicia o campo renewalWebAmount a cada renova';


--
-- Name: seq_loanbetweenlibraryid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_loanbetweenlibraryid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_loanbetweenlibraryid OWNER TO postgres;

--
-- Name: gtcloanbetweenlibrary; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcloanbetweenlibrary (
    loanbetweenlibraryid integer DEFAULT nextval('seq_loanbetweenlibraryid'::regclass) NOT NULL,
    loandate timestamp without time zone NOT NULL,
    returnforecastdate timestamp without time zone NOT NULL,
    returndate timestamp without time zone,
    limitdate timestamp without time zone,
    libraryunitid integer,
    personid bigint,
    loanbetweenlibrarystatusid integer NOT NULL,
    observation text
);


ALTER TABLE public.gtcloanbetweenlibrary OWNER TO postgres;

--
-- Name: TABLE gtcloanbetweenlibrary; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcloanbetweenlibrary IS 'emprestimos';


--
-- Name: COLUMN gtcloanbetweenlibrary.loanbetweenlibraryid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcloanbetweenlibrary.loanbetweenlibraryid IS 'Identificador do emprestimo';


--
-- Name: COLUMN gtcloanbetweenlibrary.loandate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcloanbetweenlibrary.loandate IS 'Data e hora do empr';


--
-- Name: COLUMN gtcloanbetweenlibrary.returnforecastdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcloanbetweenlibrary.returnforecastdate IS 'Data prevista para devolu';


--
-- Name: COLUMN gtcloanbetweenlibrary.returndate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcloanbetweenlibrary.returndate IS 'Data da devolu';


--
-- Name: gtcloanbetweenlibrarycomposition; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcloanbetweenlibrarycomposition (
    loanbetweenlibraryid integer NOT NULL,
    itemnumber character varying(20) NOT NULL,
    isconfirmed boolean NOT NULL
);


ALTER TABLE public.gtcloanbetweenlibrarycomposition OWNER TO postgres;

--
-- Name: TABLE gtcloanbetweenlibrarycomposition; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcloanbetweenlibrarycomposition IS 'composi';


--
-- Name: COLUMN gtcloanbetweenlibrarycomposition.loanbetweenlibraryid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcloanbetweenlibrarycomposition.loanbetweenlibraryid IS 'Identificador do emprestimo';


--
-- Name: COLUMN gtcloanbetweenlibrarycomposition.itemnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcloanbetweenlibrarycomposition.itemnumber IS 'Data e hora do empr';


--
-- Name: COLUMN gtcloanbetweenlibrarycomposition.isconfirmed; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcloanbetweenlibrarycomposition.isconfirmed IS 'Data prevista para devolu';


--
-- Name: seq_loanbetweenlibrarystatusid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_loanbetweenlibrarystatusid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_loanbetweenlibrarystatusid OWNER TO postgres;

--
-- Name: gtcloanbetweenlibrarystatus; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcloanbetweenlibrarystatus (
    loanbetweenlibrarystatusid integer DEFAULT nextval('seq_loanbetweenlibrarystatusid'::regclass) NOT NULL,
    description character varying(40) NOT NULL
);


ALTER TABLE public.gtcloanbetweenlibrarystatus OWNER TO postgres;

--
-- Name: TABLE gtcloanbetweenlibrarystatus; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcloanbetweenlibrarystatus IS 'estado dos empr';


--
-- Name: COLUMN gtcloanbetweenlibrarystatus.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcloanbetweenlibrarystatus.description IS 'Descri';


--
-- Name: gtcloanbetweenlibrarystatushistory; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcloanbetweenlibrarystatushistory (
    loanbetweenlibraryid integer NOT NULL,
    loanbetweenlibrarystatusid integer NOT NULL,
    date timestamp without time zone NOT NULL,
    operator character varying(30) NOT NULL
);


ALTER TABLE public.gtcloanbetweenlibrarystatushistory OWNER TO postgres;

--
-- Name: TABLE gtcloanbetweenlibrarystatushistory; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcloanbetweenlibrarystatushistory IS 'mantem o historico dos emprestimos entre bibliotecas';


--
-- Name: COLUMN gtcloanbetweenlibrarystatushistory.loanbetweenlibraryid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcloanbetweenlibrarystatushistory.loanbetweenlibraryid IS 'Identifica';


--
-- Name: COLUMN gtcloanbetweenlibrarystatushistory.loanbetweenlibrarystatusid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcloanbetweenlibrarystatushistory.loanbetweenlibrarystatusid IS 'Estado da reserva';


--
-- Name: COLUMN gtcloanbetweenlibrarystatushistory.date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcloanbetweenlibrarystatushistory.date IS 'Cado o exemplar volta ela se torna confirmada';


--
-- Name: seq_loantypeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_loantypeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_loantypeid OWNER TO postgres;

--
-- Name: gtcloantype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcloantype (
    loantypeid integer DEFAULT nextval('seq_loantypeid'::regclass) NOT NULL,
    description character varying(40) NOT NULL
);


ALTER TABLE public.gtcloantype OWNER TO postgres;

--
-- Name: TABLE gtcloantype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcloantype IS 'identifica tipos de empr';


--
-- Name: COLUMN gtcloantype.loantypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcloantype.loantypeid IS 'Identificador do tipo de emprestimo';


--
-- Name: COLUMN gtcloantype.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcloantype.description IS 'Descri';


--
-- Name: seq_locationformaterialmovementid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_locationformaterialmovementid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_locationformaterialmovementid OWNER TO postgres;

--
-- Name: gtclocationformaterialmovement; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtclocationformaterialmovement (
    locationformaterialmovementid integer DEFAULT nextval('seq_locationformaterialmovementid'::regclass) NOT NULL,
    description character varying(40) NOT NULL,
    observation text,
    sendloanreceiptbyemail boolean,
    sendrenewreceiptbyemail boolean,
    sendreturnreceiptbyemail boolean
);


ALTER TABLE public.gtclocationformaterialmovement OWNER TO postgres;

--
-- Name: TABLE gtclocationformaterialmovement; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtclocationformaterialmovement IS 'local para circula';


--
-- Name: COLUMN gtclocationformaterialmovement.locationformaterialmovementid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclocationformaterialmovement.locationformaterialmovementid IS 'Identificador do local para circula';


--
-- Name: COLUMN gtclocationformaterialmovement.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtclocationformaterialmovement.description IS 'Descri';


--
-- Name: seq_marctaglistingid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_marctaglistingid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_marctaglistingid OWNER TO postgres;

--
-- Name: gtcmarctaglisting; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcmarctaglisting (
    marctaglistingid character varying DEFAULT nextval('seq_marctaglistingid'::regclass) NOT NULL,
    description character varying NOT NULL
);


ALTER TABLE public.gtcmarctaglisting OWNER TO postgres;

--
-- Name: gtcmarctaglistingoption; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcmarctaglistingoption (
    marctaglistingid character varying,
    option text,
    description character varying
);


ALTER TABLE public.gtcmarctaglistingoption OWNER TO postgres;

--
-- Name: seq_controlnumber; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_controlnumber
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_controlnumber OWNER TO postgres;

--
-- Name: gtcmaterial; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcmaterial (
    controlnumber integer DEFAULT nextval('seq_controlnumber'::regclass) NOT NULL,
    fieldid character varying(3) NOT NULL,
    subfieldid character varying(1) NOT NULL,
    line integer NOT NULL,
    indicator1 character varying(1),
    indicator2 character varying(1),
    content text,
    searchcontent text,
    prefixid integer,
    suffixid integer,
    separatorid integer,
    searchcontentforsearchmodule text
);


ALTER TABLE public.gtcmaterial OWNER TO postgres;

--
-- Name: TABLE gtcmaterial; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcmaterial IS 'armazena os materias no padr';


--
-- Name: gtcmaterialcontrol; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcmaterialcontrol (
    controlnumber integer NOT NULL,
    controlnumberfather integer,
    entrancedate date NOT NULL,
    lastchangedate date NOT NULL,
    category character varying(2) NOT NULL,
    level character varying(1) NOT NULL,
    materialgenderid integer,
    materialtypeid integer,
    materialphysicaltypeid integer,
    lastchangeoperator character varying(255) DEFAULT 'gnuteca3'::character varying NOT NULL
);


ALTER TABLE public.gtcmaterialcontrol OWNER TO postgres;

--
-- Name: TABLE gtcmaterialcontrol; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcmaterialcontrol IS 'armazena os exemplares';


--
-- Name: COLUMN gtcmaterialcontrol.controlnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcmaterialcontrol.controlnumber IS 'Identificador da obra';


--
-- Name: seq_materialevaluationid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_materialevaluationid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_materialevaluationid OWNER TO postgres;

--
-- Name: gtcmaterialevaluation; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcmaterialevaluation (
    materialevaluationid integer DEFAULT nextval('seq_materialevaluationid'::regclass) NOT NULL,
    controlnumber integer NOT NULL,
    personid bigint NOT NULL,
    date timestamp without time zone NOT NULL,
    comment text,
    evaluation integer
);


ALTER TABLE public.gtcmaterialevaluation OWNER TO postgres;

--
-- Name: seq_materialgenderid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_materialgenderid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_materialgenderid OWNER TO postgres;

--
-- Name: gtcmaterialgender; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcmaterialgender (
    materialgenderid integer DEFAULT nextval('seq_materialgenderid'::regclass) NOT NULL,
    description character varying
);


ALTER TABLE public.gtcmaterialgender OWNER TO postgres;

--
-- Name: seq_materialhistoryid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_materialhistoryid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_materialhistoryid OWNER TO postgres;

--
-- Name: gtcmaterialhistory; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcmaterialhistory (
    materialhistoryid integer DEFAULT nextval('seq_materialhistoryid'::regclass) NOT NULL,
    controlnumber integer NOT NULL,
    revisionnumber integer NOT NULL,
    operator character varying(30) NOT NULL,
    data timestamp without time zone NOT NULL,
    chancestype character(1) NOT NULL,
    fieldid character varying(3) NOT NULL,
    subfieldid character varying(1) NOT NULL,
    previousline integer,
    previousindicator1 character varying(1),
    previousindicator2 character varying(1),
    previouscontent text,
    currentline integer,
    currentindicator1 character varying(1),
    currentindicator2 character varying(1),
    currentcontent text,
    previousprefixid integer,
    previoussuffixid integer,
    previousseparatorid integer,
    currentprefixid integer,
    currentsuffixid integer,
    currentseparatorid integer
);


ALTER TABLE public.gtcmaterialhistory OWNER TO postgres;

--
-- Name: TABLE gtcmaterialhistory; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcmaterialhistory IS 'armazena os materias no padr';


--
-- Name: COLUMN gtcmaterialhistory.chancestype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcmaterialhistory.chancestype IS 'I - insert U - update D - delete';


--
-- Name: gtcmateriallocation; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcmateriallocation (
    materiallocationid integer NOT NULL,
    name character varying(255),
    libraryunitid integer NOT NULL
);


ALTER TABLE public.gtcmateriallocation OWNER TO postgres;

--
-- Name: gtcmateriallocationtag; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcmateriallocationtag (
    materiallocationtagid integer NOT NULL,
    type character(1),
    fieldid integer,
    subfieldidid character(1),
    rule character(1),
    content text,
    gtcmateriallocatioid integer NOT NULL
);


ALTER TABLE public.gtcmateriallocationtag OWNER TO postgres;

--
-- Name: seq_materialphysicaltypeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_materialphysicaltypeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_materialphysicaltypeid OWNER TO postgres;

--
-- Name: gtcmaterialphysicaltype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcmaterialphysicaltype (
    materialphysicaltypeid integer DEFAULT nextval('seq_materialphysicaltypeid'::regclass) NOT NULL,
    description character varying NOT NULL,
    image text,
    observation text
);


ALTER TABLE public.gtcmaterialphysicaltype OWNER TO postgres;

--
-- Name: seq_materialtypeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_materialtypeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_materialtypeid OWNER TO postgres;

--
-- Name: gtcmaterialtype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcmaterialtype (
    materialtypeid integer DEFAULT nextval('seq_materialtypeid'::regclass) NOT NULL,
    description character varying NOT NULL,
    isrestricted boolean NOT NULL,
    level integer,
    observation text
);


ALTER TABLE public.gtcmaterialtype OWNER TO postgres;

--
-- Name: seq_mylibraryid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_mylibraryid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_mylibraryid OWNER TO postgres;

--
-- Name: gtcmylibrary; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcmylibrary (
    mylibraryid integer DEFAULT nextval('seq_mylibraryid'::regclass) NOT NULL,
    personid bigint NOT NULL,
    tablename character varying(255),
    tableid character varying(255),
    date timestamp without time zone NOT NULL,
    message text NOT NULL,
    visible boolean NOT NULL
);


ALTER TABLE public.gtcmylibrary OWNER TO postgres;

--
-- Name: COLUMN gtcmylibrary.mylibraryid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcmylibrary.mylibraryid IS 'Código da minha biblioteca';


--
-- Name: gtcmylibrary_mylibraryid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE gtcmylibrary_mylibraryid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.gtcmylibrary_mylibraryid_seq OWNER TO postgres;

--
-- Name: gtcmylibrary_mylibraryid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE gtcmylibrary_mylibraryid_seq OWNED BY gtcmylibrary.mylibraryid;


--
-- Name: seq_newsid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_newsid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_newsid OWNER TO postgres;

--
-- Name: gtcnews; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcnews (
    newsid integer DEFAULT nextval('seq_newsid'::regclass) NOT NULL,
    place integer NOT NULL,
    title1 character varying,
    news text,
    date timestamp without time zone NOT NULL,
    begindate timestamp without time zone,
    enddate timestamp without time zone,
    isrestricted boolean,
    isactive boolean,
    operator character varying(30),
    libraryunitid integer
);


ALTER TABLE public.gtcnews OWNER TO postgres;

--
-- Name: TABLE gtcnews; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcnews IS 'noticia';


--
-- Name: COLUMN gtcnews.newsid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcnews.newsid IS 'Identifica';


--
-- Name: COLUMN gtcnews.place; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcnews.place IS '1 - Minha biblioteca, 2 - Tela inicial, 3 - Pesquisa';


--
-- Name: gtcnewsaccess; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcnewsaccess (
    newsid integer NOT NULL,
    linkid integer NOT NULL
);


ALTER TABLE public.gtcnewsaccess OWNER TO postgres;

--
-- Name: TABLE gtcnewsaccess; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcnewsaccess IS 'identifica os grupos que ter';


--
-- Name: gtcoperation; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcoperation (
    operationid integer DEFAULT nextval('seq_operationid'::regclass) NOT NULL,
    description character varying(100) NOT NULL,
    definerule boolean
);


ALTER TABLE public.gtcoperation OWNER TO postgres;

--
-- Name: TABLE gtcoperation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcoperation IS 'operacoes';


--
-- Name: COLUMN gtcoperation.operationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcoperation.operationid IS 'Identificador da operacao';


--
-- Name: COLUMN gtcoperation.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcoperation.description IS 'Descricao';


--
-- Name: gtcoperatorlibraryunit; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcoperatorlibraryunit (
    operator character varying NOT NULL,
    libraryunitid integer
);


ALTER TABLE public.gtcoperatorlibraryunit OWNER TO postgres;

--
-- Name: seq_penaltyid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_penaltyid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_penaltyid OWNER TO postgres;

--
-- Name: gtcpenalty; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcpenalty (
    penaltyid integer DEFAULT nextval('seq_penaltyid'::regclass) NOT NULL,
    personid bigint NOT NULL,
    libraryunitid integer,
    observation text,
    internalobservation text,
    penaltydate timestamp without time zone NOT NULL,
    penaltyenddate timestamp without time zone,
    operator character varying(30) NOT NULL
);


ALTER TABLE public.gtcpenalty OWNER TO postgres;

--
-- Name: TABLE gtcpenalty; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcpenalty IS 'penalidade';


--
-- Name: COLUMN gtcpenalty.penaltyid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcpenalty.penaltyid IS 'Identifica';


--
-- Name: COLUMN gtcpenalty.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcpenalty.personid IS 'C';


--
-- Name: COLUMN gtcpenalty.observation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcpenalty.observation IS 'Descri';


--
-- Name: COLUMN gtcpenalty.penaltydate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcpenalty.penaltydate IS 'Data da inclus';


--
-- Name: COLUMN gtcpenalty.penaltyenddate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcpenalty.penaltyenddate IS 'Data de final da penalidade.';


--
-- Name: COLUMN gtcpenalty.operator; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcpenalty.operator IS 'Usu';


--
-- Name: gtcpersonconfig; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcpersonconfig (
    personid bigint NOT NULL,
    parameter text NOT NULL,
    value text
);


ALTER TABLE public.gtcpersonconfig OWNER TO postgres;

--
-- Name: TABLE gtcpersonconfig; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcpersonconfig IS 'configuracoes do sistema';


--
-- Name: COLUMN gtcpersonconfig.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcpersonconfig.personid IS 'Modulo do parametro';


--
-- Name: COLUMN gtcpersonconfig.parameter; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcpersonconfig.parameter IS 'Parametro';


--
-- Name: COLUMN gtcpersonconfig.value; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcpersonconfig.value IS 'Valor';


--
-- Name: gtcpersonlibraryunit; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcpersonlibraryunit (
    libraryunitid integer NOT NULL,
    personid bigint NOT NULL
);


ALTER TABLE public.gtcpersonlibraryunit OWNER TO postgres;

--
-- Name: TABLE gtcpersonlibraryunit; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcpersonlibraryunit IS 'reservas';


--
-- Name: COLUMN gtcpersonlibraryunit.libraryunitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcpersonlibraryunit.libraryunitid IS 'C';


--
-- Name: COLUMN gtcpersonlibraryunit.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcpersonlibraryunit.personid IS 'C';


--
-- Name: gtcpolicy; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcpolicy (
    privilegegroupid integer NOT NULL,
    linkid integer NOT NULL,
    materialgenderid integer NOT NULL,
    loandays integer,
    loandate date,
    loanlimit integer,
    renewallimit integer,
    reservelimit integer,
    daysofwaitforreserve integer,
    reservelimitininitiallevel integer,
    daysofwaitforreserveininitiallevel integer,
    finevalue double precision,
    renewalweblimit integer,
    renewalwebbonus boolean,
    additionaldaysforholidays integer,
    penaltybydelay double precision,
    momentaryfinevalue double precision
);


ALTER TABLE public.gtcpolicy OWNER TO postgres;

--
-- Name: TABLE gtcpolicy; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcpolicy IS 'numero maximo de reservas de nivel inicial - disponivel, congelado, etc';


--
-- Name: COLUMN gtcpolicy.penaltybydelay; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcpolicy.penaltybydelay IS 'Número de dias aplicado para cada dia de atraso';


--
-- Name: gtcprecatalogue; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcprecatalogue (
    controlnumber integer NOT NULL,
    fieldid character varying(3) NOT NULL,
    subfieldid character varying(1) NOT NULL,
    line integer NOT NULL,
    indicator1 character varying(1),
    indicator2 character varying(1),
    content text,
    searchcontent text,
    prefixid integer,
    suffixid integer,
    separatorid integer
);


ALTER TABLE public.gtcprecatalogue OWNER TO postgres;

--
-- Name: TABLE gtcprecatalogue; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcprecatalogue IS 'armazena temporariamente os materias no padr';


--
-- Name: seq_prefixsuffixid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_prefixsuffixid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_prefixsuffixid OWNER TO postgres;

--
-- Name: gtcprefixsuffix; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcprefixsuffix (
    prefixsuffixid integer DEFAULT nextval('seq_prefixsuffixid'::regclass) NOT NULL,
    fieldid character varying(3) NOT NULL,
    subfieldid character varying(1) NOT NULL,
    content character varying NOT NULL,
    type integer
);


ALTER TABLE public.gtcprefixsuffix OWNER TO postgres;

--
-- Name: TABLE gtcprefixsuffix; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcprefixsuffix IS 'tabela para prefixos e sufixos';


--
-- Name: COLUMN gtcprefixsuffix.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcprefixsuffix.type IS '1 - prefix 2 - suffix';


--
-- Name: seq_privilegegroupid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_privilegegroupid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_privilegegroupid OWNER TO postgres;

--
-- Name: gtcprivilegegroup; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcprivilegegroup (
    privilegegroupid integer DEFAULT nextval('seq_privilegegroupid'::regclass) NOT NULL,
    description character varying(50) NOT NULL
);


ALTER TABLE public.gtcprivilegegroup OWNER TO postgres;

--
-- Name: TABLE gtcprivilegegroup; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcprivilegegroup IS 'grupo de privilegio. relaciona as unidade com pol';


--
-- Name: seq_gtcpurchaserequest; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_gtcpurchaserequest
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_gtcpurchaserequest OWNER TO postgres;

--
-- Name: gtcpurchaserequest; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcpurchaserequest (
    purchaserequestid integer DEFAULT nextval('seq_gtcpurchaserequest'::regclass) NOT NULL,
    libraryunitid integer NOT NULL,
    personid bigint NOT NULL,
    costcenterid integer,
    amount integer NOT NULL,
    course character varying(255),
    observation text,
    needdelivery date,
    forecastdelivery date,
    deliverydate date,
    voucher integer,
    controlnumber integer,
    precontrolnumber integer,
    externalid character varying(255)
);


ALTER TABLE public.gtcpurchaserequest OWNER TO postgres;

--
-- Name: gtcpurchaserequestmaterial; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcpurchaserequestmaterial (
    purchaserequestid integer NOT NULL,
    fieldid character varying(3) NOT NULL,
    subfieldid character varying(1) NOT NULL,
    content text NOT NULL
);


ALTER TABLE public.gtcpurchaserequestmaterial OWNER TO postgres;

--
-- Name: gtcpurchaserequestquotation; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcpurchaserequestquotation (
    purchaserequestid integer NOT NULL,
    supplierid integer NOT NULL,
    value real NOT NULL,
    observation text
);


ALTER TABLE public.gtcpurchaserequestquotation OWNER TO postgres;

--
-- Name: gtcpurchaserequestquotation_supplierid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE gtcpurchaserequestquotation_supplierid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.gtcpurchaserequestquotation_supplierid_seq OWNER TO postgres;

--
-- Name: gtcpurchaserequestquotation_supplierid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE gtcpurchaserequestquotation_supplierid_seq OWNED BY gtcpurchaserequestquotation.supplierid;


--
-- Name: seq_renewid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_renewid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_renewid OWNER TO postgres;

--
-- Name: gtcrenew; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcrenew (
    renewid integer DEFAULT nextval('seq_renewid'::regclass) NOT NULL,
    loanid integer NOT NULL,
    renewtypeid integer,
    renewdate timestamp without time zone,
    returnforecastdate timestamp without time zone NOT NULL,
    operator character varying(30) NOT NULL
);


ALTER TABLE public.gtcrenew OWNER TO postgres;

--
-- Name: TABLE gtcrenew; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcrenew IS 'renovacao';


--
-- Name: COLUMN gtcrenew.renewid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcrenew.renewid IS 'Identifica';


--
-- Name: COLUMN gtcrenew.loanid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcrenew.loanid IS 'C';


--
-- Name: COLUMN gtcrenew.renewdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcrenew.renewdate IS 'Data e hora da renovacao';


--
-- Name: COLUMN gtcrenew.returnforecastdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcrenew.returnforecastdate IS 'Data da inclus';


--
-- Name: COLUMN gtcrenew.operator; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcrenew.operator IS 'Usu';


--
-- Name: seq_renewtypeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_renewtypeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_renewtypeid OWNER TO postgres;

--
-- Name: gtcrenewtype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcrenewtype (
    renewtypeid integer DEFAULT nextval('seq_renewtypeid'::regclass) NOT NULL,
    description character varying(40) NOT NULL
);


ALTER TABLE public.gtcrenewtype OWNER TO postgres;

--
-- Name: TABLE gtcrenewtype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcrenewtype IS 'identifica tipos de renovacao.';


--
-- Name: COLUMN gtcrenewtype.renewtypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcrenewtype.renewtypeid IS 'Identificador do tipo de renovaca';


--
-- Name: COLUMN gtcrenewtype.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcrenewtype.description IS 'Descri';


--
-- Name: gtcreport; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcreport (
    reportid character varying(20) NOT NULL,
    title character varying NOT NULL,
    description text,
    permission character varying NOT NULL,
    reportsql text,
    reportsubsql text,
    script text,
    model character varying,
    isactive boolean NOT NULL,
    reportgroup character varying,
    CONSTRAINT chk_gtcreport_reportgroup CHECK (gtc_chk_domain('REPORT_GROUP'::character varying, reportgroup))
);


ALTER TABLE public.gtcreport OWNER TO postgres;

--
-- Name: TABLE gtcreport; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcreport IS 'relatorios';


--
-- Name: gtcreportparameter; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcreportparameter (
    reportparameterid integer DEFAULT nextval('seq_reportparameterid'::regclass) NOT NULL,
    reportid character varying(20) NOT NULL,
    label character varying NOT NULL,
    identifier character varying NOT NULL,
    type character varying NOT NULL,
    defaultvalue character varying,
    options text,
    lastvalue character varying,
    level integer
);


ALTER TABLE public.gtcreportparameter OWNER TO postgres;

--
-- Name: TABLE gtcreportparameter; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcreportparameter IS 'parametros do relatorios';


--
-- Name: seq_requestchangeexemplarystatusid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_requestchangeexemplarystatusid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_requestchangeexemplarystatusid OWNER TO postgres;

--
-- Name: gtcrequestchangeexemplarystatus; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcrequestchangeexemplarystatus (
    requestchangeexemplarystatusid integer DEFAULT nextval('seq_requestchangeexemplarystatusid'::regclass) NOT NULL,
    futurestatusid integer NOT NULL,
    personid bigint NOT NULL,
    observation text,
    date timestamp without time zone NOT NULL,
    finaldate timestamp without time zone NOT NULL,
    requestchangeexemplarystatusstatusid integer NOT NULL,
    libraryunitid integer NOT NULL,
    aprovejustone boolean DEFAULT true,
    discipline character varying
);


ALTER TABLE public.gtcrequestchangeexemplarystatus OWNER TO postgres;

--
-- Name: TABLE gtcrequestchangeexemplarystatus; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcrequestchangeexemplarystatus IS 'estado do exemplar';


--
-- Name: COLUMN gtcrequestchangeexemplarystatus.requestchangeexemplarystatusstatusid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcrequestchangeexemplarystatus.requestchangeexemplarystatusstatusid IS 'referencia tabela de possiveis estados';


--
-- Name: COLUMN gtcrequestchangeexemplarystatus.libraryunitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcrequestchangeexemplarystatus.libraryunitid IS 'referencia biblioteca';


--
-- Name: COLUMN gtcrequestchangeexemplarystatus.discipline; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcrequestchangeexemplarystatus.discipline IS 'Disciplina (mat';


--
-- Name: gtcrequestchangeexemplarystatusaccess; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcrequestchangeexemplarystatusaccess (
    baslinkid integer NOT NULL,
    exemplarystatusid integer NOT NULL
);


ALTER TABLE public.gtcrequestchangeexemplarystatusaccess OWNER TO postgres;

--
-- Name: gtcrequestchangeexemplarystatuscomposition; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcrequestchangeexemplarystatuscomposition (
    requestchangeexemplarystatusid integer NOT NULL,
    itemnumber character varying(20) NOT NULL,
    exemplaryfuturestatusdefinedid integer,
    confirm boolean DEFAULT false,
    date timestamp without time zone NOT NULL,
    applied boolean DEFAULT false
);


ALTER TABLE public.gtcrequestchangeexemplarystatuscomposition OWNER TO postgres;

--
-- Name: TABLE gtcrequestchangeexemplarystatuscomposition; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcrequestchangeexemplarystatuscomposition IS 'quando o administrador permite a requisi';


--
-- Name: COLUMN gtcrequestchangeexemplarystatuscomposition.applied; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcrequestchangeexemplarystatuscomposition.applied IS 'quando a requisi';


--
-- Name: seq_requestchangeexemplarystatusstatusid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_requestchangeexemplarystatusstatusid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_requestchangeexemplarystatusstatusid OWNER TO postgres;

--
-- Name: gtcrequestchangeexemplarystatusstatus; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcrequestchangeexemplarystatusstatus (
    requestchangeexemplarystatusstatusid integer DEFAULT nextval('seq_requestchangeexemplarystatusstatusid'::regclass) NOT NULL,
    description character varying(40) NOT NULL
);


ALTER TABLE public.gtcrequestchangeexemplarystatusstatus OWNER TO postgres;

--
-- Name: gtcrequestchangeexemplarystatusstatushistory; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcrequestchangeexemplarystatusstatushistory (
    requestchangeexemplarystatusid integer NOT NULL,
    requestchangeexemplarystatusstatusid integer NOT NULL,
    date timestamp without time zone NOT NULL,
    operator character varying(40) NOT NULL
);


ALTER TABLE public.gtcrequestchangeexemplarystatusstatushistory OWNER TO postgres;

--
-- Name: seq_reserveid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_reserveid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_reserveid OWNER TO postgres;

--
-- Name: gtcreserve; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcreserve (
    reserveid integer DEFAULT nextval('seq_reserveid'::regclass) NOT NULL,
    libraryunitid integer,
    personid bigint NOT NULL,
    requesteddate timestamp without time zone NOT NULL,
    limitdate timestamp without time zone,
    reservestatusid integer NOT NULL,
    reservetypeid integer NOT NULL
);


ALTER TABLE public.gtcreserve OWNER TO postgres;

--
-- Name: TABLE gtcreserve; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcreserve IS 'reservas';


--
-- Name: COLUMN gtcreserve.reserveid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcreserve.reserveid IS 'Identificador da reserva';


--
-- Name: COLUMN gtcreserve.libraryunitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcreserve.libraryunitid IS 'C';


--
-- Name: COLUMN gtcreserve.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcreserve.personid IS 'C';


--
-- Name: COLUMN gtcreserve.limitdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcreserve.limitdate IS 'Data limite de esprera. ';


--
-- Name: COLUMN gtcreserve.reservestatusid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcreserve.reservestatusid IS 'C';


--
-- Name: gtcreservecomposition; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcreservecomposition (
    reserveid integer NOT NULL,
    itemnumber character varying(20) NOT NULL,
    isconfirmed boolean DEFAULT false
);


ALTER TABLE public.gtcreservecomposition OWNER TO postgres;

--
-- Name: TABLE gtcreservecomposition; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcreservecomposition IS 'composi';


--
-- Name: COLUMN gtcreservecomposition.reserveid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcreservecomposition.reserveid IS 'Identifica';


--
-- Name: COLUMN gtcreservecomposition.itemnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcreservecomposition.itemnumber IS 'N';


--
-- Name: COLUMN gtcreservecomposition.isconfirmed; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcreservecomposition.isconfirmed IS 'Cado o exemplar volta ela se torna confirmada';


--
-- Name: seq_reservestatusid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_reservestatusid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_reservestatusid OWNER TO postgres;

--
-- Name: gtcreservestatus; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcreservestatus (
    reservestatusid integer DEFAULT nextval('seq_reservestatusid'::regclass) NOT NULL,
    description character varying(40) NOT NULL
);


ALTER TABLE public.gtcreservestatus OWNER TO postgres;

--
-- Name: TABLE gtcreservestatus; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcreservestatus IS 'estado da reserva';


--
-- Name: COLUMN gtcreservestatus.reservestatusid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcreservestatus.reservestatusid IS 'Identificador da situa';


--
-- Name: COLUMN gtcreservestatus.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcreservestatus.description IS 'Descri';


--
-- Name: gtcreservestatushistory; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcreservestatushistory (
    reserveid integer NOT NULL,
    reservestatusid integer NOT NULL,
    date timestamp without time zone NOT NULL,
    operator character varying(30) NOT NULL
);


ALTER TABLE public.gtcreservestatushistory OWNER TO postgres;

--
-- Name: TABLE gtcreservestatushistory; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcreservestatushistory IS 'mantem o historico das trocas de estado';


--
-- Name: COLUMN gtcreservestatushistory.reserveid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcreservestatushistory.reserveid IS 'Identifica';


--
-- Name: COLUMN gtcreservestatushistory.reservestatusid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcreservestatushistory.reservestatusid IS 'Estado da reserva';


--
-- Name: COLUMN gtcreservestatushistory.date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcreservestatushistory.date IS 'Cado o exemplar volta ela se torna confirmada';


--
-- Name: seq_reservetypeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_reservetypeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_reservetypeid OWNER TO postgres;

--
-- Name: gtcreservetype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcreservetype (
    reservetypeid integer DEFAULT nextval('seq_reservetypeid'::regclass) NOT NULL,
    description character varying(40) NOT NULL
);


ALTER TABLE public.gtcreservetype OWNER TO postgres;

--
-- Name: TABLE gtcreservetype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcreservetype IS 'identifica tipos de reserva.';


--
-- Name: COLUMN gtcreservetype.reservetypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcreservetype.reservetypeid IS 'Identificador do tipo de reserva';


--
-- Name: COLUMN gtcreservetype.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcreservetype.description IS 'Descri';


--
-- Name: seq_returnregisterid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_returnregisterid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_returnregisterid OWNER TO postgres;

--
-- Name: gtcreturnregister; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcreturnregister (
    returnregisterid integer DEFAULT nextval('seq_returnregisterid'::regclass) NOT NULL,
    returntypeid integer NOT NULL,
    itemnumber character varying(20) NOT NULL,
    date timestamp without time zone NOT NULL,
    operator character varying(30) NOT NULL
);


ALTER TABLE public.gtcreturnregister OWNER TO postgres;

--
-- Name: TABLE gtcreturnregister; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcreturnregister IS 'registra as devolu';


--
-- Name: seq_returntypeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_returntypeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_returntypeid OWNER TO postgres;

--
-- Name: gtcreturntype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcreturntype (
    returntypeid integer DEFAULT nextval('seq_returntypeid'::regclass) NOT NULL,
    description character varying(250) NOT NULL,
    sendmailreturnreceipt boolean
);


ALTER TABLE public.gtcreturntype OWNER TO postgres;

--
-- Name: TABLE gtcreturntype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcreturntype IS 'define os tipos de devolu';


--
-- Name: gtcright; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcright (
    privilegegroupid integer NOT NULL,
    linkid integer NOT NULL,
    materialgenderid integer NOT NULL,
    operationid integer NOT NULL
);


ALTER TABLE public.gtcright OWNER TO postgres;

--
-- Name: gtcrulesformaterialmovement; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcrulesformaterialmovement (
    currentstate integer NOT NULL,
    operationid integer NOT NULL,
    locationformaterialmovementid integer NOT NULL,
    futurestate integer NOT NULL
);


ALTER TABLE public.gtcrulesformaterialmovement OWNER TO postgres;

--
-- Name: TABLE gtcrulesformaterialmovement; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcrulesformaterialmovement IS 'regras para circulacao de material';


--
-- Name: COLUMN gtcrulesformaterialmovement.currentstate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcrulesformaterialmovement.currentstate IS 'Estado atual';


--
-- Name: COLUMN gtcrulesformaterialmovement.operationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcrulesformaterialmovement.operationid IS 'Identificador da operacao';


--
-- Name: COLUMN gtcrulesformaterialmovement.locationformaterialmovementid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcrulesformaterialmovement.locationformaterialmovementid IS 'Identificacao do local para circulacao do material';


--
-- Name: COLUMN gtcrulesformaterialmovement.futurestate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcrulesformaterialmovement.futurestate IS 'Estado futuro';


--
-- Name: seq_rulestocompletefieldsmarcid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_rulestocompletefieldsmarcid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_rulestocompletefieldsmarcid OWNER TO postgres;

--
-- Name: gtcrulestocompletefieldsmarc; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcrulestocompletefieldsmarc (
    rulestocompletefieldsmarcid integer DEFAULT nextval('seq_rulestocompletefieldsmarcid'::regclass) NOT NULL,
    category character varying(2) NOT NULL,
    originfield text NOT NULL,
    fatefield text NOT NULL,
    affectrecordscompleted boolean
);


ALTER TABLE public.gtcrulestocompletefieldsmarc OWNER TO postgres;

--
-- Name: TABLE gtcrulestocompletefieldsmarc; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcrulestocompletefieldsmarc IS 'regras para preenchimento de campos marc';


--
-- Name: COLUMN gtcrulestocompletefieldsmarc.affectrecordscompleted; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcrulestocompletefieldsmarc.affectrecordscompleted IS 'Se for true altera os registros com valor';


--
-- Name: gtcschedulecycle; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcschedulecycle (
    schedulecycleid integer NOT NULL,
    description character varying NOT NULL,
    valuetype character varying NOT NULL
);


ALTER TABLE public.gtcschedulecycle OWNER TO postgres;

--
-- Name: TABLE gtcschedulecycle; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcschedulecycle IS 'ciclos de agendamento';


--
-- Name: gtcscheduletask; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcscheduletask (
    scheduletaskid integer NOT NULL,
    taskid integer NOT NULL,
    schedulecycleid integer NOT NULL,
    description character varying NOT NULL,
    cyclevalue character varying NOT NULL,
    enable boolean DEFAULT true,
    parameters character varying
);


ALTER TABLE public.gtcscheduletask OWNER TO postgres;

--
-- Name: TABLE gtcscheduletask; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcscheduletask IS 'agendamento de tarefas';


--
-- Name: gtcscheduletasklog; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcscheduletasklog (
    scheduletaskid integer NOT NULL,
    log text NOT NULL,
    date timestamp without time zone NOT NULL,
    status character varying(50) NOT NULL
);


ALTER TABLE public.gtcscheduletasklog OWNER TO postgres;

--
-- Name: TABLE gtcscheduletasklog; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcscheduletasklog IS 'Log de tarefas realizadas';


--
-- Name: COLUMN gtcscheduletasklog.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcscheduletasklog.status IS 'Estado deste log';


--
-- Name: seq_searchablefieldid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_searchablefieldid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_searchablefieldid OWNER TO postgres;

--
-- Name: gtcsearchablefield; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcsearchablefield (
    searchablefieldid integer DEFAULT nextval('seq_searchablefieldid'::regclass) NOT NULL,
    description character varying NOT NULL,
    field character varying NOT NULL,
    identifier character varying NOT NULL,
    fieldtype integer,
    isrestricted boolean,
    level integer,
    observation text,
    helps character varying
);


ALTER TABLE public.gtcsearchablefield OWNER TO postgres;

--
-- Name: TABLE gtcsearchablefield; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcsearchablefield IS 'campos pesquisaveis';


--
-- Name: COLUMN gtcsearchablefield.fieldtype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsearchablefield.fieldtype IS '1 - Numerico, 2 - String';


--
-- Name: gtcsearchablefieldaccess; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcsearchablefieldaccess (
    searchablefieldid integer NOT NULL,
    linkid integer NOT NULL
);


ALTER TABLE public.gtcsearchablefieldaccess OWNER TO postgres;

--
-- Name: TABLE gtcsearchablefieldaccess; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcsearchablefieldaccess IS 'especifica o acesso para o formato da pesquisa';


--
-- Name: seq_searchformatid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_searchformatid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_searchformatid OWNER TO postgres;

--
-- Name: gtcsearchformat; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcsearchformat (
    searchformatid integer DEFAULT nextval('seq_searchformatid'::regclass) NOT NULL,
    description character varying NOT NULL,
    isrestricted boolean
);


ALTER TABLE public.gtcsearchformat OWNER TO postgres;

--
-- Name: TABLE gtcsearchformat; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcsearchformat IS 'formato da pesquisa';


--
-- Name: gtcsearchformataccess; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcsearchformataccess (
    searchformatid integer NOT NULL,
    linkid integer NOT NULL
);


ALTER TABLE public.gtcsearchformataccess OWNER TO postgres;

--
-- Name: TABLE gtcsearchformataccess; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcsearchformataccess IS 'especifica o acesso para o formato da pesquisa';


--
-- Name: gtcsearchformatcolumn; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcsearchformatcolumn (
    searchformatid integer NOT NULL,
    "column" character varying NOT NULL
);


ALTER TABLE public.gtcsearchformatcolumn OWNER TO postgres;

--
-- Name: TABLE gtcsearchformatcolumn; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcsearchformatcolumn IS 'especifica as colunas no search format';


--
-- Name: gtcsearchmaterialview; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcsearchmaterialview (
    controlnumber integer,
    entrancedate date,
    lastchangedate date,
    category character varying(2),
    level character varying(1),
    materialgenderid integer,
    materialtypeid integer,
    materialphysicaltypeid integer,
    exemplaryitemnumber character varying(20),
    exemplaryoriginallibraryunitid integer,
    exemplarylibraryunitid integer,
    exemplaryacquisitiontype character varying(1),
    exemplaryexemplarystatusid integer,
    exemplarymaterialgenderid integer,
    exemplarymaterialtypeid integer,
    exemplarymaterialphysicaltypeid integer,
    exemplaryentrancedate date,
    exemplarylowdate date
);


ALTER TABLE public.gtcsearchmaterialview OWNER TO postgres;

--
-- Name: gtcsearchpresentationformat; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcsearchpresentationformat (
    searchformatid integer NOT NULL,
    category character varying(2) NOT NULL,
    searchformat text NOT NULL,
    detailformat text NOT NULL
);


ALTER TABLE public.gtcsearchpresentationformat OWNER TO postgres;

--
-- Name: TABLE gtcsearchpresentationformat; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcsearchpresentationformat IS 'formato da apresentacao da pesquisa';


--
-- Name: gtcsearchtableupdatecontrol; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcsearchtableupdatecontrol (
    lastupdate timestamp without time zone
);


ALTER TABLE public.gtcsearchtableupdatecontrol OWNER TO postgres;

--
-- Name: seq_separatorid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_separatorid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_separatorid OWNER TO postgres;

--
-- Name: gtcseparator; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcseparator (
    separatorid integer DEFAULT nextval('seq_separatorid'::regclass) NOT NULL,
    cataloguingformatid integer NOT NULL,
    fieldid character varying(3) NOT NULL,
    subfieldid character varying(1) NOT NULL,
    content character varying NOT NULL,
    fieldid2 character varying(3) NOT NULL,
    subfieldid2 character varying(1) NOT NULL
);


ALTER TABLE public.gtcseparator OWNER TO postgres;

--
-- Name: TABLE gtcseparator; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcseparator IS 'tabela para separadores';


--
-- Name: gtcsession; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcsession (
    sessionid integer NOT NULL,
    sipequipamentid character varying(255) NOT NULL,
    personid bigint,
    isclosed boolean DEFAULT false NOT NULL
);


ALTER TABLE public.gtcsession OWNER TO postgres;

--
-- Name: COLUMN gtcsession.sessionid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsession.sessionid IS 'Código da sessão';


--
-- Name: COLUMN gtcsession.sipequipamentid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsession.sipequipamentid IS 'Código do equipamento sip';


--
-- Name: COLUMN gtcsession.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsession.personid IS 'Código da pessoa';


--
-- Name: COLUMN gtcsession.isclosed; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsession.isclosed IS 'Flag para determinar se a sessão está aberta ou fechada';


--
-- Name: gtcsession_sessionid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE gtcsession_sessionid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.gtcsession_sessionid_seq OWNER TO postgres;

--
-- Name: gtcsession_sessionid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE gtcsession_sessionid_seq OWNED BY gtcsession.sessionid;


--
-- Name: gtcsessionoperation; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcsessionoperation (
    sessionoperationid integer NOT NULL,
    sessionid integer NOT NULL,
    datetime timestamp without time zone DEFAULT now() NOT NULL,
    operation character(1) NOT NULL,
    loanid integer,
    returnregisterid integer,
    renewid integer
);


ALTER TABLE public.gtcsessionoperation OWNER TO postgres;

--
-- Name: COLUMN gtcsessionoperation.sessionoperationid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsessionoperation.sessionoperationid IS 'Código da operação da sessão';


--
-- Name: COLUMN gtcsessionoperation.sessionid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsessionoperation.sessionid IS 'Código da sessão';


--
-- Name: COLUMN gtcsessionoperation.datetime; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsessionoperation.datetime IS 'Data e hora do registro de operação';


--
-- Name: COLUMN gtcsessionoperation.operation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsessionoperation.operation IS 'Código da operação que está sendo realizada
Operação:
1-Empréstimo
2-Renovação';


--
-- Name: gtcsessionoperation_sessionoperationid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE gtcsessionoperation_sessionoperationid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.gtcsessionoperation_sessionoperationid_seq OWNER TO postgres;

--
-- Name: gtcsessionoperation_sessionoperationid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE gtcsessionoperation_sessionoperationid_seq OWNED BY gtcsessionoperation.sessionoperationid;


--
-- Name: gtcsipcirculationstatus; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcsipcirculationstatus (
    sipcirculationstatusid integer NOT NULL,
    exemplarystatusid integer NOT NULL
);


ALTER TABLE public.gtcsipcirculationstatus OWNER TO postgres;

--
-- Name: gtcsipequipament; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcsipequipament (
    sipequipamentid character varying(255) NOT NULL,
    password character varying(255),
    libraryunitid integer NOT NULL,
    makeloan boolean DEFAULT false NOT NULL,
    makereturn boolean DEFAULT false NOT NULL,
    makerenew boolean DEFAULT false NOT NULL,
    denyusercard boolean DEFAULT false NOT NULL,
    offlinemode boolean DEFAULT false NOT NULL,
    timeoutperiod integer,
    retriesallow integer,
    locationformaterialmovementid integer NOT NULL,
    bindefault character varying(255) NOT NULL,
    screenmessage text,
    printmessage text
);


ALTER TABLE public.gtcsipequipament OWNER TO postgres;

--
-- Name: COLUMN gtcsipequipament.sipequipamentid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsipequipament.sipequipamentid IS 'Código do equipamento Sip';


--
-- Name: COLUMN gtcsipequipament.password; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsipequipament.password IS 'Senha do equipamento Sip.';


--
-- Name: COLUMN gtcsipequipament.libraryunitid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsipequipament.libraryunitid IS 'Unidade de biblioteca';


--
-- Name: COLUMN gtcsipequipament.makeloan; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsipequipament.makeloan IS 'Define se equipamento realiza empréstimo';


--
-- Name: COLUMN gtcsipequipament.makereturn; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsipequipament.makereturn IS 'Define se equipamento realiza devolução';


--
-- Name: COLUMN gtcsipequipament.makerenew; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsipequipament.makerenew IS 'Define se equipamento realiza renovação';


--
-- Name: COLUMN gtcsipequipament.denyusercard; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsipequipament.denyusercard IS 'Define se equipamento bloqueia cartão de usuário';


--
-- Name: COLUMN gtcsipequipament.offlinemode; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsipequipament.offlinemode IS 'Define se equipamento trabalha em modo off-line';


--
-- Name: COLUMN gtcsipequipament.timeoutperiod; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsipequipament.timeoutperiod IS 'Define o timeout do equipamento';


--
-- Name: COLUMN gtcsipequipament.retriesallow; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsipequipament.retriesallow IS 'Quantidade de retentativas de conexão';


--
-- Name: COLUMN gtcsipequipament.locationformaterialmovementid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsipequipament.locationformaterialmovementid IS 'Define local de circulação de material do equipamento';


--
-- Name: COLUMN gtcsipequipament.bindefault; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsipequipament.bindefault IS 'Bin padrão para materiais';


--
-- Name: COLUMN gtcsipequipament.screenmessage; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsipequipament.screenmessage IS 'Define a mensagem que aparecerá na tela do equipamento';


--
-- Name: COLUMN gtcsipequipament.printmessage; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsipequipament.printmessage IS 'Define a mensagem que será impressa';


--
-- Name: gtcsipequipamentbinrules; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcsipequipamentbinrules (
    sipequipamentid character varying(255) NOT NULL,
    exemplarystatusid integer NOT NULL,
    bin character varying(255) NOT NULL
);


ALTER TABLE public.gtcsipequipamentbinrules OWNER TO postgres;

--
-- Name: COLUMN gtcsipequipamentbinrules.sipequipamentid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsipequipamentbinrules.sipequipamentid IS 'Código do equipamento sip
';


--
-- Name: COLUMN gtcsipequipamentbinrules.exemplarystatusid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsipequipamentbinrules.exemplarystatusid IS 'Código do estado do exemplar';


--
-- Name: COLUMN gtcsipequipamentbinrules.bin; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsipequipamentbinrules.bin IS 'Bin para onde exemplar é encaminhado de acordo com o estado do material';


--
-- Name: gtcsipequipamentlog; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcsipequipamentlog (
    sipequipamentlogid integer NOT NULL,
    sipequipamentid character varying(255) NOT NULL,
    datetime timestamp without time zone DEFAULT now() NOT NULL,
    status character(1) DEFAULT '1'::bpchar NOT NULL
);


ALTER TABLE public.gtcsipequipamentlog OWNER TO postgres;

--
-- Name: COLUMN gtcsipequipamentlog.sipequipamentlogid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsipequipamentlog.sipequipamentlogid IS 'Código do log do equipamento sip';


--
-- Name: COLUMN gtcsipequipamentlog.sipequipamentid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsipequipamentlog.sipequipamentid IS 'Código do equipamento sip';


--
-- Name: COLUMN gtcsipequipamentlog.datetime; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsipequipamentlog.datetime IS 'Data e hora do registro';


--
-- Name: COLUMN gtcsipequipamentlog.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsipequipamentlog.status IS 'Status do equipamento
Valores possiveis:
1 - OK
2 - Sem papel
3 - Desligando';


--
-- Name: gtcsipequipamentlog_sipequipamentlogid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE gtcsipequipamentlog_sipequipamentlogid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.gtcsipequipamentlog_sipequipamentlogid_seq OWNER TO postgres;

--
-- Name: gtcsipequipamentlog_sipequipamentlogid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE gtcsipequipamentlog_sipequipamentlogid_seq OWNED BY gtcsipequipamentlog.sipequipamentlogid;


--
-- Name: gtcsoapaccess; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcsoapaccess (
    soapclientid integer NOT NULL,
    webserviceid integer NOT NULL
);


ALTER TABLE public.gtcsoapaccess OWNER TO postgres;

--
-- Name: TABLE gtcsoapaccess; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcsoapaccess IS 'access soap';


--
-- Name: gtcsoapclient; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcsoapclient (
    soapclientid integer NOT NULL,
    clientdescription character varying,
    ip character varying NOT NULL,
    password character varying NOT NULL,
    enable boolean DEFAULT true
);


ALTER TABLE public.gtcsoapclient OWNER TO postgres;

--
-- Name: TABLE gtcsoapclient; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcsoapclient IS 'clientes soap';


--
-- Name: gtcspreadsheet; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcspreadsheet (
    category character varying(2) NOT NULL,
    level character varying(1) NOT NULL,
    field text NOT NULL,
    required text,
    repeatfieldrequired text,
    defaultvalue text,
    menuname character varying,
    menuoption character varying,
    menulevel integer
);


ALTER TABLE public.gtcspreadsheet OWNER TO postgres;

--
-- Name: TABLE gtcspreadsheet; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcspreadsheet IS 'armazenam o modelo das planilhas';


--
-- Name: COLUMN gtcspreadsheet.level; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcspreadsheet.level IS 'Nivel de catalogacao';


--
-- Name: COLUMN gtcspreadsheet.required; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcspreadsheet.required IS 'Campo obrigatorios';


--
-- Name: COLUMN gtcspreadsheet.defaultvalue; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcspreadsheet.defaultvalue IS 'Valor padrao de um campo marc';


--
-- Name: seq_supplierid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_supplierid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_supplierid OWNER TO postgres;

--
-- Name: gtcsupplier; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcsupplier (
    supplierid integer DEFAULT nextval('seq_supplierid'::regclass) NOT NULL,
    name character varying,
    companyname character varying,
    date timestamp without time zone
);


ALTER TABLE public.gtcsupplier OWNER TO postgres;

--
-- Name: TABLE gtcsupplier; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcsupplier IS 'fornecedor';


--
-- Name: COLUMN gtcsupplier.supplierid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsupplier.supplierid IS 'Identifica';


--
-- Name: gtcsuppliertypeandlocation; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcsuppliertypeandlocation (
    supplierid integer DEFAULT nextval('seq_supplierid'::regclass) NOT NULL,
    type character(1) NOT NULL,
    name character varying,
    companyname character varying,
    cnpj character varying,
    location character varying,
    neighborhood character varying,
    city character varying,
    zipcode character varying,
    phone character varying,
    fax character varying,
    alternativephone character varying,
    email character varying,
    alternativeemail character varying,
    contact character varying,
    site character varying,
    observation text,
    bankdeposit text,
    date timestamp without time zone,
    CONSTRAINT gtcsuppliertypeandlocation_type_check CHECK ((type = ANY (ARRAY['c'::bpchar, 'p'::bpchar, 'd'::bpchar])))
);


ALTER TABLE public.gtcsuppliertypeandlocation OWNER TO postgres;

--
-- Name: TABLE gtcsuppliertypeandlocation; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcsuppliertypeandlocation IS 'tipo de fornecedor e detalhes de localiza';


--
-- Name: COLUMN gtcsuppliertypeandlocation.supplierid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsuppliertypeandlocation.supplierid IS 'Identifica';


--
-- Name: COLUMN gtcsuppliertypeandlocation.cnpj; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsuppliertypeandlocation.cnpj IS 'CNPJ';


--
-- Name: COLUMN gtcsuppliertypeandlocation.location; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsuppliertypeandlocation.location IS 'Endere';


--
-- Name: COLUMN gtcsuppliertypeandlocation.neighborhood; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcsuppliertypeandlocation.neighborhood IS 'Bairro';


--
-- Name: gtctag; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtctag (
    fieldid character varying(3) NOT NULL,
    subfieldid character varying(1) NOT NULL,
    description character varying(100) NOT NULL,
    observation text,
    isrepetitive boolean,
    hassubfield boolean,
    isactive boolean,
    indemonstration boolean,
    isobsolete boolean,
    help text
);


ALTER TABLE public.gtctag OWNER TO postgres;

--
-- Name: TABLE gtctag; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtctag IS 'etiquetas';


--
-- Name: COLUMN gtctag.fieldid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtctag.fieldid IS 'Campo marc';


--
-- Name: COLUMN gtctag.subfieldid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtctag.subfieldid IS 'Subcampo marc';


--
-- Name: gtctask; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtctask (
    taskid integer NOT NULL,
    description character varying NOT NULL,
    parameters character varying,
    enable boolean DEFAULT true,
    scriptname character varying NOT NULL
);


ALTER TABLE public.gtctask OWNER TO postgres;

--
-- Name: TABLE gtctask; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtctask IS 'tarefas';


--
-- Name: gtcwebservice; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcwebservice (
    webserviceid integer NOT NULL,
    servicedescription text,
    class character varying NOT NULL,
    method character varying NOT NULL,
    enable boolean DEFAULT true,
    needauthentication boolean DEFAULT true,
    checkclientip boolean DEFAULT true
);


ALTER TABLE public.gtcwebservice OWNER TO postgres;

--
-- Name: TABLE gtcwebservice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcwebservice IS 'lista de servi';


--
-- Name: seq_weekdayid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_weekdayid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_weekdayid OWNER TO postgres;

--
-- Name: gtcweekday; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcweekday (
    weekdayid integer DEFAULT nextval('seq_weekdayid'::regclass) NOT NULL,
    description character varying(40) NOT NULL
);


ALTER TABLE public.gtcweekday OWNER TO postgres;

--
-- Name: seq_workflowhistoryid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_workflowhistoryid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_workflowhistoryid OWNER TO postgres;

--
-- Name: gtcworkflowhistory; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcworkflowhistory (
    workflowhistoryid integer DEFAULT nextval('seq_workflowhistoryid'::regclass) NOT NULL,
    workflowinstanceid integer NOT NULL,
    workflowstatusid integer NOT NULL,
    date timestamp without time zone NOT NULL,
    operator character varying(30) NOT NULL,
    comment text
);


ALTER TABLE public.gtcworkflowhistory OWNER TO postgres;

--
-- Name: seq_workflowinstanceid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_workflowinstanceid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_workflowinstanceid OWNER TO postgres;

--
-- Name: gtcworkflowinstance; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcworkflowinstance (
    workflowinstanceid integer DEFAULT nextval('seq_workflowinstanceid'::regclass) NOT NULL,
    workflowstatusid integer NOT NULL,
    date timestamp without time zone NOT NULL,
    tablename character varying(255) NOT NULL,
    tableid character varying(255) NOT NULL
);


ALTER TABLE public.gtcworkflowinstance OWNER TO postgres;

--
-- Name: seq_workflowstatusid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_workflowstatusid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_workflowstatusid OWNER TO postgres;

--
-- Name: gtcworkflowstatus; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcworkflowstatus (
    workflowstatusid integer DEFAULT nextval('seq_workflowstatusid'::regclass) NOT NULL,
    workflowid character varying(255) NOT NULL,
    name character varying(255) NOT NULL,
    initial boolean NOT NULL,
    transaction character varying,
    CONSTRAINT chk_gtcworkflowstatus_workflowid CHECK (gtc_chk_domain('WORKFLOW'::character varying, workflowid))
);


ALTER TABLE public.gtcworkflowstatus OWNER TO postgres;

--
-- Name: COLUMN gtcworkflowstatus.transaction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN gtcworkflowstatus.transaction IS 'Transação necessária para verificar a permissão';


--
-- Name: gtcworkflowtransition; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcworkflowtransition (
    previousworkflowstatusid integer NOT NULL,
    nextworkflowstatusid integer NOT NULL,
    name character varying(255) NOT NULL,
    function character varying(255)
);


ALTER TABLE public.gtcworkflowtransition OWNER TO postgres;

--
-- Name: seq_serverid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_serverid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_serverid OWNER TO postgres;

--
-- Name: gtcz3950servers; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE gtcz3950servers (
    serverid integer DEFAULT nextval('seq_serverid'::regclass) NOT NULL,
    description character varying(255) NOT NULL,
    host character varying(255) NOT NULL,
    recordtype character varying(100) NOT NULL,
    sintax character varying(50),
    username character varying(50),
    password character varying(32),
    country character varying(100),
    CONSTRAINT chk_gtcz3950servers_recordtype CHECK (gtc_chk_domain('Z3950_RECORD_TYPE'::character varying, recordtype))
);


ALTER TABLE public.gtcz3950servers OWNER TO postgres;

--
-- Name: TABLE gtcz3950servers; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE gtcz3950servers IS 'armazena o servidores z3950';


--
-- Name: seq_areatypeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_areatypeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_areatypeid OWNER TO postgres;

--
-- Name: insareatype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE insareatype (
    areatypeid integer DEFAULT nextval('seq_areatypeid'::regclass) NOT NULL,
    description text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.insareatype OWNER TO postgres;

--
-- Name: seq_grouptypeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_grouptypeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_grouptypeid OWNER TO postgres;

--
-- Name: insgrouptype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE insgrouptype (
    grouptypeid integer DEFAULT nextval('seq_grouptypeid'::regclass) NOT NULL,
    description text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.insgrouptype OWNER TO postgres;

--
-- Name: TABLE insgrouptype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE insgrouptype IS 'tabela dos grupos';


--
-- Name: COLUMN insgrouptype.grouptypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN insgrouptype.grouptypeid IS 'Codigo do grupo';


--
-- Name: COLUMN insgrouptype.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN insgrouptype.description IS 'Descricao';


--
-- Name: lancamentos_financeiros; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW lancamentos_financeiros AS
    SELECT e.courseid, e.courseversion, e.turnid, e.unitid, a.invoiceid, p.personid, p.name, c.operationtypeid, c.operationid, c.description AS operation, round(b.value, 2) AS value, a.maturitydate, b.entrydate, e.contractid, getcontractclassid(e.contractid) AS classid, b.incentivetypeid FROM ((((ONLY finreceivableinvoice a JOIN basphysicalperson p ON ((p.personid = a.personid))) JOIN finentry b ON ((a.invoiceid = b.invoiceid))) JOIN finoperation c ON ((b.operationid = c.operationid))) LEFT JOIN acdcontract e ON ((e.contractid = COALESCE(b.contractid, getinvoicecontract(a.invoiceid))))) WHERE ((a.iscanceled IS FALSE) AND (a.invoiceiddependence IS NULL)) ORDER BY e.courseid, a.invoiceid;


ALTER TABLE public.lancamentos_financeiros OWNER TO solis;

--
-- Name: miolo_access; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE miolo_access (
    idgroup integer NOT NULL,
    idtransaction integer NOT NULL,
    rights integer,
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp without time zone DEFAULT now(),
    ipaddress inet
);


ALTER TABLE public.miolo_access OWNER TO postgres;

--
-- Name: miolo_audit; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE miolo_audit (
    audit_id integer NOT NULL,
    schema_name text NOT NULL,
    table_name text NOT NULL,
    user_name text,
    action_timestamp_utc timestamp without time zone DEFAULT timezone('UTC'::text, now()) NOT NULL,
    action text NOT NULL,
    query text,
    CONSTRAINT miolo_audit_action_check CHECK ((action = ANY (ARRAY['INSERT'::text, 'DELETE'::text, 'UPDATE'::text])))
);


ALTER TABLE public.miolo_audit OWNER TO postgres;

--
-- Name: miolo_audit_audit_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE miolo_audit_audit_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.miolo_audit_audit_id_seq OWNER TO postgres;

--
-- Name: miolo_audit_audit_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE miolo_audit_audit_id_seq OWNED BY miolo_audit.audit_id;


--
-- Name: miolo_audit_detail; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE miolo_audit_detail (
    audit_id integer NOT NULL,
    column_name text NOT NULL,
    original_value text,
    new_value text,
    is_pkey boolean DEFAULT false NOT NULL
);


ALTER TABLE public.miolo_audit_detail OWNER TO postgres;

--
-- Name: miolo_custom_field_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE miolo_custom_field_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.miolo_custom_field_id_seq OWNER TO postgres;

--
-- Name: miolo_custom_field; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE miolo_custom_field (
    id character varying DEFAULT nextval('miolo_custom_field_id_seq'::regclass) NOT NULL,
    identifier character varying(30) DEFAULT ''::character varying NOT NULL,
    name character varying(30) DEFAULT ''::character varying NOT NULL,
    field_format character varying(30) DEFAULT ''::character varying NOT NULL,
    possible_values text,
    regexp character varying(255) DEFAULT ''::character varying,
    min_length integer DEFAULT 0,
    max_length integer DEFAULT 0,
    required boolean DEFAULT false NOT NULL,
    "position" integer DEFAULT 1,
    default_value text,
    editable boolean DEFAULT true,
    visible boolean DEFAULT true NOT NULL,
    label character varying(255)
);


ALTER TABLE public.miolo_custom_field OWNER TO postgres;

--
-- Name: COLUMN miolo_custom_field.label; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN miolo_custom_field.label IS 'Nome amigável ao usuário que deve ser exibido nos formulários, grids, relatórios...';


--
-- Name: miolo_custom_value; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE miolo_custom_value (
    id integer NOT NULL,
    customized_id character varying(30) DEFAULT '0'::character varying NOT NULL,
    custom_field_id character varying DEFAULT 0 NOT NULL,
    value text,
    name character varying(255)
);


ALTER TABLE public.miolo_custom_value OWNER TO postgres;

--
-- Name: COLUMN miolo_custom_value.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN miolo_custom_value.name IS 'Nome do campo, mesmo nome do miolo_custom_field.name referenciado, utilizado por questoes de performance na hora de buscar os dados.';


--
-- Name: miolo_custom_value_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE miolo_custom_value_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.miolo_custom_value_id_seq OWNER TO postgres;

--
-- Name: miolo_group; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE miolo_group (
    idgroup integer NOT NULL,
    m_group character varying,
    idmodule character varying(40)
);


ALTER TABLE public.miolo_group OWNER TO postgres;

--
-- Name: miolo_group_idgroup_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE miolo_group_idgroup_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.miolo_group_idgroup_seq OWNER TO postgres;

--
-- Name: miolo_groupuser; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE miolo_groupuser (
    iduser integer NOT NULL,
    idgroup integer NOT NULL,
    unitid integer
);


ALTER TABLE public.miolo_groupuser OWNER TO postgres;

--
-- Name: miolo_log; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE miolo_log (
    idlog integer NOT NULL,
    m_timestamp character(15),
    description character(200),
    module character(25),
    class character(25),
    iduser integer NOT NULL,
    idtransaction integer NOT NULL
);


ALTER TABLE public.miolo_log OWNER TO postgres;

--
-- Name: miolo_log_idlog_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE miolo_log_idlog_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.miolo_log_idlog_seq OWNER TO postgres;

--
-- Name: miolo_module; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE miolo_module (
    idmodule character varying(40) NOT NULL,
    name character varying(100),
    description text
);


ALTER TABLE public.miolo_module OWNER TO postgres;

--
-- Name: miolo_schedule_idschedule_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE miolo_schedule_idschedule_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.miolo_schedule_idschedule_seq OWNER TO postgres;

--
-- Name: miolo_sequence; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE miolo_sequence (
    sequence character(30) NOT NULL,
    value integer
);


ALTER TABLE public.miolo_sequence OWNER TO postgres;

--
-- Name: miolo_session; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE miolo_session (
    idsession integer NOT NULL,
    tsin character(15),
    tsout character(15),
    name character(50),
    sid character(40),
    forced character(1),
    remoteaddr character(15),
    iduser integer NOT NULL
);


ALTER TABLE public.miolo_session OWNER TO postgres;

--
-- Name: miolo_session_idsession_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE miolo_session_idsession_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.miolo_session_idsession_seq OWNER TO postgres;

--
-- Name: miolo_transaction; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE miolo_transaction (
    idtransaction integer NOT NULL,
    m_transaction text NOT NULL,
    nametransaction character varying(80),
    idmodule character varying(40),
    parentm_transaction text,
    action character varying(255),
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp without time zone DEFAULT now(),
    ipaddress inet,
    isdynamicreport boolean DEFAULT false,
    dynamicreporttype integer,
    parent_transaction text,
    urlpath character varying(255)
);


ALTER TABLE public.miolo_transaction OWNER TO postgres;

--
-- Name: COLUMN miolo_transaction.nametransaction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN miolo_transaction.nametransaction IS 'Descricao da transacao';


--
-- Name: COLUMN miolo_transaction.idmodule; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN miolo_transaction.idmodule IS 'Modulo da transacao';


--
-- Name: COLUMN miolo_transaction.parentm_transaction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN miolo_transaction.parentm_transaction IS 'Transacao pai';


--
-- Name: COLUMN miolo_transaction.isdynamicreport; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN miolo_transaction.isdynamicreport IS 'Indica se esta permissao e do tipo relatorios/documentos dinamicos';


--
-- Name: COLUMN miolo_transaction.dynamicreporttype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN miolo_transaction.dynamicreporttype IS 'Indica qual o tipo de relatorio ( 0 = Todos, 1 = Relatorio, 2 = Documento, etc.. )';


--
-- Name: COLUMN miolo_transaction.parent_transaction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN miolo_transaction.parent_transaction IS 'Transacao pai';


--
-- Name: COLUMN miolo_transaction.urlpath; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN miolo_transaction.urlpath IS 'Sub-diretório (path) em que a URL do menu deve ser redirecionado, caso nao seja informado, o padrão será utilizado. Ex.: http://sagu2/PATH/...';


--
-- Name: miolo_transaction_idtransaction_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE miolo_transaction_idtransaction_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.miolo_transaction_idtransaction_seq OWNER TO postgres;

--
-- Name: miolo_transaction_idtransaction_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE miolo_transaction_idtransaction_seq OWNED BY miolo_transaction.idtransaction;


--
-- Name: numero_de_registro; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE numero_de_registro
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.numero_de_registro OWNER TO postgres;

--
-- Name: olap_receitas_financeiras; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW olap_receitas_financeiras AS
    SELECT a.invoiceid AS cod_titulo, a.personid AS cod_pessoa, b.name AS pessoa, (SELECT getcontractcourseid(aa.contractid) AS getcontractcourseid FROM ONLY finentry aa WHERE (aa.invoiceid = a.invoiceid) LIMIT 1) AS curso, to_char((a.maturitydate)::timestamp with time zone, 'MM/YYYY'::text) AS competencia, a.parcelnumber AS parcela, to_char((a.maturitydate)::timestamp with time zone, 'DD/MM/YYYY'::text) AS dt_vencimento, (SELECT to_char((max(aa.entrydate))::timestamp with time zone, 'DD/MM/YYYY'::text) AS to_char FROM finentry aa WHERE ((aa.invoiceid = a.invoiceid) AND (aa.operationid = (SELECT findefaultoperations.paymentoperation FROM findefaultoperations LIMIT 1)))) AS dt_pagamento, round(a.nominalvalue, 2) AS vl_nominal, (SELECT round(sum(bb.value), 2) AS round FROM (finentry bb JOIN finoperation cc ON ((bb.operationid = cc.operationid))) WHERE ((bb.invoiceid = a.invoiceid) AND (cc.operationgroupid = 'J'::bpchar))) AS vl_multajuros, (SELECT round(sum(dd.value), 2) AS round FROM (finentry dd JOIN finoperation ee ON ((dd.operationid = ee.operationid))) WHERE ((dd.invoiceid = a.invoiceid) AND (ee.operationgroupid = 'D'::bpchar))) AS vl_desconto, (SELECT round(sum(ff.value), 2) AS round FROM (finentry ff JOIN finoperation gg ON ((ff.operationid = gg.operationid))) WHERE ((ff.invoiceid = a.invoiceid) AND (gg.operationgroupid = 'P'::bpchar))) AS vl_pago, round(balance(a.invoiceid), 2) AS vl_devido, round(balancewithpoliciesdated(a.invoiceid, (now())::date), 2) AS vl_corrigido FROM (finreceivableinvoice a JOIN basphysicalperson b ON ((a.personid = b.personid))) WHERE ((a.iscanceled = false) AND (EXISTS (SELECT 1 FROM finentry hh WHERE ((hh.invoiceid = a.invoiceid) AND (hh.contractid IS NOT NULL))))) GROUP BY a.invoiceid, a.personid, b.name, (SELECT getcontractcourseid(aa.contractid) AS getcontractcourseid FROM ONLY finentry aa WHERE (aa.invoiceid = a.invoiceid) LIMIT 1), to_char((a.maturitydate)::timestamp with time zone, 'MM/YYYY'::text), a.parcelnumber, to_char((a.maturitydate)::timestamp with time zone, 'DD/MM/YYYY'::text), (SELECT to_char((max(aa.entrydate))::timestamp with time zone, 'DD/MM/YYYY'::text) AS to_char FROM finentry aa WHERE ((aa.invoiceid = a.invoiceid) AND (aa.operationid = (SELECT findefaultoperations.paymentoperation FROM findefaultoperations LIMIT 1)))), round(a.nominalvalue, 2), (SELECT round(sum(bb.value), 2) AS round FROM (finentry bb JOIN finoperation cc ON ((bb.operationid = cc.operationid))) WHERE ((bb.invoiceid = a.invoiceid) AND (cc.operationgroupid = 'J'::bpchar))) ORDER BY b.name;


ALTER TABLE public.olap_receitas_financeiras OWNER TO solis;

--
-- Name: prccondicaodepagamento; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE prccondicaodepagamento (
    condicaodepagamentoid integer NOT NULL,
    descricao character varying(255) NOT NULL,
    exigeentrada boolean NOT NULL,
    numerodeparcelas integer NOT NULL,
    unitid integer
);


ALTER TABLE public.prccondicaodepagamento OWNER TO postgres;

--
-- Name: prccondicaodepagamento_condicaodepagamentoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE prccondicaodepagamento_condicaodepagamentoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.prccondicaodepagamento_condicaodepagamentoid_seq OWNER TO postgres;

--
-- Name: prccondicaodepagamento_condicaodepagamentoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE prccondicaodepagamento_condicaodepagamentoid_seq OWNED BY prccondicaodepagamento.condicaodepagamentoid;


--
-- Name: prcdiadevencimento; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE prcdiadevencimento (
    diadevencimentoid integer NOT NULL,
    dia integer NOT NULL
);


ALTER TABLE public.prcdiadevencimento OWNER TO postgres;

--
-- Name: prcdiadevencimento_diadevencimentoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE prcdiadevencimento_diadevencimentoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.prcdiadevencimento_diadevencimentoid_seq OWNER TO postgres;

--
-- Name: prcdiadevencimento_diadevencimentoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE prcdiadevencimento_diadevencimentoid_seq OWNED BY prcdiadevencimento.diadevencimentoid;


--
-- Name: prcformadepagamentodopreco; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE prcformadepagamentodopreco (
    formadepagamentodoprecoid integer NOT NULL,
    precocursoid integer NOT NULL,
    formadepagamentoid integer NOT NULL
);


ALTER TABLE public.prcformadepagamentodopreco OWNER TO postgres;

--
-- Name: prcformadepagamentodopreco_formadepagamentodoprecoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE prcformadepagamentodopreco_formadepagamentodoprecoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.prcformadepagamentodopreco_formadepagamentodoprecoid_seq OWNER TO postgres;

--
-- Name: prcformadepagamentodopreco_formadepagamentodoprecoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE prcformadepagamentodopreco_formadepagamentodoprecoid_seq OWNED BY prcformadepagamentodopreco.formadepagamentodoprecoid;


--
-- Name: prcmovimentoprecocurso; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE prcmovimentoprecocurso (
    movimentoprecocursoid integer NOT NULL,
    ofertacursoid integer,
    ocorrenciacursoid integer,
    ofertaturmaid integer,
    policyid integer,
    bankaccountid integer,
    costcenterid character varying(30),
    diasvencimentoentrada integer,
    usuario character varying(255),
    datamovimento timestamp without time zone,
    evento character varying(255),
    valoravista numeric(16,2),
    datainicial date,
    valoraprazo numeric(16,2),
    incomesourceid integer,
    datafinal date,
    tipo character(1),
    unitid integer,
    valor numeric(19,4)
);


ALTER TABLE public.prcmovimentoprecocurso OWNER TO postgres;

--
-- Name: prcmovimentoprecocurso_movimentoprecocursoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE prcmovimentoprecocurso_movimentoprecocursoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.prcmovimentoprecocurso_movimentoprecocursoid_seq OWNER TO postgres;

--
-- Name: prcmovimentoprecocurso_movimentoprecocursoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE prcmovimentoprecocurso_movimentoprecocursoid_seq OWNED BY prcmovimentoprecocurso.movimentoprecocursoid;


--
-- Name: prcprecocondicao; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE prcprecocondicao (
    precocondicaoid integer NOT NULL,
    precocursoid integer,
    condicaodepagamentoid integer,
    valortotal numeric(16,2),
    valorparcela numeric(16,2),
    unitid integer,
    operationid integer,
    precocursogrupoid integer
);


ALTER TABLE public.prcprecocondicao OWNER TO postgres;

--
-- Name: prcprecocondicao_precocondicaoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE prcprecocondicao_precocondicaoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.prcprecocondicao_precocondicaoid_seq OWNER TO postgres;

--
-- Name: prcprecocondicao_precocondicaoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE prcprecocondicao_precocondicaoid_seq OWNED BY prcprecocondicao.precocondicaoid;


--
-- Name: prcprecocurso; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE prcprecocurso (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    precocursoid integer NOT NULL,
    incomesourceid integer NOT NULL,
    ofertaturmaid integer,
    ocorrenciacursoid integer NOT NULL,
    ofertacursoid integer,
    costcenterid character varying(30) NOT NULL,
    bankaccountid integer NOT NULL,
    operationid integer NOT NULL,
    policyid integer NOT NULL,
    valoravista numeric(16,2) NOT NULL,
    diasvencimentoentrada integer NOT NULL,
    tipo character(1) NOT NULL,
    datafinal date,
    valoraprazo numeric(16,2),
    datainicial date NOT NULL,
    unitid integer,
    formadecalculo character(1)
)
INHERITS (baslog);


ALTER TABLE public.prcprecocurso OWNER TO postgres;

--
-- Name: prcprecocurso_precocursoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE prcprecocurso_precocursoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.prcprecocurso_precocursoid_seq OWNER TO postgres;

--
-- Name: prcprecocurso_precocursoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE prcprecocurso_precocursoid_seq OWNED BY prcprecocurso.precocursoid;


--
-- Name: prcprecocursogrupo; Type: TABLE; Schema: public; Owner: solis; Tablespace: 
--

CREATE TABLE prcprecocursogrupo (
    precocursogrupoid integer NOT NULL,
    matrizcurriculargrupoid integer,
    precocursoid integer,
    valoravista numeric(16,2),
    valoraprazo numeric(16,2)
);


ALTER TABLE public.prcprecocursogrupo OWNER TO solis;

--
-- Name: prcprecocursogrupo_precocursogrupoid_seq; Type: SEQUENCE; Schema: public; Owner: solis
--

CREATE SEQUENCE prcprecocursogrupo_precocursogrupoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.prcprecocursogrupo_precocursogrupoid_seq OWNER TO solis;

--
-- Name: prcprecocursogrupo_precocursogrupoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: solis
--

ALTER SEQUENCE prcprecocursogrupo_precocursogrupoid_seq OWNED BY prcprecocursogrupo.precocursogrupoid;


--
-- Name: prctituloinscricao; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE prctituloinscricao (
    tituloinscricaoid integer NOT NULL,
    inscricaoid integer NOT NULL,
    invoiceid integer NOT NULL,
    tipo character(1) NOT NULL,
    unitid integer,
    precocondicaoid integer
);


ALTER TABLE public.prctituloinscricao OWNER TO postgres;

--
-- Name: prctituloinscricao_tituloinscricaoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE prctituloinscricao_tituloinscricaoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.prctituloinscricao_tituloinscricaoid_seq OWNER TO postgres;

--
-- Name: prctituloinscricao_tituloinscricaoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE prctituloinscricao_tituloinscricaoid_seq OWNED BY prctituloinscricao.tituloinscricaoid;


--
-- Name: prtanexo; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE prtanexo (
    fileid integer NOT NULL,
    mensagemid integer NOT NULL,
    descricao text
)
INHERITS (baslog);


ALTER TABLE public.prtanexo OWNER TO postgres;

--
-- Name: prtmensagem; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE prtmensagem (
    mensagemid integer NOT NULL,
    unitid integer NOT NULL,
    remetenteid integer,
    conteudo text,
    date timestamp without time zone DEFAULT now()
)
INHERITS (baslog);


ALTER TABLE public.prtmensagem OWNER TO postgres;

--
-- Name: prtmensagem_mensagemid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE prtmensagem_mensagemid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.prtmensagem_mensagemid_seq OWNER TO postgres;

--
-- Name: prtmensagem_mensagemid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE prtmensagem_mensagemid_seq OWNED BY prtmensagem.mensagemid;


--
-- Name: prtmensagemdestinatario; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE prtmensagemdestinatario (
    mensagemdestinatarioid integer NOT NULL,
    mensagemid integer NOT NULL,
    groupid integer,
    personid bigint NOT NULL,
    courseid character varying(10)
)
INHERITS (baslog);


ALTER TABLE public.prtmensagemdestinatario OWNER TO postgres;

--
-- Name: prtmensagemdestinatario_mensagemdestinatarioid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE prtmensagemdestinatario_mensagemdestinatarioid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.prtmensagemdestinatario_mensagemdestinatarioid_seq OWNER TO postgres;

--
-- Name: prtmensagemdestinatario_mensagemdestinatarioid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE prtmensagemdestinatario_mensagemdestinatarioid_seq OWNED BY prtmensagemdestinatario.mensagemdestinatarioid;


--
-- Name: prtmensagemmural; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE prtmensagemmural (
    mensagemmuralid integer NOT NULL,
    personid integer NOT NULL,
    unitid integer NOT NULL,
    groupid integer NOT NULL,
    conteudo text NOT NULL,
    fileid integer
)
INHERITS (baslog);


ALTER TABLE public.prtmensagemmural OWNER TO postgres;

--
-- Name: prtmensagemmural_mensagemmuralid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE prtmensagemmural_mensagemmuralid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.prtmensagemmural_mensagemmuralid_seq OWNER TO postgres;

--
-- Name: prtmensagemmural_mensagemmuralid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE prtmensagemmural_mensagemmuralid_seq OWNED BY prtmensagemmural.mensagemmuralid;


--
-- Name: prtpreferenciaaluno; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE prtpreferenciaaluno (
    preferenciaalunoid integer NOT NULL,
    personid integer NOT NULL,
    notifmsgrecebida boolean,
    notifpostagemmural boolean,
    notifregistrofrequencia boolean NOT NULL,
    notifregistronota boolean NOT NULL,
    notiffinalizacaodisciplina boolean NOT NULL,
    numeropostagensmural integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.prtpreferenciaaluno OWNER TO postgres;

--
-- Name: prtpreferenciaaluno_preferenciaalunoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE prtpreferenciaaluno_preferenciaalunoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.prtpreferenciaaluno_preferenciaalunoid_seq OWNER TO postgres;

--
-- Name: prtpreferenciaaluno_preferenciaalunoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE prtpreferenciaaluno_preferenciaalunoid_seq OWNED BY prtpreferenciaaluno.preferenciaalunoid;


--
-- Name: prtpreferenciaprofessor; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE prtpreferenciaprofessor (
    preferenciaprofessorid integer NOT NULL,
    personid integer NOT NULL,
    notifmsgrecebida boolean,
    notifpostagemmural boolean,
    notifconviteatividade boolean NOT NULL,
    notifsolicitacaoreposicao boolean NOT NULL,
    notiffinalizacaodisciplina boolean NOT NULL,
    numeropostagensmural integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.prtpreferenciaprofessor OWNER TO postgres;

--
-- Name: prtpreferenciaprofessor_preferenciaprofessorid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE prtpreferenciaprofessor_preferenciaprofessorid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.prtpreferenciaprofessor_preferenciaprofessorid_seq OWNER TO postgres;

--
-- Name: prtpreferenciaprofessor_preferenciaprofessorid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE prtpreferenciaprofessor_preferenciaprofessorid_seq OWNED BY prtpreferenciaprofessor.preferenciaprofessorid;


--
-- Name: prtpreferenciascoordenador; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE prtpreferenciascoordenador (
    preferenciacoordenadorid integer NOT NULL,
    personid integer NOT NULL,
    notificacaonovamensagem boolean DEFAULT false,
    notificacaoconviteatividade boolean DEFAULT false,
    notificacaosolicitacaoreposicao boolean DEFAULT false
)
INHERITS (baslog);


ALTER TABLE public.prtpreferenciascoordenador OWNER TO postgres;

--
-- Name: prtpreferenciascoordenador_preferenciacoordenadorid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE prtpreferenciascoordenador_preferenciacoordenadorid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.prtpreferenciascoordenador_preferenciacoordenadorid_seq OWNER TO postgres;

--
-- Name: prtpreferenciascoordenador_preferenciacoordenadorid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE prtpreferenciascoordenador_preferenciacoordenadorid_seq OWNED BY prtpreferenciascoordenador.preferenciacoordenadorid;


--
-- Name: ptcdispatch; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ptcdispatch (
    requestid integer NOT NULL,
    dispatchdatetime timestamp without time zone NOT NULL,
    subjectid integer NOT NULL,
    sectorid integer NOT NULL,
    level integer NOT NULL,
    forwardedsubjectid integer,
    forwardedsectorid integer,
    forwardedlevel integer,
    description text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.ptcdispatch OWNER TO postgres;

--
-- Name: ptcdocument; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ptcdocument (
    documentid integer NOT NULL,
    requestid integer NOT NULL,
    description text,
    fileid integer
)
INHERITS (baslog);


ALTER TABLE public.ptcdocument OWNER TO postgres;

--
-- Name: ptcdocument_documentid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ptcdocument_documentid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ptcdocument_documentid_seq OWNER TO postgres;

--
-- Name: ptcdocument_documentid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ptcdocument_documentid_seq OWNED BY ptcdocument.documentid;


--
-- Name: ptcrequest; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ptcrequest (
    requestid integer NOT NULL,
    personid bigint NOT NULL,
    subjectid integer NOT NULL,
    statusid integer NOT NULL,
    currentsubjectid integer,
    currentsectorid integer,
    currentlevel integer,
    number character varying(50) NOT NULL,
    description text,
    starttime timestamp without time zone NOT NULL,
    endtime timestamp without time zone,
    sectorid integer NOT NULL,
    invoiceid integer,
    courseid character varying,
    courseversion integer,
    turnid integer,
    unitid integer
)
INHERITS (baslog);


ALTER TABLE public.ptcrequest OWNER TO postgres;

--
-- Name: ptcrequest_requestid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ptcrequest_requestid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ptcrequest_requestid_seq OWNER TO postgres;

--
-- Name: ptcrequest_requestid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ptcrequest_requestid_seq OWNED BY ptcrequest.requestid;


--
-- Name: ptcrequeststatus; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ptcrequeststatus (
    requeststatusid integer NOT NULL,
    description text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.ptcrequeststatus OWNER TO postgres;

--
-- Name: ptcrequeststatus_requeststatusid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ptcrequeststatus_requeststatusid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ptcrequeststatus_requeststatusid_seq OWNER TO postgres;

--
-- Name: ptcrequeststatus_requeststatusid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ptcrequeststatus_requeststatusid_seq OWNED BY ptcrequeststatus.requeststatusid;


--
-- Name: ptcrequireddocument; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ptcrequireddocument (
    requireddocumentid integer NOT NULL,
    subjectid integer NOT NULL,
    description text NOT NULL,
    uploadrequired boolean DEFAULT false,
    descriptionrequired boolean DEFAULT false
)
INHERITS (baslog);


ALTER TABLE public.ptcrequireddocument OWNER TO postgres;

--
-- Name: ptcrequireddocument_requireddocumentid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ptcrequireddocument_requireddocumentid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ptcrequireddocument_requireddocumentid_seq OWNER TO postgres;

--
-- Name: ptcrequireddocument_requireddocumentid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ptcrequireddocument_requireddocumentid_seq OWNED BY ptcrequireddocument.requireddocumentid;


--
-- Name: ptcsubject; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ptcsubject (
    subjectid integer NOT NULL,
    sectorid integer NOT NULL,
    description text NOT NULL,
    taxvalue numeric(14,4) DEFAULT 0 NOT NULL,
    term integer,
    isactive character(1) DEFAULT 'A'::bpchar,
    showdescription boolean DEFAULT true,
    descriptionrequired boolean DEFAULT true
)
INHERITS (baslog);


ALTER TABLE public.ptcsubject OWNER TO postgres;

--
-- Name: ptcsubject_subjectid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE ptcsubject_subjectid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ptcsubject_subjectid_seq OWNER TO postgres;

--
-- Name: ptcsubject_subjectid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE ptcsubject_subjectid_seq OWNED BY ptcsubject.subjectid;


--
-- Name: ptcsubjectavailableto; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ptcsubjectavailableto (
    subjectid integer NOT NULL,
    availableto character(1) NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.ptcsubjectavailableto OWNER TO postgres;

--
-- Name: ptcsubjectsector; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ptcsubjectsector (
    subjectid integer NOT NULL,
    sectorid integer NOT NULL,
    level integer NOT NULL,
    maxdays integer,
    maxtime time(6) without time zone,
    paracoordenador boolean DEFAULT false
)
INHERITS (baslog);


ALTER TABLE public.ptcsubjectsector OWNER TO postgres;

--
-- Name: rccassuntodecontato; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE rccassuntodecontato (
    assuntodecontatoid integer NOT NULL,
    descricao character(255) NOT NULL
);


ALTER TABLE public.rccassuntodecontato OWNER TO postgres;

--
-- Name: TABLE rccassuntodecontato; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE rccassuntodecontato IS 'Assunto do contato';


--
-- Name: COLUMN rccassuntodecontato.assuntodecontatoid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccassuntodecontato.assuntodecontatoid IS 'Código do assunto';


--
-- Name: COLUMN rccassuntodecontato.descricao; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccassuntodecontato.descricao IS 'Descrição';


--
-- Name: rccassuntodecontato_assuntodecontatoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rccassuntodecontato_assuntodecontatoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rccassuntodecontato_assuntodecontatoid_seq OWNER TO postgres;

--
-- Name: rccassuntodecontato_assuntodecontatoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rccassuntodecontato_assuntodecontatoid_seq OWNED BY rccassuntodecontato.assuntodecontatoid;


--
-- Name: rcccontato; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE rcccontato (
    contatoid integer NOT NULL,
    pessoa integer,
    interesseid integer NOT NULL,
    datahoraprevista timestamp without time zone NOT NULL,
    datahoradocontato timestamp without time zone DEFAULT now() NOT NULL,
    orientacao character(255) NOT NULL,
    mensagem character(255) NOT NULL,
    origemdecontatoid integer NOT NULL,
    assuntodecontato integer NOT NULL,
    tipodecontatoid integer NOT NULL,
    operador integer NOT NULL
);


ALTER TABLE public.rcccontato OWNER TO postgres;

--
-- Name: TABLE rcccontato; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE rcccontato IS 'Contato';


--
-- Name: COLUMN rcccontato.contatoid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rcccontato.contatoid IS 'Contato';


--
-- Name: COLUMN rcccontato.interesseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rcccontato.interesseid IS 'Interesse';


--
-- Name: COLUMN rcccontato.datahoraprevista; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rcccontato.datahoraprevista IS 'Data/hora prevista';


--
-- Name: COLUMN rcccontato.datahoradocontato; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rcccontato.datahoradocontato IS 'Data/hora do contato';


--
-- Name: COLUMN rcccontato.orientacao; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rcccontato.orientacao IS 'Orientação';


--
-- Name: COLUMN rcccontato.origemdecontatoid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rcccontato.origemdecontatoid IS 'Origem';


--
-- Name: COLUMN rcccontato.assuntodecontato; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rcccontato.assuntodecontato IS 'Assunto';


--
-- Name: COLUMN rcccontato.tipodecontatoid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rcccontato.tipodecontatoid IS 'Tipo';


--
-- Name: rcccontato_contatoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rcccontato_contatoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rcccontato_contatoid_seq OWNER TO postgres;

--
-- Name: rcccontato_contatoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rcccontato_contatoid_seq OWNED BY rcccontato.contatoid;


--
-- Name: rccinteresse; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE rccinteresse (
    interesseid integer NOT NULL,
    rcccontatocontatoid integer NOT NULL,
    datahora timestamp without time zone DEFAULT now() NOT NULL,
    nome character(255) NOT NULL,
    telefone character(255) NOT NULL,
    email character(255) NOT NULL,
    cpf character(255) NOT NULL,
    observacao character(255) NOT NULL,
    curso integer NOT NULL,
    contrato integer NOT NULL
);


ALTER TABLE public.rccinteresse OWNER TO postgres;

--
-- Name: TABLE rccinteresse; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE rccinteresse IS 'Interesse';


--
-- Name: COLUMN rccinteresse.interesseid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccinteresse.interesseid IS 'Código do interesse';


--
-- Name: COLUMN rccinteresse.datahora; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccinteresse.datahora IS 'Data';


--
-- Name: COLUMN rccinteresse.nome; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccinteresse.nome IS 'Nome';


--
-- Name: COLUMN rccinteresse.telefone; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccinteresse.telefone IS 'Telefone';


--
-- Name: COLUMN rccinteresse.email; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccinteresse.email IS 'E-mail';


--
-- Name: COLUMN rccinteresse.cpf; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccinteresse.cpf IS 'CPF';


--
-- Name: COLUMN rccinteresse.observacao; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccinteresse.observacao IS 'Observação';


--
-- Name: rccinteresse_interesseid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rccinteresse_interesseid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rccinteresse_interesseid_seq OWNER TO postgres;

--
-- Name: rccinteresse_interesseid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rccinteresse_interesseid_seq OWNED BY rccinteresse.interesseid;


--
-- Name: rccmensagemouvidoria; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE rccmensagemouvidoria (
    mensagemouvidoriaid integer NOT NULL,
    datahora timestamp without time zone DEFAULT now() NOT NULL,
    nome character(255) NOT NULL,
    email character(255),
    telefone character(255),
    vinculodecontatoid integer NOT NULL,
    matricula character(255),
    tipodecontatoid integer NOT NULL,
    assuntodecontatoid integer NOT NULL,
    origemdecontatoid integer NOT NULL,
    mensagem character(255) NOT NULL,
    estacancelada boolean NOT NULL,
    motivocancelamento character varying(255)
);


ALTER TABLE public.rccmensagemouvidoria OWNER TO postgres;

--
-- Name: TABLE rccmensagemouvidoria; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE rccmensagemouvidoria IS 'Mensagem da ouvidoria';


--
-- Name: COLUMN rccmensagemouvidoria.mensagemouvidoriaid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccmensagemouvidoria.mensagemouvidoriaid IS 'Código da ouvidoria';


--
-- Name: COLUMN rccmensagemouvidoria.datahora; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccmensagemouvidoria.datahora IS 'Data hora';


--
-- Name: COLUMN rccmensagemouvidoria.vinculodecontatoid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccmensagemouvidoria.vinculodecontatoid IS 'Vínculo';


--
-- Name: COLUMN rccmensagemouvidoria.matricula; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccmensagemouvidoria.matricula IS 'Matrícula';


--
-- Name: COLUMN rccmensagemouvidoria.tipodecontatoid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccmensagemouvidoria.tipodecontatoid IS 'Tipo';


--
-- Name: COLUMN rccmensagemouvidoria.assuntodecontatoid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccmensagemouvidoria.assuntodecontatoid IS 'Assunto';


--
-- Name: COLUMN rccmensagemouvidoria.origemdecontatoid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccmensagemouvidoria.origemdecontatoid IS 'Origem';


--
-- Name: COLUMN rccmensagemouvidoria.estacancelada; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccmensagemouvidoria.estacancelada IS 'Está cancelado';


--
-- Name: COLUMN rccmensagemouvidoria.motivocancelamento; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccmensagemouvidoria.motivocancelamento IS 'Motivo cancelamento';


--
-- Name: rccmensagemouvidoria_mensagemouvidoriaid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rccmensagemouvidoria_mensagemouvidoriaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rccmensagemouvidoria_mensagemouvidoriaid_seq OWNER TO postgres;

--
-- Name: rccmensagemouvidoria_mensagemouvidoriaid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rccmensagemouvidoria_mensagemouvidoriaid_seq OWNED BY rccmensagemouvidoria.mensagemouvidoriaid;


--
-- Name: rccorigemdecontato; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE rccorigemdecontato (
    origemdecontatoid integer NOT NULL,
    descricao character(255) NOT NULL
);


ALTER TABLE public.rccorigemdecontato OWNER TO postgres;

--
-- Name: TABLE rccorigemdecontato; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE rccorigemdecontato IS 'Origem do contato';


--
-- Name: COLUMN rccorigemdecontato.origemdecontatoid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccorigemdecontato.origemdecontatoid IS 'Código da Origem';


--
-- Name: COLUMN rccorigemdecontato.descricao; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccorigemdecontato.descricao IS 'Descrição';


--
-- Name: rccorigemdecontato_origemdecontatoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rccorigemdecontato_origemdecontatoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rccorigemdecontato_origemdecontatoid_seq OWNER TO postgres;

--
-- Name: rccorigemdecontato_origemdecontatoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rccorigemdecontato_origemdecontatoid_seq OWNED BY rccorigemdecontato.origemdecontatoid;


--
-- Name: rccpopuppessoa; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW rccpopuppessoa AS
    SELECT a.personid, a.name, a.email, b.courseid, b.turnid, c.operationid, d.operationtypeid, c.value, c.invoiceid FROM ((((ONLY basperson a JOIN acdcontract b ON ((a.personid = b.personid))) JOIN fininvoice z ON ((a.personid = z.personid))) JOIN finentry c ON ((z.invoiceid = c.invoiceid))) JOIN finoperation d ON ((((d.operationid = c.operationid) AND (z.maturitydate < now())) AND (z.maturitydate > (SELECT max(acdtimesheet.begindate) AS max FROM acdtimesheet))))) ORDER BY c.invoiceid LIMIT 5;


ALTER TABLE public.rccpopuppessoa OWNER TO postgres;

--
-- Name: rccregistroemail; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE rccregistroemail (
    registrodeemailid integer NOT NULL,
    datahora timestamp without time zone NOT NULL,
    operador integer NOT NULL,
    mensagem character(255) NOT NULL,
    assunto character(255) NOT NULL,
    destinatarios character(255) NOT NULL,
    anexos character(255)
);


ALTER TABLE public.rccregistroemail OWNER TO postgres;

--
-- Name: TABLE rccregistroemail; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE rccregistroemail IS 'Registro de Email';


--
-- Name: COLUMN rccregistroemail.registrodeemailid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccregistroemail.registrodeemailid IS 'Código do registro';


--
-- Name: COLUMN rccregistroemail.datahora; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccregistroemail.datahora IS 'Data/hora';


--
-- Name: rccregistroemail_registrodeemailid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rccregistroemail_registrodeemailid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rccregistroemail_registrodeemailid_seq OWNER TO postgres;

--
-- Name: rccregistroemail_registrodeemailid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rccregistroemail_registrodeemailid_seq OWNED BY rccregistroemail.registrodeemailid;


--
-- Name: rccrespostaouvidoria; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE rccrespostaouvidoria (
    respostaouvidoriaid integer NOT NULL,
    mensagemouvidoriaid integer NOT NULL,
    origemdecontatoid integer NOT NULL,
    datahoradasolicitacao timestamp without time zone DEFAULT now() NOT NULL,
    datahoraprevista timestamp without time zone NOT NULL,
    respondente integer NOT NULL,
    orientacao character(255) NOT NULL,
    datahoradaresposta timestamp without time zone,
    resposta character(255)
);


ALTER TABLE public.rccrespostaouvidoria OWNER TO postgres;

--
-- Name: TABLE rccrespostaouvidoria; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE rccrespostaouvidoria IS 'Resposta da ouvidoria';


--
-- Name: COLUMN rccrespostaouvidoria.respostaouvidoriaid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccrespostaouvidoria.respostaouvidoriaid IS 'Código da resposta';


--
-- Name: COLUMN rccrespostaouvidoria.origemdecontatoid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccrespostaouvidoria.origemdecontatoid IS 'Origem';


--
-- Name: COLUMN rccrespostaouvidoria.datahoradasolicitacao; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccrespostaouvidoria.datahoradasolicitacao IS 'Data/hora da solicitação';


--
-- Name: COLUMN rccrespostaouvidoria.datahoraprevista; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccrespostaouvidoria.datahoraprevista IS 'Data/hora prevista';


--
-- Name: COLUMN rccrespostaouvidoria.orientacao; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccrespostaouvidoria.orientacao IS 'Orientação';


--
-- Name: COLUMN rccrespostaouvidoria.datahoradaresposta; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccrespostaouvidoria.datahoradaresposta IS 'Data/hora da resposta';


--
-- Name: rccrespostaouvidoria_respostaouvidoriaid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rccrespostaouvidoria_respostaouvidoriaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rccrespostaouvidoria_respostaouvidoriaid_seq OWNER TO postgres;

--
-- Name: rccrespostaouvidoria_respostaouvidoriaid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rccrespostaouvidoria_respostaouvidoriaid_seq OWNED BY rccrespostaouvidoria.respostaouvidoriaid;


--
-- Name: rcctipodecontato; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE rcctipodecontato (
    tipodecontatoid integer NOT NULL,
    descricao character(255) NOT NULL
);


ALTER TABLE public.rcctipodecontato OWNER TO postgres;

--
-- Name: TABLE rcctipodecontato; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE rcctipodecontato IS 'Tipo do contato';


--
-- Name: COLUMN rcctipodecontato.tipodecontatoid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rcctipodecontato.tipodecontatoid IS 'Código do tipo';


--
-- Name: COLUMN rcctipodecontato.descricao; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rcctipodecontato.descricao IS 'Descrição';


--
-- Name: rcctipodecontato_tipodecontatoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rcctipodecontato_tipodecontatoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rcctipodecontato_tipodecontatoid_seq OWNER TO postgres;

--
-- Name: rcctipodecontato_tipodecontatoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rcctipodecontato_tipodecontatoid_seq OWNED BY rcctipodecontato.tipodecontatoid;


--
-- Name: rccvinculodecontato; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE rccvinculodecontato (
    vinculodecontatoid integer NOT NULL,
    descricao character varying(255) NOT NULL
);


ALTER TABLE public.rccvinculodecontato OWNER TO postgres;

--
-- Name: TABLE rccvinculodecontato; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE rccvinculodecontato IS 'Vínculo do contato';


--
-- Name: COLUMN rccvinculodecontato.vinculodecontatoid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccvinculodecontato.vinculodecontatoid IS 'Código do vínculo';


--
-- Name: COLUMN rccvinculodecontato.descricao; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rccvinculodecontato.descricao IS 'Descrição';


--
-- Name: rccvinculodecontato_vinculodecontatoid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE rccvinculodecontato_vinculodecontatoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rccvinculodecontato_vinculodecontatoid_seq OWNER TO postgres;

--
-- Name: rccvinculodecontato_vinculodecontatoid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE rccvinculodecontato_vinculodecontatoid_seq OWNED BY rccvinculodecontato.vinculodecontatoid;


--
-- Name: view_movimentacoes; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW view_movimentacoes AS
    SELECT DISTINCT a.contractid AS contrato, COALESCE(d.periodid, e.periodid) AS periodo, b.statetime AS datahora, b.statecontractid AS codigo, c.description AS estado FROM ((((acdcontract a JOIN acdmovementcontract b USING (contractid)) JOIN acdstatecontract c USING (statecontractid)) LEFT JOIN acdlearningperiod d USING (learningperiodid)) LEFT JOIN acdlearningperiod e ON ((((((((e.courseid)::text = (a.courseid)::text) AND (e.courseversion = a.courseversion)) AND (e.turnid = a.turnid)) AND (e.unitid = a.unitid)) AND ((b.statetime)::date >= e.begindate)) AND ((b.statetime)::date <= e.enddate))));


ALTER TABLE public.view_movimentacoes OWNER TO postgres;

--
-- Name: view_situacao_do_contrato_no_periodo; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW view_situacao_do_contrato_no_periodo AS
    SELECT b.begindate AS data, b.periodid AS periodo, a.contractid AS contrato, a.personid AS pessoa, a.courseid AS curso, a.courseversion AS versao, a.turnid AS turno, a.unitid AS unidade, CASE WHEN (SELECT (count(DISTINCT view_movimentacoes.periodo) > 1) FROM view_movimentacoes WHERE (((view_movimentacoes.datahora <= b.enddate) AND (view_movimentacoes.codigo = (getparameter('BASIC'::character varying, 'STATE_CONTRACT_ID_ENROLLED'::character varying))::integer)) AND (view_movimentacoes.contrato = a.contractid)) GROUP BY view_movimentacoes.contrato) THEN CASE WHEN (EXISTS (SELECT aa.enrollid FROM ((acdenroll aa JOIN acdgroup bb USING (groupid)) JOIN acdlearningperiod cc ON ((cc.learningperiodid = bb.learningperiodid))) WHERE ((((cc.periodid)::text = (b.periodid)::text) AND (aa.contractid = a.contractid)) AND (aa.statusid = ANY (ARRAY[(getparameter('ACADEMIC'::character varying, 'ENROLL_STATUS_ENROLLED'::character varying))::integer, (getparameter('ACADEMIC'::character varying, 'ENROLL_STATUS_APPROVED'::character varying))::integer, (getparameter('ACADEMIC'::character varying, 'ENROLL_STATUS_DISAPPROVED'::character varying))::integer, (getparameter('ACADEMIC'::character varying, 'ENROLL_STATUS_DISAPPROVED_FOR_LACKS'::character varying))::integer]))))) THEN CASE WHEN (SELECT (view_movimentacoes.codigo = (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_UNLOCKED'::character varying))::integer) FROM view_movimentacoes WHERE (((view_movimentacoes.codigo <> (getparameter('BASIC'::character varying, 'STATE_CONTRACT_ID_ENROLLED'::character varying))::integer) AND (view_movimentacoes.contrato = a.contractid)) AND (view_movimentacoes.datahora <= b.enddate)) ORDER BY view_movimentacoes.datahora DESC LIMIT 1) THEN 'Reingresso'::text ELSE 'Renovaï¿½ï¿½o'::text END ELSE CASE WHEN (SELECT (view_movimentacoes.codigo = (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_LOCKED'::character varying))::integer) FROM view_movimentacoes WHERE (((view_movimentacoes.codigo <> (getparameter('BASIC'::character varying, 'STATE_CONTRACT_ID_ENROLLED'::character varying))::integer) AND ((view_movimentacoes.periodo)::text = (b.periodid)::text)) AND (view_movimentacoes.contrato = a.contractid)) ORDER BY view_movimentacoes.datahora DESC LIMIT 1) THEN 'Trancamento'::text WHEN (SELECT (view_movimentacoes.codigo = (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_EXTERNAL_TRANSFER_TO'::character varying))::integer) FROM view_movimentacoes WHERE (((view_movimentacoes.codigo <> (getparameter('BASIC'::character varying, 'STATE_CONTRACT_ID_ENROLLED'::character varying))::integer) AND ((view_movimentacoes.periodo)::text = (b.periodid)::text)) AND (view_movimentacoes.contrato = a.contractid)) ORDER BY view_movimentacoes.datahora DESC LIMIT 1) THEN 'Transferï¿½ncia (S)'::text WHEN (SELECT (view_movimentacoes.codigo = (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_INTERNAL_TRANSFER_TO'::character varying))::integer) FROM view_movimentacoes WHERE (((view_movimentacoes.codigo <> (getparameter('BASIC'::character varying, 'STATE_CONTRACT_ID_ENROLLED'::character varying))::integer) AND ((view_movimentacoes.periodo)::text = (b.periodid)::text)) AND (view_movimentacoes.contrato = a.contractid)) ORDER BY view_movimentacoes.datahora DESC LIMIT 1) THEN CASE WHEN (SELECT ((getcoursename(ab.courseid))::text = (getcoursename(ba.courseid))::text) FROM (((view_movimentacoes aa JOIN acdcontract ab ON ((ab.contractid = aa.contrato))) JOIN acdcontract ba ON ((ba.personid = ab.personid))) JOIN view_movimentacoes bb ON (((bb.contrato = ba.contractid) AND (bb.contrato <> aa.contrato)))) WHERE (((((bb.datahora >= aa.datahora) AND (aa.contrato = a.contractid)) AND ((aa.periodo)::text = (b.periodid)::text)) AND (aa.codigo = (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_INTERNAL_TRANSFER_TO'::character varying))::integer)) AND (bb.codigo = (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_INTERNAL_TRANSFER_FROM'::character varying))::integer)) ORDER BY bb.datahora LIMIT 1) THEN 'Mudanï¿½a de turno/versï¿½o'::text ELSE 'Mudanï¿½a de curso (S)'::text END WHEN (SELECT (view_movimentacoes.codigo = ANY (ARRAY[(getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_ALL_FINISHED'::character varying))::integer, (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_GRADUATION'::character varying))::integer])) FROM view_movimentacoes WHERE (((view_movimentacoes.periodo)::text = (b.periodid)::text) AND (view_movimentacoes.contrato = a.contractid)) ORDER BY view_movimentacoes.datahora DESC LIMIT 1) THEN 'Concluintes'::text ELSE 'Outros (S)'::text END END ELSE CASE WHEN (EXISTS (SELECT aa.enrollid FROM ((acdenroll aa JOIN acdgroup bb USING (groupid)) JOIN acdlearningperiod cc ON ((cc.learningperiodid = bb.learningperiodid))) WHERE ((((cc.periodid)::text = (b.periodid)::text) AND (aa.contractid = a.contractid)) AND (aa.statusid = ANY (ARRAY[(getparameter('ACADEMIC'::character varying, 'ENROLL_STATUS_ENROLLED'::character varying))::integer, (getparameter('ACADEMIC'::character varying, 'ENROLL_STATUS_APPROVED'::character varying))::integer, (getparameter('ACADEMIC'::character varying, 'ENROLL_STATUS_DISAPPROVED'::character varying))::integer, (getparameter('ACADEMIC'::character varying, 'ENROLL_STATUS_DISAPPROVED_FOR_LACKS'::character varying))::integer]))))) THEN CASE WHEN (EXISTS (SELECT view_movimentacoes.codigo FROM view_movimentacoes WHERE ((view_movimentacoes.contrato = a.contractid) AND (view_movimentacoes.codigo = (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_DIPLOMA_HOLDER'::character varying))::integer)))) THEN 'Portador de diploma'::text WHEN (EXISTS (SELECT view_movimentacoes.codigo FROM view_movimentacoes WHERE ((view_movimentacoes.contrato = a.contractid) AND (view_movimentacoes.codigo = (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_EXTERNAL_TRANSFER_FROM'::character varying))::integer)))) THEN 'Transferï¿½ncia (E)'::text WHEN (EXISTS (SELECT view_movimentacoes.codigo FROM view_movimentacoes WHERE ((view_movimentacoes.contrato = a.contractid) AND (view_movimentacoes.codigo = (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_INTERNAL_TRANSFER_FROM'::character varying))::integer)))) THEN CASE WHEN (SELECT (((getcoursename(ab.courseid))::text = (getcoursename(ba.courseid))::text) AND (SELECT (count(DISTINCT view_movimentacoes.periodo) > 1) FROM view_movimentacoes WHERE ((view_movimentacoes.codigo = (getparameter('BASIC'::character varying, 'STATE_CONTRACT_ID_ENROLLED'::character varying))::integer) AND (view_movimentacoes.contrato = ANY (ARRAY[ab.contractid, ba.contractid]))))) FROM (((view_movimentacoes aa JOIN acdcontract ab ON ((ab.contractid = aa.contrato))) JOIN acdcontract ba ON ((ba.personid = ab.personid))) JOIN view_movimentacoes bb ON (((bb.contrato = ba.contractid) AND (bb.contrato <> aa.contrato)))) WHERE (((((bb.datahora <= aa.datahora) AND (aa.contrato = a.contractid)) AND ((aa.periodo)::text = (b.periodid)::text)) AND (aa.codigo = (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_INTERNAL_TRANSFER_FROM'::character varying))::integer)) AND (bb.codigo = (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_INTERNAL_TRANSFER_TO'::character varying))::integer)) ORDER BY bb.datahora DESC LIMIT 1) THEN 'Renovaï¿½ï¿½o'::text ELSE 'Matrï¿½cula'::text END WHEN (EXISTS (SELECT view_movimentacoes.codigo FROM view_movimentacoes WHERE ((view_movimentacoes.contrato = a.contractid) AND (view_movimentacoes.codigo = ANY (ARRAY[(getparameter('BASIC'::character varying, 'WRITING_STATE_CONTRACT'::character varying))::integer, (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_SUBSCRIPTION'::character varying))::integer, (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_ENEM'::character varying))::integer]))))) THEN 'Matrï¿½cula'::text ELSE 'Outros (E)'::text END ELSE CASE WHEN ((SELECT (bb.isclosecontract = true) FROM (view_movimentacoes aa JOIN acdstatecontract bb ON ((bb.statecontractid = aa.codigo))) WHERE ((aa.contrato = a.contractid) AND ((aa.periodo)::text = (b.periodid)::text)) ORDER BY aa.datahora DESC LIMIT 1) AND (EXISTS (SELECT view_movimentacoes.periodo FROM view_movimentacoes WHERE (((view_movimentacoes.contrato = a.contractid) AND ((view_movimentacoes.periodo)::text = (b.periodid)::text)) AND (view_movimentacoes.codigo = (getparameter('BASIC'::character varying, 'STATE_CONTRACT_ID_ENROLLED'::character varying))::integer))))) THEN 'Cancelamento'::text WHEN (SELECT (view_movimentacoes.codigo = (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_LOCKED'::character varying))::integer) FROM view_movimentacoes WHERE (((view_movimentacoes.codigo <> (getparameter('BASIC'::character varying, 'STATE_CONTRACT_ID_ENROLLED'::character varying))::integer) AND ((view_movimentacoes.periodo)::text = (b.periodid)::text)) AND (view_movimentacoes.contrato = a.contractid)) ORDER BY view_movimentacoes.datahora DESC LIMIT 1) THEN 'Trancamento'::text WHEN (SELECT (view_movimentacoes.codigo = (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_EXTERNAL_TRANSFER_TO'::character varying))::integer) FROM view_movimentacoes WHERE (((view_movimentacoes.codigo <> (getparameter('BASIC'::character varying, 'STATE_CONTRACT_ID_ENROLLED'::character varying))::integer) AND ((view_movimentacoes.periodo)::text = (b.periodid)::text)) AND (view_movimentacoes.contrato = a.contractid)) ORDER BY view_movimentacoes.datahora DESC LIMIT 1) THEN 'Transferï¿½ncia (S)'::text WHEN (SELECT (view_movimentacoes.codigo = (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_INTERNAL_TRANSFER_TO'::character varying))::integer) FROM view_movimentacoes WHERE (((view_movimentacoes.codigo <> (getparameter('BASIC'::character varying, 'STATE_CONTRACT_ID_ENROLLED'::character varying))::integer) AND ((view_movimentacoes.periodo)::text = (b.periodid)::text)) AND (view_movimentacoes.contrato = a.contractid)) ORDER BY view_movimentacoes.datahora DESC LIMIT 1) THEN CASE WHEN (SELECT ((getcoursename(ab.courseid))::text = (getcoursename(ba.courseid))::text) FROM (((view_movimentacoes aa JOIN acdcontract ab ON ((ab.contractid = aa.contrato))) JOIN acdcontract ba ON ((ba.personid = ab.personid))) JOIN view_movimentacoes bb ON (((bb.contrato = ba.contractid) AND (bb.contrato <> aa.contrato)))) WHERE (((((bb.datahora >= aa.datahora) AND (aa.contrato = a.contractid)) AND ((aa.periodo)::text = (b.periodid)::text)) AND (aa.codigo = (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_INTERNAL_TRANSFER_TO'::character varying))::integer)) AND (bb.codigo = (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_INTERNAL_TRANSFER_FROM'::character varying))::integer)) ORDER BY bb.datahora LIMIT 1) THEN 'Mudanï¿½a de turno/versï¿½o'::text ELSE 'Mudanï¿½a de curso (S)'::text END WHEN (SELECT (view_movimentacoes.codigo = ANY (ARRAY[(getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_ALL_FINISHED'::character varying))::integer, (getparameter('ACADEMIC'::character varying, 'STATE_CONTRACT_ID_GRADUATION'::character varying))::integer])) FROM view_movimentacoes WHERE (((view_movimentacoes.periodo)::text = (b.periodid)::text) AND (view_movimentacoes.contrato = a.contractid)) ORDER BY view_movimentacoes.datahora DESC LIMIT 1) THEN 'Concluintes'::text ELSE 'Nï¿½o matriculado'::text END END END AS situacao FROM (acdcontract a JOIN acdlearningperiod b ON ((((((b.courseid)::text = (a.courseid)::text) AND (b.courseversion = a.courseversion)) AND (b.turnid = a.turnid)) AND (b.unitid = a.unitid)))) WHERE (EXISTS (SELECT view_movimentacoes.contrato FROM view_movimentacoes WHERE (((view_movimentacoes.periodo)::text = (b.periodid)::text) AND (view_movimentacoes.contrato = a.contractid)))) ORDER BY a.contractid, b.periodid;


ALTER TABLE public.view_situacao_do_contrato_no_periodo OWNER TO solis;

--
-- Name: receita; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW receita AS
    SELECT DISTINCT b.personid AS cod_pessoa, a.invoiceid AS titulo, c.ournumber AS nosso_numero, b.maturitydate AS vencimento, CASE WHEN ((d.situacao IS NOT NULL) AND (b.parcelnumber = 1)) THEN d.situacao ELSE e.description END AS descricao, (SELECT sum(xx.value) AS sum FROM lancamentos_financeiros xx WHERE (((xx.invoiceid = a.invoiceid) AND (xx.operationtypeid = 'D'::bpchar)) AND (NOT (EXISTS (SELECT findefaultoperations.username, findefaultoperations.datetime, findefaultoperations.ipaddress, findefaultoperations.addcurricularcomponentoperation, findefaultoperations.cancelcurricularcomponentoperation, findefaultoperations.protocoloperation, findefaultoperations.interestoperation, findefaultoperations.discountoperation, findefaultoperations.libraryfineoperation, findefaultoperations.closeincomeforecastoperation, findefaultoperations.enrolloperation, findefaultoperations.paymentoperation, findefaultoperations.agreementoperation, findefaultoperations.banktaxoperation, findefaultoperations.selectiveprocesstaxoperation, findefaultoperations.bankclosingtaxoperation, findefaultoperations.renewaloperation, findefaultoperations.negotiationoperation, findefaultoperations.opencounteroperation, findefaultoperations.counterwithdrawaloperation, findefaultoperations.otherdiscountsoperation, findefaultoperations.otheradditionsoperation, findefaultoperations.monthlyfeeoperation, findefaultoperations.withdrawoperation FROM findefaultoperations WHERE ((findefaultoperations.interestoperation = xx.operationid) OR (findefaultoperations.otheradditionsoperation = xx.operationid))))))) AS valor_nominal, (SELECT sum(xx.value) AS sum FROM lancamentos_financeiros xx WHERE (((xx.invoiceid = a.invoiceid) AND (xx.operationtypeid = 'C'::bpchar)) AND (NOT (EXISTS (SELECT findefaultoperations.username, findefaultoperations.datetime, findefaultoperations.ipaddress, findefaultoperations.addcurricularcomponentoperation, findefaultoperations.cancelcurricularcomponentoperation, findefaultoperations.protocoloperation, findefaultoperations.interestoperation, findefaultoperations.discountoperation, findefaultoperations.libraryfineoperation, findefaultoperations.closeincomeforecastoperation, findefaultoperations.enrolloperation, findefaultoperations.paymentoperation, findefaultoperations.agreementoperation, findefaultoperations.banktaxoperation, findefaultoperations.selectiveprocesstaxoperation, findefaultoperations.bankclosingtaxoperation, findefaultoperations.renewaloperation, findefaultoperations.negotiationoperation, findefaultoperations.opencounteroperation, findefaultoperations.counterwithdrawaloperation, findefaultoperations.otherdiscountsoperation, findefaultoperations.otheradditionsoperation, findefaultoperations.monthlyfeeoperation, findefaultoperations.withdrawoperation FROM findefaultoperations WHERE (findefaultoperations.paymentoperation = xx.operationid)))))) AS descontos, 'BANCO'::text AS tipo_entrada, (((((a.bankid)::text || '-'::text) || (a.branch)::text) || '/'::text) || (a.branchnumber)::text) AS conta_bancaria, a.occurrencedate AS data_pgto, a.creditdate AS data_credito, NULL::text AS forma_pagamento, a.valuepaid AS valor_pago, a.username AS usuario FROM ((((fin.bankmovement a JOIN finreceivableinvoice b ON ((b.invoiceid = a.invoiceid))) JOIN finincomesource e ON ((e.incomesourceid = b.incomesourceid))) JOIN finbankinvoiceinfo c ON ((c.invoiceid = b.invoiceid))) LEFT JOIN view_situacao_do_contrato_no_periodo d ON (((d.contrato = (SELECT finentry.contractid FROM finentry WHERE ((finentry.invoiceid = b.invoiceid) AND (finentry.contractid IS NOT NULL)) ORDER BY finentry.entryid DESC LIMIT 1)) AND ((d.periodo)::text = ((SELECT bb.periodid FROM (finentry aa JOIN acdlearningperiod bb ON ((aa.learningperiodid = bb.learningperiodid))) WHERE (aa.invoiceid = b.invoiceid) ORDER BY aa.entryid DESC LIMIT 1))::text)))) WHERE (a.bankmovementstatusid <> ALL (ARRAY[4, 5])) UNION SELECT DISTINCT b.personid AS cod_pessoa, a.invoiceid AS titulo, c.ournumber AS nosso_numero, b.maturitydate AS vencimento, CASE WHEN ((d.situacao IS NOT NULL) AND (b.parcelnumber = 1)) THEN d.situacao ELSE e.description END AS descricao, (SELECT sum(xx.value) AS sum FROM lancamentos_financeiros xx WHERE (((xx.invoiceid = a.invoiceid) AND (xx.operationtypeid = 'D'::bpchar)) AND (NOT (EXISTS (SELECT findefaultoperations.username, findefaultoperations.datetime, findefaultoperations.ipaddress, findefaultoperations.addcurricularcomponentoperation, findefaultoperations.cancelcurricularcomponentoperation, findefaultoperations.protocoloperation, findefaultoperations.interestoperation, findefaultoperations.discountoperation, findefaultoperations.libraryfineoperation, findefaultoperations.closeincomeforecastoperation, findefaultoperations.enrolloperation, findefaultoperations.paymentoperation, findefaultoperations.agreementoperation, findefaultoperations.banktaxoperation, findefaultoperations.selectiveprocesstaxoperation, findefaultoperations.bankclosingtaxoperation, findefaultoperations.renewaloperation, findefaultoperations.negotiationoperation, findefaultoperations.opencounteroperation, findefaultoperations.counterwithdrawaloperation, findefaultoperations.otherdiscountsoperation, findefaultoperations.otheradditionsoperation, findefaultoperations.monthlyfeeoperation, findefaultoperations.withdrawoperation FROM findefaultoperations WHERE ((findefaultoperations.interestoperation = xx.operationid) OR (findefaultoperations.otheradditionsoperation = xx.operationid))))))) AS valor_nominal, (SELECT sum(xx.value) AS sum FROM lancamentos_financeiros xx WHERE (((xx.invoiceid = a.invoiceid) AND (xx.operationtypeid = 'C'::bpchar)) AND (NOT (EXISTS (SELECT findefaultoperations.username, findefaultoperations.datetime, findefaultoperations.ipaddress, findefaultoperations.addcurricularcomponentoperation, findefaultoperations.cancelcurricularcomponentoperation, findefaultoperations.protocoloperation, findefaultoperations.interestoperation, findefaultoperations.discountoperation, findefaultoperations.libraryfineoperation, findefaultoperations.closeincomeforecastoperation, findefaultoperations.enrolloperation, findefaultoperations.paymentoperation, findefaultoperations.agreementoperation, findefaultoperations.banktaxoperation, findefaultoperations.selectiveprocesstaxoperation, findefaultoperations.bankclosingtaxoperation, findefaultoperations.renewaloperation, findefaultoperations.negotiationoperation, findefaultoperations.opencounteroperation, findefaultoperations.counterwithdrawaloperation, findefaultoperations.otherdiscountsoperation, findefaultoperations.otheradditionsoperation, findefaultoperations.monthlyfeeoperation, findefaultoperations.withdrawoperation FROM findefaultoperations WHERE (findefaultoperations.paymentoperation = xx.operationid)))))) AS descontos, 'CAIXA'::text AS tipo_entrada, NULL::text AS conta_bancaria, (a.movementdate)::date AS data_pgto, (a.movementdate)::date AS data_credito, (SELECT finspecies.description FROM finspecies WHERE (finspecies.speciesid = a.speciesid)) AS forma_pagamento, CASE WHEN (a.operation = 'C'::bpchar) THEN a.value ELSE (((-1))::numeric * a.value) END AS valor_pago, (SELECT bb.miolousername FROM (finopencounter aa JOIN basphysicalpersonemployee bb ON ((bb.personid = aa.operatorid))) WHERE (aa.opencounterid = a.opencounterid)) AS usuario FROM ((((fincountermovement a JOIN finreceivableinvoice b ON ((b.invoiceid = a.invoiceid))) JOIN finincomesource e ON ((e.incomesourceid = b.incomesourceid))) LEFT JOIN finbankinvoiceinfo c ON ((c.invoiceid = a.invoiceid))) LEFT JOIN view_situacao_do_contrato_no_periodo d ON (((d.contrato = (SELECT finentry.contractid FROM finentry WHERE ((finentry.invoiceid = b.invoiceid) AND (finentry.contractid IS NOT NULL)) ORDER BY finentry.entryid DESC LIMIT 1)) AND ((d.periodo)::text = ((SELECT bb.periodid FROM (finentry aa JOIN acdlearningperiod bb ON ((aa.learningperiodid = bb.learningperiodid))) WHERE (aa.invoiceid = b.invoiceid) ORDER BY aa.entryid DESC LIMIT 1))::text))));


ALTER TABLE public.receita OWNER TO solis;

--
-- Name: relclienteinadimplentes; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW relclienteinadimplentes AS
    SELECT a.personid, b.name, ((now())::date - (c.datahoradocontato)::date) AS contato, a.balance, ((now())::date - a.maturitydate) AS dias FROM ((ONLY basphysicalperson b JOIN (SELECT min(aa.maturitydate) AS maturitydate, aa.personid, sum(aa.balance) AS balance FROM finreceivableinvoice aa WHERE ((aa.balance > (0)::numeric) AND (aa.maturitydate < (now())::date)) GROUP BY aa.personid) a ON ((a.personid = b.personid))) LEFT JOIN (SELECT max(c.contatoid) AS contatoid, c.pessoa, c.datahoradocontato FROM rcccontato c GROUP BY c.pessoa, c.datahoradocontato) c ON ((c.pessoa = b.personid))) ORDER BY a.personid;


ALTER TABLE public.relclienteinadimplentes OWNER TO postgres;

--
-- Name: rptpessoa; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW rptpessoa AS
    SELECT a.personid, a.name, a.name AS personname, ((a.personid || ' - '::text) || (a.name)::text) AS nomecod, a.cityid, b.name AS cityname, a.zipcode, a.location, a.number, COALESCE(a.complement, '-'::character varying) AS complement, a.neighborhood, a.email, a.sex, a.maritalstatusid, a.residentialphone, a.cellphone, a.datebirth, c.description, c.description AS necessidadeespecial, d.content AS cpf, e.content AS rg, e.organ, COALESCE(doctitulo.content, '-'::text) AS tituloeleitor, COALESCE(obtercidadeestado(e.cityid), '-'::character varying) AS rgcity, a.miolousername, dataporextenso((now())::date) AS dataporextenso, datetouser((now())::date) AS datahoje, timestamptouser((now())::timestamp without time zone) AS datahorahoje, COALESCE(a.workfunction, '-'::character varying) AS workfunction, datetouser(a.datebirth) AS datanascimento, CASE WHEN ((pai.name IS NOT NULL) OR (mae.name IS NOT NULL)) THEN array_to_string(ARRAY(SELECT DISTINCT unnest(ARRAY[pai.name, mae.name]) AS unnest), ' e '::text) ELSE '-'::text END AS filiacao, COALESCE(mae.name, a.mothername, '-'::character varying) AS nomemae, COALESCE(pai.name, a.fathername, '-'::character varying) AS nomepai, COALESCE(docmil.content, '-'::text) AS certificadomilitar, ((((COALESCE(a.location, ''::text) || ', NO. '::text) || (COALESCE(a.number, ''::character varying))::text) || ', BAIRRO '::text) || COALESCE(a.neighborhood, ''::text)) AS endereco, obtercidadeestado(a.cityid) AS cidadeestado, obtercidadeestado(a.cityidbirth) AS naturalidade, s.institutionidhs, getpersonname((s.institutionidhs)::bigint) AS ensmedioescola, s.cityidhs, obtercidadeestado(s.cityidhs) AS ensmediocidade, s.yearhs, COALESCE(ms.description, '-'::text) AS estadocivil, a.neighborhood AS bairro, a.location AS rua, a.countryidbirth, COALESCE(cnt.name, '-'::character varying) AS nacionalidade, a.mothername, a.fathername, CASE WHEN ((a.fathername IS NOT NULL) OR (a.mothername IS NOT NULL)) THEN array_to_string(ARRAY(SELECT DISTINCT unnest(ARRAY[a.mothername, a.fathername]) AS unnest), ' e '::text) ELSE '-'::text END AS filiation, CASE WHEN (a.sex = 'F'::bpchar) THEN 'FEMININO'::text ELSE 'MASCULINO'::text END AS sexo FROM ((((((((((((((ONLY basphysicalperson a LEFT JOIN ONLY basphysicalpersonstudent s ON ((a.personid = s.personid))) LEFT JOIN ONLY baslegalperson lp ON ((lp.personid = s.institutionidhs))) LEFT JOIN bascity b ON ((a.cityid = b.cityid))) LEFT JOIN basspecialnecessity c ON ((a.specialnecessityid = c.specialnecessityid))) LEFT JOIN basdocument d ON (((a.personid = d.personid) AND (d.documenttypeid = (getparameter('BASIC'::character varying, 'DEFAULT_DOCUMENT_TYPE_ID_CPF'::character varying))::integer)))) LEFT JOIN basdocument e ON (((a.personid = e.personid) AND (e.documenttypeid = (getparameter('BASIC'::character varying, 'DEFAULT_DOCUMENT_TYPE_ID_RG'::character varying))::integer)))) LEFT JOIN basdocument docmil ON (((docmil.personid = a.personid) AND (docmil.documenttypeid = (getparameter('BASIC'::character varying, 'DEFAULT_DOCUMENT_TYPE_ID_MILITARY'::character varying))::integer)))) LEFT JOIN basdocument doctitulo ON (((doctitulo.personid = a.personid) AND (doctitulo.documenttypeid = (getparameter('BASIC'::character varying, 'DEFAULT_DOCUMENT_TYPE_ID_ELECTION_TITLE'::character varying))::integer)))) LEFT JOIN basphysicalpersonkinship pkmae ON (((pkmae.personid = a.personid) AND (pkmae.kinshipid = (getparameter('BASIC'::character varying, 'MOTHER_KINSHIP_ID'::character varying))::integer)))) LEFT JOIN basphysicalpersonkinship pkpai ON (((pkpai.personid = a.personid) AND (pkpai.kinshipid = (getparameter('BASIC'::character varying, 'FATHER_KINSHIP_ID'::character varying))::integer)))) LEFT JOIN ONLY basperson mae ON ((mae.personid = pkmae.relativepersonid))) LEFT JOIN ONLY basperson pai ON ((pai.personid = pkpai.relativepersonid))) LEFT JOIN basmaritalstatus ms ON ((ms.maritalstatusid = a.maritalstatusid))) LEFT JOIN bascountry cnt ON (((a.countryidbirth)::text = (cnt.countryid)::text)));


ALTER TABLE public.rptpessoa OWNER TO solis;

--
-- Name: VIEW rptpessoa; Type: COMMENT; Schema: public; Owner: solis
--

COMMENT ON VIEW rptpessoa IS 'Pessoas';


--
-- Name: COLUMN rptpessoa.personid; Type: COMMENT; Schema: public; Owner: solis
--

COMMENT ON COLUMN rptpessoa.personid IS 'Cï¿½digo da pessoa';


--
-- Name: COLUMN rptpessoa.name; Type: COMMENT; Schema: public; Owner: solis
--

COMMENT ON COLUMN rptpessoa.name IS 'Nome';


--
-- Name: COLUMN rptpessoa.cityid; Type: COMMENT; Schema: public; Owner: solis
--

COMMENT ON COLUMN rptpessoa.cityid IS 'Cï¿½digo da cidade';


--
-- Name: COLUMN rptpessoa.cityname; Type: COMMENT; Schema: public; Owner: solis
--

COMMENT ON COLUMN rptpessoa.cityname IS 'Cidade';


--
-- Name: COLUMN rptpessoa.zipcode; Type: COMMENT; Schema: public; Owner: solis
--

COMMENT ON COLUMN rptpessoa.zipcode IS 'CEP';


--
-- Name: COLUMN rptpessoa.location; Type: COMMENT; Schema: public; Owner: solis
--

COMMENT ON COLUMN rptpessoa.location IS 'Estado';


--
-- Name: COLUMN rptpessoa.number; Type: COMMENT; Schema: public; Owner: solis
--

COMMENT ON COLUMN rptpessoa.number IS 'Nï¿½mero';


--
-- Name: COLUMN rptpessoa.complement; Type: COMMENT; Schema: public; Owner: solis
--

COMMENT ON COLUMN rptpessoa.complement IS 'Complemento';


--
-- Name: COLUMN rptpessoa.neighborhood; Type: COMMENT; Schema: public; Owner: solis
--

COMMENT ON COLUMN rptpessoa.neighborhood IS 'Bairro';


--
-- Name: COLUMN rptpessoa.email; Type: COMMENT; Schema: public; Owner: solis
--

COMMENT ON COLUMN rptpessoa.email IS 'Email';


--
-- Name: COLUMN rptpessoa.sex; Type: COMMENT; Schema: public; Owner: solis
--

COMMENT ON COLUMN rptpessoa.sex IS 'Sexo';


--
-- Name: COLUMN rptpessoa.maritalstatusid; Type: COMMENT; Schema: public; Owner: solis
--

COMMENT ON COLUMN rptpessoa.maritalstatusid IS 'Estado civil';


--
-- Name: COLUMN rptpessoa.residentialphone; Type: COMMENT; Schema: public; Owner: solis
--

COMMENT ON COLUMN rptpessoa.residentialphone IS 'Telefone residencial';


--
-- Name: COLUMN rptpessoa.cellphone; Type: COMMENT; Schema: public; Owner: solis
--

COMMENT ON COLUMN rptpessoa.cellphone IS 'Telefone celular';


--
-- Name: COLUMN rptpessoa.datebirth; Type: COMMENT; Schema: public; Owner: solis
--

COMMENT ON COLUMN rptpessoa.datebirth IS 'Data de nascimento';


--
-- Name: COLUMN rptpessoa.description; Type: COMMENT; Schema: public; Owner: solis
--

COMMENT ON COLUMN rptpessoa.description IS 'Nescecidade especial';


--
-- Name: COLUMN rptpessoa.cpf; Type: COMMENT; Schema: public; Owner: solis
--

COMMENT ON COLUMN rptpessoa.cpf IS 'CPF';


--
-- Name: COLUMN rptpessoa.rg; Type: COMMENT; Schema: public; Owner: solis
--

COMMENT ON COLUMN rptpessoa.rg IS 'RG';


--
-- Name: COLUMN rptpessoa.miolousername; Type: COMMENT; Schema: public; Owner: solis
--

COMMENT ON COLUMN rptpessoa.miolousername IS 'Login miolo';


SET search_path = spr, pg_catalog;

--
-- Name: selectiveprocess; Type: TABLE; Schema: spr; Owner: postgres; Tablespace: 
--

CREATE TABLE selectiveprocess (
    selectiveprocessid integer NOT NULL,
    subscriptionemailid integer,
    financeinformationid integer,
    socialeconomicformid integer,
    description character varying(255) NOT NULL,
    numberofoptions integer NOT NULL,
    minimumnumberofoptions integer NOT NULL,
    subscriptionstartdate timestamp without time zone NOT NULL,
    subscriptionenddate timestamp without time zone NOT NULL,
    endofprocessdate timestamp without time zone NOT NULL,
    notifysubscribers boolean NOT NULL,
    createuserforsubscribers boolean NOT NULL,
    initialmessage text,
    finalmessage text,
    allowothersubscriptions boolean NOT NULL,
    generatefinance boolean NOT NULL,
    hasformationlevelinfo boolean NOT NULL,
    hasemploymentinfo boolean NOT NULL,
    destinationmodule integer DEFAULT 2 NOT NULL,
    requireauthentication boolean DEFAULT true NOT NULL,
    showpasswordaftersubscription boolean DEFAULT true NOT NULL,
    periodid character varying,
    permitedadosbancarios boolean DEFAULT false
)
INHERITS (public.baslog);


ALTER TABLE spr.selectiveprocess OWNER TO postgres;

--
-- Name: subscription; Type: TABLE; Schema: spr; Owner: postgres; Tablespace: 
--

CREATE TABLE subscription (
    subscriptionid integer NOT NULL,
    selectiveprocessid integer NOT NULL,
    personid bigint NOT NULL,
    subscriptionorder integer NOT NULL,
    hassubscriptionfee boolean NOT NULL,
    finishedhighschool boolean NOT NULL,
    subscriptiondate timestamp without time zone NOT NULL,
    invoiceid integer,
    formationlevelid integer,
    conclusionyear integer,
    degreename character varying(100),
    institutionname character varying(255),
    coursename character varying(255),
    isquotaholder boolean DEFAULT false
)
INHERITS (public.baslog);


ALTER TABLE spr.subscription OWNER TO postgres;

--
-- Name: subscriptionoption; Type: TABLE; Schema: spr; Owner: postgres; Tablespace: 
--

CREATE TABLE subscriptionoption (
    optionid integer NOT NULL,
    subscriptionid integer NOT NULL,
    subscriptionstatusid integer NOT NULL,
    optionnumber integer NOT NULL,
    "position" integer,
    subscriptionoptionorder integer NOT NULL,
    enrollconfirmed boolean,
    canenroll boolean DEFAULT false,
    usequota boolean DEFAULT false,
    updatejustification text
)
INHERITS (public.baslog);


ALTER TABLE spr.subscriptionoption OWNER TO postgres;

--
-- Name: subscriptionstepinfo; Type: TABLE; Schema: spr; Owner: postgres; Tablespace: 
--

CREATE TABLE subscriptionstepinfo (
    subscriptionid integer NOT NULL,
    stepid integer NOT NULL,
    subscriptionstatusid integer NOT NULL,
    totalpoints double precision,
    useinternalevaluations boolean NOT NULL,
    "position" integer,
    totalpointsstep double precision,
    locationid integer
)
INHERITS (public.baslog);


ALTER TABLE spr.subscriptionstepinfo OWNER TO postgres;

SET search_path = public, pg_catalog;

--
-- Name: rptcontrato; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW rptcontrato AS
    SELECT a.personid, a.name, a.personname, a.nomecod, a.cityid, a.cityname, a.zipcode, a.location, a.number, a.complement, a.neighborhood, a.email, a.sex, a.maritalstatusid, a.residentialphone, a.cellphone, a.datebirth, a.description, a.necessidadeespecial, a.cpf, a.rg, a.organ, a.tituloeleitor, a.rgcity, a.miolousername, a.dataporextenso, a.datahoje, a.datahorahoje, a.workfunction, a.datanascimento, a.filiacao, a.nomemae, a.nomepai, a.certificadomilitar, a.endereco, a.cidadeestado, a.naturalidade, a.institutionidhs, a.ensmedioescola, a.cityidhs, a.ensmediocidade, a.yearhs, a.estadocivil, a.bairro, a.rua, a.countryidbirth, a.nacionalidade, a.mothername, a.fathername, a.filiation, a.sexo, c.contractid, t.description AS turn, u.description AS unit, COALESCE(ci.name, '-'::text) AS unitcity, co.name AS course, c.subscriptionid, COALESCE(c.obs, '-'::text) AS obs, co.name AS coursename, COALESCE((SELECT datetouser(min((acdmovementcontract.statetime)::date)) AS datetouser FROM acdmovementcontract WHERE ((acdmovementcontract.contractid = c.contractid) AND (acdmovementcontract.statecontractid = 4)) LIMIT 1), '-'::character varying) AS dtadmissao, COALESCE(datetouser(c.formationdate), '-'::character varying) AS formationdate, COALESCE(datetouser(c.diplomadate), '-'::character varying) AS diplomadate, COALESCE(datetouser(c.conclusiondate), '-'::character varying) AS conclusiondate, COALESCE(rc.documentoreconhecimento, '-'::text) AS portariavigente, COALESCE(datetouser(rc.datareconhecimento), '-'::character varying) AS portariadatareconhecimento, COALESCE(co.degree, '-'::text) AS coursedegree, COALESCE((get_semester_contract(c.contractid))::character varying, '-'::character varying) AS semestre, COALESCE(getcontractclassid(c.contractid), '-'::character varying) AS classid, COALESCE(pp.name, '-'::character varying) AS coordinatorname, pp.personid AS coordinatorpersonid, co.courseid, rc.datareconhecimento, c.formationdate AS formationdatedb, COALESCE((SELECT datetouser((acdmovementcontract.statetime)::date) AS datetouser FROM acdmovementcontract WHERE ((acdmovementcontract.contractid = c.contractid) AND (acdmovementcontract.statecontractid = 11)) LIMIT 1), '-'::character varying) AS datacolacao, round(((100 / NULLIF(((SELECT CASE WHEN (count(*) < 1) THEN (1)::bigint ELSE count(*) END AS count FROM acdcurriculum cu WHERE (((((cu.courseid)::text = (c.courseid)::text) AND (cu.courseversion = c.courseversion)) AND (cu.turnid = c.turnid)) AND (cu.unitid = c.unitid))) / (SELECT CASE WHEN (count(*) < 1) THEN (1)::bigint ELSE count(*) END AS count FROM (acdenroll e JOIN acdcontract cc ON ((cc.contractid = e.contractid))) WHERE ((cc.contractid = c.contractid) AND (e.statusid = (getparameter('ACADEMIC'::character varying, 'ENROLL_STATUS_APPROVED'::character varying))::integer)))), 0)))::numeric, 2) AS percentualcursado, ci.name AS unitcityname, spr.description AS ingresso_procsel, datetouser((spr.endofprocessdate)::date) AS procsel_concluido_em, (SELECT so."position" FROM spr.subscriptionoption so WHERE ((so.subscriptionid = s.subscriptionid) AND (so."position" IS NOT NULL)) LIMIT 1) AS procsel_classif_curso, (SELECT ssi."position" FROM spr.subscriptionstepinfo ssi WHERE (ssi.subscriptionid = s.subscriptionid) LIMIT 1) AS procsel_classif_geral, (SELECT ssi.totalpoints FROM spr.subscriptionstepinfo ssi WHERE (ssi.subscriptionid = s.subscriptionid) LIMIT 1) AS nota_vestibular, ci.stateid AS estado, c.courseversion, c.turnid, c.unitid, c.formationperiodid FROM (((((((((((((acdcontract c JOIN rptpessoa a ON ((c.personid = a.personid))) JOIN basturn t ON ((t.turnid = c.turnid))) JOIN basunit u ON ((u.unitid = c.unitid))) LEFT JOIN baslocation l ON ((l.locationid = u.locationid))) LEFT JOIN bascity ci ON ((ci.cityid = l.cityid))) JOIN acdcourseversion cv ON ((((cv.courseid)::text = (c.courseid)::text) AND (cv.courseversion = c.courseversion)))) JOIN acdcourse co ON (((c.courseid)::text = (co.courseid)::text))) LEFT JOIN acdreconhecimentodecurso rc ON ((rc.reconhecimentodecursoid = COALESCE((SELECT acdreconhecimentodecurso.reconhecimentodecursoid FROM acdreconhecimentodecurso WHERE ((((((acdreconhecimentodecurso.courseid)::text = (c.courseid)::text) AND (acdreconhecimentodecurso.courseversion = c.courseversion)) AND (acdreconhecimentodecurso.turnid = c.turnid)) AND (acdreconhecimentodecurso.unitid = c.unitid)) AND (((SELECT (acdmovementcontract.statetime)::date AS statetime FROM acdmovementcontract WHERE ((acdmovementcontract.contractid = c.contractid) AND (acdmovementcontract.statecontractid = 11)) LIMIT 1) >= acdreconhecimentodecurso.datainicial) AND ((SELECT (acdmovementcontract.statetime)::date AS statetime FROM acdmovementcontract WHERE ((acdmovementcontract.contractid = c.contractid) AND (acdmovementcontract.statecontractid = 11)) LIMIT 1) <= acdreconhecimentodecurso.datafinal))) ORDER BY acdreconhecimentodecurso.datareconhecimento LIMIT 1), (SELECT acdreconhecimentodecurso.reconhecimentodecursoid FROM acdreconhecimentodecurso WHERE ((((((acdreconhecimentodecurso.courseid)::text = (c.courseid)::text) AND (acdreconhecimentodecurso.courseversion = c.courseversion)) AND (acdreconhecimentodecurso.turnid = c.turnid)) AND (acdreconhecimentodecurso.unitid = c.unitid)) AND (((now())::date >= acdreconhecimentodecurso.datainicial) AND ((now())::date <= acdreconhecimentodecurso.datafinal))) ORDER BY acdreconhecimentodecurso.datareconhecimento LIMIT 1))))) JOIN acdlearningperiod lp ON ((lp.learningperiodid = (SELECT acdlearningperiod.learningperiodid FROM acdlearningperiod WHERE (((((acdlearningperiod.courseid)::text = (c.courseid)::text) AND (acdlearningperiod.courseversion = c.courseversion)) AND (acdlearningperiod.turnid = c.turnid)) AND (acdlearningperiod.unitid = c.unitid)) ORDER BY acdlearningperiod.begindate DESC LIMIT 1)))) LEFT JOIN acdcoursecoordinator cc ON (((((((cc.courseid)::text = (c.courseid)::text) AND (cc.courseversion = c.courseversion)) AND (cc.turnid = c.turnid)) AND (cc.unitid = c.unitid)) AND (((cc.begindate IS NULL) OR (cc.begindate <= (now())::date)) AND ((cc.enddate IS NULL) OR (cc.enddate >= (now())::date)))))) LEFT JOIN ONLY basphysicalpersonprofessor pp ON ((pp.personid = cc.coordinatorid))) LEFT JOIN spr.subscription s ON ((s.subscriptionid = c.subscriptionid))) LEFT JOIN spr.selectiveprocess spr ON ((spr.selectiveprocessid = s.selectiveprocessid)));


ALTER TABLE public.rptcontrato OWNER TO solis;

--
-- Name: rptdisciplina; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW rptdisciplina AS
    SELECT g.groupid, g.curriculumid, g.classid, cc.name AS disciplina, cu.curricularcomponentid AS disciplinacod, (((cu.curricularcomponentid)::text || ' - '::text) || cc.name) AS disciplinacomcod, CASE WHEN (prof.personid IS NOT NULL) THEN prof.name ELSE '-'::character varying END AS profresponsavel, prof.personid AS profpersonid, g.professorresponsible, cc.academicnumberhours AS cargahoraria, cc.academiccredits AS creditos, cc.curricularcomponentid, lp.periodid, (((lp.courseid)::text || ' - '::text) || lp.courseversion) AS courseandversion, t.description AS turn, u.description AS unit, lp.learningperiodid, lp.description AS learningperiod, datetouser((now())::date) AS datahoje, co.courseid, co.name AS coursename, cc.academicnumberhours AS horasaula FROM (((((((acdgroup g JOIN acdlearningperiod lp ON ((lp.learningperiodid = g.learningperiodid))) JOIN acdcurriculum cu ON ((g.curriculumid = cu.curriculumid))) JOIN acdcurricularcomponent cc ON ((((cu.curricularcomponentid)::text = (cc.curricularcomponentid)::text) AND (cu.curricularcomponentversion = cc.curricularcomponentversion)))) JOIN basturn t ON ((t.turnid = lp.turnid))) JOIN basunit u ON ((u.unitid = lp.unitid))) JOIN acdcourse co ON (((lp.courseid)::text = (co.courseid)::text))) LEFT JOIN ONLY basphysicalperson prof ON ((g.professorresponsible = prof.personid)));


ALTER TABLE public.rptdisciplina OWNER TO solis;

--
-- Name: rptdisciplinaaluno; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW rptdisciplinaaluno AS
    SELECT d.groupid, d.curriculumid, d.classid, d.disciplina, d.disciplinacod, d.disciplinacomcod, d.profresponsavel, d.profpersonid, d.professorresponsible, d.cargahoraria, d.creditos, d.curricularcomponentid, d.periodid, d.courseandversion, d.turn, d.unit, d.learningperiodid, d.learningperiod, d.datahoje, d.courseid, d.coursename, d.horasaula, e.contractid, c.personid, e.enrollid, e.statusid AS enrollstatusid, obternotaouconceitofinal(e.enrollid) AS nota, (e.statusid = (getparameter('ACADEMIC'::character varying, 'ENROLL_STATUS_APPROVED'::character varying))::integer) AS aprovado, (e.statusid = (getparameter('ACADEMIC'::character varying, 'ENROLL_STATUS_DISAPPROVED'::character varying))::integer) AS reprovado, (e.statusid = (getparameter('ACADEMIC'::character varying, 'ENROLL_STATUS_ENROLLED'::character varying))::integer) AS cursando, (e.statusid = (getparameter('ACADEMIC'::character varying, 'ENROLL_STATUS_EXCUSED'::character varying))::integer) AS dispensado FROM ((rptdisciplina d JOIN acdenroll e ON ((e.groupid = d.groupid))) JOIN acdcontract c ON ((c.contractid = e.contractid))) UNION SELECT NULL::integer AS groupid, NULL::integer AS curriculumid, NULL::character varying AS classid, d.name AS disciplina, d.curricularcomponentid AS disciplinacod, (((d.curricularcomponentid)::text || ' - '::text) || d.name) AS disciplinacomcod, NULL::character varying AS profresponsavel, NULL::bigint AS profpersonid, NULL::integer AS professorresponsible, d.academicnumberhours AS cargahoraria, d.academiccredits AS creditos, NULL::character varying AS curricularcomponentid, e.periodid, (((e.courseid)::text || ' - '::text) || e.courseversion) AS courseandversion, NULL::character varying AS turn, NULL::text AS unit, e.learningperiodid, e.description AS learningperiod, datetouser((now())::date) AS datahoje, c.courseid, NULL::text AS coursename, d.academicnumberhours AS horasaula, a.contractid, f.personid, a.enrollid, a.statusid AS enrollstatusid, obternotaouconceitofinal(a.enrollid) AS nota, (a.statusid = (getparameter('ACADEMIC'::character varying, 'ENROLL_STATUS_APPROVED'::character varying))::integer) AS aprovado, (a.statusid = (getparameter('ACADEMIC'::character varying, 'ENROLL_STATUS_DISAPPROVED'::character varying))::integer) AS reprovado, (a.statusid = (getparameter('ACADEMIC'::character varying, 'ENROLL_STATUS_ENROLLED'::character varying))::integer) AS cursando, (a.statusid = (getparameter('ACADEMIC'::character varying, 'ENROLL_STATUS_EXCUSED'::character varying))::integer) AS dispensado FROM (((((acdenroll a JOIN acdexploitation b ON ((a.enrollid = b.enrollid))) JOIN acdcurriculum c ON ((a.curriculumid = c.curriculumid))) JOIN acdcurricularcomponent d ON ((((c.curricularcomponentid)::text = (d.curricularcomponentid)::text) AND (c.curricularcomponentversion = d.curricularcomponentversion)))) JOIN acdlearningperiod e ON ((a.learningperiodid = e.learningperiodid))) JOIN acdcontract f ON ((a.contractid = f.contractid)));


ALTER TABLE public.rptdisciplinaaluno OWNER TO solis;

--
-- Name: rpthorarios; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW rpthorarios AS
    SELECT (((x.scheduleid || ''::text) || x.timeid) || to_char((x.occurrencedate)::timestamp with time zone, 'mmdd'::text)) AS horarioidunique, x.occurrencedate, x.timeid, x.scheduleid, x.groupid, x.unitid, x.weekdayid, x.physicalresourceid, x.physicalresourceversion, x.beginhour, x.endhour, x.numberminutes FROM (SELECT unnest(s.occurrencedates) AS occurrencedate, t.timeid, s.scheduleid, s.groupid, s.unitid, s.weekdayid, s.physicalresourceid, s.physicalresourceversion, timetouser(t.beginhour) AS beginhour, timetouser(t.endhour) AS endhour, t.numberminutes FROM ((acdgroup g JOIN acdschedule s ON ((s.groupid = g.groupid))) JOIN acdtime t ON ((t.timeid = ANY (s.timeids))))) x;


ALTER TABLE public.rpthorarios OWNER TO solis;

--
-- Name: COLUMN rpthorarios.horarioidunique; Type: COMMENT; Schema: public; Owner: solis
--

COMMENT ON COLUMN rpthorarios.horarioidunique IS 'Identificador unico, utilizado para lookups (academic - lookupHorarios) e relatorios para simplificar filtros';


--
-- Name: COLUMN rpthorarios.occurrencedate; Type: COMMENT; Schema: public; Owner: solis
--

COMMENT ON COLUMN rpthorarios.occurrencedate IS 'Data da aula';


--
-- Name: COLUMN rpthorarios.timeid; Type: COMMENT; Schema: public; Owner: solis
--

COMMENT ON COLUMN rpthorarios.timeid IS 'Hora da aula';


--
-- Name: rpthorariodias; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW rpthorariodias AS
    SELECT (SELECT ((((obterdiaabreviado((date_part('dow'::text, x.occurrencedate))::integer))::text || ' ('::text) || array_to_string(ARRAY(SELECT DISTINCT (((rpthorarios.beginhour)::text || ' - '::text) || (rpthorarios.endhour)::text) FROM rpthorarios WHERE (rpthorarios.scheduleid = x.scheduleid) ORDER BY (((rpthorarios.beginhour)::text || ' - '::text) || (rpthorarios.endhour)::text)), ', '::text)) || ')'::text)) AS horario, x.groupid, x.beginhour, x.endhour, x.occurrencedate, (date_part('dow'::text, x.occurrencedate))::integer AS diasemana FROM rpthorarios x;


ALTER TABLE public.rpthorariodias OWNER TO solis;

--
-- Name: rptperiodoletivo; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW rptperiodoletivo AS
    SELECT lp.learningperiodid, lp.periodid, lp.courseid, lp.courseversion, lp.turnid, lp.unitid, lp.description, lp.formationlevelid, lp.previouslearningperiodid, lp.begindate, lp.enddate, lp.begindatelessons, lp.weekendexamsbegin, lp.finalaverage, lp.minimumfrequency, lp.sagu1periodid, lp.minimumcredits, lp.minimumcreditsfreshman, lp.minimumcreditsturn, lp.sagu1previousperiodid, lp.parcelsnumber, t.description AS turn, u.description AS unit, datetouser((now())::date) AS datahoje, timestamptouser((now())::timestamp without time zone) AS datahorahoje, co.name AS coursename FROM (((acdlearningperiod lp JOIN basturn t ON ((t.turnid = lp.turnid))) JOIN basunit u ON ((u.unitid = lp.unitid))) JOIN acdcourse co ON (((lp.courseid)::text = (co.courseid)::text)));


ALTER TABLE public.rptperiodoletivo OWNER TO solis;

--
-- Name: rptprofessorch; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW rptprofessorch AS
    SELECT DISTINCT p.name AS professor, cc.academicnumberhours AS cargahoraria, (SELECT date_part('hours'::text, sum(_h.numberminutes)) AS date_part FROM rpthorarios _h WHERE (_h.groupid = g.groupid)) AS cargahorariarealizada, lp.periodid, lp.learningperiodid FROM ((((((acdschedule s JOIN acdscheduleprofessor sp ON ((sp.scheduleid = s.scheduleid))) JOIN ONLY basphysicalpersonprofessor p ON ((p.personid = sp.professorid))) JOIN acdgroup g ON ((g.groupid = s.groupid))) JOIN acdcurriculum cu ON ((cu.curriculumid = g.curriculumid))) JOIN acdcurricularcomponent cc ON ((((cu.curricularcomponentid)::text = (cc.curricularcomponentid)::text) AND (cu.curricularcomponentversion = cc.curricularcomponentversion)))) JOIN acdlearningperiod lp ON ((lp.learningperiodid = g.learningperiodid)));


ALTER TABLE public.rptprofessorch OWNER TO solis;

--
-- Name: seq_answerid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_answerid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_answerid OWNER TO postgres;

--
-- Name: rshanswer; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE rshanswer (
    answerid integer DEFAULT nextval('seq_answerid'::regclass) NOT NULL,
    personid bigint NOT NULL,
    questionid integer NOT NULL,
    optionid integer,
    answer text
)
INHERITS (baslog);


ALTER TABLE public.rshanswer OWNER TO postgres;

--
-- Name: TABLE rshanswer; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE rshanswer IS 'respostas';


--
-- Name: COLUMN rshanswer.answerid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rshanswer.answerid IS 'Codigo da resposta';


--
-- Name: COLUMN rshanswer.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rshanswer.personid IS 'Codigo da pessoa';


--
-- Name: COLUMN rshanswer.questionid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rshanswer.questionid IS 'Codigo da questao';


--
-- Name: COLUMN rshanswer.optionid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rshanswer.optionid IS 'Opção de resposta para questoes que possuem apenas opcoes como resposta (optativas).';


--
-- Name: COLUMN rshanswer.answer; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rshanswer.answer IS 'Resposta para questoes do tipo textual (descritivas).';


--
-- Name: rshanswertype; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE rshanswertype (
    answertypeid integer NOT NULL,
    description text
);


ALTER TABLE public.rshanswertype OWNER TO postgres;

--
-- Name: TABLE rshanswertype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE rshanswertype IS 'Tabela responsábel por armazenar os tipos de respostas das questões';


--
-- Name: COLUMN rshanswertype.answertypeid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rshanswertype.answertypeid IS 'Código identificador do tipo de resposta';


--
-- Name: COLUMN rshanswertype.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rshanswertype.description IS 'Descrição do tipo de resposta';


--
-- Name: seq_formid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_formid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_formid OWNER TO postgres;

--
-- Name: rshform; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE rshform (
    formid integer DEFAULT nextval('seq_formid'::regclass) NOT NULL,
    description text NOT NULL,
    shortdescription character varying(25) NOT NULL,
    isrestricted boolean DEFAULT false NOT NULL,
    isidentified boolean DEFAULT true NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.rshform OWNER TO postgres;

--
-- Name: TABLE rshform; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE rshform IS 'questionarios';


--
-- Name: COLUMN rshform.formid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rshform.formid IS 'Codigo do questionario';


--
-- Name: COLUMN rshform.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rshform.description IS 'Descricao';


--
-- Name: COLUMN rshform.shortdescription; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rshform.shortdescription IS 'Descricao suscinta';


--
-- Name: COLUMN rshform.isrestricted; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rshform.isrestricted IS 'Se e restrito (exige login e senha)';


--
-- Name: COLUMN rshform.isidentified; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rshform.isidentified IS 'Se e identificado (grava as informacoes do usuario nos questionarios)';


--
-- Name: seq_optionid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_optionid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_optionid OWNER TO postgres;

--
-- Name: rshoption; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE rshoption (
    optionid integer DEFAULT nextval('seq_optionid'::regclass) NOT NULL,
    questionid integer NOT NULL,
    description text NOT NULL,
    allowadditionaltext boolean DEFAULT false NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.rshoption OWNER TO postgres;

--
-- Name: TABLE rshoption; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE rshoption IS 'opcoes';


--
-- Name: COLUMN rshoption.optionid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rshoption.optionid IS 'Codigo da opcao';


--
-- Name: COLUMN rshoption.questionid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rshoption.questionid IS 'Codigo da questao';


--
-- Name: COLUMN rshoption.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rshoption.description IS 'Descricao';


--
-- Name: seq_questionid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_questionid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_questionid OWNER TO postgres;

--
-- Name: rshquestion; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE rshquestion (
    questionid integer DEFAULT nextval('seq_questionid'::regclass) NOT NULL,
    formid integer NOT NULL,
    questioncategoryid integer NOT NULL,
    description text NOT NULL,
    isrequired boolean DEFAULT false NOT NULL,
    answertypeid integer NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.rshquestion OWNER TO postgres;

--
-- Name: TABLE rshquestion; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE rshquestion IS 'questoes/topicos';


--
-- Name: COLUMN rshquestion.questionid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rshquestion.questionid IS 'Codigo da questao';


--
-- Name: COLUMN rshquestion.formid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rshquestion.formid IS 'Codigo do questionario';


--
-- Name: COLUMN rshquestion.questioncategoryid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rshquestion.questioncategoryid IS 'Codigo da categoria de questao';


--
-- Name: COLUMN rshquestion.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rshquestion.description IS 'Descricao';


--
-- Name: seq_questioncategoryid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_questioncategoryid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_questioncategoryid OWNER TO postgres;

--
-- Name: rshquestioncategory; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE rshquestioncategory (
    questioncategoryid integer DEFAULT nextval('seq_questioncategoryid'::regclass) NOT NULL,
    description text NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.rshquestioncategory OWNER TO postgres;

--
-- Name: TABLE rshquestioncategory; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE rshquestioncategory IS 'tipos/grupos de questao - categorias';


--
-- Name: COLUMN rshquestioncategory.questioncategoryid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rshquestioncategory.questioncategoryid IS 'Codigo da categoria';


--
-- Name: COLUMN rshquestioncategory.description; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rshquestioncategory.description IS 'Descricao';


--
-- Name: rshwho; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE rshwho (
    formid integer NOT NULL,
    personid bigint NOT NULL
)
INHERITS (baslog);


ALTER TABLE public.rshwho OWNER TO postgres;

--
-- Name: TABLE rshwho; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE rshwho IS 'publico que responde a pesquisa';


--
-- Name: COLUMN rshwho.formid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rshwho.formid IS 'Codigo do questionario';


--
-- Name: COLUMN rshwho.personid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN rshwho.personid IS 'Codigo da pessoa';


--
-- Name: searchmaterialview; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW searchmaterialview AS
    (((SELECT gtcmaterialcontrol.controlnumber, gtcmaterialcontrol.entrancedate, gtcmaterialcontrol.lastchangedate, gtcmaterialcontrol.category, gtcmaterialcontrol.level, gtcmaterialcontrol.materialgenderid, gtcmaterialcontrol.materialtypeid, gtcmaterialcontrol.materialphysicaltypeid, gtcexemplarycontrol.itemnumber AS exemplaryitemnumber, gtcexemplarycontrol.originallibraryunitid AS exemplaryoriginallibraryunitid, gtcexemplarycontrol.libraryunitid AS exemplarylibraryunitid, gtcexemplarycontrol.acquisitiontype AS exemplaryacquisitiontype, gtcexemplarycontrol.exemplarystatusid AS exemplaryexemplarystatusid, gtcexemplarycontrol.materialgenderid AS exemplarymaterialgenderid, gtcexemplarycontrol.materialtypeid AS exemplarymaterialtypeid, gtcexemplarycontrol.materialphysicaltypeid AS exemplarymaterialphysicaltypeid, gtcexemplarycontrol.entrancedate AS exemplaryentrancedate, gtcexemplarycontrol.lowdate AS exemplarylowdate FROM (gtcmaterialcontrol LEFT JOIN gtcexemplarycontrol USING (controlnumber)) UNION SELECT gtcmaterialcontrol.controlnumberfather AS controlnumber, gtcmaterialcontrol.entrancedate, gtcmaterialcontrol.lastchangedate, gtcmaterialcontrolfather.category, gtcmaterialcontrolfather.level, gtcmaterialcontrol.materialgenderid, gtcmaterialcontrol.materialtypeid, gtcmaterialcontrol.materialphysicaltypeid, gtcexemplarycontrol.itemnumber AS exemplaryitemnumber, gtcexemplarycontrol.originallibraryunitid AS exemplaryoriginallibraryunitid, gtcexemplarycontrol.libraryunitid AS exemplarylibraryunitid, gtcexemplarycontrol.acquisitiontype AS exemplaryacquisitiontype, gtcexemplarycontrol.exemplarystatusid AS exemplaryexemplarystatusid, gtcexemplarycontrol.materialgenderid AS exemplarymaterialgenderid, gtcexemplarycontrol.materialtypeid AS exemplarymaterialtypeid, gtcexemplarycontrol.materialphysicaltypeid AS exemplarymaterialphysicaltypeid, gtcexemplarycontrol.entrancedate AS exemplaryentrancedate, gtcexemplarycontrol.lowdate AS exemplarylowdate FROM ((gtcmaterialcontrol LEFT JOIN gtcexemplarycontrol USING (controlnumber)) JOIN gtcmaterialcontrol gtcmaterialcontrolfather ON ((gtcmaterialcontrol.controlnumberfather = gtcmaterialcontrolfather.controlnumber))) WHERE (gtcmaterialcontrol.controlnumberfather IS NOT NULL)) UNION SELECT a.controlnumberfather AS controlnumber, b.entrancedate, b.lastchangedate, b.category, b.level, b.materialgenderid, b.materialtypeid, b.materialphysicaltypeid, c.itemnumber AS exemplaryitemnumber, c.originallibraryunitid AS exemplaryoriginallibraryunitid, c.libraryunitid AS exemplarylibraryunitid, c.acquisitiontype AS exemplaryacquisitiontype, c.exemplarystatusid AS exemplaryexemplarystatusid, c.materialgenderid AS exemplarymaterialgenderid, c.materialtypeid AS exemplarymaterialtypeid, c.materialphysicaltypeid AS exemplarymaterialphysicaltypeid, c.entrancedate AS exemplaryentrancedate, c.lowdate AS exemplarylowdate FROM ((gtcmaterialcontrol a LEFT JOIN gtcmaterialcontrol b ON ((b.controlnumber = a.controlnumberfather))) LEFT JOIN gtcexemplarycontrol c ON ((a.controlnumber = c.controlnumber))) WHERE (a.controlnumberfather IS NOT NULL)) UNION SELECT gtcmaterialcontrol.controlnumber, gtcmaterialcontrol.entrancedate, gtcmaterialcontrol.lastchangedate, gtcmaterialcontrol.category, gtcmaterialcontrol.level, gtcmaterialcontrol.materialgenderid, gtcmaterialcontrol.materialtypeid, gtcmaterialcontrol.materialphysicaltypeid, gtcexemplarycontrol.itemnumber AS exemplaryitemnumber, gtcexemplarycontrol.originallibraryunitid AS exemplaryoriginallibraryunitid, gtcexemplarycontrol.libraryunitid AS exemplarylibraryunitid, gtcexemplarycontrol.acquisitiontype AS exemplaryacquisitiontype, gtcexemplarycontrol.exemplarystatusid AS exemplaryexemplarystatusid, gtcexemplarycontrol.materialgenderid AS exemplarymaterialgenderid, gtcexemplarycontrol.materialtypeid AS exemplarymaterialtypeid, gtcexemplarycontrol.materialphysicaltypeid AS exemplarymaterialphysicaltypeid, gtcexemplarycontrol.entrancedate AS exemplaryentrancedate, gtcexemplarycontrol.lowdate AS exemplarylowdate FROM (gtcmaterialcontrol JOIN gtcexemplarycontrol ON ((gtcmaterialcontrol.controlnumberfather = gtcexemplarycontrol.controlnumber)))) UNION SELECT gtcmaterialcontrol.controlnumber, gtcmaterialcontrol.entrancedate, gtcmaterialcontrol.lastchangedate, gtcmaterialcontrol.category, gtcmaterialcontrol.level, gtcmaterialcontrol.materialgenderid, gtcmaterialcontrol.materialtypeid, gtcmaterialcontrol.materialphysicaltypeid, ''::character varying(20) AS exemplaryitemnumber, gtckardexcontrol.libraryunitid AS exemplaryoriginallibraryunitid, gtckardexcontrol.libraryunitid AS exemplarylibraryunitid, gtckardexcontrol.acquisitiontype AS exemplaryacquisitiontype, NULL::integer AS exemplaryexemplarystatusid, NULL::integer AS exemplarymaterialgenderid, gtcmaterialcontrol.materialtypeid AS exemplarymaterialtypeid, NULL::integer AS exemplarymaterialphysicaltypeid, gtckardexcontrol.entrancedate AS exemplaryentrancedate, NULL::date AS exemplarylowdate FROM (gtcmaterialcontrol RIGHT JOIN gtckardexcontrol USING (controlnumber));


ALTER TABLE public.searchmaterialview OWNER TO postgres;

--
-- Name: seq_bankinvoiceinfo; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_bankinvoiceinfo
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_bankinvoiceinfo OWNER TO postgres;

--
-- Name: seq_conceptid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_conceptid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_conceptid OWNER TO postgres;

--
-- Name: seq_courseoccurrenceid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_courseoccurrenceid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_courseoccurrenceid OWNER TO postgres;

--
-- Name: seq_coursevacantid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_coursevacantid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_coursevacantid OWNER TO postgres;

--
-- Name: seq_examid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_examid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_examid OWNER TO postgres;

--
-- Name: seq_examoccurrenceid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_examoccurrenceid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_examoccurrenceid OWNER TO postgres;

--
-- Name: seq_gtcmaterialevaluation; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_gtcmaterialevaluation
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_gtcmaterialevaluation OWNER TO postgres;

--
-- Name: seq_gtcworkflowhistory; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_gtcworkflowhistory
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_gtcworkflowhistory OWNER TO postgres;

--
-- Name: seq_gtcworkflowinstance; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_gtcworkflowinstance
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_gtcworkflowinstance OWNER TO postgres;

--
-- Name: seq_gtcworkflowstatus; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_gtcworkflowstatus
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_gtcworkflowstatus OWNER TO postgres;

--
-- Name: seq_inscriptionid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_inscriptionid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_inscriptionid OWNER TO postgres;

--
-- Name: seq_inscriptionoptionid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_inscriptionoptionid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_inscriptionoptionid OWNER TO postgres;

--
-- Name: seq_inscriptionstatus; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_inscriptionstatus
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_inscriptionstatus OWNER TO postgres;

--
-- Name: seq_itemphysicalresourceid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_itemphysicalresourceid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_itemphysicalresourceid OWNER TO postgres;

--
-- Name: seq_languageid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_languageid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_languageid OWNER TO postgres;

--
-- Name: seq_materialid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_materialid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_materialid OWNER TO postgres;

--
-- Name: seq_materialstate; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_materialstate
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_materialstate OWNER TO postgres;

--
-- Name: seq_materialtype; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_materialtype
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_materialtype OWNER TO postgres;

--
-- Name: seq_miolo_group; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_miolo_group
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_miolo_group OWNER TO postgres;

--
-- Name: seq_miolo_log; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_miolo_log
    START WITH 100
    INCREMENT BY 1
    MINVALUE 100
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_miolo_log OWNER TO postgres;

--
-- Name: seq_miolo_session; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_miolo_session
    START WITH 100
    INCREMENT BY 1
    MINVALUE 100
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_miolo_session OWNER TO postgres;

--
-- Name: seq_miolo_transaction; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_miolo_transaction
    START WITH 100
    INCREMENT BY 1
    MINVALUE 100
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_miolo_transaction OWNER TO postgres;

--
-- Name: seq_miolo_user; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_miolo_user
    START WITH 100
    INCREMENT BY 1
    MINVALUE 100
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_miolo_user OWNER TO postgres;

--
-- Name: seq_miolo_user_iduser; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_miolo_user_iduser
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_miolo_user_iduser OWNER TO postgres;

--
-- Name: seq_othersattleofmatterid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_othersattleofmatterid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_othersattleofmatterid OWNER TO postgres;

--
-- Name: seq_phoneid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_phoneid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_phoneid OWNER TO postgres;

--
-- Name: seq_placeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_placeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_placeid OWNER TO postgres;

--
-- Name: seq_placeroomid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_placeroomid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_placeroomid OWNER TO postgres;

--
-- Name: seq_requerimentid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_requerimentid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_requerimentid OWNER TO postgres;

--
-- Name: seq_sattleofmatterid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_sattleofmatterid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_sattleofmatterid OWNER TO postgres;

--
-- Name: seq_schedulelearningperiodid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_schedulelearningperiodid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_schedulelearningperiodid OWNER TO postgres;

--
-- Name: seq_selectiveprocesstypeid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_selectiveprocesstypeid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_selectiveprocesstypeid OWNER TO postgres;

--
-- Name: seq_tombo; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_tombo
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_tombo OWNER TO postgres;

--
-- Name: seq_tombostate; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_tombostate
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_tombostate OWNER TO postgres;

--
-- Name: seq_webdailylogid; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE seq_webdailylogid
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.seq_webdailylogid OWNER TO postgres;

--
-- Name: tabelareferenciada; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE tabelareferenciada (
    tabelareferenciadaid integer NOT NULL,
    referencia character varying(255) NOT NULL,
    cadastrodinamicoid integer NOT NULL
);


ALTER TABLE public.tabelareferenciada OWNER TO postgres;

--
-- Name: tabelareferenciada_tabelareferenciadaid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE tabelareferenciada_tabelareferenciadaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.tabelareferenciada_tabelareferenciadaid_seq OWNER TO postgres;

--
-- Name: tabelareferenciada_tabelareferenciadaid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE tabelareferenciada_tabelareferenciadaid_seq OWNED BY tabelareferenciada.tabelareferenciadaid;


--
-- Name: temp_bank_movement; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE temp_bank_movement (
    tempbankmovementid integer NOT NULL,
    invoiceid integer,
    filediscount numeric,
    fileinterestfine numeric,
    otherdiscounts numeric,
    otheradditions numeric,
    expenditure numeric,
    value numeric,
    valuepaid numeric,
    ournumber character varying(255),
    branch character varying(255),
    branchnumber character varying(255),
    wallet character varying(255),
    occurrencedate character varying(255),
    creditdate character varying(255),
    filematuritydate character varying(255),
    bankid character varying(3),
    fileid integer,
    occurrence character varying(255),
    bankreturnid integer,
    discountvalue numeric,
    convenantvalue numeric,
    interestvalue numeric,
    finevalue numeric,
    balance numeric,
    balancewithpolicies numeric,
    statusid integer
)
INHERITS (baslog);


ALTER TABLE public.temp_bank_movement OWNER TO postgres;

--
-- Name: temp_bank_movement_entries; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE temp_bank_movement_entries (
    tempentryid integer NOT NULL,
    invoiceid integer,
    operationid integer,
    entrydate date,
    value numeric,
    costcenterid character varying(30),
    comments text,
    bankreturncode character varying(50),
    isaccounted boolean DEFAULT false,
    creationtype character(1) DEFAULT 'A'::bpchar,
    tempbankmovementid integer
)
INHERITS (baslog);


ALTER TABLE public.temp_bank_movement_entries OWNER TO postgres;

--
-- Name: temp_bank_movement_entries_tempentryid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE temp_bank_movement_entries_tempentryid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.temp_bank_movement_entries_tempentryid_seq OWNER TO postgres;

--
-- Name: temp_bank_movement_entries_tempentryid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE temp_bank_movement_entries_tempentryid_seq OWNED BY temp_bank_movement_entries.tempentryid;


--
-- Name: temp_bank_movement_tempbankmovementid_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE temp_bank_movement_tempbankmovementid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.temp_bank_movement_tempbankmovementid_seq OWNER TO postgres;

--
-- Name: temp_bank_movement_tempbankmovementid_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE temp_bank_movement_tempbankmovementid_seq OWNED BY temp_bank_movement.tempbankmovementid;


--
-- Name: unit_acdacademiccalendar; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdacademiccalendar AS
    SELECT a.username, a.datetime, a.ipaddress, a.calendaryear, a.description, a.unitid, p.value, ul.unidadelogada FROM ((acdacademiccalendar a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdacademiccalendar OWNER TO solis;

--
-- Name: unit_acdclass; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdclass AS
    SELECT a.username, a.datetime, a.ipaddress, a.classid, a.name, a.initiallearningperiodid, a.vacant, a.unitid, p.value, ul.unidadelogada FROM ((acdclass a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdclass OWNER TO solis;

--
-- Name: unit_acdclasspupil; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdclasspupil AS
    SELECT a.username, a.datetime, a.ipaddress, a.classid, a.contractid, a.begindate, a.enddate, a.reasonid, a.unitid, p.value, ul.unidadelogada FROM ((acdclasspupil a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdclasspupil OWNER TO solis;

--
-- Name: unit_acdcondition; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdcondition AS
    SELECT a.username, a.datetime, a.ipaddress, a.conditionid, a.type, a.curriculumid, a.conditioncurriculumid, a.credits, a.numberhour, a.educationareaid, a.unitid, p.value, ul.unidadelogada FROM ((acdcondition a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdcondition OWNER TO solis;

--
-- Name: unit_acdcontract; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdcontract AS
    SELECT a.username, a.datetime, a.ipaddress, a.contractid, a.personid, a.courseid, a.courseversion, a.turnid, a.unitid, a.formationdate, a.formationperiodid, a.conclusiondate, a.emendsdate, a.diplomadate, a.maturityday, a.islistener, a.isrequestacademicdegree, a.globalaverage, a.contractnumber, a.obs, a.parcelsnumber, a.enadestatusid, a.bankaccountid, a.exploitenrollsintransfer, a.internalcontractid, a.internalcourseoccurrenceid, a.internalcourseoccurrenceversion, a.externalcourseid, a.internalunitid, a.internalturnid, a.externalconclusionperiod, a.cityid, a.externalconclusioninstitutionid, a.externalconclusiondate, a.year, a.institutionid, a.subscriptionid, p.value, ul.unidadelogada FROM ((acdcontract a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdcontract OWNER TO solis;

--
-- Name: unit_acdcontractexaminingboard; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdcontractexaminingboard AS
    SELECT a.username, a.datetime, a.ipaddress, a.contractexaminingboardid, a.contractid, a.examiningboarddate, a.title, a.professorids, a.unitid, p.value, ul.unidadelogada FROM ((acdcontractexaminingboard a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdcontractexaminingboard OWNER TO solis;

--
-- Name: unit_acdcourseoccurrence; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdcourseoccurrence AS
    SELECT a.username, a.datetime, a.ipaddress, a.courseid, a.courseversion, a.turnid, a.unitid, a.authorizationdate, a.authorizationdocument, a.status, a.minimumconclusioncourse, a.maximumconclusioncourse, a.costcenterid, a.daystofrequencenotification, a.idcursoinep, a.vagasinep, p.value, ul.unidadelogada FROM ((acdcourseoccurrence a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdcourseoccurrence OWNER TO solis;

--
-- Name: unit_acdcourseparent; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdcourseparent AS
    SELECT a.username, a.datetime, a.ipaddress, a.courseparentid, a.courseid, a.courseversion, a.turnid, a.unitid, a.parentcourseid, a.parentcourseversion, a.parentturnid, a.parentunitid, a.parentcurricularcomponentsperiod, p.value, ul.unidadelogada FROM ((acdcourseparent a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdcourseparent OWNER TO solis;

--
-- Name: unit_acdcourseversiontype; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdcourseversiontype AS
    SELECT a.username, a.datetime, a.ipaddress, a.courseversiontypeid, a.description, a.regimen, a.unitid, p.value, ul.unidadelogada FROM ((acdcourseversiontype a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdcourseversiontype OWNER TO solis;

--
-- Name: unit_acdcurricularcomponentgroup; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdcurricularcomponentgroup AS
    SELECT a.username, a.datetime, a.ipaddress, a.curricularcomponentgroupid, a.name, a.shortname, a.unitid, p.value, ul.unidadelogada FROM ((acdcurricularcomponentgroup a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdcurricularcomponentgroup OWNER TO solis;

--
-- Name: unit_acdcurriculum; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdcurriculum AS
    SELECT a.username, a.datetime, a.ipaddress, a.curriculumid, a.courseid, a.courseversion, a.turnid, a.unitid, a.curricularcomponentid, a.curricularcomponentversion, a.curricularcomponenttypeid, a.semester, a.showinscholarshipdescription, a.curricularcomponentgroupdocumentendcourseid, a.curricularcomponentgroupelectiveid, a.curriculumtypeid, a.enddate, a.showinbulletin, p.value, ul.unidadelogada FROM ((acdcurriculum a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdcurriculum OWNER TO solis;

--
-- Name: unit_acdcurriculumconcurrence; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdcurriculumconcurrence AS
    SELECT a.username, a.datetime, a.ipaddress, a.curriculumoutid, a.curriculuminid, a.unitid, p.value, ul.unidadelogada FROM ((acdcurriculumconcurrence a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdcurriculumconcurrence OWNER TO solis;

--
-- Name: unit_acdcurriculumlink; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdcurriculumlink AS
    SELECT a.username, a.datetime, a.ipaddress, a.curriculumid, a.curriculumlinkid, a.unitid, p.value, ul.unidadelogada FROM ((acdcurriculumlink a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdcurriculumlink OWNER TO solis;

--
-- Name: unit_acdenroll; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdenroll AS
    SELECT a.username, a.datetime, a.ipaddress, a.enrollid, a.contractid, a.groupid, a.curriculumid, a.dateenroll, a.hourenroll, a.datecancellation, a.hourcancellation, a.reasoncancellationid, a.note, a.examnote, a.finalnote, a.concept, a.textevaluation, a.frequency, a.obsexploitation, a.exploitationinstitutionid, a.numberhourexploitation, a.creditsexploitation, a.isshowdocumentendcourse, a.statusid, a.frequencyalertemail, a.isinternet, a.ip, a.isconfirm, a.issetfree, a.complement, a.exploitationtype, a.process, a.isexploitation, a.learningperiodid, a.subclassid, a.finalexaminationtheme, a.detailenrollstatusid, a.preenrollconsumevacant, a.unitid, a.examiningboard, p.value, ul.unidadelogada FROM ((acdenroll a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdenroll OWNER TO solis;

--
-- Name: unit_acdenrollconfig; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdenrollconfig AS
    SELECT a.username, a.datetime, a.ipaddress, a.enrollconfigid, a.courseid, a.courseversion, a.turnid, a.unitid, a.freeincourseconditions, a.timetocoursedisapproved, a.showelectives, a.showoptionals, a.blockdebt, a.sendconfirmationemail, a.confirmationemailid, a.showothercoursesgroups, a.showotherunitsgroups, a.showotherturnsgroups, a.showspecialregimengroups, a.showotherclassesgroups, a.freeotherperiodgroups, a.disapprovementstoblock, a.maychoosegroups, a.checkscheduleshock, a.blockdocsmissing, a.blockrequirementmissing, a.showothergroupsfield, a.scheduledisplaymode, a.checkdebits, a.disapprovementstoblocktimetocoursedisapproved, a.showelectivesexternal, a.showoptionalsexternal, a.showoothercoursesgroupsexternal, a.showootherunitsgroupsexternal, a.showotherturnsgroupsexternal, a.showotherclassesgroupsexternal, a.freeotherperiodgroupsexternal, a.checkscheduleshockexternal, a.blockdocsmissingexternal, a.blockdebtexternal, a.checkdebitsexternal, a.scheduledisplaymodeexternal, a.sendconfirmationemailexternal, a.minimumandmaxlimitcreditsblockenroll, a.minimumcreditsturncourse, a.maxcreditsturncourse, a.minimumcreditsotherturn, a.maxcreditsotherturn, a.enableselectcurricularcomponentpending, a.enableselectcurricularcomponentoffutureperiods, a.enableenrollweb, a.minimumandmaxlimitcreditsblockenrollexternal, a.minimumcreditsturncourseexternal, a.maxcreditsturncourseexternal, a.minimumcreditsotherturncourseexternal, a.maxcreditsotherturncourseexternal, a.enableselectcurricularcomponentoffutureperiodsexternal, a.enableselectcurricularcomponentpendingexternal, a.configurablemessagestep1, a.configurablemessagestep2, a.configurablemessagestep3, a.avaliablecontract, a.avaliableaddendum, a.avaliableenrollconfirmation, a.begindate, a.enddate, a.enablepreenroll, a.preenrollconsumevacant, a.preenrollchecksignature, a.preenrollcheckfirstpayment, a.preenrollwebconfirmation, a.ativaprematriculapara, a.pendenciasgnuteca, a.bloqueioemprestimos, a.bloqueiomultas, a.bloqueiopenalidades, a.bloqueiomensagem, a.diasprazoconfirmacao, a.cancelamentostatecontractid, a.cancelamentoreasonid, p.value, ul.unidadelogada FROM ((acdenrollconfig a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdenrollconfig OWNER TO solis;

--
-- Name: unit_acdevaluation; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdevaluation AS
    SELECT a.username, a.datetime, a.ipaddress, a.evaluationid, a.degreeid, a.description, a.dateforecast, a.weight, a.professorid, a.groupid, a.moodleevaluationid, a.maxpoints, a.unitid, p.value, ul.unidadelogada FROM ((acdevaluation a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdevaluation OWNER TO solis;

--
-- Name: unit_acdevent; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdevent AS
    SELECT a.username, a.datetime, a.ipaddress, a.eventid, a.description, a.begindate, a.enddate, a.accountschemeid, a.costcenterid, a.policyid, a.incomesourceid, a.inscriptionfee, a.numberhours, a.unitid, p.value, ul.unidadelogada FROM ((acdevent a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdevent OWNER TO solis;

--
-- Name: unit_acdeventparticipation; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdeventparticipation AS
    SELECT a.username, a.datetime, a.ipaddress, a.eventid, a.personid, a.unitid, p.value, ul.unidadelogada FROM ((acdeventparticipation a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdeventparticipation OWNER TO solis;

--
-- Name: unit_acdexploitation; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdexploitation AS
    SELECT a.username, a.datetime, a.ipaddress, a.exploitationid, a.enrollid, a.exploitationtype, a.exploitationenrollid, a.exploitationnumberhours, a.exploitationcredits, a.institutionid, a.coursename, a.curricularcomponentname, a.finalnote, a.numberhours, a.credits, a.period, a.unitid, a.electivecurriculumid, p.value, ul.unidadelogada FROM ((acdexploitation a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdexploitation OWNER TO solis;

--
-- Name: unit_acdgroup; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdgroup AS
    SELECT a.username, a.datetime, a.ipaddress, a.groupid, a.learningperiodid, a.curriculumid, a.complement, a.vacant, a.iscancellation, a.objectives, a.content, a.methodology, a.evaluation, a.basicbibliography, a.complementarybibliography, a.observation, a.regimenid, a.isusewebdaily, a.isclosed, a.totalenrolled, a.iscontentprogrammarian, a.basicbibliographydescription, a.classid, a.useconcept, a.leaderid, a.subleaderid, a.financecredits, a.professorresponsible, a.evaluationtypeid, a.frequenceregisternotification, a.conceptgroupid, a.gradestypingfinished, a.complementarybibliographydescription, a.unitid, a.creationdate, p.value, ul.unidadelogada FROM ((acdgroup a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdgroup OWNER TO solis;

--
-- Name: unit_acdlearningperiod; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdlearningperiod AS
    SELECT a.username, a.datetime, a.ipaddress, a.learningperiodid, a.periodid, a.courseid, a.courseversion, a.turnid, a.unitid, a.description, a.formationlevelid, a.previouslearningperiodid, a.begindate, a.enddate, a.begindatelessons, a.weekendexamsbegin, a.finalaverage, a.minimumfrequency, a.sagu1periodid, a.minimumcredits, a.minimumcreditsfreshman, a.minimumcreditsturn, a.sagu1previousperiodid, a.parcelsnumber, a.isfinancegenerate, a.disapprovementstodisapproveperiod, a.isclosed, a.maximumdisapprovals, a.maximumperiods, a.isnumberhours, a.maximumcredits, a.maximumcreditsfreshman, a.gradesbyconcept, a.evaluationcontrolmethodid, a.justifydisapprovals, a.maximumfinalaverage, a.enrollacceptedterm, a.limitregisterdate, p.value, ul.unidadelogada FROM ((acdlearningperiod a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdlearningperiod OWNER TO solis;

--
-- Name: unit_acdmessagecontractrenewal; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdmessagecontractrenewal AS
    SELECT a.username, a.datetime, a.ipaddress, a.messagecontractrenewalid, a.learningperiodid, a.message, a.font, a.sequence, a.length, a.islistener, a.status, a.unitid, p.value, ul.unidadelogada FROM ((acdmessagecontractrenewal a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdmessagecontractrenewal OWNER TO solis;

--
-- Name: unit_acdperiodenrolldate; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdperiodenrolldate AS
    SELECT a.username, a.datetime, a.ipaddress, a.periodenrolldateid, a.learningperiodid, a.description, a.begindate, a.enddate, a.isinternet, a.isadjustment, a.isselectiveproc, a.unitid, p.value, ul.unidadelogada FROM ((acdperiodenrolldate a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdperiodenrolldate OWNER TO solis;

--
-- Name: unit_acdrestricteddocuments; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdrestricteddocuments AS
    SELECT a.username, a.datetime, a.ipaddress, a.restricteddocumentid, a.documenttypeid, a.formationlevelid, a.courseid, a.courseversion, a.turnid, a.unitid, a.isin, p.value, ul.unidadelogada FROM ((acdrestricteddocuments a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdrestricteddocuments OWNER TO solis;

--
-- Name: unit_acdsubclass; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdsubclass AS
    SELECT a.username, a.datetime, a.ipaddress, a.subclassid, a.classid, a.description, a.personid, a.groupid, a.unitid, p.value, ul.unidadelogada FROM ((acdsubclass a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdsubclass OWNER TO solis;

--
-- Name: unit_acdtestendcoursetype; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdtestendcoursetype AS
    SELECT a.username, a.datetime, a.ipaddress, a.testendcoursetypeid, a.description, a.begindate, a.enddate, a.unitid, p.value, ul.unidadelogada FROM ((acdtestendcoursetype a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdtestendcoursetype OWNER TO solis;

--
-- Name: unit_acdtimesheet; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdtimesheet AS
    SELECT a.username, a.datetime, a.ipaddress, a.timesheetid, a.description, a.begindate, a.enddate, a.unitid, p.value, ul.unidadelogada FROM ((acdtimesheet a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdtimesheet OWNER TO solis;

--
-- Name: unit_acdtrainingemphasis; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW unit_acdtrainingemphasis AS
    SELECT a.username, a.datetime, a.ipaddress, a.trainingemphasisid, a.groupid, a.description, a.responsibleid, a.summary, a.place, a.unitid, p.value, ul.unidadelogada FROM ((acdtrainingemphasis a JOIN (SELECT getparameter.getparameter AS value FROM getparameter('BASIC'::character varying, 'ATIVAR_MULTIUNIDADE'::character varying) getparameter(getparameter)) p ON (true)) JOIN (SELECT obterunidadelogada.obterunidadelogada AS unidadelogada FROM obterunidadelogada() obterunidadelogada(obterunidadelogada)) ul ON (((ul.unidadelogada = a.unitid) OR ((p.value)::text = 'f'::text))));


ALTER TABLE public.unit_acdtrainingemphasis OWNER TO solis;

--
-- Name: view_alunos_ojs; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW view_alunos_ojs AS
    SELECT c.login AS usuario, c.m_password AS senha, a.personid AS matricula, a.name AS nome, CASE WHEN (EXISTS (SELECT aa.enrollid FROM ((acdenroll aa JOIN acdgroup bb USING (groupid)) JOIN acdlearningperiod cc ON ((cc.learningperiodid = bb.learningperiodid))) WHERE (((((now())::date >= cc.begindate) AND ((now())::date <= cc.enddate)) AND (aa.statusid <> 5)) AND (aa.contractid = b.contractid)))) THEN 'A'::text ELSE 'I'::text END AS situacao, a.email, b.courseid AS cod_curso, getcoursename(b.courseid) AS curso, getunitdescription(b.unitid) AS unidade FROM ((basphysicalpersonstudent a JOIN acdcontract b USING (personid)) LEFT JOIN miolo_user c ON (((c.login)::text = (a.miolousername)::text)));


ALTER TABLE public.view_alunos_ojs OWNER TO postgres;

--
-- Name: view_censo_aluno_cursos; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW view_censo_aluno_cursos AS
    SELECT DISTINCT sel.id_aluno, COALESCE(sel.id_curso, ''::character varying) AS id_curso, sel.contrato, CASE WHEN (sel.turno = (getparameter('BASIC'::character varying, 'TURNO_MATUTINO'::character varying))::integer) THEN '1'::text WHEN (sel.turno = (getparameter('BASIC'::character varying, 'TURNO_VESPERTINO'::character varying))::integer) THEN '2'::text WHEN (sel.turno = (getparameter('BASIC'::character varying, 'TURNO_NOTURNO'::character varying))::integer) THEN '3'::text WHEN (sel.turno = (getparameter('BASIC'::character varying, 'TURNO_INTEGRAL'::character varying))::integer) THEN '4'::text ELSE NULL::text END AS turno, CASE WHEN (matriculados.estado_contratual IS NOT NULL) THEN matriculados.estado_contratual ELSE evasoes.estado_contratual END AS situacao_de_vinculo, CASE WHEN (matriculados.estado_contratual = 2) THEN '0'::text ELSE ''::text END AS forma_ingresso_pecg, CASE WHEN (matriculados.estado_contratual = 2) THEN '0'::text ELSE ''::text END AS mobilidade_academica, COALESCE(sel.semestre_de_conclusao, ''::character varying) AS semestre_de_conclusao, CASE WHEN (ingresso.datahora IS NOT NULL) THEN COALESCE(to_char(((ingresso.datahora)::date)::timestamp with time zone, 'ddmmyyyy'::text), ''::text) ELSE COALESCE((SELECT to_char(min(acdmovementcontract.statetime), 'ddmmyyyy'::text) AS to_char FROM acdmovementcontract WHERE (acdmovementcontract.contractid = sel.contrato)), ''::text) END AS data_de_ingresso, 0 AS ingresso_por_enem, CASE WHEN (ingresso.estado = 1) THEN 1 ELSE 0 END AS ingresso_por_vestibular, CASE WHEN ((ingresso.estado <> 1) OR (ingresso.estado IS NULL)) THEN 1 ELSE 0 END AS outras_formas_de_ingresso, CASE WHEN (sum(sel.possui_financiamento) > 0) THEN '1'::text ELSE '0'::text END AS possui_financiamento, CASE WHEN (sum(sel.possui_financiamento) > 0) THEN CASE WHEN (sum(sel.possui_fies) > 0) THEN '1'::text ELSE '0'::text END ELSE ''::text END AS possui_fies, CASE WHEN (sum(sel.possui_financiamento) > 0) THEN CASE WHEN (sum(sel.possui_prouni_integral) > 0) THEN '1'::text ELSE '0'::text END ELSE ''::text END AS possui_prouni_integral, CASE WHEN (sum(sel.possui_financiamento) > 0) THEN CASE WHEN (sum(sel.possui_prouni_parcial) > 0) THEN '1'::text ELSE '0'::text END ELSE ''::text END AS possui_prouni_parcial, CASE WHEN (sum(sel.possui_financiamento) > 0) THEN '0'::text ELSE ''::text END AS financ_reembolsavel_estadual, CASE WHEN (sum(sel.possui_financiamento) > 0) THEN '0'::text ELSE ''::text END AS financ_reembolsavel_municipal, CASE WHEN (sum(sel.possui_financiamento) > 0) THEN '0'::text ELSE ''::text END AS financ_reembolsavel_ies, CASE WHEN (sum(sel.possui_financiamento) > 0) THEN '0'::text ELSE ''::text END AS financ_reembolsavel_externas, CASE WHEN (sum(sel.possui_financiamento) > 0) THEN '0'::text ELSE ''::text END AS financ_n_reembolsavel_estadual, CASE WHEN (sum(sel.possui_financiamento) > 0) THEN '0'::text ELSE ''::text END AS financ_n_reembolsavel_municipal, CASE WHEN (sum(sel.possui_financiamento) > 0) THEN '0'::text ELSE ''::text END AS financ_n_reembolsavel_ies, CASE WHEN (sum(sel.possui_financiamento) > 0) THEN '0'::text ELSE ''::text END AS financ_n_reembolsavel_externas FROM ((((SELECT a.personid AS id_aluno, co.idcursoinep AS id_curso, a.turnid AS turno, semestreconclusaocursopessoacenso(a.contractid) AS semestre_de_conclusao, CASE WHEN (c.value > (0)::numeric) THEN 1 ELSE 0 END AS possui_financiamento, CASE WHEN (c.incentivetypeid = 3) THEN 1 ELSE 0 END AS possui_fies, CASE WHEN (((c.incentivetypeid = 4) AND (c.valueispercent IS TRUE)) AND (c.value = (100)::numeric)) THEN 1 ELSE 0 END AS possui_prouni_integral, CASE WHEN (((c.incentivetypeid = 4) AND (c.valueispercent IS TRUE)) AND (c.value < (100)::numeric)) THEN 1 ELSE 0 END AS possui_prouni_parcial, a.contractid AS contrato, b.periodid AS periodo FROM (((acdcontract a JOIN acdcourseoccurrence co ON ((((((co.courseid)::text = (a.courseid)::text) AND (co.courseversion = a.courseversion)) AND (co.turnid = a.turnid)) AND (co.unitid = a.unitid)))) JOIN acdlearningperiod b ON ((((((b.courseid)::text = (a.courseid)::text) AND (b.courseversion = a.courseversion)) AND (b.turnid = a.turnid)) AND (b.unitid = a.unitid)))) LEFT JOIN finincentive c ON ((((c.contractid = a.contractid) AND (c.incentivetypeid = ANY (ARRAY[3, 4]))) AND "overlaps"((b.begindate)::timestamp with time zone, (b.enddate)::timestamp with time zone, (c.startdate)::timestamp with time zone, (c.enddate)::timestamp with time zone)))) WHERE (((b.periodid)::text = '2013/2'::text) AND (a.contractid IN (SELECT max(xc.contractid) AS max FROM (acdcontract xc JOIN acdcourseoccurrence xco ON ((((((xc.courseid)::text = (xco.courseid)::text) AND (xc.courseversion = xco.courseversion)) AND (xc.turnid = xco.turnid)) AND (xc.unitid = xco.unitid)))) WHERE ((xc.personid = a.personid) AND ((xco.idcursoinep)::text = (co.idcursoinep)::text)))))) sel LEFT JOIN (SELECT a.contractid AS contrato, a.statecontractid AS estado, min(a.statetime) AS datahora FROM (acdmovementcontract a JOIN acdstatecontract b USING (statecontractid)) WHERE (upper((b.inouttransition)::text) = 'I'::text) GROUP BY a.contractid, a.statecontractid) ingresso ON ((ingresso.contrato = sel.contrato))) LEFT JOIN (SELECT DISTINCT c.contractid AS contrato, f.periodid AS periodo, 2 AS estado_contratual FROM (acdcontract c JOIN acdlearningperiod f ON ((((((f.courseid)::text = (c.courseid)::text) AND (f.courseversion = c.courseversion)) AND (f.unitid = c.unitid)) AND (f.turnid = c.turnid)))) WHERE ((EXISTS (SELECT aa.enrollid FROM ((acdenroll aa JOIN acdgroup bb USING (groupid)) JOIN acdlearningperiod cc ON ((cc.learningperiodid = bb.learningperiodid))) WHERE (((aa.contractid = c.contractid) AND ((cc.periodid)::text = (f.periodid)::text)) AND (aa.statusid <> ALL (ARRAY[5, 6, 7]))))) AND ((f.periodid)::text = '2013/2'::text))) matriculados ON (((matriculados.contrato = sel.contrato) AND ((matriculados.periodo)::text = (sel.periodo)::text)))) LEFT JOIN (SELECT DISTINCT COALESCE(d.periodid, (SELECT acdlearningperiod.periodid FROM acdlearningperiod WHERE (((((((acdlearningperiod.courseid)::text = (c.courseid)::text) AND (acdlearningperiod.courseversion = c.courseversion)) AND (acdlearningperiod.unitid = c.unitid)) AND (acdlearningperiod.turnid = c.turnid)) AND (a.statetime >= acdlearningperiod.begindate)) AND (a.statetime <= acdlearningperiod.enddate)))) AS periodo, CASE WHEN (a.statecontractid = 5) THEN 3 WHEN (a.statecontractid = 7) THEN 5 WHEN (a.statecontractid = ANY (ARRAY[9, 10, 11])) THEN 6 WHEN (a.statecontractid = ANY (ARRAY[12, 18])) THEN 4 WHEN (a.statecontractid = ANY (ARRAY[13, 17])) THEN 4 ELSE 4 END AS estado_contratual, c.contractid AS contrato FROM ((((acdmovementcontract a JOIN acdstatecontract b USING (statecontractid)) JOIN acdcontract c USING (contractid)) JOIN basphysicalpersonstudent e USING (personid)) LEFT JOIN acdlearningperiod d USING (learningperiodid)) WHERE ((b.isclosecontract IS TRUE) AND (NOT (EXISTS (SELECT aa.enrollid FROM ((acdenroll aa JOIN acdgroup bb USING (groupid)) JOIN acdlearningperiod cc ON ((cc.learningperiodid = bb.learningperiodid))) WHERE (((aa.contractid = a.contractid) AND (((cc.periodid)::text = (d.periodid)::text) OR (((d.periodid IS NULL) AND ((a.statetime)::date >= cc.begindate)) AND ((a.statetime)::date <= cc.enddate)))) AND (aa.statusid <> ALL (ARRAY[5, 6, 7])))))))) evasoes ON (((evasoes.contrato = sel.contrato) AND ((evasoes.periodo)::text = (sel.periodo)::text)))) WHERE (((sel.periodo)::text = '2013/2'::text) AND ((evasoes.estado_contratual IS NOT NULL) OR (matriculados.estado_contratual IS NOT NULL))) GROUP BY sel.contrato, sel.id_aluno, sel.id_curso, sel.turno, CASE WHEN (matriculados.estado_contratual IS NOT NULL) THEN matriculados.estado_contratual ELSE evasoes.estado_contratual END, CASE WHEN (matriculados.estado_contratual = 2) THEN '0'::text ELSE ''::text END, sel.semestre_de_conclusao, ingresso.datahora, ingresso.estado, CASE WHEN ((ingresso.estado <> 1) OR (ingresso.estado IS NULL)) THEN 1 ELSE 0 END ORDER BY sel.id_aluno, COALESCE(sel.id_curso, ''::character varying);


ALTER TABLE public.view_censo_aluno_cursos OWNER TO solis;

--
-- Name: view_censo_aluno; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW view_censo_aluno AS
    SELECT DISTINCT a.personid AS id_aluno, COALESCE(a.name, ''::character varying) AS nome, COALESCE(replace(replace(b.content, '.'::text, ''::text), '-'::text, ''::text), ''::text) AS cpf, COALESCE(to_char((a.datebirth)::timestamp with time zone, 'ddmmyyyy'::text), ''::text) AS data_nascimento, CASE WHEN (upper((a.sex)::text) = 'M'::text) THEN '0'::text ELSE '1'::text END AS sexo, '6'::text AS origemetnica, COALESCE(unaccent((CASE WHEN (a.mothername IS NOT NULL) THEN a.mothername ELSE COALESCE((SELECT basperson.name FROM ONLY basperson WHERE (basperson.personid = c.relativepersonid)), ''::character varying) END)::text), ''::text) AS nome_da_mae, CASE WHEN (((a.countryidbirth)::text <> 'BRA'::text) AND (a.countryidbirth IS NOT NULL)) THEN '3'::text ELSE '1'::text END AS nacionalidade, CASE WHEN (a.countryidbirth IS NULL) THEN ('BRA'::character varying)::text ELSE (a.countryidbirth)::text END AS pais_de_origem, CASE WHEN ((a.specialnecessityid IS NOT NULL) AND (a.specialnecessityid <> 0)) THEN '1'::text ELSE '0'::text END AS tem_deficiencia, CASE WHEN ((a.specialnecessityid IS NOT NULL) AND (a.specialnecessityid <> 0)) THEN '0'::text ELSE ''::text END AS deficiencia_cegueira, CASE WHEN ((a.specialnecessityid IS NOT NULL) AND (a.specialnecessityid <> 0)) THEN CASE WHEN (a.specialnecessityid = 5) THEN '1'::text ELSE '0'::text END ELSE ''::text END AS deficiencia_visao, CASE WHEN ((a.specialnecessityid IS NOT NULL) AND (a.specialnecessityid <> 0)) THEN '0'::text ELSE ''::text END AS deficiencia_surdez, CASE WHEN ((a.specialnecessityid IS NOT NULL) AND (a.specialnecessityid <> 0)) THEN CASE WHEN (a.specialnecessityid = 1) THEN '1'::text ELSE '0'::text END ELSE ''::text END AS deficiencia_auditiva, CASE WHEN ((a.specialnecessityid IS NOT NULL) AND (a.specialnecessityid <> 0)) THEN CASE WHEN (a.specialnecessityid = 2) THEN '1'::text ELSE '0'::text END ELSE ''::text END AS deficiencia_fisica, CASE WHEN ((a.specialnecessityid IS NOT NULL) AND (a.specialnecessityid <> 0)) THEN '0'::text ELSE ''::text END AS deficiencia_surdocegueira, CASE WHEN ((a.specialnecessityid IS NOT NULL) AND (a.specialnecessityid <> 0)) THEN CASE WHEN (a.specialnecessityid = 3) THEN '1'::text ELSE '0'::text END ELSE ''::text END AS deficiencia_multipla, CASE WHEN ((a.specialnecessityid IS NOT NULL) AND (a.specialnecessityid <> 0)) THEN CASE WHEN (a.specialnecessityid = 4) THEN '1'::text ELSE '0'::text END ELSE ''::text END AS deficiencia_intelectual, CASE WHEN ((a.specialnecessityid IS NOT NULL) AND (a.specialnecessityid <> 0)) THEN '0'::text ELSE ''::text END AS deficiencia_autismo, CASE WHEN ((a.specialnecessityid IS NOT NULL) AND (a.specialnecessityid <> 0)) THEN '0'::text ELSE ''::text END AS deficiencia_sindrome_asperger, CASE WHEN ((a.specialnecessityid IS NOT NULL) AND (a.specialnecessityid <> 0)) THEN '0'::text ELSE ''::text END AS deficiencia_sindrome_rett, CASE WHEN ((a.specialnecessityid IS NOT NULL) AND (a.specialnecessityid <> 0)) THEN '0'::text ELSE ''::text END AS deficiencia_transtorno_desintegrativo, CASE WHEN ((a.specialnecessityid IS NOT NULL) AND (a.specialnecessityid <> 0)) THEN '0'::text ELSE ''::text END AS deficiencia_superdotado FROM (((ONLY basphysicalpersonstudent a JOIN view_censo_aluno_cursos d ON ((d.id_aluno = a.personid))) LEFT JOIN basdocument b ON (((b.personid = a.personid) AND (b.documenttypeid = (getparameter('BASIC'::character varying, 'DEFAULT_DOCUMENT_TYPE_ID_CPF'::character varying))::integer)))) LEFT JOIN basphysicalpersonkinship c ON (((c.personid = a.personid) AND (c.kinshipid = (getparameter('BASIC'::character varying, 'MOTHER_KINSHIP_ID'::character varying))::integer)))) ORDER BY a.personid;


ALTER TABLE public.view_censo_aluno OWNER TO solis;

SET search_path = spr, pg_catalog;

--
-- Name: option; Type: TABLE; Schema: spr; Owner: postgres; Tablespace: 
--

CREATE TABLE option (
    optionid integer NOT NULL,
    selectiveprocessid integer NOT NULL,
    description character varying(255) NOT NULL,
    vacancies integer NOT NULL,
    maximumsubstitutes integer NOT NULL,
    quotes integer
)
INHERITS (public.baslog);


ALTER TABLE spr.option OWNER TO postgres;

--
-- Name: optioncourse; Type: TABLE; Schema: spr; Owner: postgres; Tablespace: 
--

CREATE TABLE optioncourse (
    optionid integer NOT NULL,
    courseid character varying(10) NOT NULL,
    courseversion integer NOT NULL,
    unitid integer NOT NULL,
    turnid integer NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE spr.optioncourse OWNER TO postgres;

SET search_path = public, pg_catalog;

--
-- Name: view_censo_cursos; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW view_censo_cursos AS
    SELECT cursos.curso, CASE WHEN (cursos.teve_alunos IS TRUE) THEN '1'::text ELSE '0'::text END AS teve_alunos, CASE WHEN (cursos.teve_alunos IS FALSE) THEN '4'::text ELSE ''::text END AS motivo_nao_teve_alunos, CASE WHEN (curso_turno.matutino IS TRUE) THEN '1'::text ELSE '0'::text END AS turno_matutino, CASE WHEN (curso_turno.matutino IS TRUE) THEN (curso_turno.prazo_minimo_matutino)::text ELSE ''::text END AS prazo_minimo_matutino, CASE WHEN (curso_turno.matutino IS TRUE) THEN COALESCE((curso_turno.vagas_ps_matutino)::text, '0'::text) ELSE ''::text END AS vagas_ps_matutino, CASE WHEN (curso_turno.matutino IS TRUE) THEN (curso_turno.inscritos_ps_matutino)::text ELSE ''::text END AS inscritos_ps_matutino, CASE WHEN (curso_turno.matutino IS TRUE) THEN '0'::text ELSE ''::text END AS numero_outras_vagas_matutino, CASE WHEN (curso_turno.matutino IS TRUE) THEN '0'::text ELSE ''::text END AS numero_inscritos_outras_vagas_matutino, CASE WHEN (curso_turno.vespertino IS TRUE) THEN '1'::text ELSE '0'::text END AS turno_vespertino, CASE WHEN (curso_turno.vespertino IS TRUE) THEN (curso_turno.prazo_minimo_vespertino)::text ELSE ''::text END AS prazo_minimo_vespertino, CASE WHEN (curso_turno.vespertino IS TRUE) THEN COALESCE((curso_turno.vagas_ps_vespertino)::text, '0'::text) ELSE ''::text END AS vagas_ps_vespertino, CASE WHEN (curso_turno.vespertino IS TRUE) THEN (curso_turno.inscritos_ps_vespertino)::text ELSE ''::text END AS inscritos_ps_vespertino, CASE WHEN (curso_turno.vespertino IS TRUE) THEN '0'::text ELSE ''::text END AS numero_outras_vagas_vespertino, CASE WHEN (curso_turno.vespertino IS TRUE) THEN '0'::text ELSE ''::text END AS numero_inscritos_outras_vagas_vespertino, CASE WHEN (curso_turno.noturno IS TRUE) THEN '1'::text ELSE '0'::text END AS turno_noturno, CASE WHEN (curso_turno.noturno IS TRUE) THEN (curso_turno.prazo_minimo_noturno)::text ELSE ''::text END AS prazo_minimo_noturno, CASE WHEN (curso_turno.noturno IS TRUE) THEN COALESCE((curso_turno.vagas_ps_noturno)::text, '0'::text) ELSE ''::text END AS vagas_ps_noturno, CASE WHEN (curso_turno.noturno IS TRUE) THEN (curso_turno.inscritos_ps_noturno)::text ELSE ''::text END AS inscritos_ps_noturno, CASE WHEN (curso_turno.noturno IS TRUE) THEN '0'::text ELSE ''::text END AS numero_outras_vagas_noturno, CASE WHEN (curso_turno.noturno IS TRUE) THEN '0'::text ELSE ''::text END AS numero_inscritos_outras_vagas_noturno, CASE WHEN (curso_turno.integral IS TRUE) THEN '1'::text ELSE '0'::text END AS turno_integral, CASE WHEN (curso_turno.integral IS TRUE) THEN (curso_turno.prazo_minimo_integral)::text ELSE ''::text END AS prazo_minimo_integral, CASE WHEN (curso_turno.integral IS TRUE) THEN COALESCE((curso_turno.vagas_ps_integral)::text, '0'::text) ELSE ''::text END AS vagas_ps_integral, CASE WHEN (curso_turno.integral IS TRUE) THEN (curso_turno.inscritos_ps_integral)::text ELSE ''::text END AS inscritos_ps_integral, CASE WHEN (curso_turno.integral IS TRUE) THEN '0'::text ELSE ''::text END AS numero_outras_vagas_integral, CASE WHEN (curso_turno.integral IS TRUE) THEN '0'::text ELSE ''::text END AS numero_inscritos_outras_vagas_integral, CASE WHEN (cursos.teve_alunos = true) THEN '0'::text ELSE ''::text END AS condicoes_ensino_aprendizagem, CASE WHEN (cursos.teve_alunos = true) THEN '0'::text ELSE ''::text END AS utiliza_instalacoes_aulas_praticas, CASE WHEN (cursos.teve_alunos = true) THEN '0'::text ELSE ''::text END AS oferece_disciplina_semipresencial, array_to_string(ARRAY[CASE WHEN (1 = 1) THEN 'Erro 1'::text ELSE NULL::text END, CASE WHEN (1 = 2) THEN 'Erro 2'::text ELSE NULL::text END, CASE WHEN (1 = 1) THEN 'Erro 3'::text ELSE NULL::text END], ', '::text) AS erros FROM ((SELECT DISTINCT a.idcursoinep AS curso, (EXISTS (SELECT aa.contractid FROM ((((acdenroll aa JOIN acdcontract bb USING (contractid)) JOIN acdgroup cc USING (groupid)) JOIN acdlearningperiod dd ON ((dd.learningperiodid = cc.learningperiodid))) JOIN acdcourseoccurrence ee ON (((ee.courseid)::text = (bb.courseid)::text))) WHERE ((((ee.idcursoinep)::text = (a.idcursoinep)::text) AND (aa.statusid <> ALL (ARRAY[5, 6, 7]))) AND ((dd.periodid)::text = ANY (ARRAY[('2013/2'::character varying)::text, ('2013/1'::character varying)::text]))))) AS teve_alunos FROM acdcourseoccurrence a) cursos JOIN (SELECT DISTINCT a.idcursoinep AS curso, (EXISTS (SELECT 1 FROM acdcourseoccurrence WHERE (((acdcourseoccurrence.idcursoinep)::text = (a.idcursoinep)::text) AND (acdcourseoccurrence.turnid = (getparameter('BASIC'::character varying, 'TURNO_MATUTINO'::character varying))::integer)))) AS matutino, (SELECT COALESCE(min(acdcourseoccurrence.minimumconclusioncourse), (0)::double precision) AS "coalesce" FROM acdcourseoccurrence WHERE (((acdcourseoccurrence.idcursoinep)::text = (acdcourseoccurrence.idcursoinep)::text) AND (acdcourseoccurrence.turnid = (getparameter('BASIC'::character varying, 'TURNO_MATUTINO'::character varying))::integer))) AS prazo_minimo_matutino, (EXISTS (SELECT 1 FROM acdcourseoccurrence WHERE (((acdcourseoccurrence.idcursoinep)::text = (a.idcursoinep)::text) AND (acdcourseoccurrence.turnid = (getparameter('BASIC'::character varying, 'TURNO_VESPERTINO'::character varying))::integer)))) AS vespertino, (SELECT COALESCE(min(acdcourseoccurrence.minimumconclusioncourse), (0)::double precision) AS "coalesce" FROM acdcourseoccurrence WHERE (((acdcourseoccurrence.idcursoinep)::text = (a.idcursoinep)::text) AND (acdcourseoccurrence.turnid = (getparameter('BASIC'::character varying, 'TURNO_VESPERTINO'::character varying))::integer))) AS prazo_minimo_vespertino, (EXISTS (SELECT 1 FROM acdcourseoccurrence WHERE (((acdcourseoccurrence.idcursoinep)::text = (a.idcursoinep)::text) AND (acdcourseoccurrence.turnid = (getparameter('BASIC'::character varying, 'TURNO_NOTURNO'::character varying))::integer)))) AS noturno, (SELECT COALESCE(min(acdcourseoccurrence.minimumconclusioncourse), (0)::double precision) AS "coalesce" FROM acdcourseoccurrence WHERE (((acdcourseoccurrence.idcursoinep)::text = (a.idcursoinep)::text) AND (acdcourseoccurrence.turnid = (getparameter('BASIC'::character varying, 'TURNO_NOTURNO'::character varying))::integer))) AS prazo_minimo_noturno, (EXISTS (SELECT 1 FROM acdcourseoccurrence WHERE (((acdcourseoccurrence.idcursoinep)::text = (a.idcursoinep)::text) AND (acdcourseoccurrence.turnid = (getparameter('BASIC'::character varying, 'TURNO_INTEGRAL'::character varying))::integer)))) AS integral, (SELECT COALESCE(min(acdcourseoccurrence.minimumconclusioncourse), (0)::double precision) AS "coalesce" FROM acdcourseoccurrence WHERE (((acdcourseoccurrence.idcursoinep)::text = (a.idcursoinep)::text) AND (acdcourseoccurrence.turnid = (getparameter('BASIC'::character varying, 'TURNO_INTEGRAL'::character varying))::integer))) AS prazo_minimo_integral, (SELECT DISTINCT COALESCE((acdcourseoccurrence.vagasinep)::double precision, (0)::double precision) AS "coalesce" FROM acdcourseoccurrence WHERE (((acdcourseoccurrence.idcursoinep)::text = (acdcourseoccurrence.idcursoinep)::text) AND (acdcourseoccurrence.turnid = (getparameter('BASIC'::character varying, 'TURNO_MATUTINO'::character varying))::integer))) AS vagas_ps_matutino, (SELECT DISTINCT COALESCE((acdcourseoccurrence.vagasinep)::double precision, (0)::double precision) AS "coalesce" FROM acdcourseoccurrence WHERE (((acdcourseoccurrence.idcursoinep)::text = (acdcourseoccurrence.idcursoinep)::text) AND (acdcourseoccurrence.turnid = (getparameter('BASIC'::character varying, 'TURNO_VESPERTINO'::character varying))::integer))) AS vagas_ps_vespertino, (SELECT DISTINCT COALESCE((acdcourseoccurrence.vagasinep)::double precision, (0)::double precision) AS "coalesce" FROM acdcourseoccurrence WHERE (((acdcourseoccurrence.idcursoinep)::text = (acdcourseoccurrence.idcursoinep)::text) AND (acdcourseoccurrence.turnid = (getparameter('BASIC'::character varying, 'TURNO_NOTURNO'::character varying))::integer))) AS vagas_ps_noturno, (SELECT DISTINCT COALESCE((acdcourseoccurrence.vagasinep)::double precision, (0)::double precision) AS "coalesce" FROM acdcourseoccurrence WHERE (((acdcourseoccurrence.idcursoinep)::text = (acdcourseoccurrence.idcursoinep)::text) AND (acdcourseoccurrence.turnid = (getparameter('BASIC'::character varying, 'TURNO_INTEGRAL'::character varying))::integer))) AS vagas_ps_integral, (SELECT count(*) AS count FROM ((((spr.optioncourse oc LEFT JOIN spr.option o ON ((o.optionid = oc.optionid))) LEFT JOIN spr.subscriptionoption s ON ((s.optionid = o.optionid))) LEFT JOIN spr.selectiveprocess sp ON ((sp.selectiveprocessid = o.selectiveprocessid))) LEFT JOIN acdcourseoccurrence co ON ((((((co.courseid)::text = (oc.courseid)::text) AND (co.courseversion = oc.courseversion)) AND (co.turnid = oc.turnid)) AND (co.unitid = oc.unitid)))) WHERE (((((co.idcursoinep)::text = (a.idcursoinep)::text) AND (oc.turnid = (getparameter('BASIC'::character varying, 'TURNO_MATUTINO'::character varying))::integer)) AND (s.optionnumber = 1)) AND ((sp.periodid)::text = ANY (ARRAY[('2013/2'::character varying)::text, ('2013/1'::character varying)::text])))) AS inscritos_ps_matutino, (SELECT count(*) AS count FROM ((((spr.optioncourse oc LEFT JOIN spr.option o ON ((o.optionid = oc.optionid))) LEFT JOIN spr.subscriptionoption s ON ((s.optionid = o.optionid))) LEFT JOIN spr.selectiveprocess sp ON ((sp.selectiveprocessid = o.selectiveprocessid))) LEFT JOIN acdcourseoccurrence co ON ((((((co.courseid)::text = (oc.courseid)::text) AND (co.courseversion = oc.courseversion)) AND (co.turnid = oc.turnid)) AND (co.unitid = oc.unitid)))) WHERE (((((co.idcursoinep)::text = (a.idcursoinep)::text) AND (oc.turnid = (getparameter('BASIC'::character varying, 'TURNO_VESPERTINO'::character varying))::integer)) AND (s.optionnumber = 1)) AND ((sp.periodid)::text = ANY (ARRAY[('2013/2'::character varying)::text, ('2013/1'::character varying)::text])))) AS inscritos_ps_vespertino, (SELECT count(*) AS count FROM ((((spr.optioncourse oc LEFT JOIN spr.option o ON ((o.optionid = oc.optionid))) LEFT JOIN spr.subscriptionoption s ON ((s.optionid = o.optionid))) LEFT JOIN spr.selectiveprocess sp ON ((sp.selectiveprocessid = o.selectiveprocessid))) LEFT JOIN acdcourseoccurrence co ON ((((((co.courseid)::text = (oc.courseid)::text) AND (co.courseversion = oc.courseversion)) AND (co.turnid = oc.turnid)) AND (co.unitid = oc.unitid)))) WHERE (((((co.idcursoinep)::text = (a.idcursoinep)::text) AND (oc.turnid = (getparameter('BASIC'::character varying, 'TURNO_NOTURNO'::character varying))::integer)) AND (s.optionnumber = 1)) AND ((sp.periodid)::text = ANY (ARRAY[('2013/2'::character varying)::text, ('2013/1'::character varying)::text])))) AS inscritos_ps_noturno, (SELECT count(*) AS count FROM ((((spr.optioncourse oc LEFT JOIN spr.option o ON ((o.optionid = oc.optionid))) LEFT JOIN spr.subscriptionoption s ON ((s.optionid = o.optionid))) LEFT JOIN spr.selectiveprocess sp ON ((sp.selectiveprocessid = o.selectiveprocessid))) LEFT JOIN acdcourseoccurrence co ON ((((((co.courseid)::text = (oc.courseid)::text) AND (co.courseversion = oc.courseversion)) AND (co.turnid = oc.turnid)) AND (co.unitid = oc.unitid)))) WHERE (((((co.idcursoinep)::text = (a.idcursoinep)::text) AND (oc.turnid = (getparameter('BASIC'::character varying, 'TURNO_INTEGRAL'::character varying))::integer)) AND (s.optionnumber = 1)) AND ((sp.periodid)::text = ANY (ARRAY[('2013/2'::character varying)::text, ('2013/1'::character varying)::text])))) AS inscritos_ps_integral FROM acdcourseoccurrence a) curso_turno ON (((curso_turno.curso)::text = (cursos.curso)::text))) WHERE (cursos.curso IS NOT NULL) ORDER BY cursos.curso;


ALTER TABLE public.view_censo_cursos OWNER TO solis;

--
-- Name: view_censo_docente; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW view_censo_docente AS
    SELECT (a.personid)::text AS id_professor, COALESCE((a.name)::text, ''::text) AS nome, COALESCE(replace(replace(b.content, '.'::text, ''::text), '-'::text, ''::text), ''::text) AS cpf, COALESCE(to_char((a.datebirth)::timestamp with time zone, 'ddmmyyyy'::text), ''::text) AS data_nascimento, CASE WHEN (upper((a.sex)::text) = 'M'::text) THEN '0'::text ELSE '1'::text END AS sexo, (verificaorigemetnicapessoacenso(a.ethnicoriginid))::text AS origemetnica, unaccent((CASE WHEN (a.mothername IS NOT NULL) THEN a.mothername ELSE COALESCE((SELECT basperson.name FROM ONLY basperson WHERE (basperson.personid = c.relativepersonid)), ''::character varying) END)::text) AS nome_da_mae, CASE WHEN (((a.countryidbirth)::text <> 'BRA'::text) AND (a.countryidbirth IS NOT NULL)) THEN '3'::text ELSE '1'::text END AS nacionalidade, CASE WHEN (a.countryidbirth IS NULL) THEN 'BRA'::text ELSE (a.countryidbirth)::text END AS pais_de_origem, CASE WHEN ((a.specialnecessityid IS NOT NULL) AND (a.specialnecessityid <> 0)) THEN '1'::text ELSE '0'::text END AS tem_deficiencia, CASE WHEN ((a.specialnecessityid IS NOT NULL) AND (a.specialnecessityid <> 0)) THEN '0'::text ELSE ''::text END AS deficiencia_cegueira, CASE WHEN ((a.specialnecessityid IS NOT NULL) AND (a.specialnecessityid <> 0)) THEN CASE WHEN (a.specialnecessityid = 5) THEN '1'::text ELSE '0'::text END ELSE ''::text END AS deficiencia_visao, CASE WHEN ((a.specialnecessityid IS NOT NULL) AND (a.specialnecessityid <> 0)) THEN '0'::text ELSE ''::text END AS deficiencia_surdez, CASE WHEN ((a.specialnecessityid IS NOT NULL) AND (a.specialnecessityid <> 0)) THEN CASE WHEN (a.specialnecessityid = 1) THEN '1'::text ELSE '0'::text END ELSE ''::text END AS deficiencia_auditiva, CASE WHEN ((a.specialnecessityid IS NOT NULL) AND (a.specialnecessityid <> 0)) THEN CASE WHEN (a.specialnecessityid = 2) THEN '1'::text ELSE '0'::text END ELSE ''::text END AS deficiencia_fisica, CASE WHEN ((a.specialnecessityid IS NOT NULL) AND (a.specialnecessityid <> 0)) THEN '0'::text ELSE ''::text END AS deficiencia_surdocegueira, CASE WHEN ((a.specialnecessityid IS NOT NULL) AND (a.specialnecessityid <> 0)) THEN CASE WHEN (a.specialnecessityid = 3) THEN '1'::text ELSE '0'::text END ELSE ''::text END AS deficiencia_multipla, CASE WHEN ((a.specialnecessityid IS NOT NULL) AND (a.specialnecessityid <> 0)) THEN CASE WHEN (a.specialnecessityid = 4) THEN '1'::text ELSE '0'::text END ELSE ''::text END AS deficiencia_intelectual, CASE WHEN (a.escolaridade IS NOT NULL) THEN (a.escolaridade)::text ELSE '1'::text END AS escolaridade, CASE WHEN (a.escolaridade = 2) THEN ((a.posgraduacao - 1))::text ELSE ''::text END AS pos_graduacao, CASE WHEN (a.situacao IS NOT NULL) THEN (a.situacao)::text ELSE '0'::text END AS situacao_ies, CASE WHEN (a.situacao = 1) THEN CASE WHEN (EXISTS (SELECT DISTINCT aa.professorid AS id_professor, dd.courseid AS curso FROM (((acdscheduleprofessor aa JOIN acdschedule bb USING (scheduleid)) JOIN acdgroup cc USING (groupid)) JOIN acdlearningperiod dd USING (learningperiodid)) WHERE (((dd.periodid)::text = '2013/2'::text) AND (aa.professorid = a.personid)))) THEN '1'::text ELSE '0'::text END ELSE ''::text END AS esteve_em_exercicio, CASE WHEN (a.situacao = 1) THEN COALESCE((a.regimetrabalho)::text, ''::text) ELSE ''::text END AS regime_trabalho, CASE WHEN (a.situacao = 1) THEN CASE WHEN (a.substituto IS TRUE) THEN '1'::text ELSE '0'::text END ELSE ''::text END AS substituto, CASE WHEN (a.situacao = 1) THEN CASE WHEN (a.visitante IS TRUE) THEN '1'::text ELSE '0'::text END ELSE ''::text END AS visitante, CASE WHEN ((a.situacao = 1) AND (a.visitante IS TRUE)) THEN COALESCE((a.tipovinculo)::text, ''::text) ELSE ''::text END AS tipo_vinculo_ies, CASE WHEN (a.situacao = 1) THEN CASE WHEN (EXISTS (SELECT 1 FROM basatuacaoprofessor ap WHERE ((ap.personid = a.personid) AND (ap.tipoatuacaoprofessorid = 10001)))) THEN '1'::text ELSE '0'::text END ELSE ''::text END AS atuacao_sequencial_formacao_especifica, CASE WHEN (a.situacao = 1) THEN CASE WHEN (EXISTS (SELECT 1 FROM basatuacaoprofessor ap WHERE ((ap.personid = a.personid) AND (ap.tipoatuacaoprofessorid = 10002)))) THEN '1'::text ELSE '0'::text END ELSE ''::text END AS atuacao_graduacao_presencial, CASE WHEN (a.situacao = 1) THEN CASE WHEN (EXISTS (SELECT 1 FROM basatuacaoprofessor ap WHERE ((ap.personid = a.personid) AND (ap.tipoatuacaoprofessorid = 10003)))) THEN '1'::text ELSE '0'::text END ELSE ''::text END AS atuacao_graduacao_distancia, CASE WHEN (a.situacao = 1) THEN CASE WHEN (EXISTS (SELECT 1 FROM basatuacaoprofessor ap WHERE ((ap.personid = a.personid) AND (ap.tipoatuacaoprofessorid = 10004)))) THEN '1'::text ELSE '0'::text END ELSE ''::text END AS atuacao_stricto_sensu_presencial, CASE WHEN (a.situacao = 1) THEN CASE WHEN (EXISTS (SELECT 1 FROM basatuacaoprofessor ap WHERE ((ap.personid = a.personid) AND (ap.tipoatuacaoprofessorid = 10005)))) THEN '1'::text ELSE '0'::text END ELSE ''::text END AS atuacao_stricto_sensu_distancia, CASE WHEN (a.situacao = 1) THEN CASE WHEN (EXISTS (SELECT 1 FROM basatuacaoprofessor ap WHERE ((ap.personid = a.personid) AND (ap.tipoatuacaoprofessorid = 10006)))) THEN '1'::text ELSE '0'::text END ELSE ''::text END AS atuacao_pesquisa, CASE WHEN (a.situacao = 1) THEN CASE WHEN (EXISTS (SELECT 1 FROM basatuacaoprofessor ap WHERE ((ap.personid = a.personid) AND (ap.tipoatuacaoprofessorid = 10007)))) THEN '1'::text ELSE '0'::text END ELSE ''::text END AS atuacao_extensao, CASE WHEN (a.situacao = 1) THEN CASE WHEN (EXISTS (SELECT 1 FROM basatuacaoprofessor ap WHERE ((ap.personid = a.personid) AND (ap.tipoatuacaoprofessorid = 10008)))) THEN '1'::text ELSE '0'::text END ELSE ''::text END AS atuacao_gestao_planejamento_avaliacao, CASE WHEN (a.situacao = 1) THEN CASE WHEN (EXISTS (SELECT 1 FROM basatuacaoprofessor ap WHERE ((ap.personid = a.personid) AND (ap.tipoatuacaoprofessorid = 10006)))) THEN '1'::text ELSE '0'::text END ELSE ''::text END AS bolsa_pesquisa, CASE WHEN (EXISTS (SELECT DISTINCT aa.professorid AS id_professor, dd.courseid AS curso FROM (((acdscheduleprofessor aa JOIN acdschedule bb USING (scheduleid)) JOIN acdgroup cc USING (groupid)) JOIN acdlearningperiod dd USING (learningperiodid)) WHERE (((dd.periodid)::text = '2013/2'::text) AND (aa.professorid = a.personid)))) THEN '1'::text ELSE '0'::text END AS esta_ativo, array_to_string(ARRAY[CASE WHEN ((a.situacao = 1) AND ((SELECT count(*) AS count FROM basatuacaoprofessor ap WHERE (ap.personid = a.personid)) = 0)) THEN 'A situacao do docente na IES esta como `Em exercicio`, porem, nao foi definido nenhuma atuacao (cadastro no passo 5 do Professor)'::text ELSE NULL::text END, CASE WHEN (1 = 2) THEN 'Erro 2'::text ELSE NULL::text END, CASE WHEN (1 = 1) THEN 'Erro 3'::text ELSE NULL::text END], ', '::text) AS erros FROM ((basphysicalpersonprofessor a LEFT JOIN basdocument b ON (((b.personid = a.personid) AND (b.documenttypeid = (getparameter('BASIC'::character varying, 'DEFAULT_DOCUMENT_TYPE_ID_CPF'::character varying))::integer)))) LEFT JOIN basphysicalpersonkinship c ON (((c.personid = a.personid) AND (c.kinshipid = (getparameter('BASIC'::character varying, 'MOTHER_KINSHIP_ID'::character varying))::integer))));


ALTER TABLE public.view_censo_docente OWNER TO solis;

--
-- Name: view_censo_docente_cursos; Type: VIEW; Schema: public; Owner: solis
--

CREATE VIEW view_censo_docente_cursos AS
    SELECT DISTINCT a.professorid AS id_professor, d.courseid AS curso, COALESCE(co.idcursoinep, ''::character varying) AS idcursoinep, array_to_string(ARRAY[CASE WHEN (co.idcursoinep IS NULL) THEN 'Nao foi informado o ID do curso no INEP (cadastro em Ocorrencia de curso)'::text ELSE NULL::text END], ', '::text) AS erros FROM ((((acdscheduleprofessor a JOIN acdschedule b USING (scheduleid)) JOIN acdgroup c USING (groupid)) JOIN acdlearningperiod d USING (learningperiodid)) JOIN acdcourseoccurrence co ON ((((((co.courseid)::text = (d.courseid)::text) AND (co.courseversion = d.courseversion)) AND (co.turnid = d.turnid)) AND (co.unitid = d.unitid)))) WHERE ((d.periodid)::text = '2013/2'::text) ORDER BY a.professorid;


ALTER TABLE public.view_censo_docente_cursos OWNER TO solis;

--
-- Name: view_centros; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW view_centros AS
    SELECT DISTINCT (SELECT a.valor FROM ava_totalizadores_atributos a WHERE ((a.ref_totalizador = t.id_totalizador) AND (a.chave = 'ref_centro'::text))) AS id, (SELECT a.valor FROM ava_totalizadores_atributos a WHERE ((a.ref_totalizador = t.id_totalizador) AND (a.chave = 'nome_centro'::text))) AS nome FROM ava_totalizadores t ORDER BY (SELECT a.valor FROM ava_totalizadores_atributos a WHERE ((a.ref_totalizador = t.id_totalizador) AND (a.chave = 'ref_centro'::text))), (SELECT a.valor FROM ava_totalizadores_atributos a WHERE ((a.ref_totalizador = t.id_totalizador) AND (a.chave = 'nome_centro'::text)));


ALTER TABLE public.view_centros OWNER TO postgres;

--
-- Name: view_lancamentos_categorizados; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW view_lancamentos_categorizados AS
    SELECT a.invoiceid AS cod_titulo, a.personid AS cod_pessoa, b.name AS pessoa, n.description AS nv_formacao, a.parcelnumber AS no_parcela, a.maturitydate AS dt_vencimento, CASE WHEN (ARRAY[c.operationid] && array_append(d.paymentoperations, j.paymentoperation)) THEN c.entrydate ELSE NULL::date END AS dt_pagamento, c.value AS valor, CASE WHEN (ARRAY[c.operationid] && ARRAY[j.interestoperation]) THEN 'multa/Juros'::text WHEN (ARRAY[c.operationid] && array_cat(i.discountoperations, ARRAY[j.otherdiscountsoperation, j.discountoperation])) THEN 'Pontualidade'::text WHEN (ARRAY[c.operationid] && array_append(d.paymentoperations, j.paymentoperation)) THEN 'Liquido Recebido'::text WHEN (h.operationid = e.operationid) THEN 'Bolsas'::text WHEN (ARRAY[c.operationid] && ARRAY[j.banktaxoperation, j.bankclosingtaxoperation]) THEN 'Taxas'::text WHEN (ARRAY[c.operationid] && ARRAY[j.enrolloperation]) THEN 'Valor original'::text ELSE 'Outros'::text END AS tipo, CASE WHEN (ARRAY[c.operationid] && ARRAY[j.interestoperation]) THEN 80 WHEN (ARRAY[c.operationid] && array_cat(i.discountoperations, ARRAY[j.otherdiscountsoperation, j.discountoperation])) THEN 2 WHEN (ARRAY[c.operationid] && array_append(d.paymentoperations, j.paymentoperation)) THEN 100 WHEN (h.operationid = e.operationid) THEN 3 WHEN (ARRAY[c.operationid] && ARRAY[j.banktaxoperation, j.bankclosingtaxoperation]) THEN 70 WHEN (ARRAY[c.operationid] && ARRAY[j.enrolloperation]) THEN 1 ELSE 99 END AS ordem_tipo, c.operationid AS cod_operacao, l.unitid AS cod_unidade, a.bankaccountid AS cod_conta_bancaria FROM (((((((((((((ONLY finreceivableinvoice a JOIN ONLY basphysicalperson b ON ((a.personid = b.personid))) JOIN ONLY finentry c ON ((a.invoiceid = c.invoiceid))) FULL JOIN (SELECT (string_to_array((((getparameter('FINANCE'::character varying, 'PAYMENT_OPERATIONS'::character varying))::text || ','::text) || (getparameter('BASIC'::character varying, 'BANK_PAYMENT_OPERATION_ID'::character varying))::text), ','::text))::integer[] AS paymentoperations) d ON (true)) JOIN ONLY finoperation e ON ((c.operationid = e.operationid))) JOIN (SELECT a1.invoiceid, b1.contractid FROM (finreceivableinvoice a1 JOIN finentry b1 ON (((a1.invoiceid = b1.invoiceid) AND (b1.contractid IS NOT NULL)))) GROUP BY a1.invoiceid, b1.contractid) f ON ((a.invoiceid = f.invoiceid))) LEFT JOIN ONLY finincentive g ON ((f.contractid = g.contractid))) LEFT JOIN ONLY finincentivetype h ON ((g.incentivetypeid = h.incentivetypeid))) FULL JOIN (SELECT (string_to_array((getparameter('FINANCE'::character varying, 'DISCOUNT'::character varying))::text, ','::text))::integer[] AS discountoperations) i ON (true)) FULL JOIN (SELECT findefaultoperations.interestoperation, findefaultoperations.otherdiscountsoperation, findefaultoperations.discountoperation, findefaultoperations.banktaxoperation, findefaultoperations.paymentoperation, findefaultoperations.bankclosingtaxoperation, findefaultoperations.enrolloperation FROM findefaultoperations) j ON (true)) FULL JOIN (SELECT (string_to_array((getparameter('FINANCE'::character varying, 'DEFAULT_TAX_BANK_OPERATION_ID'::character varying))::text, ','::text))::integer[] AS discountoperations) k ON (true)) JOIN acdcontract l ON ((f.contractid = l.contractid))) JOIN acdcourse m ON (((l.courseid)::text = (m.courseid)::text))) JOIN acdformationlevel n ON ((m.formationlevelid = n.formationlevelid))) WHERE (a.iscanceled IS FALSE);


ALTER TABLE public.view_lancamentos_categorizados OWNER TO postgres;

--
-- Name: view_projetos_pedagogicos; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW view_projetos_pedagogicos AS
    SELECT DISTINCT (SELECT a.valor FROM ava_totalizadores_atributos a WHERE ((a.ref_totalizador = t.id_totalizador) AND (a.chave = 'ref_projeto_pedagogico'::text))) AS id, (SELECT a.valor FROM ava_totalizadores_atributos a WHERE ((a.ref_totalizador = t.id_totalizador) AND (a.chave = 'nome_projeto_pedagogico'::text))) AS nome FROM ava_totalizadores t ORDER BY (SELECT a.valor FROM ava_totalizadores_atributos a WHERE ((a.ref_totalizador = t.id_totalizador) AND (a.chave = 'ref_projeto_pedagogico'::text))), (SELECT a.valor FROM ava_totalizadores_atributos a WHERE ((a.ref_totalizador = t.id_totalizador) AND (a.chave = 'nome_projeto_pedagogico'::text)));


ALTER TABLE public.view_projetos_pedagogicos OWNER TO postgres;

--
-- Name: view_receita; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW view_receita AS
    SELECT a.unidade, a.curso, a.turno, a.periodo, a.matricula, a.nome, a.titulo, a.vencimento, a.referencia, a.cod_origem, a.origem, a.valor_nominal, a.valor_incentivos, ((a.valor_descontos + getinvoicediscountvalue(a.titulo, (now())::date)) + getinvoiceconvenantvalue(a.titulo, (now())::date)) AS valor_descontos, a.valor_pago, CASE WHEN (a.inadimplencia > (0)::numeric) THEN a.inadimplencia ELSE CASE WHEN ((a.vencimento < (now())::date) AND (b.balance > (0)::numeric)) THEN ((a.valor_nominal - a.valor_incentivos) - ((a.valor_descontos + getinvoicediscountvalue(a.titulo, (now())::date)) + getinvoiceconvenantvalue(a.titulo, (now())::date))) ELSE (0)::numeric END END AS inadimplencia, CASE WHEN ((SELECT count(xx.invoiceid) AS count FROM finhistoricoremessa xx WHERE (xx.invoiceid = a.titulo) LIMIT 1) > (0)::bigint) THEN 't'::text ELSE 'f'::text END AS envionaremessa, a.periodo_letivo, a.contrato FROM (fininfotitulo a JOIN finreceivableinvoice b ON ((b.invoiceid = a.titulo)));


ALTER TABLE public.view_receita OWNER TO postgres;

SET search_path = res, pg_catalog;

--
-- Name: atividadeextra; Type: TABLE; Schema: res; Owner: postgres; Tablespace: 
--

CREATE TABLE atividadeextra (
    atividadeextraid integer NOT NULL,
    descricao character varying(255) NOT NULL,
    conteudo text,
    inicio timestamp without time zone NOT NULL,
    fim timestamp without time zone NOT NULL,
    cargahoraria real NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE res.atividadeextra OWNER TO postgres;

--
-- Name: atividadeextra_atividadeextraid_seq; Type: SEQUENCE; Schema: res; Owner: postgres
--

CREATE SEQUENCE atividadeextra_atividadeextraid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE res.atividadeextra_atividadeextraid_seq OWNER TO postgres;

--
-- Name: atividadeextra_atividadeextraid_seq; Type: SEQUENCE OWNED BY; Schema: res; Owner: postgres
--

ALTER SEQUENCE atividadeextra_atividadeextraid_seq OWNED BY atividadeextra.atividadeextraid;


--
-- Name: cargahorariacomplementar; Type: TABLE; Schema: res; Owner: postgres; Tablespace: 
--

CREATE TABLE cargahorariacomplementar (
    cargahorariacomplementarid integer NOT NULL,
    tipodecargahorariacomplementarid integer NOT NULL,
    unidadetematicaid integer NOT NULL,
    residenteid integer NOT NULL,
    cargahoraria real NOT NULL,
    justificativa character varying(255)
)
INHERITS (public.baslog);


ALTER TABLE res.cargahorariacomplementar OWNER TO postgres;

--
-- Name: cargahorariacomplementar_cargahorariacomplementarid_seq; Type: SEQUENCE; Schema: res; Owner: postgres
--

CREATE SEQUENCE cargahorariacomplementar_cargahorariacomplementarid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE res.cargahorariacomplementar_cargahorariacomplementarid_seq OWNER TO postgres;

--
-- Name: cargahorariacomplementar_cargahorariacomplementarid_seq; Type: SEQUENCE OWNED BY; Schema: res; Owner: postgres
--

ALTER SEQUENCE cargahorariacomplementar_cargahorariacomplementarid_seq OWNED BY cargahorariacomplementar.cargahorariacomplementarid;


--
-- Name: coorientador; Type: TABLE; Schema: res; Owner: postgres; Tablespace: 
--

CREATE TABLE coorientador (
    personid bigint NOT NULL,
    trabalhodeconclusaoid integer NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE res.coorientador OWNER TO postgres;

--
-- Name: encontro; Type: TABLE; Schema: res; Owner: postgres; Tablespace: 
--

CREATE TABLE encontro (
    encontroid integer NOT NULL,
    temaid integer,
    ofertadeunidadetematicaid integer NOT NULL,
    inicio timestamp without time zone NOT NULL,
    fim timestamp without time zone NOT NULL,
    cargahoraria real NOT NULL,
    conteudoministrado text,
    ministrante character varying(255) NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE res.encontro OWNER TO postgres;

--
-- Name: encontro_encontroid_seq; Type: SEQUENCE; Schema: res; Owner: postgres
--

CREATE SEQUENCE encontro_encontroid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE res.encontro_encontroid_seq OWNER TO postgres;

--
-- Name: encontro_encontroid_seq; Type: SEQUENCE OWNED BY; Schema: res; Owner: postgres
--

ALTER SEQUENCE encontro_encontroid_seq OWNED BY encontro.encontroid;


--
-- Name: ofertadeunidadetematica; Type: TABLE; Schema: res; Owner: postgres; Tablespace: 
--

CREATE TABLE ofertadeunidadetematica (
    ofertadeunidadetematicaid integer NOT NULL,
    personid bigint NOT NULL,
    unidadetematicaid integer NOT NULL,
    inicio date NOT NULL,
    fim date NOT NULL,
    encerramento timestamp without time zone,
    encerradopor integer
)
INHERITS (public.baslog);


ALTER TABLE res.ofertadeunidadetematica OWNER TO postgres;

--
-- Name: tema; Type: TABLE; Schema: res; Owner: postgres; Tablespace: 
--

CREATE TABLE tema (
    temaid integer NOT NULL,
    descricao character varying(255) NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE res.tema OWNER TO postgres;

--
-- Name: unidadetematica; Type: TABLE; Schema: res; Owner: postgres; Tablespace: 
--

CREATE TABLE unidadetematica (
    unidadetematicaid integer NOT NULL,
    periodo character varying(10) NOT NULL,
    descricao character varying(255) NOT NULL,
    sumula text,
    cargahoraria real NOT NULL,
    frequenciaminima real NOT NULL,
    tipo character(1) NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE res.unidadetematica OWNER TO postgres;

--
-- Name: encontrosofertadeunidadetematica; Type: VIEW; Schema: res; Owner: solis
--

CREATE VIEW encontrosofertadeunidadetematica AS
    SELECT a.ofertadeunidadetematicaid, e.personid AS personidpreceptor_oferta, e.name AS nomepreceptor_oferta, a.inicio AS inicio_oferta, a.fim AS fim_oferta, a.encerramento AS dataencerramento_oferta, a.encerradopor AS encerradopor_oferta, a.unidadetematicaid, b.descricao AS descricao_unidadetematica, b.periodo AS periodo_unidadetematica, b.sumula AS sumula_unidadetematica, b.cargahoraria AS cargahoraria_unidadetematica, b.frequenciaminima AS frequenciaminima_unidadetematica, b.tipo AS tipo_unidadetematica, CASE WHEN (b.tipo = 'T'::bpchar) THEN 'TEÓRICA'::text ELSE 'PRÁTICA'::text END AS descricaotipo_unidadetematica, f.encontroid AS codigo_encontro, f.temaid AS codigotema_encontro, g.descricao AS descricaotema_encontro, (f.inicio)::date AS datainicio_encontro, (f.fim)::date AS datafim_encontro, (f.inicio)::time without time zone AS horainicio_encontro, (f.fim)::time without time zone AS horafim_encontro, f.cargahoraria AS cargahoraria_encontro, f.conteudoministrado AS conteudoministrado_encontro, f.ministrante AS ministrante_encontro FROM ((((ofertadeunidadetematica a JOIN unidadetematica b ON ((a.unidadetematicaid = b.unidadetematicaid))) JOIN ONLY public.basphysicalperson e ON ((e.personid = a.personid))) JOIN encontro f ON ((f.ofertadeunidadetematicaid = a.ofertadeunidadetematicaid))) LEFT JOIN tema g ON ((f.temaid = g.temaid)));


ALTER TABLE res.encontrosofertadeunidadetematica OWNER TO solis;

--
-- Name: enfase; Type: TABLE; Schema: res; Owner: postgres; Tablespace: 
--

CREATE TABLE enfase (
    enfaseid integer NOT NULL,
    descricao character varying(255) NOT NULL,
    abreviatura character varying(30) NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE res.enfase OWNER TO postgres;

--
-- Name: enfase_enfaseid_seq; Type: SEQUENCE; Schema: res; Owner: postgres
--

CREATE SEQUENCE enfase_enfaseid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE res.enfase_enfaseid_seq OWNER TO postgres;

--
-- Name: enfase_enfaseid_seq; Type: SEQUENCE OWNED BY; Schema: res; Owner: postgres
--

ALTER SEQUENCE enfase_enfaseid_seq OWNED BY enfase.enfaseid;


--
-- Name: enfasedaunidadetematica; Type: TABLE; Schema: res; Owner: postgres; Tablespace: 
--

CREATE TABLE enfasedaunidadetematica (
    unidadetematicaid integer NOT NULL,
    enfaseid integer NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE res.enfasedaunidadetematica OWNER TO postgres;

--
-- Name: frequencia; Type: TABLE; Schema: res; Owner: postgres; Tablespace: 
--

CREATE TABLE frequencia (
    encontroid integer NOT NULL,
    residenteid integer NOT NULL,
    presenca character(1) NOT NULL,
    justificativa character varying(255)
)
INHERITS (public.baslog);


ALTER TABLE res.frequencia OWNER TO postgres;

--
-- Name: membrodabanca; Type: TABLE; Schema: res; Owner: postgres; Tablespace: 
--

CREATE TABLE membrodabanca (
    personid bigint NOT NULL,
    trabalhodeconclusaoid integer NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE res.membrodabanca OWNER TO postgres;

--
-- Name: nucleodaunidadetematica; Type: TABLE; Schema: res; Owner: postgres; Tablespace: 
--

CREATE TABLE nucleodaunidadetematica (
    unidadetematicaid integer NOT NULL,
    nucleoprofissionalid integer NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE res.nucleodaunidadetematica OWNER TO postgres;

--
-- Name: nucleoprofissional; Type: TABLE; Schema: res; Owner: postgres; Tablespace: 
--

CREATE TABLE nucleoprofissional (
    nucleoprofissionalid integer NOT NULL,
    descricao character varying(255) NOT NULL,
    abreviatura character varying(30) NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE res.nucleoprofissional OWNER TO postgres;

--
-- Name: nucleoprofissional_nucleoprofissionalid_seq; Type: SEQUENCE; Schema: res; Owner: postgres
--

CREATE SEQUENCE nucleoprofissional_nucleoprofissionalid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE res.nucleoprofissional_nucleoprofissionalid_seq OWNER TO postgres;

--
-- Name: nucleoprofissional_nucleoprofissionalid_seq; Type: SEQUENCE OWNED BY; Schema: res; Owner: postgres
--

ALTER SEQUENCE nucleoprofissional_nucleoprofissionalid_seq OWNED BY nucleoprofissional.nucleoprofissionalid;


--
-- Name: ocorrenciadecontrato; Type: TABLE; Schema: res; Owner: postgres; Tablespace: 
--

CREATE TABLE ocorrenciadecontrato (
    ocorrenciadecontratoid integer NOT NULL,
    statusdaocorrenciadecontratoid integer NOT NULL,
    residenteid integer,
    datahora timestamp without time zone NOT NULL,
    observacoes text
)
INHERITS (public.baslog);


ALTER TABLE res.ocorrenciadecontrato OWNER TO postgres;

--
-- Name: ocorrenciadecontrato_ocorrenciadecontratoid_seq; Type: SEQUENCE; Schema: res; Owner: postgres
--

CREATE SEQUENCE ocorrenciadecontrato_ocorrenciadecontratoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE res.ocorrenciadecontrato_ocorrenciadecontratoid_seq OWNER TO postgres;

--
-- Name: ocorrenciadecontrato_ocorrenciadecontratoid_seq; Type: SEQUENCE OWNED BY; Schema: res; Owner: postgres
--

ALTER SEQUENCE ocorrenciadecontrato_ocorrenciadecontratoid_seq OWNED BY ocorrenciadecontrato.ocorrenciadecontratoid;


--
-- Name: ocorrenciadeoferta; Type: TABLE; Schema: res; Owner: postgres; Tablespace: 
--

CREATE TABLE ocorrenciadeoferta (
    ocorrenciadeofertaid integer NOT NULL,
    ofertadoresidenteid integer NOT NULL,
    datahora timestamp without time zone NOT NULL,
    status integer NOT NULL,
    observacoes text
)
INHERITS (public.baslog);


ALTER TABLE res.ocorrenciadeoferta OWNER TO postgres;

--
-- Name: ocorrenciadeoferta_ocorrenciadeofertaid_seq; Type: SEQUENCE; Schema: res; Owner: postgres
--

CREATE SEQUENCE ocorrenciadeoferta_ocorrenciadeofertaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE res.ocorrenciadeoferta_ocorrenciadeofertaid_seq OWNER TO postgres;

--
-- Name: ocorrenciadeoferta_ocorrenciadeofertaid_seq; Type: SEQUENCE OWNED BY; Schema: res; Owner: postgres
--

ALTER SEQUENCE ocorrenciadeoferta_ocorrenciadeofertaid_seq OWNED BY ocorrenciadeoferta.ocorrenciadeofertaid;


--
-- Name: ofertadeunidadetematica_ofertadeunidadetematicaid_seq; Type: SEQUENCE; Schema: res; Owner: postgres
--

CREATE SEQUENCE ofertadeunidadetematica_ofertadeunidadetematicaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE res.ofertadeunidadetematica_ofertadeunidadetematicaid_seq OWNER TO postgres;

--
-- Name: ofertadeunidadetematica_ofertadeunidadetematicaid_seq; Type: SEQUENCE OWNED BY; Schema: res; Owner: postgres
--

ALTER SEQUENCE ofertadeunidadetematica_ofertadeunidadetematicaid_seq OWNED BY ofertadeunidadetematica.ofertadeunidadetematicaid;


--
-- Name: ofertadoresidente; Type: TABLE; Schema: res; Owner: postgres; Tablespace: 
--

CREATE TABLE ofertadoresidente (
    ofertadoresidenteid integer NOT NULL,
    residenteid integer NOT NULL,
    ofertadeunidadetematicaid integer NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE res.ofertadoresidente OWNER TO postgres;

--
-- Name: ofertadoresidente_ofertadoresidenteid_seq; Type: SEQUENCE; Schema: res; Owner: postgres
--

CREATE SEQUENCE ofertadoresidente_ofertadoresidenteid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE res.ofertadoresidente_ofertadoresidenteid_seq OWNER TO postgres;

--
-- Name: ofertadoresidente_ofertadoresidenteid_seq; Type: SEQUENCE OWNED BY; Schema: res; Owner: postgres
--

ALTER SEQUENCE ofertadoresidente_ofertadoresidenteid_seq OWNED BY ofertadoresidente.ofertadoresidenteid;


--
-- Name: participacaoematividadeextra; Type: TABLE; Schema: res; Owner: postgres; Tablespace: 
--

CREATE TABLE participacaoematividadeextra (
    atividadeextraid integer NOT NULL,
    residenteid integer NOT NULL,
    cargahoraria real NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE res.participacaoematividadeextra OWNER TO postgres;

--
-- Name: periodounidadetematica; Type: VIEW; Schema: res; Owner: solis
--

CREATE VIEW periodounidadetematica AS
    SELECT 'P1'::character varying AS periodoid, 'Primeiro ano'::character varying AS descricao UNION SELECT 'P2'::character varying AS periodoid, 'Segundo ano'::character varying AS descricao;


ALTER TABLE res.periodounidadetematica OWNER TO solis;

--
-- Name: preceptoria; Type: TABLE; Schema: res; Owner: postgres; Tablespace: 
--

CREATE TABLE preceptoria (
    preceptorid integer NOT NULL,
    personid bigint NOT NULL,
    enfaseid integer,
    nucleoprofissionalid integer,
    inicio date NOT NULL,
    fim date,
    responsavel boolean DEFAULT false,
    titulacao character varying,
    chsemanal double precision,
    chmensal double precision,
    referencia boolean DEFAULT false
)
INHERITS (public.baslog);


ALTER TABLE res.preceptoria OWNER TO postgres;

--
-- Name: COLUMN preceptoria.referencia; Type: COMMENT; Schema: res; Owner: postgres
--

COMMENT ON COLUMN preceptoria.referencia IS 'Define que o preceptor é responsavel pela sua enfase';


--
-- Name: preceptoria_preceptorid_seq; Type: SEQUENCE; Schema: res; Owner: postgres
--

CREATE SEQUENCE preceptoria_preceptorid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE res.preceptoria_preceptorid_seq OWNER TO postgres;

--
-- Name: preceptoria_preceptorid_seq; Type: SEQUENCE OWNED BY; Schema: res; Owner: postgres
--

ALTER SEQUENCE preceptoria_preceptorid_seq OWNED BY preceptoria.preceptorid;


--
-- Name: residente; Type: TABLE; Schema: res; Owner: postgres; Tablespace: 
--

CREATE TABLE residente (
    residenteid integer NOT NULL,
    enfaseid integer NOT NULL,
    nucleoprofissionalid integer NOT NULL,
    inicio date NOT NULL,
    fimprevisto date NOT NULL,
    notaperiodo1semestre1 real,
    parecerperiodo1semestre1 text,
    notaperiodo1semestre2 real,
    parecerperiodo1semestre2 text,
    mediaperiodo1 real,
    parecermediaperiodo1 text,
    notaperiodo2semestre1 real,
    parecerperiodo2semestre1 text,
    notaperiodo2semestre2 real,
    parecerperiodo2semestre2 text,
    mediaperiodo2 real,
    parecermediaperiodo2 text,
    notafinal real,
    parecerfinal text,
    personid bigint NOT NULL,
    subscriptionid integer,
    unidade2 integer,
    unidade1 integer,
    descricao text
)
INHERITS (public.baslog);


ALTER TABLE res.residente OWNER TO postgres;

--
-- Name: residente_residenteid_seq; Type: SEQUENCE; Schema: res; Owner: postgres
--

CREATE SEQUENCE residente_residenteid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE res.residente_residenteid_seq OWNER TO postgres;

--
-- Name: residente_residenteid_seq; Type: SEQUENCE OWNED BY; Schema: res; Owner: postgres
--

ALTER SEQUENCE residente_residenteid_seq OWNED BY residente.residenteid;


--
-- Name: statusdaocorrenciadecontrato; Type: TABLE; Schema: res; Owner: postgres; Tablespace: 
--

CREATE TABLE statusdaocorrenciadecontrato (
    statusdaocorrenciadecontratoid integer NOT NULL,
    descricao character varying(255) NOT NULL,
    bloqueiaresidencia boolean NOT NULL,
    concluiresidencia boolean DEFAULT false
)
INHERITS (public.baslog);


ALTER TABLE res.statusdaocorrenciadecontrato OWNER TO postgres;

--
-- Name: statusdaocorrenciadecontrato_statusdaocorrenciadecontratoid_seq; Type: SEQUENCE; Schema: res; Owner: postgres
--

CREATE SEQUENCE statusdaocorrenciadecontrato_statusdaocorrenciadecontratoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE res.statusdaocorrenciadecontrato_statusdaocorrenciadecontratoid_seq OWNER TO postgres;

--
-- Name: statusdaocorrenciadecontrato_statusdaocorrenciadecontratoid_seq; Type: SEQUENCE OWNED BY; Schema: res; Owner: postgres
--

ALTER SEQUENCE statusdaocorrenciadecontrato_statusdaocorrenciadecontratoid_seq OWNED BY statusdaocorrenciadecontrato.statusdaocorrenciadecontratoid;


--
-- Name: tema_temaid_seq; Type: SEQUENCE; Schema: res; Owner: postgres
--

CREATE SEQUENCE tema_temaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE res.tema_temaid_seq OWNER TO postgres;

--
-- Name: tema_temaid_seq; Type: SEQUENCE OWNED BY; Schema: res; Owner: postgres
--

ALTER SEQUENCE tema_temaid_seq OWNED BY tema.temaid;


--
-- Name: temadaunidadetematica; Type: TABLE; Schema: res; Owner: postgres; Tablespace: 
--

CREATE TABLE temadaunidadetematica (
    temaid integer NOT NULL,
    cargahoraria real NOT NULL,
    ofertadeunidadetematicaid integer
)
INHERITS (public.baslog);


ALTER TABLE res.temadaunidadetematica OWNER TO postgres;

--
-- Name: temasofertadeunidadetematica; Type: VIEW; Schema: res; Owner: solis
--

CREATE VIEW temasofertadeunidadetematica AS
    SELECT a.ofertadeunidadetematicaid, e.personid AS personidpreceptor_oferta, e.name AS nomepreceptor_oferta, a.inicio AS inicio_oferta, a.fim AS fim_oferta, a.encerramento AS dataencerramento_oferta, a.encerradopor AS encerradopor_oferta, a.unidadetematicaid, b.descricao AS descricao_unidadetematica, b.periodo AS periodo_unidadetematica, b.sumula AS sumula_unidadetematica, b.cargahoraria AS cargahoraria_unidadetematica, b.frequenciaminima AS frequenciaminima_unidadetematica, b.tipo AS tipo_unidadetematica, CASE WHEN (b.tipo = 'T'::bpchar) THEN 'TEÓRICA'::text ELSE 'PRÁTICA'::text END AS descricaotipo_unidadetematica, d.temaid, c.cargahoraria AS cargahoraria_temaoferta, d.descricao FROM ((((ofertadeunidadetematica a JOIN unidadetematica b ON ((a.unidadetematicaid = b.unidadetematicaid))) JOIN temadaunidadetematica c ON ((c.ofertadeunidadetematicaid = a.ofertadeunidadetematicaid))) JOIN tema d ON ((c.temaid = d.temaid))) JOIN ONLY public.basphysicalperson e ON ((e.personid = a.personid)));


ALTER TABLE res.temasofertadeunidadetematica OWNER TO solis;

--
-- Name: tipodecargahorariacomplementar; Type: TABLE; Schema: res; Owner: postgres; Tablespace: 
--

CREATE TABLE tipodecargahorariacomplementar (
    tipodecargahorariacomplementarid integer NOT NULL,
    descricao character varying(255) NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE res.tipodecargahorariacomplementar OWNER TO postgres;

--
-- Name: tipodecargahorariacomplementa_tipodecargahorariacomplementa_seq; Type: SEQUENCE; Schema: res; Owner: postgres
--

CREATE SEQUENCE tipodecargahorariacomplementa_tipodecargahorariacomplementa_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE res.tipodecargahorariacomplementa_tipodecargahorariacomplementa_seq OWNER TO postgres;

--
-- Name: tipodecargahorariacomplementa_tipodecargahorariacomplementa_seq; Type: SEQUENCE OWNED BY; Schema: res; Owner: postgres
--

ALTER SEQUENCE tipodecargahorariacomplementa_tipodecargahorariacomplementa_seq OWNED BY tipodecargahorariacomplementar.tipodecargahorariacomplementarid;


--
-- Name: tipounidadetematica; Type: VIEW; Schema: res; Owner: solis
--

CREATE VIEW tipounidadetematica AS
    SELECT 'T'::character varying AS tipoid, 'Teï¿½rica'::character varying AS descricao UNION SELECT 'P'::character varying AS tipoid, 'Prï¿½tica'::character varying AS descricao;


ALTER TABLE res.tipounidadetematica OWNER TO solis;

--
-- Name: trabalhodeconclusao; Type: TABLE; Schema: res; Owner: postgres; Tablespace: 
--

CREATE TABLE trabalhodeconclusao (
    trabalhodeconclusaoid integer NOT NULL,
    orientadorid integer,
    residenteid integer NOT NULL,
    titulo character varying(255) NOT NULL,
    tema text,
    apto boolean
)
INHERITS (public.baslog);


ALTER TABLE res.trabalhodeconclusao OWNER TO postgres;

--
-- Name: trabalhodeconclusao_trabalhodeconclusaoid_seq; Type: SEQUENCE; Schema: res; Owner: postgres
--

CREATE SEQUENCE trabalhodeconclusao_trabalhodeconclusaoid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE res.trabalhodeconclusao_trabalhodeconclusaoid_seq OWNER TO postgres;

--
-- Name: trabalhodeconclusao_trabalhodeconclusaoid_seq; Type: SEQUENCE OWNED BY; Schema: res; Owner: postgres
--

ALTER SEQUENCE trabalhodeconclusao_trabalhodeconclusaoid_seq OWNED BY trabalhodeconclusao.trabalhodeconclusaoid;


--
-- Name: unidadetematica_unidadetematicaid_seq; Type: SEQUENCE; Schema: res; Owner: postgres
--

CREATE SEQUENCE unidadetematica_unidadetematicaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE res.unidadetematica_unidadetematicaid_seq OWNER TO postgres;

--
-- Name: unidadetematica_unidadetematicaid_seq; Type: SEQUENCE OWNED BY; Schema: res; Owner: postgres
--

ALTER SEQUENCE unidadetematica_unidadetematicaid_seq OWNED BY unidadetematica.unidadetematicaid;


SET search_path = spr, pg_catalog;

--
-- Name: attachment; Type: TABLE; Schema: spr; Owner: postgres; Tablespace: 
--

CREATE TABLE attachment (
    fileid integer NOT NULL,
    evaluationoptionid integer NOT NULL,
    subscriptionid integer NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE spr.attachment OWNER TO postgres;

--
-- Name: evaluation; Type: TABLE; Schema: spr; Owner: postgres; Tablespace: 
--

CREATE TABLE evaluation (
    evaluationid integer NOT NULL,
    stepid integer NOT NULL,
    description character varying(255),
    maxpoints double precision,
    minpoints double precision,
    weight double precision,
    informedatsubscription boolean NOT NULL,
    maxselectableoptions integer,
    allowattachment integer,
    enabledescriptionfield boolean NOT NULL,
    enabledesiredscorefield boolean NOT NULL,
    isinternal boolean NOT NULL,
    priority integer
)
INHERITS (public.baslog);


ALTER TABLE spr.evaluation OWNER TO postgres;

--
-- Name: evaluation_evaluationid_seq; Type: SEQUENCE; Schema: spr; Owner: postgres
--

CREATE SEQUENCE evaluation_evaluationid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE spr.evaluation_evaluationid_seq OWNER TO postgres;

--
-- Name: evaluation_evaluationid_seq; Type: SEQUENCE OWNED BY; Schema: spr; Owner: postgres
--

ALTER SEQUENCE evaluation_evaluationid_seq OWNED BY evaluation.evaluationid;


--
-- Name: evaluationoption; Type: TABLE; Schema: spr; Owner: postgres; Tablespace: 
--

CREATE TABLE evaluationoption (
    evaluationoptionid integer NOT NULL,
    evaluationid integer NOT NULL,
    description character varying(255) NOT NULL,
    scoringinfo text,
    maximumscore double precision
)
INHERITS (public.baslog);


ALTER TABLE spr.evaluationoption OWNER TO postgres;

--
-- Name: TABLE evaluationoption; Type: COMMENT; Schema: spr; Owner: postgres
--

COMMENT ON TABLE evaluationoption IS 'Forma de pontuação.';


--
-- Name: evaluationoption_evaluationoptionid_seq; Type: SEQUENCE; Schema: spr; Owner: postgres
--

CREATE SEQUENCE evaluationoption_evaluationoptionid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE spr.evaluationoption_evaluationoptionid_seq OWNER TO postgres;

--
-- Name: evaluationoption_evaluationoptionid_seq; Type: SEQUENCE OWNED BY; Schema: spr; Owner: postgres
--

ALTER SEQUENCE evaluationoption_evaluationoptionid_seq OWNED BY evaluationoption.evaluationoptionid;


--
-- Name: evaluationpoints; Type: TABLE; Schema: spr; Owner: postgres; Tablespace: 
--

CREATE TABLE evaluationpoints (
    evaluationid integer NOT NULL,
    subscriptionid integer NOT NULL,
    totalpoints real NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE spr.evaluationpoints OWNER TO postgres;

--
-- Name: examiningboard; Type: TABLE; Schema: spr; Owner: postgres; Tablespace: 
--

CREATE TABLE examiningboard (
    examiningboardid integer NOT NULL,
    stepid integer NOT NULL,
    description character varying(255) NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE spr.examiningboard OWNER TO postgres;

--
-- Name: examiningboard_examiningboardid_seq; Type: SEQUENCE; Schema: spr; Owner: postgres
--

CREATE SEQUENCE examiningboard_examiningboardid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE spr.examiningboard_examiningboardid_seq OWNER TO postgres;

--
-- Name: examiningboard_examiningboardid_seq; Type: SEQUENCE OWNED BY; Schema: spr; Owner: postgres
--

ALTER SEQUENCE examiningboard_examiningboardid_seq OWNED BY examiningboard.examiningboardid;


--
-- Name: examiningboardmember; Type: TABLE; Schema: spr; Owner: postgres; Tablespace: 
--

CREATE TABLE examiningboardmember (
    examiningboardid integer NOT NULL,
    personid bigint NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE spr.examiningboardmember OWNER TO postgres;

--
-- Name: financeinformation; Type: TABLE; Schema: spr; Owner: postgres; Tablespace: 
--

CREATE TABLE financeinformation (
    financeinformationid integer NOT NULL,
    bankaccountid integer NOT NULL,
    operationid integer NOT NULL,
    costcenterid character varying(30) NOT NULL,
    policyid integer NOT NULL,
    description character varying(255) NOT NULL,
    inscriptionfee real NOT NULL,
    allowinvoicegeneration boolean NOT NULL,
    parcelsnumber integer NOT NULL,
    daystomaturity integer,
    datetomaturity date
)
INHERITS (public.baslog);


ALTER TABLE spr.financeinformation OWNER TO postgres;

--
-- Name: financeinformation_financeinformationid_seq; Type: SEQUENCE; Schema: spr; Owner: postgres
--

CREATE SEQUENCE financeinformation_financeinformationid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE spr.financeinformation_financeinformationid_seq OWNER TO postgres;

--
-- Name: financeinformation_financeinformationid_seq; Type: SEQUENCE OWNED BY; Schema: spr; Owner: postgres
--

ALTER SEQUENCE financeinformation_financeinformationid_seq OWNED BY financeinformation.financeinformationid;


--
-- Name: option_optionid_seq; Type: SEQUENCE; Schema: spr; Owner: postgres
--

CREATE SEQUENCE option_optionid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE spr.option_optionid_seq OWNER TO postgres;

--
-- Name: option_optionid_seq; Type: SEQUENCE OWNED BY; Schema: spr; Owner: postgres
--

ALTER SEQUENCE option_optionid_seq OWNED BY option.optionid;


--
-- Name: optionnucleoenfase; Type: TABLE; Schema: spr; Owner: postgres; Tablespace: 
--

CREATE TABLE optionnucleoenfase (
    enfaseid integer NOT NULL,
    optionid integer NOT NULL,
    nucleoprofissionalid integer NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE spr.optionnucleoenfase OWNER TO postgres;

--
-- Name: selectiveprocess_selectiveprocessid_seq; Type: SEQUENCE; Schema: spr; Owner: postgres
--

CREATE SEQUENCE selectiveprocess_selectiveprocessid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE spr.selectiveprocess_selectiveprocessid_seq OWNER TO postgres;

--
-- Name: selectiveprocess_selectiveprocessid_seq; Type: SEQUENCE OWNED BY; Schema: spr; Owner: postgres
--

ALTER SEQUENCE selectiveprocess_selectiveprocessid_seq OWNED BY selectiveprocess.selectiveprocessid;


--
-- Name: step; Type: TABLE; Schema: spr; Owner: postgres; Tablespace: 
--

CREATE TABLE step (
    stepid integer NOT NULL,
    selectiveprocessid integer NOT NULL,
    description character varying(255) NOT NULL,
    minpoints double precision NOT NULL,
    accumulateprevioussteps boolean NOT NULL,
    weight double precision NOT NULL,
    classificationmethod character(1) NOT NULL,
    vacancies integer,
    subscriberchoosesplace boolean NOT NULL,
    initialmessage text,
    finalmessage text,
    hasuserinteraction boolean NOT NULL,
    startdate timestamp without time zone NOT NULL,
    enddate timestamp without time zone NOT NULL,
    scoredate date NOT NULL,
    disclosuredate date NOT NULL,
    classificationdate date NOT NULL,
    steporder integer NOT NULL,
    confirmationemailid integer,
    calculationmethod integer DEFAULT 1 NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE spr.step OWNER TO postgres;

--
-- Name: step_stepid_seq; Type: SEQUENCE; Schema: spr; Owner: postgres
--

CREATE SEQUENCE step_stepid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE spr.step_stepid_seq OWNER TO postgres;

--
-- Name: step_stepid_seq; Type: SEQUENCE OWNED BY; Schema: spr; Owner: postgres
--

ALTER SEQUENCE step_stepid_seq OWNED BY step.stepid;


--
-- Name: stepdocument; Type: TABLE; Schema: spr; Owner: postgres; Tablespace: 
--

CREATE TABLE stepdocument (
    stepdocumentid integer NOT NULL,
    stepid integer,
    description character varying(255) NOT NULL,
    allowfileattach boolean NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE spr.stepdocument OWNER TO postgres;

--
-- Name: stepdocument_stepdocumentid_seq; Type: SEQUENCE; Schema: spr; Owner: postgres
--

CREATE SEQUENCE stepdocument_stepdocumentid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE spr.stepdocument_stepdocumentid_seq OWNER TO postgres;

--
-- Name: stepdocument_stepdocumentid_seq; Type: SEQUENCE OWNED BY; Schema: spr; Owner: postgres
--

ALTER SEQUENCE stepdocument_stepdocumentid_seq OWNED BY stepdocument.stepdocumentid;


--
-- Name: stepplace; Type: TABLE; Schema: spr; Owner: postgres; Tablespace: 
--

CREATE TABLE stepplace (
    stepplaceid integer NOT NULL,
    locationid integer,
    physicalresourceid integer,
    physicalresourceversion integer,
    stepid integer NOT NULL,
    isinternal boolean NOT NULL,
    number character varying(255),
    complement character varying(255),
    room character varying(255),
    building character varying(255),
    vacancies integer NOT NULL,
    allocationorder integer NOT NULL,
    allowdisabledpeople boolean NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE spr.stepplace OWNER TO postgres;

--
-- Name: stepplace_stepplaceid_seq; Type: SEQUENCE; Schema: spr; Owner: postgres
--

CREATE SEQUENCE stepplace_stepplaceid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE spr.stepplace_stepplaceid_seq OWNER TO postgres;

--
-- Name: stepplace_stepplaceid_seq; Type: SEQUENCE OWNED BY; Schema: spr; Owner: postgres
--

ALTER SEQUENCE stepplace_stepplaceid_seq OWNED BY stepplace.stepplaceid;


--
-- Name: steptiebreak; Type: TABLE; Schema: spr; Owner: postgres; Tablespace: 
--

CREATE TABLE steptiebreak (
    tiebreakid integer NOT NULL,
    stepid integer NOT NULL,
    priority integer NOT NULL,
    tiebreakstepid integer,
    steptiebreakid integer NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE spr.steptiebreak OWNER TO postgres;

--
-- Name: steptiebreak_steptiebreakid_seq; Type: SEQUENCE; Schema: spr; Owner: postgres
--

CREATE SEQUENCE steptiebreak_steptiebreakid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE spr.steptiebreak_steptiebreakid_seq OWNER TO postgres;

--
-- Name: steptiebreak_steptiebreakid_seq; Type: SEQUENCE OWNED BY; Schema: spr; Owner: postgres
--

ALTER SEQUENCE steptiebreak_steptiebreakid_seq OWNED BY steptiebreak.steptiebreakid;


--
-- Name: subscription_subscriptionid_seq; Type: SEQUENCE; Schema: spr; Owner: postgres
--

CREATE SEQUENCE subscription_subscriptionid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE spr.subscription_subscriptionid_seq OWNER TO postgres;

--
-- Name: subscription_subscriptionid_seq; Type: SEQUENCE OWNED BY; Schema: spr; Owner: postgres
--

ALTER SEQUENCE subscription_subscriptionid_seq OWNED BY subscription.subscriptionid;


--
-- Name: subscriptiondocument; Type: TABLE; Schema: spr; Owner: postgres; Tablespace: 
--

CREATE TABLE subscriptiondocument (
    subscriptionid integer NOT NULL,
    stepdocumentid integer NOT NULL,
    fileid integer,
    contents character varying(255),
    isdelivered boolean NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE spr.subscriptiondocument OWNER TO postgres;

--
-- Name: subscriptionevaluationoption; Type: TABLE; Schema: spr; Owner: postgres; Tablespace: 
--

CREATE TABLE subscriptionevaluationoption (
    evaluationoptionid integer NOT NULL,
    subscriptionid integer NOT NULL,
    description character varying(255),
    desiredscore integer,
    finalscore integer,
    observation character varying(255)
)
INHERITS (public.baslog);


ALTER TABLE spr.subscriptionevaluationoption OWNER TO postgres;

--
-- Name: TABLE subscriptionevaluationoption; Type: COMMENT; Schema: spr; Owner: postgres
--

COMMENT ON TABLE subscriptionevaluationoption IS 'Pontuação final.';


--
-- Name: subscriptionstatus; Type: TABLE; Schema: spr; Owner: postgres; Tablespace: 
--

CREATE TABLE subscriptionstatus (
    subscriptionstatusid integer NOT NULL,
    description character varying(255) NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE spr.subscriptionstatus OWNER TO postgres;

--
-- Name: subscriptionstatus_subscriptionstatusid_seq; Type: SEQUENCE; Schema: spr; Owner: postgres
--

CREATE SEQUENCE subscriptionstatus_subscriptionstatusid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE spr.subscriptionstatus_subscriptionstatusid_seq OWNER TO postgres;

--
-- Name: subscriptionstatus_subscriptionstatusid_seq; Type: SEQUENCE OWNED BY; Schema: spr; Owner: postgres
--

ALTER SEQUENCE subscriptionstatus_subscriptionstatusid_seq OWNED BY subscriptionstatus.subscriptionstatusid;


--
-- Name: subscriptionstepplace; Type: TABLE; Schema: spr; Owner: postgres; Tablespace: 
--

CREATE TABLE subscriptionstepplace (
    subscriptionid integer NOT NULL,
    stepplaceid integer NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE spr.subscriptionstepplace OWNER TO postgres;

--
-- Name: subscriptionsubstitutescall; Type: TABLE; Schema: spr; Owner: postgres; Tablespace: 
--

CREATE TABLE subscriptionsubstitutescall (
    subscriptionsubstitutescallid integer NOT NULL,
    substitutescallid integer,
    subscriptionid integer NOT NULL,
    optionid integer NOT NULL,
    usequote boolean DEFAULT false NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE spr.subscriptionsubstitutescall OWNER TO postgres;

--
-- Name: subscriptionsubstitutescall_subscriptionsubstitutescallid_seq; Type: SEQUENCE; Schema: spr; Owner: postgres
--

CREATE SEQUENCE subscriptionsubstitutescall_subscriptionsubstitutescallid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE spr.subscriptionsubstitutescall_subscriptionsubstitutescallid_seq OWNER TO postgres;

--
-- Name: subscriptionsubstitutescall_subscriptionsubstitutescallid_seq; Type: SEQUENCE OWNED BY; Schema: spr; Owner: postgres
--

ALTER SEQUENCE subscriptionsubstitutescall_subscriptionsubstitutescallid_seq OWNED BY subscriptionsubstitutescall.subscriptionsubstitutescallid;


--
-- Name: substitutescall; Type: TABLE; Schema: spr; Owner: postgres; Tablespace: 
--

CREATE TABLE substitutescall (
    substitutescallid integer NOT NULL,
    selectiveprocessid integer NOT NULL,
    substitutescallnumber integer NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE spr.substitutescall OWNER TO postgres;

--
-- Name: substitutescall_substitutescallid_seq; Type: SEQUENCE; Schema: spr; Owner: postgres
--

CREATE SEQUENCE substitutescall_substitutescallid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE spr.substitutescall_substitutescallid_seq OWNER TO postgres;

--
-- Name: substitutescall_substitutescallid_seq; Type: SEQUENCE OWNED BY; Schema: spr; Owner: postgres
--

ALTER SEQUENCE substitutescall_substitutescallid_seq OWNED BY substitutescall.substitutescallid;


--
-- Name: tiebreak; Type: TABLE; Schema: spr; Owner: postgres; Tablespace: 
--

CREATE TABLE tiebreak (
    tiebreakid integer NOT NULL,
    description character varying(255) NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE spr.tiebreak OWNER TO postgres;

--
-- Name: tiebreak_tiebreakid_seq; Type: SEQUENCE; Schema: spr; Owner: postgres
--

CREATE SEQUENCE tiebreak_tiebreakid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE spr.tiebreak_tiebreakid_seq OWNER TO postgres;

--
-- Name: tiebreak_tiebreakid_seq; Type: SEQUENCE OWNED BY; Schema: spr; Owner: postgres
--

ALTER SEQUENCE tiebreak_tiebreakid_seq OWNED BY tiebreak.tiebreakid;


SET search_path = tra, pg_catalog;

--
-- Name: addendum; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE addendum (
    addendumid character varying(20) NOT NULL,
    agreementid character varying(20) NOT NULL,
    begindate date NOT NULL,
    enddate date NOT NULL,
    object text NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE tra.addendum OWNER TO postgres;

--
-- Name: addendumcourse; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE addendumcourse (
    addendumcourseid integer NOT NULL,
    courseid integer NOT NULL,
    addendumid character varying(20) NOT NULL,
    vacanciesperareacontrol boolean NOT NULL,
    vacancies integer
)
INHERITS (public.baslog);


ALTER TABLE tra.addendumcourse OWNER TO postgres;

--
-- Name: addendumcourse_addendumcourseid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE addendumcourse_addendumcourseid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.addendumcourse_addendumcourseid_seq OWNER TO postgres;

--
-- Name: addendumcourse_addendumcourseid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE addendumcourse_addendumcourseid_seq OWNED BY addendumcourse.addendumcourseid;


--
-- Name: addendumcourseadmin; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE addendumcourseadmin (
    addendumcourseadminid integer NOT NULL,
    personid bigint NOT NULL,
    addendumcourseid integer NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE tra.addendumcourseadmin OWNER TO postgres;

--
-- Name: addendumcourseadmin_addendumcourseadminid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE addendumcourseadmin_addendumcourseadminid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.addendumcourseadmin_addendumcourseadminid_seq OWNER TO postgres;

--
-- Name: addendumcourseadmin_addendumcourseadminid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE addendumcourseadmin_addendumcourseadminid_seq OWNED BY addendumcourseadmin.addendumcourseadminid;


--
-- Name: addendumcoursearea; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE addendumcoursearea (
    addendumcourseareaid integer NOT NULL,
    vacancies integer NOT NULL,
    areaid integer NOT NULL,
    addendumcourseid integer NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE tra.addendumcoursearea OWNER TO postgres;

--
-- Name: addendumcoursearea_addendumcourseareaid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE addendumcoursearea_addendumcourseareaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.addendumcoursearea_addendumcourseareaid_seq OWNER TO postgres;

--
-- Name: addendumcoursearea_addendumcourseareaid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE addendumcoursearea_addendumcourseareaid_seq OWNED BY addendumcoursearea.addendumcourseareaid;


--
-- Name: addendumfile; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE addendumfile (
    addendumfileid integer NOT NULL,
    fileid integer NOT NULL,
    addendumid character varying(20) NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE tra.addendumfile OWNER TO postgres;

--
-- Name: addendumfile_addendumfileid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE addendumfile_addendumfileid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.addendumfile_addendumfileid_seq OWNER TO postgres;

--
-- Name: addendumfile_addendumfileid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE addendumfile_addendumfileid_seq OWNED BY addendumfile.addendumfileid;


--
-- Name: agreement; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE agreement (
    agreementid character varying(20) NOT NULL,
    legalpersonid bigint NOT NULL,
    begindate date NOT NULL,
    enddate date NOT NULL,
    suspensiondate date,
    object text
)
INHERITS (public.baslog);


ALTER TABLE tra.agreement OWNER TO postgres;

--
-- Name: agreementfile; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE agreementfile (
    agreementfileid integer NOT NULL,
    fileid integer NOT NULL,
    agreementid character varying(20) NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE tra.agreementfile OWNER TO postgres;

--
-- Name: agreementfile_agreementfileid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE agreementfile_agreementfileid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.agreementfile_agreementfileid_seq OWNER TO postgres;

--
-- Name: agreementfile_agreementfileid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE agreementfile_agreementfileid_seq OWNED BY agreementfile.agreementfileid;


--
-- Name: area; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE area (
    areaid integer NOT NULL,
    description character varying(255) NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE tra.area OWNER TO postgres;

--
-- Name: area_areaid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE area_areaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.area_areaid_seq OWNER TO postgres;

--
-- Name: area_areaid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE area_areaid_seq OWNED BY area.areaid;


--
-- Name: concept; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE concept (
    conceptid integer NOT NULL,
    degreeequivalenceid integer NOT NULL,
    concept character varying(20) NOT NULL,
    lowerbound real NOT NULL,
    upperbound real NOT NULL,
    approves boolean NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE tra.concept OWNER TO postgres;

--
-- Name: concept_conceptid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE concept_conceptid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.concept_conceptid_seq OWNER TO postgres;

--
-- Name: concept_conceptid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE concept_conceptid_seq OWNED BY concept.conceptid;


--
-- Name: counterpart; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE counterpart (
    counterpartid integer NOT NULL,
    counterparttypeid integer NOT NULL,
    description text,
    "order" integer NOT NULL,
    resourceavailable boolean NOT NULL,
    addendumid character varying(20) NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE tra.counterpart OWNER TO postgres;

--
-- Name: counterpart_counterpartid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE counterpart_counterpartid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.counterpart_counterpartid_seq OWNER TO postgres;

--
-- Name: counterpart_counterpartid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE counterpart_counterpartid_seq OWNED BY counterpart.counterpartid;


--
-- Name: counterparttype; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE counterparttype (
    counterparttypeid integer NOT NULL,
    description character varying(255) NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE tra.counterparttype OWNER TO postgres;

--
-- Name: counterparttype_counterparttypeid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE counterparttype_counterparttypeid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.counterparttype_counterparttypeid_seq OWNER TO postgres;

--
-- Name: counterparttype_counterparttypeid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE counterparttype_counterparttypeid_seq OWNED BY counterparttype.counterparttypeid;


--
-- Name: counterpartuse; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE counterpartuse (
    counterpartuseid integer NOT NULL,
    counterpartid integer NOT NULL,
    description text NOT NULL,
    dateofuse date NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE tra.counterpartuse OWNER TO postgres;

--
-- Name: counterpartuse_counterpartuseid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE counterpartuse_counterpartuseid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.counterpartuse_counterpartuseid_seq OWNER TO postgres;

--
-- Name: counterpartuse_counterpartuseid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE counterpartuse_counterpartuseid_seq OWNED BY counterpartuse.counterpartuseid;


--
-- Name: course; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE course (
    courseid integer NOT NULL,
    description character varying(255) NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE tra.course OWNER TO postgres;

--
-- Name: course_courseid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE course_courseid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.course_courseid_seq OWNER TO postgres;

--
-- Name: course_courseid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE course_courseid_seq OWNED BY course.courseid;


--
-- Name: coursearea; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE coursearea (
    courseareaid integer NOT NULL,
    courseid integer NOT NULL,
    activitiesplan text,
    unitareaid integer NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE tra.coursearea OWNER TO postgres;

--
-- Name: coursearea_courseareaid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE coursearea_courseareaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.coursearea_courseareaid_seq OWNER TO postgres;

--
-- Name: coursearea_courseareaid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE coursearea_courseareaid_seq OWNED BY coursearea.courseareaid;


--
-- Name: degreeequivalence; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE degreeequivalence (
    degreeequivalenceid integer NOT NULL,
    description character varying(255) NOT NULL,
    begindate date NOT NULL,
    enddate date
)
INHERITS (public.baslog);


ALTER TABLE tra.degreeequivalence OWNER TO postgres;

--
-- Name: degreeequivalence_degreeequivalenceid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE degreeequivalence_degreeequivalenceid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.degreeequivalence_degreeequivalenceid_seq OWNER TO postgres;

--
-- Name: degreeequivalence_degreeequivalenceid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE degreeequivalence_degreeequivalenceid_seq OWNED BY degreeequivalence.degreeequivalenceid;


--
-- Name: delivereddocument; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE delivereddocument (
    delivereddocumentid integer NOT NULL,
    requestid integer NOT NULL,
    documentid integer NOT NULL,
    contents character varying(255),
    deliverydate timestamp without time zone NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE tra.delivereddocument OWNER TO postgres;

--
-- Name: delivereddocument_delivereddocumentid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE delivereddocument_delivereddocumentid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.delivereddocument_delivereddocumentid_seq OWNER TO postgres;

--
-- Name: delivereddocument_delivereddocumentid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE delivereddocument_delivereddocumentid_seq OWNED BY delivereddocument.delivereddocumentid;


--
-- Name: delivereddocumentfile; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE delivereddocumentfile (
    delivereddocumentfileid integer NOT NULL,
    delivereddocumentid integer NOT NULL,
    fileid integer NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE tra.delivereddocumentfile OWNER TO postgres;

--
-- Name: delivereddocumentfile_delivereddocumentfileid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE delivereddocumentfile_delivereddocumentfileid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.delivereddocumentfile_delivereddocumentfileid_seq OWNER TO postgres;

--
-- Name: delivereddocumentfile_delivereddocumentfileid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE delivereddocumentfile_delivereddocumentfileid_seq OWNED BY delivereddocumentfile.delivereddocumentfileid;


--
-- Name: document; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE document (
    documentid integer NOT NULL,
    description character varying(255) NOT NULL,
    ismandatory boolean NOT NULL,
    extinct boolean NOT NULL,
    hastextcontent boolean NOT NULL,
    numberofattachments integer NOT NULL,
    unitareaid integer NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE tra.document OWNER TO postgres;

--
-- Name: document_documentid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE document_documentid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.document_documentid_seq OWNER TO postgres;

--
-- Name: document_documentid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE document_documentid_seq OWNED BY document.documentid;


--
-- Name: evaluationgroup; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE evaluationgroup (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    evaluationgroupid integer NOT NULL,
    grouporder integer NOT NULL,
    description character varying(255) NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE tra.evaluationgroup OWNER TO postgres;

--
-- Name: evaluationgroup_evaluationgroupid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE evaluationgroup_evaluationgroupid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.evaluationgroup_evaluationgroupid_seq OWNER TO postgres;

--
-- Name: evaluationgroup_evaluationgroupid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE evaluationgroup_evaluationgroupid_seq OWNED BY evaluationgroup.evaluationgroupid;


--
-- Name: evaluationitem; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE evaluationitem (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    evaluationitemid integer NOT NULL,
    evaluationgroupid integer NOT NULL,
    degreeorder integer NOT NULL,
    lowestdegreedescription text NOT NULL,
    highestdegreedescription text NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE tra.evaluationitem OWNER TO postgres;

--
-- Name: evaluationitem_evaluationitemid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE evaluationitem_evaluationitemid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.evaluationitem_evaluationitemid_seq OWNER TO postgres;

--
-- Name: evaluationitem_evaluationitemid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE evaluationitem_evaluationitemid_seq OWNED BY evaluationitem.evaluationitemid;


--
-- Name: evaluationtype; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE evaluationtype (
    evaluationtypeid integer NOT NULL,
    description character varying(255) NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE tra.evaluationtype OWNER TO postgres;

--
-- Name: evaluationtype_evaluationtypeid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE evaluationtype_evaluationtypeid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.evaluationtype_evaluationtypeid_seq OWNER TO postgres;

--
-- Name: evaluationtype_evaluationtypeid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE evaluationtype_evaluationtypeid_seq OWNED BY evaluationtype.evaluationtypeid;


--
-- Name: preceptorsubstitution; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE preceptorsubstitution (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    preceptorsubstitutionid bigint NOT NULL,
    teamid integer NOT NULL,
    personid bigint NOT NULL,
    begindate date NOT NULL,
    enddate date,
    CONSTRAINT chk_preceptor_substitution CHECK (fn_chk_preceptor_substitution(preceptorsubstitutionid, teamid, personid, begindate, enddate))
)
INHERITS (public.baslog);


ALTER TABLE tra.preceptorsubstitution OWNER TO postgres;

--
-- Name: preceptorsubstitution_preceptorsubstitutionid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE preceptorsubstitution_preceptorsubstitutionid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.preceptorsubstitution_preceptorsubstitutionid_seq OWNER TO postgres;

--
-- Name: preceptorsubstitution_preceptorsubstitutionid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE preceptorsubstitution_preceptorsubstitutionid_seq OWNED BY preceptorsubstitution.preceptorsubstitutionid;


--
-- Name: request; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE request (
    requestid integer NOT NULL,
    unitareaid integer NOT NULL,
    trainingtypeid integer NOT NULL,
    personid bigint NOT NULL,
    begindate date NOT NULL,
    enddate date NOT NULL,
    institution character varying(255),
    semester integer,
    courseid integer NOT NULL,
    observation text,
    status character(1) NOT NULL,
    desistencedate date,
    supervisor character varying(255),
    place character varying,
    agreementid character varying(20),
    requestdate date,
    addendumcourseadminid integer,
    CONSTRAINT chk_begindate_lower_than_enddate CHECK ((begindate <= enddate))
)
INHERITS (public.baslog);


ALTER TABLE tra.request OWNER TO postgres;

--
-- Name: COLUMN request.agreementid; Type: COMMENT; Schema: tra; Owner: postgres
--

COMMENT ON COLUMN request.agreementid IS 'Campo utilizado apenas quando tipo de estagio for CURRICULAR, para trazer o convênio no ajuste (requestAdjustment)';


--
-- Name: COLUMN request.addendumcourseadminid; Type: COMMENT; Schema: tra; Owner: postgres
--

COMMENT ON COLUMN request.addendumcourseadminid IS 'Código do responsável da conveniada.';


--
-- Name: request_requestid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE request_requestid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.request_requestid_seq OWNER TO postgres;

--
-- Name: request_requestid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE request_requestid_seq OWNED BY request.requestid;


--
-- Name: requestadjustment; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE requestadjustment (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    requestadjustmentid integer NOT NULL,
    requestid integer NOT NULL,
    begindate date NOT NULL,
    enddate date NOT NULL,
    institution character varying(255),
    observation text,
    semester integer,
    trainingtypeid integer NOT NULL,
    agreementid character varying(20),
    addendumid character varying(20),
    place character varying,
    supervisor character varying(255),
    unitareaid integer,
    courseid integer
)
INHERITS (public.baslog);


ALTER TABLE tra.requestadjustment OWNER TO postgres;

--
-- Name: requestadjustment_requestadjustmentid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE requestadjustment_requestadjustmentid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.requestadjustment_requestadjustmentid_seq OWNER TO postgres;

--
-- Name: requestadjustment_requestadjustmentid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE requestadjustment_requestadjustmentid_seq OWNED BY requestadjustment.requestadjustmentid;


--
-- Name: requestcurrentdata; Type: VIEW; Schema: tra; Owner: solis
--

CREATE VIEW requestcurrentdata AS
    SELECT COALESCE(b.username, a.username) AS username, COALESCE(b.datetime, a.datetime) AS datetime, COALESCE(b.ipaddress, a.ipaddress) AS ipaddress, a.requestid, COALESCE(b.unitareaid, a.unitareaid) AS unitareaid, a.trainingtypeid, a.personid, COALESCE(b.begindate, a.begindate) AS begindate, COALESCE(b.enddate, a.enddate) AS enddate, COALESCE(b.institution, a.institution) AS institution, COALESCE(b.semester, a.semester) AS semester, COALESCE(b.courseid, a.courseid) AS courseid, a.observation AS requestobservation, a.status, a.desistencedate, COALESCE(b.supervisor, a.supervisor) AS supervisor, b.observation AS adjustmentobservation, b.agreementid, COALESCE(b.observation, a.observation) AS observation, COALESCE(b.place, a.place) AS place, a.requestdate, a.addendumcourseadminid FROM (request a LEFT JOIN requestadjustment b ON ((b.requestid = a.requestid)));


ALTER TABLE tra.requestcurrentdata OWNER TO solis;

--
-- Name: subscription; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE subscription (
    subscriptionid integer NOT NULL,
    requestid integer NOT NULL,
    desistencedate date,
    status character(1) NOT NULL,
    degree real,
    frequency real,
    approved boolean,
    evaluationcomments text,
    trainingended boolean
)
INHERITS (public.baslog);


ALTER TABLE tra.subscription OWNER TO postgres;

--
-- Name: subscription_subscriptionid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE subscription_subscriptionid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.subscription_subscriptionid_seq OWNER TO postgres;

--
-- Name: subscription_subscriptionid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE subscription_subscriptionid_seq OWNED BY subscription.subscriptionid;


--
-- Name: subscriptionteam; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE subscriptionteam (
    subscriptionteamid integer NOT NULL,
    teamid integer NOT NULL,
    subscriptionid integer NOT NULL,
    begindate date NOT NULL,
    enddate date NOT NULL,
    degree real,
    approved boolean,
    frequency real,
    evaluationcomments text,
    trainingended boolean NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE tra.subscriptionteam OWNER TO postgres;

--
-- Name: subscriptionteam_subscriptionteamid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE subscriptionteam_subscriptionteamid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.subscriptionteam_subscriptionteamid_seq OWNER TO postgres;

--
-- Name: subscriptionteam_subscriptionteamid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE subscriptionteam_subscriptionteamid_seq OWNED BY subscriptionteam.subscriptionteamid;


--
-- Name: subscriptionteamevaluation; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE subscriptionteamevaluation (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    evaluationitemid integer NOT NULL,
    subscriptionteamid integer,
    concept character varying(20) NOT NULL,
    subscriptionteamevaluationid integer NOT NULL,
    subscriptionid integer
)
INHERITS (public.baslog);


ALTER TABLE tra.subscriptionteamevaluation OWNER TO postgres;

--
-- Name: subscriptionteamevaluation_subscriptionteamevaluationid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE subscriptionteamevaluation_subscriptionteamevaluationid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.subscriptionteamevaluation_subscriptionteamevaluationid_seq OWNER TO postgres;

--
-- Name: subscriptionteamevaluation_subscriptionteamevaluationid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE subscriptionteamevaluation_subscriptionteamevaluationid_seq OWNED BY subscriptionteamevaluation.subscriptionteamevaluationid;


--
-- Name: team; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE team (
    teamid integer NOT NULL,
    unitareaid integer NOT NULL,
    preceptorid integer NOT NULL,
    description character varying(255) NOT NULL,
    begindate date NOT NULL,
    enddate date,
    vacancies integer NOT NULL,
    place text
)
INHERITS (public.baslog);


ALTER TABLE tra.team OWNER TO postgres;

--
-- Name: team_teamid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE team_teamid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.team_teamid_seq OWNER TO postgres;

--
-- Name: team_teamid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE team_teamid_seq OWNED BY team.teamid;


--
-- Name: teamorganizer; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE teamorganizer (
    teamorganizerid integer NOT NULL,
    personid bigint NOT NULL,
    unitareaid integer NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE tra.teamorganizer OWNER TO postgres;

--
-- Name: teamorganizer_teamorganizerid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE teamorganizer_teamorganizerid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.teamorganizer_teamorganizerid_seq OWNER TO postgres;

--
-- Name: teamorganizer_teamorganizerid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE teamorganizer_teamorganizerid_seq OWNED BY teamorganizer.teamorganizerid;


--
-- Name: trainingevaluationanswer; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE trainingevaluationanswer (
    username character varying(20) DEFAULT "current_user"(),
    datetime timestamp with time zone DEFAULT now(),
    ipaddress inet,
    trainingevaluationanswerid integer NOT NULL,
    questionid integer NOT NULL,
    optionid integer,
    answer text,
    subscriptionid integer NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE tra.trainingevaluationanswer OWNER TO postgres;

--
-- Name: trainingevaluationanswer_trainingevaluationanswerid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE trainingevaluationanswer_trainingevaluationanswerid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.trainingevaluationanswer_trainingevaluationanswerid_seq OWNER TO postgres;

--
-- Name: trainingevaluationanswer_trainingevaluationanswerid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE trainingevaluationanswer_trainingevaluationanswerid_seq OWNED BY trainingevaluationanswer.trainingevaluationanswerid;


--
-- Name: trainingtype; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE trainingtype (
    trainingtypeid integer NOT NULL,
    description character varying(255) NOT NULL,
    longdescription text,
    minimuminterval integer,
    requireinstitution boolean NOT NULL,
    evaluationtypeid integer NOT NULL,
    degreeequivalenceid integer,
    requireddocuments text,
    requiresemester character(1)
)
INHERITS (public.baslog);


ALTER TABLE tra.trainingtype OWNER TO postgres;

--
-- Name: trainingtype_trainingtypeid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE trainingtype_trainingtypeid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.trainingtype_trainingtypeid_seq OWNER TO postgres;

--
-- Name: trainingtype_trainingtypeid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE trainingtype_trainingtypeid_seq OWNED BY trainingtype.trainingtypeid;


--
-- Name: trainingtypearea; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE trainingtypearea (
    trainingtypeareaid integer NOT NULL,
    trainingtypeid integer NOT NULL,
    unitareaid integer NOT NULL,
    minimumsemester integer NOT NULL,
    trainingminimumduration integer NOT NULL,
    trainingmaximumduration integer NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE tra.trainingtypearea OWNER TO postgres;

--
-- Name: trainingtypearea_trainingtypeareaid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE trainingtypearea_trainingtypeareaid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.trainingtypearea_trainingtypeareaid_seq OWNER TO postgres;

--
-- Name: trainingtypearea_trainingtypeareaid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE trainingtypearea_trainingtypeareaid_seq OWNED BY trainingtypearea.trainingtypeareaid;


--
-- Name: unit; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE unit (
    unitid integer NOT NULL,
    description character varying(255) NOT NULL,
    maximumdaysuntiltrainingstart integer NOT NULL,
    minimumdaysuntiltrainingstart integer NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE tra.unit OWNER TO postgres;

--
-- Name: unit_unitid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE unit_unitid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.unit_unitid_seq OWNER TO postgres;

--
-- Name: unit_unitid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE unit_unitid_seq OWNED BY unit.unitid;


--
-- Name: unitarea; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE unitarea (
    unitareaid integer NOT NULL,
    preceptorid integer NOT NULL,
    unitid integer NOT NULL,
    areaid integer NOT NULL,
    begindate date NOT NULL,
    enddate date,
    vacancies integer NOT NULL,
    requiretrainingplace boolean NOT NULL,
    CONSTRAINT chk_unit_area CHECK (chk_unit_area(unitareaid, unitid, areaid, begindate, enddate))
)
INHERITS (public.baslog);


ALTER TABLE tra.unitarea OWNER TO postgres;

--
-- Name: unitareacourse_unitareacourseid_seq; Type: SEQUENCE; Schema: tra; Owner: postgres
--

CREATE SEQUENCE unitareacourse_unitareacourseid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tra.unitareacourse_unitareacourseid_seq OWNER TO postgres;

--
-- Name: unitareacourse_unitareacourseid_seq; Type: SEQUENCE OWNED BY; Schema: tra; Owner: postgres
--

ALTER SEQUENCE unitareacourse_unitareacourseid_seq OWNED BY unitarea.unitareaid;


--
-- Name: unitlegalperson; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE unitlegalperson (
    unitid integer NOT NULL,
    personid bigint NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE tra.unitlegalperson OWNER TO postgres;

--
-- Name: unituser; Type: TABLE; Schema: tra; Owner: postgres; Tablespace: 
--

CREATE TABLE unituser (
    unitid integer NOT NULL,
    iduser integer NOT NULL
)
INHERITS (public.baslog);


ALTER TABLE tra.unituser OWNER TO postgres;

SET search_path = bas, pg_catalog;

--
-- Name: username; Type: DEFAULT; Schema: bas; Owner: postgres
--

ALTER TABLE ONLY systemtask ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: bas; Owner: postgres
--

ALTER TABLE ONLY systemtask ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: systemtaskid; Type: DEFAULT; Schema: bas; Owner: postgres
--

ALTER TABLE ONLY systemtask ALTER COLUMN systemtaskid SET DEFAULT nextval('systemtask_systemtaskid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: bas; Owner: postgres
--

ALTER TABLE ONLY task ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: bas; Owner: postgres
--

ALTER TABLE ONLY task ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: taskid; Type: DEFAULT; Schema: bas; Owner: postgres
--

ALTER TABLE ONLY task ALTER COLUMN taskid SET DEFAULT nextval('bastask_taskid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: bas; Owner: postgres
--

ALTER TABLE ONLY taskconfiggroup ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: bas; Owner: postgres
--

ALTER TABLE ONLY taskconfiggroup ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: taskconfiggroupid; Type: DEFAULT; Schema: bas; Owner: postgres
--

ALTER TABLE ONLY taskconfiggroup ALTER COLUMN taskconfiggroupid SET DEFAULT nextval('taskconfiggroup_taskconfiggroupid_seq'::regclass);


SET search_path = fin, pg_catalog;

--
-- Name: username; Type: DEFAULT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY bankmovement ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY bankmovement ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: bankmovementid; Type: DEFAULT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY bankmovement ALTER COLUMN bankmovementid SET DEFAULT nextval('bankmovement_bankmovementid_seq'::regclass);


--
-- Name: bankmovementstatusid; Type: DEFAULT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY bankmovementstatus ALTER COLUMN bankmovementstatusid SET DEFAULT nextval('bankmovementstatus_bankmovementstatusid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY filelog ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY filelog ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: filelogid; Type: DEFAULT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY filelog ALTER COLUMN filelogid SET DEFAULT nextval('filelog_filelogid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY invoicenegociationconfig ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY invoicenegociationconfig ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: financeinformationid; Type: DEFAULT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY invoicenegociationconfig ALTER COLUMN financeinformationid SET DEFAULT nextval('invoicenegociationconfig_financeinformationid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY invoicespeciebank ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY invoicespeciebank ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY negotiation ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY negotiation ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: negotiationid; Type: DEFAULT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY negotiation ALTER COLUMN negotiationid SET DEFAULT nextval('negotiation_negotiationid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY negotiationgeneratedentries ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY negotiationgeneratedentries ALTER COLUMN datetime SET DEFAULT now();


SET search_path = hur, pg_catalog;

--
-- Name: username; Type: DEFAULT; Schema: hur; Owner: postgres
--

ALTER TABLE ONLY activitytype ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: hur; Owner: postgres
--

ALTER TABLE ONLY activitytype ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: activitytypeid; Type: DEFAULT; Schema: hur; Owner: postgres
--

ALTER TABLE ONLY activitytype ALTER COLUMN activitytypeid SET DEFAULT nextval('activitytype_activitytypeid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: hur; Owner: postgres
--

ALTER TABLE ONLY realizedactivity ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: hur; Owner: postgres
--

ALTER TABLE ONLY realizedactivity ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: realizedactivityid; Type: DEFAULT; Schema: hur; Owner: postgres
--

ALTER TABLE ONLY realizedactivity ALTER COLUMN realizedactivityid SET DEFAULT nextval('realizedactivity_realizedactivityid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: hur; Owner: postgres
--

ALTER TABLE ONLY realizedactivityparticipant ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: hur; Owner: postgres
--

ALTER TABLE ONLY realizedactivityparticipant ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: hur; Owner: postgres
--

ALTER TABLE ONLY scheduledactivity ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: hur; Owner: postgres
--

ALTER TABLE ONLY scheduledactivity ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: scheduledactivityid; Type: DEFAULT; Schema: hur; Owner: postgres
--

ALTER TABLE ONLY scheduledactivity ALTER COLUMN scheduledactivityid SET DEFAULT nextval('scheduledactivity_scheduledactivityid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: hur; Owner: postgres
--

ALTER TABLE ONLY scheduledactivityparticipant ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: hur; Owner: postgres
--

ALTER TABLE ONLY scheduledactivityparticipant ALTER COLUMN datetime SET DEFAULT now();


SET search_path = ins, pg_catalog;

--
-- Name: username; Type: DEFAULT; Schema: ins; Owner: postgres
--

ALTER TABLE ONLY material ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: ins; Owner: postgres
--

ALTER TABLE ONLY material ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: materialid; Type: DEFAULT; Schema: ins; Owner: postgres
--

ALTER TABLE ONLY material ALTER COLUMN materialid SET DEFAULT nextval('material_materialid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: ins; Owner: postgres
--

ALTER TABLE ONLY materialloan ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: ins; Owner: postgres
--

ALTER TABLE ONLY materialloan ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: materialloanid; Type: DEFAULT; Schema: ins; Owner: postgres
--

ALTER TABLE ONLY materialloan ALTER COLUMN materialloanid SET DEFAULT nextval('materialloan_materialloanid_seq'::regclass);


--
-- Name: personid; Type: DEFAULT; Schema: ins; Owner: postgres
--

ALTER TABLE ONLY materialloan ALTER COLUMN personid SET DEFAULT nextval('materialloan_personid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: ins; Owner: postgres
--

ALTER TABLE ONLY materialrequest ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: ins; Owner: postgres
--

ALTER TABLE ONLY materialrequest ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: materialrequestid; Type: DEFAULT; Schema: ins; Owner: postgres
--

ALTER TABLE ONLY materialrequest ALTER COLUMN materialrequestid SET DEFAULT nextval('materialrequest_materialrequestid_seq'::regclass);


--
-- Name: personid; Type: DEFAULT; Schema: ins; Owner: postgres
--

ALTER TABLE ONLY materialrequest ALTER COLUMN personid SET DEFAULT nextval('materialrequest_personid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: ins; Owner: postgres
--

ALTER TABLE ONLY materialtype ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: ins; Owner: postgres
--

ALTER TABLE ONLY materialtype ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: materialtypeid; Type: DEFAULT; Schema: ins; Owner: postgres
--

ALTER TABLE ONLY materialtype ALTER COLUMN materialtypeid SET DEFAULT nextval('materialtype_materialtypeid_seq'::regclass);


SET search_path = public, pg_catalog;

--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY accaccountbalance ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY accaccountbalance ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY accaccountinglimit ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY accaccountinglimit ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY accaccountscheme ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY accaccountscheme ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acccostcenter ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acccostcenter ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acccourseaccount ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acccourseaccount ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acccoursebalance ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acccoursebalance ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY accentryintegration ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY accentryintegration ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: accintegrationid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY accentryintegration ALTER COLUMN accintegrationid SET DEFAULT nextval('seq_accintegrationid'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY accincomeforecastintegration ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY accincomeforecastintegration ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: accintegrationid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY accincomeforecastintegration ALTER COLUMN accintegrationid SET DEFAULT nextval('seq_accintegrationid'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY accintegration ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY accintegration ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY accpersonbalance ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY accpersonbalance ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdacademiccalendar ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdacademiccalendar ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdacademiccalendarevent ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdacademiccalendarevent ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: academiccalendareventid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdacademiccalendarevent ALTER COLUMN academiccalendareventid SET DEFAULT nextval('acdacademiccalendarevent_academiccalendareventid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcamposconfiguraveispessoa ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcamposconfiguraveispessoa ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: camposconfiguraveispessoaid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcamposconfiguraveispessoa ALTER COLUMN camposconfiguraveispessoaid SET DEFAULT nextval('acdcamposconfiguraveispessoa_camposconfiguraveispessoaid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcenter ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcenter ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcertified ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcertified ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcertifiedtype ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcertifiedtype ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdclass ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdclass ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdclasspupil ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdclasspupil ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcomplementaryactivities ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcomplementaryactivities ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcomplementaryactivitiescategory ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcomplementaryactivitiescategory ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcomplementaryactivitiescategoryrules ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcomplementaryactivitiescategoryrules ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcomplementaryenroll ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcomplementaryenroll ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdconcept ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdconcept ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: conceptid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdconcept ALTER COLUMN conceptid SET DEFAULT nextval('acdconcept_conceptid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdconceptgroup ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdconceptgroup ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: conceptgroupid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdconceptgroup ALTER COLUMN conceptgroupid SET DEFAULT nextval('acdconceptgroup_conceptgroupid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcondition ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcondition ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcontract ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcontract ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcontractexaminingboard ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcontractexaminingboard ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourse ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourse ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourseability ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourseability ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcoursecoordinator ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcoursecoordinator ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourseoccurrence ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourseoccurrence ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourseparent ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourseparent ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourseversion ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourseversion ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourseversiontype ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourseversiontype ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurricularcomponent ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurricularcomponent ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurricularcomponentcategory ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurricularcomponentcategory ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurricularcomponentcategorycredit ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurricularcomponentcategorycredit ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: curricularcomponentcategorycreditid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurricularcomponentcategorycredit ALTER COLUMN curricularcomponentcategorycreditid SET DEFAULT nextval('acdcurricularcomponentcategor_curricularcomponentcategorycr_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurricularcomponentgroup ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurricularcomponentgroup ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurricularcomponenttype ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurricularcomponenttype ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurricularcomponentunblock ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurricularcomponentunblock ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurriculum ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurriculum ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurriculumconcurrence ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurriculumconcurrence ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurriculumlink ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurriculumlink ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurriculumtype ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurriculumtype ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acddegree ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acddegree ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acddegreecurricularcomponentgroup ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acddegreecurricularcomponentgroup ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: degreecurricularcomponentgroupid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acddegreecurricularcomponentgroup ALTER COLUMN degreecurricularcomponentgroupid SET DEFAULT nextval('acddegreecurricularcomponentg_degreecurricularcomponentgrou_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acddegreeenroll ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acddegreeenroll ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acddetailenrollstatus ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acddetailenrollstatus ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: detailenrollstatusid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acddetailenrollstatus ALTER COLUMN detailenrollstatusid SET DEFAULT nextval('acddetailenrollstatus_detailenrollstatusid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acddiploma ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acddiploma ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdeducationarea ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdeducationarea ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdelection ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdelection ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenadestatus ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenadestatus ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenroll ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenroll ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenrollbookdata ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenrollbookdata ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenrollconfig ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenrollconfig ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenrollconfirm ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenrollconfirm ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: enrollconfirmid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenrollconfirm ALTER COLUMN enrollconfirmid SET DEFAULT nextval('acdenrollconfirm_enrollconfirmid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenrollstatus ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenrollstatus ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenrollsummary ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenrollsummary ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdevaluation ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdevaluation ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdevaluationcontrolmethod ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdevaluationcontrolmethod ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: evaluationcontrolmethodid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdevaluationcontrolmethod ALTER COLUMN evaluationcontrolmethodid SET DEFAULT nextval('acdevaluationcontrolmethod_evaluationcontrolmethodid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdevaluationenroll ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdevaluationenroll ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: evaluationtypeid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdevaluationtype ALTER COLUMN evaluationtypeid SET DEFAULT nextval('acdevaluationtype_evaluationtypeid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdevent ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdevent ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdeventparticipation ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdeventparticipation ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdexamdate ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdexamdate ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdexploitation ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdexploitation ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdexternalcourse ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdexternalcourse ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdfinalexaminationdirectors ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdfinalexaminationdirectors ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdfinalexaminationexaminingboard ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdfinalexaminationexaminingboard ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdfinalexaminationknowledgearea ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdfinalexaminationknowledgearea ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdformationlevel ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdformationlevel ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdfrequenceenroll ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdfrequenceenroll ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdgroup ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdgroup ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdgroupunblock ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdgroupunblock ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: groupunblockid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdgroupunblock ALTER COLUMN groupunblockid SET DEFAULT nextval('acdgroupunblock_groupunblockid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdinterchange ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdinterchange ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdinterchangetype ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdinterchangetype ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdknowledgearea ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdknowledgearea ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdlearningperiod ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdlearningperiod ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdmessagecontractrenewal ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdmessagecontractrenewal ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdmoodlesubscription ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdmoodlesubscription ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdmovementcontract ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdmovementcontract ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdmovementcontractcomplement ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdmovementcontractcomplement ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdperiod ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdperiod ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdperiodenrolldate ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdperiodenrolldate ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdprofessorcenter ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdprofessorcenter ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdprofessorcurricularcomponent ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdprofessorcurricularcomponent ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdprofessorformation ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdprofessorformation ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdproject ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdproject ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdreason ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdreason ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdreasoncancellation ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdreasoncancellation ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdreconhecimentodecurso ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdreconhecimentodecurso ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: reconhecimentodecursoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdreconhecimentodecurso ALTER COLUMN reconhecimentodecursoid SET DEFAULT nextval('acdreconhecimentodecurso_reconhecimentodecursoid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdregimedomiciliar ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdregimedomiciliar ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: regimedomiciliarid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdregimedomiciliar ALTER COLUMN regimedomiciliarid SET DEFAULT nextval('acdregimedomiciliar_regimedomiciliarid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdregimen ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdregimen ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdrestricteddocuments ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdrestricteddocuments ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdschedule ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdschedule ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdscheduleprofessor ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdscheduleprofessor ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdscheduleprofessorcontent ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdscheduleprofessorcontent ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: scheduleprofessorcontentid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdscheduleprofessorcontent ALTER COLUMN scheduleprofessorcontentid SET DEFAULT nextval('acdscheduleprofessorcontent_scheduleprofessorcontentid_seq'::regclass);


--
-- Name: semestercontractperiodid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdsemestercontractperiod ALTER COLUMN semestercontractperiodid SET DEFAULT nextval('acdsemestercontractperiod_semestercontractperiodid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdstatecontract ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdstatecontract ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdstatecontractfield ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdstatecontractfield ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdstateenrollbook ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdstateenrollbook ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdstateenrollbookrules ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdstateenrollbookrules ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdstatetransition ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdstatetransition ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdsubclass ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdsubclass ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtestendcoursecontract ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtestendcoursecontract ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtestendcoursetype ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtestendcoursetype ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtime ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtime ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtimesheet ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtimesheet ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtrainingdetail ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtrainingdetail ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: trainingdetailid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtrainingdetail ALTER COLUMN trainingdetailid SET DEFAULT nextval('acdtrainingdetail_trainingdetailid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtrainingemphasis ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtrainingemphasis ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: trainingemphasisid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtrainingemphasis ALTER COLUMN trainingemphasisid SET DEFAULT nextval('acdtrainingemphasis_trainingemphasisid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acompanhamentodedisciplina ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acompanhamentodedisciplina ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: acompanhamentodedisciplinaid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acompanhamentodedisciplina ALTER COLUMN acompanhamentodedisciplinaid SET DEFAULT nextval('acompanhamentodedisciplina_acompanhamentodedisciplinaid_seq'::regclass);


--
-- Name: areadeconhecimentoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpareaconhecimento ALTER COLUMN areadeconhecimentoid SET DEFAULT nextval('acpareaconhecimento_areadeconhecimentoid_seq'::regclass);


--
-- Name: atoregulatorioid; Type: DEFAULT; Schema: public; Owner: solis
--

ALTER TABLE ONLY acpatoregulatorio ALTER COLUMN atoregulatorioid SET DEFAULT nextval('acpatoregulatorio_atoregulatorioid_seq'::regclass);


--
-- Name: avaliacaoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpavaliacao ALTER COLUMN avaliacaoid SET DEFAULT nextval('acpavaliacao_avaliacaoid_seq'::regclass);


--
-- Name: camposadicionaiscursoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcamposadicionaiscurso ALTER COLUMN camposadicionaiscursoid SET DEFAULT nextval('acpcamposadicionaiscurso_camposadicionaiscursoid_seq'::regclass);


--
-- Name: componentecurricularid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentecurricular ALTER COLUMN componentecurricularid SET DEFAULT nextval('acpcomponentecurricular_componentecurricularid_seq'::regclass);


--
-- Name: componentecurricularbibliografiaid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentecurricularbibliografia ALTER COLUMN componentecurricularbibliografiaid SET DEFAULT nextval('acpcomponentecurricularbiblio_componentecurricularbibliogra_seq'::regclass);


--
-- Name: componentecurriculardisciplinaid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentecurriculardisciplina ALTER COLUMN componentecurriculardisciplinaid SET DEFAULT nextval('acpcomponentecurriculardiscip_componentecurriculardisciplin_seq'::regclass);


--
-- Name: componentecurricularmatrizid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentecurricularmatriz ALTER COLUMN componentecurricularmatrizid SET DEFAULT nextval('acpcomponentecurricularmatriz_componentecurricularmatrizid_seq'::regclass);


--
-- Name: componentecurriculartrabalhoconclusaoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentecurriculartrabalhoconclusao ALTER COLUMN componentecurriculartrabalhoconclusaoid SET DEFAULT nextval('acpcomponentecurriculartrabal_componentecurriculartrabalhoc_seq'::regclass);


--
-- Name: componentedeavaliacaoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentedeavaliacao ALTER COLUMN componentedeavaliacaoid SET DEFAULT nextval('acpcomponentedeavaliacao_componentedeavaliacaoid_seq'::regclass);


--
-- Name: componentedeavaliacaoconceitoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentedeavaliacaoconceito ALTER COLUMN componentedeavaliacaoconceitoid SET DEFAULT nextval('acpcomponentedeavaliacaoconce_componentedeavaliacaoconceito_seq'::regclass);


--
-- Name: componentedeavaliacaonotaid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentedeavaliacaonota ALTER COLUMN componentedeavaliacaonotaid SET DEFAULT nextval('acpcomponentedeavaliacaonota_componentedeavaliacaonotaid_seq'::regclass);


--
-- Name: componentedeavaliacaonotarecuperacaoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentedeavaliacaonotarecuperacao ALTER COLUMN componentedeavaliacaonotarecuperacaoid SET DEFAULT nextval('acpcomponentedeavaliacaonotar_componentedeavaliacaonotarecu_seq'::regclass);


--
-- Name: conceitodeavaliacaoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpconceitosdeavaliacao ALTER COLUMN conceitodeavaliacaoid SET DEFAULT nextval('acpconceitosdeavaliacao_conceitodeavaliacaoid_seq'::regclass);


--
-- Name: conjuntodeconceitosid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpconjuntodeconceitos ALTER COLUMN conjuntodeconceitosid SET DEFAULT nextval('acpconjuntodeconceitos_conjuntodeconceitosid_seq'::regclass);


--
-- Name: controledefrequenciaid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcontroledefrequencia ALTER COLUMN controledefrequenciaid SET DEFAULT nextval('acpcontroledefrequencia_controledefrequenciaid_seq'::regclass);


--
-- Name: coordenadorcursoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcoordenadores ALTER COLUMN coordenadorcursoid SET DEFAULT nextval('acpcoordenadores_coordenadorcursoid_seq'::regclass);


--
-- Name: cursoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcurso ALTER COLUMN cursoid SET DEFAULT nextval('acpcurso_cursoid_seq'::regclass);


--
-- Name: cursodocenteid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcursodocente ALTER COLUMN cursodocenteid SET DEFAULT nextval('acpcursodocente_cursodocenteid_seq'::regclass);


--
-- Name: estadodematriculaid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpestadodematricula ALTER COLUMN estadodematriculaid SET DEFAULT nextval('acpestadodematricula_estadodematriculaid_seq'::regclass);


--
-- Name: frequenciaid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpfrequencia ALTER COLUMN frequenciaid SET DEFAULT nextval('acpfrequencia_frequenciaid_seq'::regclass);


--
-- Name: gradehorarioid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpgradehorario ALTER COLUMN gradehorarioid SET DEFAULT nextval('acpgradehorario_gradehorarioid_seq'::regclass);


--
-- Name: grauacademicoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpgrauacademico ALTER COLUMN grauacademicoid SET DEFAULT nextval('acpgrauacademico_grauacademicoid_seq'::regclass);


--
-- Name: horarioid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acphorario ALTER COLUMN horarioid SET DEFAULT nextval('acphorario_horarioid_seq'::regclass);


--
-- Name: horarioofertacomponentecurricularid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acphorarioofertacomponentecurricular ALTER COLUMN horarioofertacomponentecurricularid SET DEFAULT nextval('acphorarioofertacomponentecur_horarioofertacomponentecurric_seq'::regclass);


--
-- Name: inscricaoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpinscricao ALTER COLUMN inscricaoid SET DEFAULT nextval('acpinscricao_inscricaoid_seq'::regclass);


--
-- Name: inscricaoturmagrupoid; Type: DEFAULT; Schema: public; Owner: solis
--

ALTER TABLE ONLY acpinscricaoturmagrupo ALTER COLUMN inscricaoturmagrupoid SET DEFAULT nextval('acpinscricaoturmagrupo_inscricaoturmagrupoid_seq'::regclass);


--
-- Name: matriculaid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpmatricula ALTER COLUMN matriculaid SET DEFAULT nextval('acpmatricula_matriculaid_seq'::regclass);


--
-- Name: matrizcurricularid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpmatrizcurricular ALTER COLUMN matrizcurricularid SET DEFAULT nextval('acpmatrizcurricular_matrizcurricularid_seq'::regclass);


--
-- Name: matrizcurriculargrupoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpmatrizcurriculargrupo ALTER COLUMN matrizcurriculargrupoid SET DEFAULT nextval('acpmatrizcurriculargrupo_matrizcurriculargrupoid_seq'::regclass);


--
-- Name: modelodeavaliacaoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpmodelodeavaliacao ALTER COLUMN modelodeavaliacaoid SET DEFAULT nextval('acpmodelodeavaliacao_modelodeavaliacaoid_seq'::regclass);


--
-- Name: movimentoinscricaoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpmovimentoinscricao ALTER COLUMN movimentoinscricaoid SET DEFAULT nextval('acpmovimentoinscricao_movimentoinscricaoid_seq'::regclass);


--
-- Name: movimentomatriculaid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpmovimentomatricula ALTER COLUMN movimentomatriculaid SET DEFAULT nextval('acpmovimentomatricula_movimentomatriculaid_seq'::regclass);


--
-- Name: ocorrenciacursoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpocorrenciacurso ALTER COLUMN ocorrenciacursoid SET DEFAULT nextval('acpocorrenciacurso_ocorrenciacursoid_seq'::regclass);


--
-- Name: ocorrenciahorarioofertaid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpocorrenciahorariooferta ALTER COLUMN ocorrenciahorarioofertaid SET DEFAULT nextval('acpocorrenciahorariooferta_ocorrenciahorarioofertaid_seq'::regclass);


--
-- Name: ofertacomponentecurricularid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpofertacomponentecurricular ALTER COLUMN ofertacomponentecurricularid SET DEFAULT nextval('acpofertacomponentecurricular_ofertacomponentecurricularid_seq'::regclass);


--
-- Name: ofertacursoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpofertacurso ALTER COLUMN ofertacursoid SET DEFAULT nextval('acpofertacurso_ofertacursoid_seq'::regclass);


--
-- Name: ofertaturmaid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpofertaturma ALTER COLUMN ofertaturmaid SET DEFAULT nextval('acpofertaturma_ofertaturmaid_seq'::regclass);


--
-- Name: perfilcursoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpperfilcurso ALTER COLUMN perfilcursoid SET DEFAULT nextval('acpperfilcurso_perfilcursoid_seq'::regclass);


--
-- Name: perfilcursocamposadicionaisid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpperfilcursocamposadicionais ALTER COLUMN perfilcursocamposadicionaisid SET DEFAULT nextval('acpperfilcursocamposadicionai_perfilcursocamposadicionaisid_seq'::regclass);


--
-- Name: perfilcursocomponentecurricularid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpperfilcursocomponentecurricular ALTER COLUMN perfilcursocomponentecurricularid SET DEFAULT nextval('acpperfilcursocomponentecurricular_pcccid_seq'::regclass);


--
-- Name: recuperacaoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acprecuperacao ALTER COLUMN recuperacaoid SET DEFAULT nextval('acprecuperacao_recuperacaoid_seq'::regclass);


--
-- Name: regrasmatriculaperfilcursoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpregrasmatriculaperfilcurso ALTER COLUMN regrasmatriculaperfilcursoid SET DEFAULT nextval('acpregrasmatriculaperfilcurso_regrasmatriculaperfilcursoid_seq'::regclass);


--
-- Name: tipocomponentecurricularid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acptipocomponentecurricular ALTER COLUMN tipocomponentecurricularid SET DEFAULT nextval('acptipocomponentecurricular_componentecurricularid_seq'::regclass);


--
-- Name: perfilcursotipodocumentoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acptipodocumento ALTER COLUMN perfilcursotipodocumentoid SET DEFAULT nextval('acptipodocumento_perfilcursotipodocumentoid_seq'::regclass);


--
-- Name: id_atributos; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_atributos ALTER COLUMN id_atributos SET DEFAULT nextval('ava_atributos_id_atributos_seq'::regclass);


--
-- Name: id_avaliacao; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_avaliacao ALTER COLUMN id_avaliacao SET DEFAULT nextval('ava_avaliacao_id_avaliacao_seq'::regclass);


--
-- Name: id_avaliacao_widget; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_avaliacao_widget ALTER COLUMN id_avaliacao_widget SET DEFAULT nextval('ava_avaliacao_widget_id_avaliacao_widget_seq'::regclass);


--
-- Name: id_bloco; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_bloco ALTER COLUMN id_bloco SET DEFAULT nextval('ava_bloco_id_bloco_seq'::regclass);


--
-- Name: id_bloco_questoes; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_bloco_questoes ALTER COLUMN id_bloco_questoes SET DEFAULT nextval('ava_bloco_questoes_id_bloco_questoes_seq'::regclass);


--
-- Name: id_formulario; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_formulario ALTER COLUMN id_formulario SET DEFAULT nextval('ava_formulario_id_formulario_seq'::regclass);


--
-- Name: id_granularidade; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_granularidade ALTER COLUMN id_granularidade SET DEFAULT nextval('ava_granularidade_id_granularidade_seq'::regclass);


--
-- Name: id_mail; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_mail ALTER COLUMN id_mail SET DEFAULT nextval('ava_mail_id_mail_seq'::regclass);


--
-- Name: id_mail_log; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_mail_log ALTER COLUMN id_mail_log SET DEFAULT nextval('ava_mail_log_id_mail_log_seq'::regclass);


--
-- Name: opcoesquestoesid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_opcoes_questoes ALTER COLUMN opcoesquestoesid SET DEFAULT nextval('ava_opcoes_questoes_opcoesquestoesid_seq'::regclass);


--
-- Name: id_perfil; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_perfil ALTER COLUMN id_perfil SET DEFAULT nextval('ava_perfil_id_perfil_seq'::regclass);


--
-- Name: id_perfil_widget; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_perfil_widget ALTER COLUMN id_perfil_widget SET DEFAULT nextval('ava_perfil_widget_id_perfil_widget_seq'::regclass);


--
-- Name: id_questoes; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_questoes ALTER COLUMN id_questoes SET DEFAULT nextval('ava_questoes_id_questoes_seq'::regclass);


--
-- Name: id_respostas; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_respostas ALTER COLUMN id_respostas SET DEFAULT nextval('ava_respostas_id_respostas_seq'::regclass);


--
-- Name: id_servico; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_servico ALTER COLUMN id_servico SET DEFAULT nextval('ava_servico_id_servico_seq'::regclass);


--
-- Name: id_totalizador; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_totalizadores ALTER COLUMN id_totalizador SET DEFAULT nextval('ava_estatisticas_id_estatistica_seq'::regclass);


--
-- Name: id_totalizador_atributo; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_totalizadores_atributos ALTER COLUMN id_totalizador_atributo SET DEFAULT nextval('ava_estatisticas_atributos_id_estatistica_atributo_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basaccess ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basaccess ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basatuacaoprofessor ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basatuacaoprofessor ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: atuacaoprofessorid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basatuacaoprofessor ALTER COLUMN atuacaoprofessorid SET DEFAULT nextval('basatuacaoprofessor_atuacaoprofessorid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basbadge ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basbadge ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basbadgeloan ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basbadgeloan ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: loanid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basbadgeloan ALTER COLUMN loanid SET DEFAULT nextval('basbadgeloan_loanid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basbadgestatus ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basbadgestatus ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: badgestatusid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basbadgestatus ALTER COLUMN badgestatusid SET DEFAULT nextval('basbadgestatus_badgestatusid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basbuscadinamica ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basbuscadinamica ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: codigo; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basbuscadinamica ALTER COLUMN codigo SET DEFAULT nextval('basbuscadinamica_codigo_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascadastrodinamico ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascadastrodinamico ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: codigo; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascadastrodinamico ALTER COLUMN codigo SET DEFAULT nextval('bascadastrodinamico_codigo_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascity ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascity ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascitysquare ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascitysquare ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascompanyconf ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascompanyconf ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basconfig ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basconfig ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basconfiguracaodatelainicial ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basconfiguracaodatelainicial ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: configuracaoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basconfiguracaodatelainicial ALTER COLUMN configuracaoid SET DEFAULT nextval('basconfiguracaodatelainicial_configuracaoid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: solis
--

ALTER TABLE ONLY basconfiguracaotrocadesenha ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: solis
--

ALTER TABLE ONLY basconfiguracaotrocadesenha ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: configuracaotrocadesenhaid; Type: DEFAULT; Schema: public; Owner: solis
--

ALTER TABLE ONLY basconfiguracaotrocadesenha ALTER COLUMN configuracaotrocadesenhaid SET DEFAULT nextval('basconfiguracaotrocadesenha_configuracaotrocadesenhaid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascountry ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascountry ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascrontablog ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascrontablog ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascsvimportation ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascsvimportation ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: csvimportationid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascsvimportation ALTER COLUMN csvimportationid SET DEFAULT nextval('bascsvimportation_csvimportationid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascsvlog ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascsvlog ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: bascsvlogid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascsvlog ALTER COLUMN bascsvlogid SET DEFAULT nextval('bascsvlog_bascsvlogid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascvslog ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascvslog ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basdocument ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basdocument ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basdocumentogerado ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basdocumentogerado ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: documentogeradoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basdocumentogerado ALTER COLUMN documentogeradoid SET DEFAULT nextval('basdocumentogerado_documentogeradoid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basdocumenttype ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basdocumenttype ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basdomain ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basdomain ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basemail ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basemail ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basemployee ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basemployee ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basemployeetype ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basemployeetype ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basethnicorigin ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basethnicorigin ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basetiquetadatabela ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basetiquetadatabela ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: etiquetadatabelaid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basetiquetadatabela ALTER COLUMN etiquetadatabelaid SET DEFAULT nextval('basetiquetadatabela_etiquetadatabelaid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basfile ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basfile ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: solis
--

ALTER TABLE ONLY basgrupotrocadesenha ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: solis
--

ALTER TABLE ONLY basgrupotrocadesenha ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: grupostrocadesenhaid; Type: DEFAULT; Schema: public; Owner: solis
--

ALTER TABLE ONLY basgrupotrocadesenha ALTER COLUMN grupostrocadesenhaid SET DEFAULT nextval('basgrupotrocadesenha_grupostrocadesenhaid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bashistoricoferias ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bashistoricoferias ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: historicoferiasid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bashistoricoferias ALTER COLUMN historicoferiasid SET DEFAULT nextval('bashistoricoferias_historicoferiasid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bashistoricofuncional ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bashistoricofuncional ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: historicofuncionalid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bashistoricofuncional ALTER COLUMN historicofuncionalid SET DEFAULT nextval('bashistoricofuncional_historicofuncionalid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baskinship ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baskinship ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: kinshipid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baskinship ALTER COLUMN kinshipid SET DEFAULT nextval('baskinship_kinshipid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baslegalperson ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baslegalperson ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: personid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baslegalperson ALTER COLUMN personid SET DEFAULT nextval('seq_personid'::regclass);


--
-- Name: isallowpersonaldata; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baslegalperson ALTER COLUMN isallowpersonaldata SET DEFAULT true;


--
-- Name: locationtypeid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baslegalperson ALTER COLUMN locationtypeid SET DEFAULT 0;


--
-- Name: sentemail; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baslegalperson ALTER COLUMN sentemail SET DEFAULT false;


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baslegalpersontype ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baslegalpersontype ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baslink ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baslink ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baslocation ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baslocation ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baslocationtype ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baslocationtype ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basmailserver ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basmailserver ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basmaritalstatus ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basmaritalstatus ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basneighborhood ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basneighborhood ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basperson ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basperson ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baspersonlink ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baspersonlink ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baspersontitle ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baspersontitle ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphone ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphone ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: phoneid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphone ALTER COLUMN phoneid SET DEFAULT nextval('basphone_phoneid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalperson ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalperson ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: personid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalperson ALTER COLUMN personid SET DEFAULT nextval('seq_personid'::regclass);


--
-- Name: isallowpersonaldata; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalperson ALTER COLUMN isallowpersonaldata SET DEFAULT true;


--
-- Name: locationtypeid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalperson ALTER COLUMN locationtypeid SET DEFAULT 0;


--
-- Name: sentemail; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalperson ALTER COLUMN sentemail SET DEFAULT false;


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonemployee ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonemployee ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: personid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonemployee ALTER COLUMN personid SET DEFAULT nextval('seq_personid'::regclass);


--
-- Name: isallowpersonaldata; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonemployee ALTER COLUMN isallowpersonaldata SET DEFAULT true;


--
-- Name: locationtypeid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonemployee ALTER COLUMN locationtypeid SET DEFAULT 0;


--
-- Name: sentemail; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonemployee ALTER COLUMN sentemail SET DEFAULT false;


--
-- Name: locationtypeidwork; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonemployee ALTER COLUMN locationtypeidwork SET DEFAULT 0;


--
-- Name: workathome; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonemployee ALTER COLUMN workathome SET DEFAULT false;


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonkinship ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonkinship ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonprofessor ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonprofessor ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: personid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonprofessor ALTER COLUMN personid SET DEFAULT nextval('seq_personid'::regclass);


--
-- Name: isallowpersonaldata; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonprofessor ALTER COLUMN isallowpersonaldata SET DEFAULT true;


--
-- Name: locationtypeid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonprofessor ALTER COLUMN locationtypeid SET DEFAULT 0;


--
-- Name: sentemail; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonprofessor ALTER COLUMN sentemail SET DEFAULT false;


--
-- Name: locationtypeidwork; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonprofessor ALTER COLUMN locationtypeidwork SET DEFAULT 0;


--
-- Name: workathome; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonprofessor ALTER COLUMN workathome SET DEFAULT false;


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonstudent ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonstudent ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: personid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonstudent ALTER COLUMN personid SET DEFAULT nextval('seq_personid'::regclass);


--
-- Name: isallowpersonaldata; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonstudent ALTER COLUMN isallowpersonaldata SET DEFAULT true;


--
-- Name: locationtypeid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonstudent ALTER COLUMN locationtypeid SET DEFAULT 0;


--
-- Name: sentemail; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonstudent ALTER COLUMN sentemail SET DEFAULT false;


--
-- Name: locationtypeidwork; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonstudent ALTER COLUMN locationtypeidwork SET DEFAULT 0;


--
-- Name: workathome; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonstudent ALTER COLUMN workathome SET DEFAULT false;


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basprofessionalactivity ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basprofessionalactivity ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basprofessionalactivityagent ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basprofessionalactivityagent ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basprofessionalactivitylinktype ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basprofessionalactivitylinktype ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basprofessionalactivitypeople ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basprofessionalactivitypeople ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basprofessorcommitment ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basprofessorcommitment ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basreport ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basreport ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basreportparameter ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basreportparameter ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basresetpassword ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basresetpassword ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: resetpasswordid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basresetpassword ALTER COLUMN resetpasswordid SET DEFAULT nextval('basresetpassword_resetpasswordid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bassector ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bassector ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bassectorboss ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bassectorboss ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bassessao ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bassessao ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: sessaoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bassessao ALTER COLUMN sessaoid SET DEFAULT nextval('bassessao_sessaoid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: solis
--

ALTER TABLE ONLY bassolicitacaotrocadesenha ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: solis
--

ALTER TABLE ONLY bassolicitacaotrocadesenha ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basspecialnecessity ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basspecialnecessity ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basstamp ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basstamp ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basstate ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basstate ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: stickynoteid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basstickynote ALTER COLUMN stickynoteid SET DEFAULT nextval('basstickynote_stickynoteid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bastaskhistory ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bastaskhistory ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: taskhistoryid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bastaskhistory ALTER COLUMN taskhistoryid SET DEFAULT nextval('bastaskhistory_taskhistoryid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bastaskstatus ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bastaskstatus ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: taskstatusid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bastaskstatus ALTER COLUMN taskstatusid SET DEFAULT nextval('bastaskstatus_taskstatusid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bastipoatuacaoprofessor ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bastipoatuacaoprofessor ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: tipoatuacaoprofessorid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bastipoatuacaoprofessor ALTER COLUMN tipoatuacaoprofessorid SET DEFAULT nextval('bastipoatuacaoprofessor_tipoatuacaoprofessorid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basturn ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basturn ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basunit ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basunit ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basunitconfig ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basunitconfig ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: unitconfigid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basunitconfig ALTER COLUMN unitconfigid SET DEFAULT nextval('basunitconfig_unitconfigid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basupdate ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basupdate ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basuploadreportinfo ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basuploadreportinfo ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: uploadreportinfoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basuploadreportinfo ALTER COLUMN uploadreportinfoid SET DEFAULT nextval('basuploadreportinfo_uploadreportinfoid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basweekday ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basweekday ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: buscadinamicaid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY buscadinamica ALTER COLUMN buscadinamicaid SET DEFAULT nextval('buscadinamica_buscadinamicaid_seq'::regclass);


--
-- Name: cadastrodinamicoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY cadastrodinamico ALTER COLUMN cadastrodinamicoid SET DEFAULT nextval('cadastrodinamico_cadastrodinamicoid_seq'::regclass);


--
-- Name: campobuscadinamicaid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY campobuscadinamica ALTER COLUMN campobuscadinamicaid SET DEFAULT nextval('campobuscadinamica_campobuscadinamicaid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY capformadepagamento ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY capformadepagamento ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY caphistorico ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY caphistorico ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: historicoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY caphistorico ALTER COLUMN historicoid SET DEFAULT nextval('caphistorico_historicoid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY caplancamento ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY caplancamento ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: lancamentoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY caplancamento ALTER COLUMN lancamentoid SET DEFAULT nextval('caplancamento_lancamentoid_seq'::regclass);


--
-- Name: solicitacaoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY capsolicitacao ALTER COLUMN solicitacaoid SET DEFAULT nextval('capsolicitacao_solicitacaoid_seq'::regclass);


--
-- Name: solicitacaoestadoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY capsolicitacaoestado ALTER COLUMN solicitacaoestadoid SET DEFAULT nextval('capsolicitacaoestado_solicitacaoestadoid_seq'::regclass);


--
-- Name: solicitacaoparcelaid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY capsolicitacaoparcela ALTER COLUMN solicitacaoparcelaid SET DEFAULT nextval('capsolicitacaoparcela_solicitacaoparcelaid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY captipolancamento ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY captipolancamento ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY captitulo ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY captitulo ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: tituloid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY captitulo ALTER COLUMN tituloid SET DEFAULT nextval('captitulo_tituloid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpcopy ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpcopy ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccppayrolldiscount ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccppayrolldiscount ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpperiod ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpperiod ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpperson ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpperson ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: personid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpperson ALTER COLUMN personid SET DEFAULT nextval('seq_personid'::regclass);


--
-- Name: isallowpersonaldata; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpperson ALTER COLUMN isallowpersonaldata SET DEFAULT true;


--
-- Name: locationtypeid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpperson ALTER COLUMN locationtypeid SET DEFAULT 0;


--
-- Name: sentemail; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpperson ALTER COLUMN sentemail SET DEFAULT false;


--
-- Name: locationtypeidwork; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpperson ALTER COLUMN locationtypeidwork SET DEFAULT 0;


--
-- Name: workathome; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpperson ALTER COLUMN workathome SET DEFAULT false;


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccppersoncopy ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccppersoncopy ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: copyid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccppersoncopy ALTER COLUMN copyid SET DEFAULT nextval('seq_copyid'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccppersonprinter ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccppersonprinter ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccppersonsector ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccppersonsector ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpprinter ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpprinter ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccprequest ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccprequest ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccprequestfax ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccprequestfax ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccprule ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccprule ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpsector ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpsector ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: sectorid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpsector ALTER COLUMN sectorid SET DEFAULT nextval('seq_sectorid'::regclass);


--
-- Name: iscoordinatorssector; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpsector ALTER COLUMN iscoordinatorssector SET DEFAULT false;


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpsectorcopy ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpsectorcopy ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: copyid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpsectorcopy ALTER COLUMN copyid SET DEFAULT nextval('seq_copyid'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpsectorperiod ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpsectorperiod ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpsectorprinter ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpsectorprinter ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpservice ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpservice ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: changeid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY dbchanges ALTER COLUMN changeid SET DEFAULT nextval('dbchanges_changeid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finagreementcomments ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finagreementcomments ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finbank ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finbank ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finbankaccount ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finbankaccount ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finbankaccountinvoiceinfo ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finbankaccountinvoiceinfo ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finbankaccountmovement ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finbankaccountmovement ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finbankinvoiceinfo ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finbankinvoiceinfo ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: solis
--

ALTER TABLE ONLY finbankmovementnotfound ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: solis
--

ALTER TABLE ONLY finbankmovementnotfound ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: bankmovementnotfoundid; Type: DEFAULT; Schema: public; Owner: solis
--

ALTER TABLE ONLY finbankmovementnotfound ALTER COLUMN bankmovementnotfoundid SET DEFAULT nextval('finbankmovementnotfound_bankmovementnotfoundid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finbanktarget ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finbanktarget ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: isactive; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finbanktarget ALTER COLUMN isactive SET DEFAULT true;


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincamporemessa ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincamporemessa ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: camporemessaid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincamporemessa ALTER COLUMN camporemessaid SET DEFAULT nextval('fincamporemessa_camporemessaid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincheque ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincheque ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: chequeid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincheque ALTER COLUMN chequeid SET DEFAULT nextval('fincheque_chequeid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincielomovement ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincielomovement ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincielostatus ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincielostatus ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincielotransaction ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincielotransaction ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: cielotransactionid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincielotransaction ALTER COLUMN cielotransactionid SET DEFAULT nextval('fincielotransaction_cielotransactionid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finclosecounter ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finclosecounter ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincobrancabancaria ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincobrancabancaria ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: cobrancabancariaid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincobrancabancaria ALTER COLUMN cobrancabancariaid SET DEFAULT nextval('fincobrancabancaria_cobrancabancariaid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincollectiontype ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincollectiontype ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finconfiguracaoremessa ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finconfiguracaoremessa ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: configuracaoremessaid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finconfiguracaoremessa ALTER COLUMN configuracaoremessaid SET DEFAULT nextval('finconfiguracaoremessa_configuracaoremessaid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finconvenant ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finconvenant ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: convenantid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finconvenant ALTER COLUMN convenantid SET DEFAULT nextval('finconvenant_convenantid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finconvenantperson ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finconvenantperson ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: convenantpersonid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finconvenantperson ALTER COLUMN convenantpersonid SET DEFAULT nextval('finconvenantperson_convenantpersonid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincounter ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincounter ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincountermovement ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincountermovement ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincountermovementcheque ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincountermovementcheque ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: movementchequeid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincountermovementcheque ALTER COLUMN movementchequeid SET DEFAULT nextval('fincountermovementcheque_movementchequeid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: solis
--

ALTER TABLE ONLY findadosbancariosdapessoa ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: solis
--

ALTER TABLE ONLY findadosbancariosdapessoa ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: dadosbancariosdapessoa; Type: DEFAULT; Schema: public; Owner: solis
--

ALTER TABLE ONLY findadosbancariosdapessoa ALTER COLUMN dadosbancariosdapessoa SET DEFAULT nextval('findadosbancariosdapessoa_dadosbancariosdapessoa_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY findefaultoperations ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY findefaultoperations ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finemissiontype ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finemissiontype ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finenrollfee ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finenrollfee ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finentry ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finentry ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfile ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfile ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfinancialaid ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfinancialaid ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: incentivetypeid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfinancialaid ALTER COLUMN incentivetypeid SET DEFAULT nextval('seq_incentivetypeid'::regclass);


--
-- Name: needadjustauthorization; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfinancialaid ALTER COLUMN needadjustauthorization SET DEFAULT false;


--
-- Name: sendinvoices; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfinancialaid ALTER COLUMN sendinvoices SET DEFAULT true;


--
-- Name: isextinct; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfinancialaid ALTER COLUMN isextinct SET DEFAULT false;


--
-- Name: applydiscounts; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfinancialaid ALTER COLUMN applydiscounts SET DEFAULT true;


--
-- Name: aditarincentivo; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfinancialaid ALTER COLUMN aditarincentivo SET DEFAULT false;


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxoaprovacao ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxoaprovacao ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: fluxoaprovacaoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxoaprovacao ALTER COLUMN fluxoaprovacaoid SET DEFAULT nextval('finfluxoaprovacao_fluxoaprovacaoid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxoaprovacaoconfiguracao ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxoaprovacaoconfiguracao ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: fluxoaprovacaoconfiguracaoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxoaprovacaoconfiguracao ALTER COLUMN fluxoaprovacaoconfiguracaoid SET DEFAULT nextval('finfluxoaprovacaoconfiguracao_fluxoaprovacaoconfiguracaoid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxoaprovacaonivel ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxoaprovacaonivel ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: fluxoaprovacaonivelid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxoaprovacaonivel ALTER COLUMN fluxoaprovacaonivelid SET DEFAULT nextval('finfluxoaprovacaonivel_fluxoaprovacaonivelid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxoaprovacaoprocesso ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxoaprovacaoprocesso ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: fluxoaprovacaoprocessoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxoaprovacaoprocesso ALTER COLUMN fluxoaprovacaoprocessoid SET DEFAULT nextval('finfluxoaprovacaoprocesso_fluxoaprovacaoprocessoid_seq'::regclass);


--
-- Name: fluxoaprovacaostatusid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxoaprovacaostatus ALTER COLUMN fluxoaprovacaostatusid SET DEFAULT nextval('finfluxoaprovacaostatus_fluxoaprovacaostatusid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxosolicitacao ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxosolicitacao ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: fluxosolicitacaoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxosolicitacao ALTER COLUMN fluxosolicitacaoid SET DEFAULT nextval('finfluxosolicitacao_fluxosolicitacaoid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxosolicitacaoregistro ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxosolicitacaoregistro ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: fluxosolicitacaoregistroid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxosolicitacaoregistro ALTER COLUMN fluxosolicitacaoregistroid SET DEFAULT nextval('finfluxosolicitacaoregistro_fluxosolicitacaoregistroid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finhistoricoremessa ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finhistoricoremessa ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: historicoremessaid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finhistoricoremessa ALTER COLUMN historicoremessaid SET DEFAULT nextval('finhistoricoremessa_historicoremessaid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finincentive ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finincentive ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finincentivetype ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finincentivetype ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finincomeforecast ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finincomeforecast ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finincomesource ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finincomesource ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininfotitulo ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininfotitulo ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoice ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoice ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoicelog ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoicelog ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoicemessage ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoicemessage ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoicemessagetype ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoicemessagetype ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoicespecie ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoicespecie ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoicetarget ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoicetarget ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoicetype ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoicetype ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: invoicetypeid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoicetype ALTER COLUMN invoicetypeid SET DEFAULT nextval('fininvoicetype_invoicetypeid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finloan ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finloan ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: incentivetypeid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finloan ALTER COLUMN incentivetypeid SET DEFAULT nextval('seq_incentivetypeid'::regclass);


--
-- Name: needadjustauthorization; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finloan ALTER COLUMN needadjustauthorization SET DEFAULT false;


--
-- Name: sendinvoices; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finloan ALTER COLUMN sendinvoices SET DEFAULT true;


--
-- Name: isextinct; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finloan ALTER COLUMN isextinct SET DEFAULT false;


--
-- Name: applydiscounts; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finloan ALTER COLUMN applydiscounts SET DEFAULT true;


--
-- Name: aditarincentivo; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finloan ALTER COLUMN aditarincentivo SET DEFAULT false;


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finmovimentacaocheque ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finmovimentacaocheque ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: movimentacaochequeid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finmovimentacaocheque ALTER COLUMN movimentacaochequeid SET DEFAULT nextval('finmovimentacaocheque_movimentacaochequeid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finoccurrenceoperation ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finoccurrenceoperation ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finopencounter ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finopencounter ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: opencounterid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finopencounter ALTER COLUMN opencounterid SET DEFAULT nextval('finopencounter_opencounterid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finoperation ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finoperation ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finoperationgroup ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finoperationgroup ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpayableinvoice ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpayableinvoice ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: invoiceid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpayableinvoice ALTER COLUMN invoiceid SET DEFAULT nextval('seq_invoiceid'::regclass);


--
-- Name: automaticdebit; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpayableinvoice ALTER COLUMN automaticdebit SET DEFAULT false;


--
-- Name: emissiontypeid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpayableinvoice ALTER COLUMN emissiontypeid SET DEFAULT 4;


--
-- Name: iscanceled; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpayableinvoice ALTER COLUMN iscanceled SET DEFAULT false;


--
-- Name: isimported; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpayableinvoice ALTER COLUMN isimported SET DEFAULT false;


--
-- Name: balance; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpayableinvoice ALTER COLUMN balance SET DEFAULT 0;


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpayableinvoicestatus ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpayableinvoicestatus ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpayrolldiscounttarget ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpayrolldiscounttarget ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: isactive; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpayrolldiscounttarget ALTER COLUMN isactive SET DEFAULT true;


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpersoninformation ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpersoninformation ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finphysicaltarget ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finphysicaltarget ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: isactive; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finphysicaltarget ALTER COLUMN isactive SET DEFAULT true;


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpolicy ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpolicy ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpolicydiscount ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpolicydiscount ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: discountid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpolicydiscount ALTER COLUMN discountid SET DEFAULT nextval('finpolicydiscount_discountid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finprice ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finprice ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpricepolicy ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpricepolicy ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: pricepolicyid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpricepolicy ALTER COLUMN pricepolicyid SET DEFAULT nextval('finpricepolicy_pricepolicyid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finreasoncancellation ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finreasoncancellation ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: reasoncancellationid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finreasoncancellation ALTER COLUMN reasoncancellationid SET DEFAULT nextval('finreasoncancellation_reasoncancellationid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finreceivableinvoice ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finreceivableinvoice ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: invoiceid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finreceivableinvoice ALTER COLUMN invoiceid SET DEFAULT nextval('seq_invoiceid'::regclass);


--
-- Name: automaticdebit; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finreceivableinvoice ALTER COLUMN automaticdebit SET DEFAULT false;


--
-- Name: emissiontypeid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finreceivableinvoice ALTER COLUMN emissiontypeid SET DEFAULT 4;


--
-- Name: iscanceled; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finreceivableinvoice ALTER COLUMN iscanceled SET DEFAULT false;


--
-- Name: isimported; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finreceivableinvoice ALTER COLUMN isimported SET DEFAULT false;


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finreceivableinvoicecommunication ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finreceivableinvoicecommunication ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finreemissaodetituloslog ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finreemissaodetituloslog ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: reemissaodetituloslogid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finreemissaodetituloslog ALTER COLUMN reemissaodetituloslogid SET DEFAULT nextval('finreemissaodetituloslog_reemissaodetituloslogid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finrelease ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finrelease ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: releaseid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finrelease ALTER COLUMN releaseid SET DEFAULT nextval('finrelease_releaseid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finspc ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finspc ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finspcmovement ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finspcmovement ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: movementid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finspcmovement ALTER COLUMN movementid SET DEFAULT nextval('finspcmovement_movementid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finspcreason ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finspcreason ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: reasonid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finspcreason ALTER COLUMN reasonid SET DEFAULT nextval('finspcreason_reasonid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finspecies ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finspecies ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finspeciestype ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finspeciestype ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: speciestypeid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finspeciestype ALTER COLUMN speciestypeid SET DEFAULT nextval('finspeciestype_speciestypeid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finstatuscheque ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finstatuscheque ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: statuschequeid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finstatuscheque ALTER COLUMN statuschequeid SET DEFAULT nextval('finstatuscheque_statuschequeid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: solis
--

ALTER TABLE ONLY finstatusdotitulo ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: solis
--

ALTER TABLE ONLY finstatusdotitulo ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: statusdotituloid; Type: DEFAULT; Schema: public; Owner: solis
--

ALTER TABLE ONLY finstatusdotitulo ALTER COLUMN statusdotituloid SET DEFAULT nextval('finstatusdotitulo_statusdotituloid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: solis
--

ALTER TABLE ONLY finstatusdotitulolog ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: solis
--

ALTER TABLE ONLY finstatusdotitulolog ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: statusdotitulologid; Type: DEFAULT; Schema: public; Owner: solis
--

ALTER TABLE ONLY finstatusdotitulolog ALTER COLUMN statusdotitulologid SET DEFAULT nextval('finstatusdotitulolog_statusdotitulologid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finstudentfinancing ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finstudentfinancing ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finsupport ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finsupport ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: incentivetypeid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finsupport ALTER COLUMN incentivetypeid SET DEFAULT nextval('seq_incentivetypeid'::regclass);


--
-- Name: needadjustauthorization; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finsupport ALTER COLUMN needadjustauthorization SET DEFAULT false;


--
-- Name: sendinvoices; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finsupport ALTER COLUMN sendinvoices SET DEFAULT true;


--
-- Name: isextinct; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finsupport ALTER COLUMN isextinct SET DEFAULT false;


--
-- Name: applydiscounts; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finsupport ALTER COLUMN applydiscounts SET DEFAULT true;


--
-- Name: aditarincentivo; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finsupport ALTER COLUMN aditarincentivo SET DEFAULT false;


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fintipovalorvariavelremessa ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fintipovalorvariavelremessa ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fintransferenciadecaixa ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fintransferenciadecaixa ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: transferenciadecaixaid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fintransferenciadecaixa ALTER COLUMN transferenciadecaixaid SET DEFAULT nextval('fintransferenciadecaixa_transferenciadecaixaid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finvouchermessages ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finvouchermessages ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: helpid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtchelp ALTER COLUMN helpid SET DEFAULT nextval('gtchelp_helpid_seq'::regclass);


--
-- Name: supplierid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcpurchaserequestquotation ALTER COLUMN supplierid SET DEFAULT nextval('gtcpurchaserequestquotation_supplierid_seq'::regclass);


--
-- Name: sessionid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcsession ALTER COLUMN sessionid SET DEFAULT nextval('gtcsession_sessionid_seq'::regclass);


--
-- Name: sessionoperationid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcsessionoperation ALTER COLUMN sessionoperationid SET DEFAULT nextval('gtcsessionoperation_sessionoperationid_seq'::regclass);


--
-- Name: sipequipamentlogid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcsipequipamentlog ALTER COLUMN sipequipamentlogid SET DEFAULT nextval('gtcsipequipamentlog_sipequipamentlogid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY insareatype ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY insareatype ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY insgrouptype ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY insgrouptype ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY insphysicalresource ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY insphysicalresource ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: audit_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY miolo_audit ALTER COLUMN audit_id SET DEFAULT nextval('miolo_audit_audit_id_seq'::regclass);


--
-- Name: idtransaction; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY miolo_transaction ALTER COLUMN idtransaction SET DEFAULT nextval('miolo_transaction_idtransaction_seq'::regclass);


--
-- Name: condicaodepagamentoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prccondicaodepagamento ALTER COLUMN condicaodepagamentoid SET DEFAULT nextval('prccondicaodepagamento_condicaodepagamentoid_seq'::regclass);


--
-- Name: diadevencimentoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prcdiadevencimento ALTER COLUMN diadevencimentoid SET DEFAULT nextval('prcdiadevencimento_diadevencimentoid_seq'::regclass);


--
-- Name: formadepagamentodoprecoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prcformadepagamentodopreco ALTER COLUMN formadepagamentodoprecoid SET DEFAULT nextval('prcformadepagamentodopreco_formadepagamentodoprecoid_seq'::regclass);


--
-- Name: movimentoprecocursoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prcmovimentoprecocurso ALTER COLUMN movimentoprecocursoid SET DEFAULT nextval('prcmovimentoprecocurso_movimentoprecocursoid_seq'::regclass);


--
-- Name: precocondicaoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prcprecocondicao ALTER COLUMN precocondicaoid SET DEFAULT nextval('prcprecocondicao_precocondicaoid_seq'::regclass);


--
-- Name: precocursoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prcprecocurso ALTER COLUMN precocursoid SET DEFAULT nextval('prcprecocurso_precocursoid_seq'::regclass);


--
-- Name: precocursogrupoid; Type: DEFAULT; Schema: public; Owner: solis
--

ALTER TABLE ONLY prcprecocursogrupo ALTER COLUMN precocursogrupoid SET DEFAULT nextval('prcprecocursogrupo_precocursogrupoid_seq'::regclass);


--
-- Name: tituloinscricaoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prctituloinscricao ALTER COLUMN tituloinscricaoid SET DEFAULT nextval('prctituloinscricao_tituloinscricaoid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtanexo ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtanexo ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtmensagem ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtmensagem ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: mensagemid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtmensagem ALTER COLUMN mensagemid SET DEFAULT nextval('prtmensagem_mensagemid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtmensagemdestinatario ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtmensagemdestinatario ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: mensagemdestinatarioid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtmensagemdestinatario ALTER COLUMN mensagemdestinatarioid SET DEFAULT nextval('prtmensagemdestinatario_mensagemdestinatarioid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtmensagemmural ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtmensagemmural ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: mensagemmuralid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtmensagemmural ALTER COLUMN mensagemmuralid SET DEFAULT nextval('prtmensagemmural_mensagemmuralid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtpreferenciaaluno ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtpreferenciaaluno ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: preferenciaalunoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtpreferenciaaluno ALTER COLUMN preferenciaalunoid SET DEFAULT nextval('prtpreferenciaaluno_preferenciaalunoid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtpreferenciaprofessor ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtpreferenciaprofessor ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: preferenciaprofessorid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtpreferenciaprofessor ALTER COLUMN preferenciaprofessorid SET DEFAULT nextval('prtpreferenciaprofessor_preferenciaprofessorid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtpreferenciascoordenador ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtpreferenciascoordenador ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: preferenciacoordenadorid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtpreferenciascoordenador ALTER COLUMN preferenciacoordenadorid SET DEFAULT nextval('prtpreferenciascoordenador_preferenciacoordenadorid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcdispatch ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcdispatch ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcdocument ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcdocument ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: documentid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcdocument ALTER COLUMN documentid SET DEFAULT nextval('ptcdocument_documentid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcrequest ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcrequest ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: requestid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcrequest ALTER COLUMN requestid SET DEFAULT nextval('ptcrequest_requestid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcrequeststatus ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcrequeststatus ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: requeststatusid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcrequeststatus ALTER COLUMN requeststatusid SET DEFAULT nextval('ptcrequeststatus_requeststatusid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcrequireddocument ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcrequireddocument ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: requireddocumentid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcrequireddocument ALTER COLUMN requireddocumentid SET DEFAULT nextval('ptcrequireddocument_requireddocumentid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcsubject ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcsubject ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: subjectid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcsubject ALTER COLUMN subjectid SET DEFAULT nextval('ptcsubject_subjectid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcsubjectavailableto ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcsubjectavailableto ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcsubjectsector ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcsubjectsector ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: assuntodecontatoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rccassuntodecontato ALTER COLUMN assuntodecontatoid SET DEFAULT nextval('rccassuntodecontato_assuntodecontatoid_seq'::regclass);


--
-- Name: contatoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rcccontato ALTER COLUMN contatoid SET DEFAULT nextval('rcccontato_contatoid_seq'::regclass);


--
-- Name: interesseid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rccinteresse ALTER COLUMN interesseid SET DEFAULT nextval('rccinteresse_interesseid_seq'::regclass);


--
-- Name: mensagemouvidoriaid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rccmensagemouvidoria ALTER COLUMN mensagemouvidoriaid SET DEFAULT nextval('rccmensagemouvidoria_mensagemouvidoriaid_seq'::regclass);


--
-- Name: origemdecontatoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rccorigemdecontato ALTER COLUMN origemdecontatoid SET DEFAULT nextval('rccorigemdecontato_origemdecontatoid_seq'::regclass);


--
-- Name: registrodeemailid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rccregistroemail ALTER COLUMN registrodeemailid SET DEFAULT nextval('rccregistroemail_registrodeemailid_seq'::regclass);


--
-- Name: respostaouvidoriaid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rccrespostaouvidoria ALTER COLUMN respostaouvidoriaid SET DEFAULT nextval('rccrespostaouvidoria_respostaouvidoriaid_seq'::regclass);


--
-- Name: tipodecontatoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rcctipodecontato ALTER COLUMN tipodecontatoid SET DEFAULT nextval('rcctipodecontato_tipodecontatoid_seq'::regclass);


--
-- Name: vinculodecontatoid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rccvinculodecontato ALTER COLUMN vinculodecontatoid SET DEFAULT nextval('rccvinculodecontato_vinculodecontatoid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rshanswer ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rshanswer ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rshform ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rshform ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rshoption ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rshoption ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rshquestion ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rshquestion ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rshquestioncategory ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rshquestioncategory ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rshwho ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rshwho ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: tabelareferenciadaid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY tabelareferenciada ALTER COLUMN tabelareferenciadaid SET DEFAULT nextval('tabelareferenciada_tabelareferenciadaid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY temp_bank_movement ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY temp_bank_movement ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: tempbankmovementid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY temp_bank_movement ALTER COLUMN tempbankmovementid SET DEFAULT nextval('temp_bank_movement_tempbankmovementid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY temp_bank_movement_entries ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY temp_bank_movement_entries ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: tempentryid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY temp_bank_movement_entries ALTER COLUMN tempentryid SET DEFAULT nextval('temp_bank_movement_entries_tempentryid_seq'::regclass);


SET search_path = res, pg_catalog;

--
-- Name: username; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY atividadeextra ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY atividadeextra ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: atividadeextraid; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY atividadeextra ALTER COLUMN atividadeextraid SET DEFAULT nextval('atividadeextra_atividadeextraid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY cargahorariacomplementar ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY cargahorariacomplementar ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: cargahorariacomplementarid; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY cargahorariacomplementar ALTER COLUMN cargahorariacomplementarid SET DEFAULT nextval('cargahorariacomplementar_cargahorariacomplementarid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY coorientador ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY coorientador ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY encontro ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY encontro ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: encontroid; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY encontro ALTER COLUMN encontroid SET DEFAULT nextval('encontro_encontroid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY enfase ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY enfase ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: enfaseid; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY enfase ALTER COLUMN enfaseid SET DEFAULT nextval('enfase_enfaseid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY enfasedaunidadetematica ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY enfasedaunidadetematica ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY frequencia ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY frequencia ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY membrodabanca ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY membrodabanca ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY nucleodaunidadetematica ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY nucleodaunidadetematica ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY nucleoprofissional ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY nucleoprofissional ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: nucleoprofissionalid; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY nucleoprofissional ALTER COLUMN nucleoprofissionalid SET DEFAULT nextval('nucleoprofissional_nucleoprofissionalid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY ocorrenciadecontrato ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY ocorrenciadecontrato ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: ocorrenciadecontratoid; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY ocorrenciadecontrato ALTER COLUMN ocorrenciadecontratoid SET DEFAULT nextval('ocorrenciadecontrato_ocorrenciadecontratoid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY ocorrenciadeoferta ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY ocorrenciadeoferta ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: ocorrenciadeofertaid; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY ocorrenciadeoferta ALTER COLUMN ocorrenciadeofertaid SET DEFAULT nextval('ocorrenciadeoferta_ocorrenciadeofertaid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY ofertadeunidadetematica ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY ofertadeunidadetematica ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: ofertadeunidadetematicaid; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY ofertadeunidadetematica ALTER COLUMN ofertadeunidadetematicaid SET DEFAULT nextval('ofertadeunidadetematica_ofertadeunidadetematicaid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY ofertadoresidente ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY ofertadoresidente ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: ofertadoresidenteid; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY ofertadoresidente ALTER COLUMN ofertadoresidenteid SET DEFAULT nextval('ofertadoresidente_ofertadoresidenteid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY participacaoematividadeextra ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY participacaoematividadeextra ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY preceptoria ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY preceptoria ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: preceptorid; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY preceptoria ALTER COLUMN preceptorid SET DEFAULT nextval('preceptoria_preceptorid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY residente ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY residente ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: residenteid; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY residente ALTER COLUMN residenteid SET DEFAULT nextval('residente_residenteid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY statusdaocorrenciadecontrato ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY statusdaocorrenciadecontrato ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: statusdaocorrenciadecontratoid; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY statusdaocorrenciadecontrato ALTER COLUMN statusdaocorrenciadecontratoid SET DEFAULT nextval('statusdaocorrenciadecontrato_statusdaocorrenciadecontratoid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY tema ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY tema ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: temaid; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY tema ALTER COLUMN temaid SET DEFAULT nextval('tema_temaid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY temadaunidadetematica ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY temadaunidadetematica ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY tipodecargahorariacomplementar ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY tipodecargahorariacomplementar ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: tipodecargahorariacomplementarid; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY tipodecargahorariacomplementar ALTER COLUMN tipodecargahorariacomplementarid SET DEFAULT nextval('tipodecargahorariacomplementa_tipodecargahorariacomplementa_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY trabalhodeconclusao ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY trabalhodeconclusao ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: trabalhodeconclusaoid; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY trabalhodeconclusao ALTER COLUMN trabalhodeconclusaoid SET DEFAULT nextval('trabalhodeconclusao_trabalhodeconclusaoid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY unidadetematica ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY unidadetematica ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: unidadetematicaid; Type: DEFAULT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY unidadetematica ALTER COLUMN unidadetematicaid SET DEFAULT nextval('unidadetematica_unidadetematicaid_seq'::regclass);


SET search_path = spr, pg_catalog;

--
-- Name: username; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY attachment ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY attachment ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY evaluation ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY evaluation ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: evaluationid; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY evaluation ALTER COLUMN evaluationid SET DEFAULT nextval('evaluation_evaluationid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY evaluationoption ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY evaluationoption ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: evaluationoptionid; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY evaluationoption ALTER COLUMN evaluationoptionid SET DEFAULT nextval('evaluationoption_evaluationoptionid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY evaluationpoints ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY evaluationpoints ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY examiningboard ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY examiningboard ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: examiningboardid; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY examiningboard ALTER COLUMN examiningboardid SET DEFAULT nextval('examiningboard_examiningboardid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY examiningboardmember ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY examiningboardmember ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY financeinformation ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY financeinformation ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: financeinformationid; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY financeinformation ALTER COLUMN financeinformationid SET DEFAULT nextval('financeinformation_financeinformationid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY option ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY option ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: optionid; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY option ALTER COLUMN optionid SET DEFAULT nextval('option_optionid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY optioncourse ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY optioncourse ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY optionnucleoenfase ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY optionnucleoenfase ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY selectiveprocess ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY selectiveprocess ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: selectiveprocessid; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY selectiveprocess ALTER COLUMN selectiveprocessid SET DEFAULT nextval('selectiveprocess_selectiveprocessid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY step ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY step ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: stepid; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY step ALTER COLUMN stepid SET DEFAULT nextval('step_stepid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY stepdocument ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY stepdocument ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: stepdocumentid; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY stepdocument ALTER COLUMN stepdocumentid SET DEFAULT nextval('stepdocument_stepdocumentid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY stepplace ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY stepplace ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: stepplaceid; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY stepplace ALTER COLUMN stepplaceid SET DEFAULT nextval('stepplace_stepplaceid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY steptiebreak ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY steptiebreak ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: steptiebreakid; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY steptiebreak ALTER COLUMN steptiebreakid SET DEFAULT nextval('steptiebreak_steptiebreakid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscription ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscription ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: subscriptionid; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscription ALTER COLUMN subscriptionid SET DEFAULT nextval('subscription_subscriptionid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptiondocument ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptiondocument ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionevaluationoption ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionevaluationoption ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionoption ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionoption ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionstatus ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionstatus ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: subscriptionstatusid; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionstatus ALTER COLUMN subscriptionstatusid SET DEFAULT nextval('subscriptionstatus_subscriptionstatusid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionstepinfo ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionstepinfo ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionstepplace ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionstepplace ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionsubstitutescall ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionsubstitutescall ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: subscriptionsubstitutescallid; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionsubstitutescall ALTER COLUMN subscriptionsubstitutescallid SET DEFAULT nextval('subscriptionsubstitutescall_subscriptionsubstitutescallid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY substitutescall ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY substitutescall ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: substitutescallid; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY substitutescall ALTER COLUMN substitutescallid SET DEFAULT nextval('substitutescall_substitutescallid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY tiebreak ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY tiebreak ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: tiebreakid; Type: DEFAULT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY tiebreak ALTER COLUMN tiebreakid SET DEFAULT nextval('tiebreak_tiebreakid_seq'::regclass);


SET search_path = tra, pg_catalog;

--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY addendum ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY addendum ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY addendumcourse ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY addendumcourse ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: addendumcourseid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY addendumcourse ALTER COLUMN addendumcourseid SET DEFAULT nextval('addendumcourse_addendumcourseid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY addendumcourseadmin ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY addendumcourseadmin ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: addendumcourseadminid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY addendumcourseadmin ALTER COLUMN addendumcourseadminid SET DEFAULT nextval('addendumcourseadmin_addendumcourseadminid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY addendumcoursearea ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY addendumcoursearea ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: addendumcourseareaid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY addendumcoursearea ALTER COLUMN addendumcourseareaid SET DEFAULT nextval('addendumcoursearea_addendumcourseareaid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY addendumfile ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY addendumfile ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: addendumfileid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY addendumfile ALTER COLUMN addendumfileid SET DEFAULT nextval('addendumfile_addendumfileid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY agreement ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY agreement ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY agreementfile ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY agreementfile ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: agreementfileid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY agreementfile ALTER COLUMN agreementfileid SET DEFAULT nextval('agreementfile_agreementfileid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY area ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY area ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: areaid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY area ALTER COLUMN areaid SET DEFAULT nextval('area_areaid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY concept ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY concept ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: conceptid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY concept ALTER COLUMN conceptid SET DEFAULT nextval('concept_conceptid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY counterpart ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY counterpart ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: counterpartid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY counterpart ALTER COLUMN counterpartid SET DEFAULT nextval('counterpart_counterpartid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY counterparttype ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY counterparttype ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: counterparttypeid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY counterparttype ALTER COLUMN counterparttypeid SET DEFAULT nextval('counterparttype_counterparttypeid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY counterpartuse ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY counterpartuse ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: counterpartuseid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY counterpartuse ALTER COLUMN counterpartuseid SET DEFAULT nextval('counterpartuse_counterpartuseid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY course ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY course ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: courseid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY course ALTER COLUMN courseid SET DEFAULT nextval('course_courseid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY coursearea ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY coursearea ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: courseareaid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY coursearea ALTER COLUMN courseareaid SET DEFAULT nextval('coursearea_courseareaid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY degreeequivalence ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY degreeequivalence ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: degreeequivalenceid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY degreeequivalence ALTER COLUMN degreeequivalenceid SET DEFAULT nextval('degreeequivalence_degreeequivalenceid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY delivereddocument ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY delivereddocument ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: delivereddocumentid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY delivereddocument ALTER COLUMN delivereddocumentid SET DEFAULT nextval('delivereddocument_delivereddocumentid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY delivereddocumentfile ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY delivereddocumentfile ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: delivereddocumentfileid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY delivereddocumentfile ALTER COLUMN delivereddocumentfileid SET DEFAULT nextval('delivereddocumentfile_delivereddocumentfileid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY document ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY document ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: documentid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY document ALTER COLUMN documentid SET DEFAULT nextval('document_documentid_seq'::regclass);


--
-- Name: evaluationgroupid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY evaluationgroup ALTER COLUMN evaluationgroupid SET DEFAULT nextval('evaluationgroup_evaluationgroupid_seq'::regclass);


--
-- Name: evaluationitemid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY evaluationitem ALTER COLUMN evaluationitemid SET DEFAULT nextval('evaluationitem_evaluationitemid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY evaluationtype ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY evaluationtype ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: evaluationtypeid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY evaluationtype ALTER COLUMN evaluationtypeid SET DEFAULT nextval('evaluationtype_evaluationtypeid_seq'::regclass);


--
-- Name: preceptorsubstitutionid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY preceptorsubstitution ALTER COLUMN preceptorsubstitutionid SET DEFAULT nextval('preceptorsubstitution_preceptorsubstitutionid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY request ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY request ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: requestid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY request ALTER COLUMN requestid SET DEFAULT nextval('request_requestid_seq'::regclass);


--
-- Name: requestadjustmentid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY requestadjustment ALTER COLUMN requestadjustmentid SET DEFAULT nextval('requestadjustment_requestadjustmentid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY subscription ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY subscription ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: subscriptionid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY subscription ALTER COLUMN subscriptionid SET DEFAULT nextval('subscription_subscriptionid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY subscriptionteam ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY subscriptionteam ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: subscriptionteamid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY subscriptionteam ALTER COLUMN subscriptionteamid SET DEFAULT nextval('subscriptionteam_subscriptionteamid_seq'::regclass);


--
-- Name: subscriptionteamevaluationid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY subscriptionteamevaluation ALTER COLUMN subscriptionteamevaluationid SET DEFAULT nextval('subscriptionteamevaluation_subscriptionteamevaluationid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY team ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY team ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: teamid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY team ALTER COLUMN teamid SET DEFAULT nextval('team_teamid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY teamorganizer ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY teamorganizer ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: teamorganizerid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY teamorganizer ALTER COLUMN teamorganizerid SET DEFAULT nextval('teamorganizer_teamorganizerid_seq'::regclass);


--
-- Name: trainingevaluationanswerid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY trainingevaluationanswer ALTER COLUMN trainingevaluationanswerid SET DEFAULT nextval('trainingevaluationanswer_trainingevaluationanswerid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY trainingtype ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY trainingtype ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: trainingtypeid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY trainingtype ALTER COLUMN trainingtypeid SET DEFAULT nextval('trainingtype_trainingtypeid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY trainingtypearea ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY trainingtypearea ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: trainingtypeareaid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY trainingtypearea ALTER COLUMN trainingtypeareaid SET DEFAULT nextval('trainingtypearea_trainingtypeareaid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY unit ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY unit ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: unitid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY unit ALTER COLUMN unitid SET DEFAULT nextval('unit_unitid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY unitarea ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY unitarea ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: unitareaid; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY unitarea ALTER COLUMN unitareaid SET DEFAULT nextval('unitareacourse_unitareacourseid_seq'::regclass);


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY unitlegalperson ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY unitlegalperson ALTER COLUMN datetime SET DEFAULT now();


--
-- Name: username; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY unituser ALTER COLUMN username SET DEFAULT "current_user"();


--
-- Name: datetime; Type: DEFAULT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY unituser ALTER COLUMN datetime SET DEFAULT now();


SET search_path = bas, pg_catalog;

--
-- Name: bastask_pkey; Type: CONSTRAINT; Schema: bas; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY task
    ADD CONSTRAINT bastask_pkey PRIMARY KEY (taskid);


--
-- Name: documentrequest_pkey; Type: CONSTRAINT; Schema: bas; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY taskconfig
    ADD CONSTRAINT documentrequest_pkey PRIMARY KEY (taskconfigid);


--
-- Name: systemtask_pkey; Type: CONSTRAINT; Schema: bas; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY systemtask
    ADD CONSTRAINT systemtask_pkey PRIMARY KEY (systemtaskid);


--
-- Name: taskconfiggroup_pkey; Type: CONSTRAINT; Schema: bas; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY taskconfiggroup
    ADD CONSTRAINT taskconfiggroup_pkey PRIMARY KEY (taskconfiggroupid);


--
-- Name: unique_idgroup_taskconfigid; Type: CONSTRAINT; Schema: bas; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY taskconfiggroup
    ADD CONSTRAINT unique_idgroup_taskconfigid UNIQUE (idgroup, taskconfigid);


SET search_path = fin, pg_catalog;

--
-- Name: bankmovement_pkey; Type: CONSTRAINT; Schema: fin; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bankmovement
    ADD CONSTRAINT bankmovement_pkey PRIMARY KEY (bankmovementid);


--
-- Name: bankmovementstatus_pkey; Type: CONSTRAINT; Schema: fin; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bankmovementstatus
    ADD CONSTRAINT bankmovementstatus_pkey PRIMARY KEY (bankmovementstatusid);


--
-- Name: filelog_pkey; Type: CONSTRAINT; Schema: fin; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY filelog
    ADD CONSTRAINT filelog_pkey PRIMARY KEY (filelogid);


--
-- Name: invoicespeciebank_pkey; Type: CONSTRAINT; Schema: fin; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY invoicespeciebank
    ADD CONSTRAINT invoicespeciebank_pkey PRIMARY KEY (bankid, invoicespecieid);


--
-- Name: negotiation_pkey; Type: CONSTRAINT; Schema: fin; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY negotiation
    ADD CONSTRAINT negotiation_pkey PRIMARY KEY (negotiationid);


--
-- Name: negotiationgeneratedentries_pkey; Type: CONSTRAINT; Schema: fin; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY negotiationgeneratedentries
    ADD CONSTRAINT negotiationgeneratedentries_pkey PRIMARY KEY (negotiationid, entryid);


SET search_path = hur, pg_catalog;

--
-- Name: activitytype_pkey; Type: CONSTRAINT; Schema: hur; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY activitytype
    ADD CONSTRAINT activitytype_pkey PRIMARY KEY (activitytypeid);


--
-- Name: realizedactivity_pkey; Type: CONSTRAINT; Schema: hur; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY realizedactivity
    ADD CONSTRAINT realizedactivity_pkey PRIMARY KEY (realizedactivityid);


--
-- Name: realizedactivityparticipant_pkey; Type: CONSTRAINT; Schema: hur; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY realizedactivityparticipant
    ADD CONSTRAINT realizedactivityparticipant_pkey PRIMARY KEY (realizedactivityid, personid);


--
-- Name: scheduledactivity_pkey; Type: CONSTRAINT; Schema: hur; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY scheduledactivity
    ADD CONSTRAINT scheduledactivity_pkey PRIMARY KEY (scheduledactivityid);


--
-- Name: scheduledactivityparticipant_pkey; Type: CONSTRAINT; Schema: hur; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY scheduledactivityparticipant
    ADD CONSTRAINT scheduledactivityparticipant_pkey PRIMARY KEY (scheduledactivityid, personid);


SET search_path = ins, pg_catalog;

--
-- Name: material_pkey; Type: CONSTRAINT; Schema: ins; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY material
    ADD CONSTRAINT material_pkey PRIMARY KEY (materialid);


--
-- Name: materialloan_pkey; Type: CONSTRAINT; Schema: ins; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY materialloan
    ADD CONSTRAINT materialloan_pkey PRIMARY KEY (materialloanid);


--
-- Name: materialrequest_pkey; Type: CONSTRAINT; Schema: ins; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY materialrequest
    ADD CONSTRAINT materialrequest_pkey PRIMARY KEY (materialrequestid);


--
-- Name: materialtype_pkey; Type: CONSTRAINT; Schema: ins; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY materialtype
    ADD CONSTRAINT materialtype_pkey PRIMARY KEY (materialtypeid);


SET search_path = public, pg_catalog;

--
-- Name: accaccountbalance_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY accaccountbalance
    ADD CONSTRAINT accaccountbalance_pkey PRIMARY KEY (accountschemeid, source, balancedate);


--
-- Name: accaccountinglimit_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY accaccountinglimit
    ADD CONSTRAINT accaccountinglimit_pkey PRIMARY KEY (accountinglimitid);


--
-- Name: accaccountscheme_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY accaccountscheme
    ADD CONSTRAINT accaccountscheme_pkey PRIMARY KEY (accountschemeid);


--
-- Name: acccostcenter_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acccostcenter
    ADD CONSTRAINT acccostcenter_pkey PRIMARY KEY (costcenterid);


--
-- Name: acccourseaccount_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acccourseaccount
    ADD CONSTRAINT acccourseaccount_pkey PRIMARY KEY (courseid, courseversion, unitid);


--
-- Name: acccoursebalance_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acccoursebalance
    ADD CONSTRAINT acccoursebalance_pkey PRIMARY KEY (coursebalanceid);


--
-- Name: accentryintegration_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY accentryintegration
    ADD CONSTRAINT accentryintegration_pkey PRIMARY KEY (accintegrationid);


--
-- Name: accincomeforecastintegration_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY accincomeforecastintegration
    ADD CONSTRAINT accincomeforecastintegration_pkey PRIMARY KEY (accintegrationid);


--
-- Name: accintegration_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY accintegration
    ADD CONSTRAINT accintegration_pkey PRIMARY KEY (accintegrationid);


--
-- Name: accpersonbalance_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY accpersonbalance
    ADD CONSTRAINT accpersonbalance_pkey PRIMARY KEY (personbalanceid);


--
-- Name: acdacademiccalendar_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdacademiccalendar
    ADD CONSTRAINT acdacademiccalendar_pkey PRIMARY KEY (calendaryear);


--
-- Name: acdacademiccalendarevent_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdacademiccalendarevent
    ADD CONSTRAINT acdacademiccalendarevent_pkey PRIMARY KEY (academiccalendareventid);


--
-- Name: acdcamposconfiguraveispessoa_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcamposconfiguraveispessoa
    ADD CONSTRAINT acdcamposconfiguraveispessoa_pkey PRIMARY KEY (camposconfiguraveispessoaid);


--
-- Name: acdcenter_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcenter
    ADD CONSTRAINT acdcenter_pkey PRIMARY KEY (centerid);


--
-- Name: acdcertified_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcertified
    ADD CONSTRAINT acdcertified_pkey PRIMARY KEY (certifiedid, dateissue);


--
-- Name: acdcertifiedtype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcertifiedtype
    ADD CONSTRAINT acdcertifiedtype_pkey PRIMARY KEY (certifiedtypeid);


--
-- Name: acdclass_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdclass
    ADD CONSTRAINT acdclass_pkey PRIMARY KEY (classid);


--
-- Name: acdclasspupil_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdclasspupil
    ADD CONSTRAINT acdclasspupil_pkey PRIMARY KEY (classid, contractid, begindate);


--
-- Name: acdcomplementaryactivities_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcomplementaryactivities
    ADD CONSTRAINT acdcomplementaryactivities_pkey PRIMARY KEY (complementaryactivitiesid);


--
-- Name: acdcomplementaryactivitiescategory_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcomplementaryactivitiescategory
    ADD CONSTRAINT acdcomplementaryactivitiescategory_pkey PRIMARY KEY (complementaryactivitiescategoryid);


--
-- Name: acdcomplementaryactivitiescategoryrules_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcomplementaryactivitiescategoryrules
    ADD CONSTRAINT acdcomplementaryactivitiescategoryrules_pkey PRIMARY KEY (complementaryactivitiescategoryrulesid);


--
-- Name: acdcomplementaryenroll_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcomplementaryenroll
    ADD CONSTRAINT acdcomplementaryenroll_pkey PRIMARY KEY (complementaryenrollid);


--
-- Name: acdconcept_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdconcept
    ADD CONSTRAINT acdconcept_pkey PRIMARY KEY (conceptid);


--
-- Name: acdconceptgroup_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdconceptgroup
    ADD CONSTRAINT acdconceptgroup_pkey PRIMARY KEY (conceptgroupid);


--
-- Name: acdcondition_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcondition
    ADD CONSTRAINT acdcondition_pkey PRIMARY KEY (conditionid);


--
-- Name: acdcontract_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcontract
    ADD CONSTRAINT acdcontract_pkey PRIMARY KEY (contractid);


--
-- Name: acdcontractexaminingboard_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcontractexaminingboard
    ADD CONSTRAINT acdcontractexaminingboard_pkey PRIMARY KEY (contractexaminingboardid);


--
-- Name: acdcourse_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcourse
    ADD CONSTRAINT acdcourse_pkey PRIMARY KEY (courseid);


--
-- Name: acdcourseability_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcourseability
    ADD CONSTRAINT acdcourseability_pkey PRIMARY KEY (courseabilityid);


--
-- Name: acdcoursecoordinator_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcoursecoordinator
    ADD CONSTRAINT acdcoursecoordinator_pkey PRIMARY KEY (courseid, courseversion, turnid, unitid, coordinatorid);


--
-- Name: acdcourseoccurrence_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcourseoccurrence
    ADD CONSTRAINT acdcourseoccurrence_pkey PRIMARY KEY (courseid, courseversion, turnid, unitid);


--
-- Name: acdcourseparent_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcourseparent
    ADD CONSTRAINT acdcourseparent_pkey PRIMARY KEY (courseparentid);


--
-- Name: acdcourseversion_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcourseversion
    ADD CONSTRAINT acdcourseversion_pkey PRIMARY KEY (courseversion, courseid);


--
-- Name: acdcourseversiontype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcourseversiontype
    ADD CONSTRAINT acdcourseversiontype_pkey PRIMARY KEY (courseversiontypeid);


--
-- Name: acdcurricularcomponent_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcurricularcomponent
    ADD CONSTRAINT acdcurricularcomponent_pkey PRIMARY KEY (curricularcomponentid, curricularcomponentversion);


--
-- Name: acdcurricularcomponentcategory_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcurricularcomponentcategory
    ADD CONSTRAINT acdcurricularcomponentcategory_pkey PRIMARY KEY (curricularcomponentcategoryid);


--
-- Name: acdcurricularcomponentcategorycredit_curricularcomponentid_key; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcurricularcomponentcategorycredit
    ADD CONSTRAINT acdcurricularcomponentcategorycredit_curricularcomponentid_key UNIQUE (curricularcomponentid, curricularcomponentcategoryid, curricularcomponentversion);


--
-- Name: acdcurricularcomponentcategorycredit_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcurricularcomponentcategorycredit
    ADD CONSTRAINT acdcurricularcomponentcategorycredit_pkey PRIMARY KEY (curricularcomponentcategorycreditid);


--
-- Name: acdcurricularcomponentgroup_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcurricularcomponentgroup
    ADD CONSTRAINT acdcurricularcomponentgroup_pkey PRIMARY KEY (curricularcomponentgroupid);


--
-- Name: acdcurricularcomponenttype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcurricularcomponenttype
    ADD CONSTRAINT acdcurricularcomponenttype_pkey PRIMARY KEY (curricularcomponenttypeid);


--
-- Name: acdcurricularcomponentunblock_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcurricularcomponentunblock
    ADD CONSTRAINT acdcurricularcomponentunblock_pkey PRIMARY KEY (curricularcomponentunblockid);


--
-- Name: acdcurriculum_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcurriculum
    ADD CONSTRAINT acdcurriculum_pkey PRIMARY KEY (curriculumid);


--
-- Name: acdcurriculumconcurrence_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcurriculumconcurrence
    ADD CONSTRAINT acdcurriculumconcurrence_pkey PRIMARY KEY (curriculumoutid, curriculuminid);


--
-- Name: acdcurriculumlink_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcurriculumlink
    ADD CONSTRAINT acdcurriculumlink_pkey PRIMARY KEY (curriculumid, curriculumlinkid);


--
-- Name: acdcurriculumtype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdcurriculumtype
    ADD CONSTRAINT acdcurriculumtype_pkey PRIMARY KEY (curriculumtypeid);


--
-- Name: acddegree_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acddegree
    ADD CONSTRAINT acddegree_pkey PRIMARY KEY (degreeid);


--
-- Name: acddegreecurricularcomponentgroup_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acddegreecurricularcomponentgroup
    ADD CONSTRAINT acddegreecurricularcomponentgroup_pkey PRIMARY KEY (degreecurricularcomponentgroupid);


--
-- Name: acddegreeenroll_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acddegreeenroll
    ADD CONSTRAINT acddegreeenroll_pkey PRIMARY KEY (degreeenrollid);


--
-- Name: acddetailenrollstatus_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acddetailenrollstatus
    ADD CONSTRAINT acddetailenrollstatus_pkey PRIMARY KEY (detailenrollstatusid);


--
-- Name: acddiploma_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acddiploma
    ADD CONSTRAINT acddiploma_pkey PRIMARY KEY (registernumber);


--
-- Name: acdeducationarea_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdeducationarea
    ADD CONSTRAINT acdeducationarea_pkey PRIMARY KEY (educationareaid);


--
-- Name: acdelection_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdelection
    ADD CONSTRAINT acdelection_pkey PRIMARY KEY (electiondate);


--
-- Name: acdenadestatus_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdenadestatus
    ADD CONSTRAINT acdenadestatus_pkey PRIMARY KEY (enadestatusid);


--
-- Name: acdenroll_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdenroll
    ADD CONSTRAINT acdenroll_pkey PRIMARY KEY (enrollid);


--
-- Name: acdenrollconfig_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdenrollconfig
    ADD CONSTRAINT acdenrollconfig_pkey PRIMARY KEY (enrollconfigid);


--
-- Name: acdenrollconfirm_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdenrollconfirm
    ADD CONSTRAINT acdenrollconfirm_pkey PRIMARY KEY (enrollconfirmid);


--
-- Name: acdenrollstatus_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdenrollstatus
    ADD CONSTRAINT acdenrollstatus_pkey PRIMARY KEY (statusid);


--
-- Name: acdenrollsummary_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdenrollsummary
    ADD CONSTRAINT acdenrollsummary_pkey PRIMARY KEY (enrollsummaryid);


--
-- Name: acdevaluation_moodleevaluationid_key; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdevaluation
    ADD CONSTRAINT acdevaluation_moodleevaluationid_key UNIQUE (moodleevaluationid);


--
-- Name: acdevaluation_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdevaluation
    ADD CONSTRAINT acdevaluation_pkey PRIMARY KEY (evaluationid);


--
-- Name: acdevaluationcontrolmethod_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdevaluationcontrolmethod
    ADD CONSTRAINT acdevaluationcontrolmethod_pkey PRIMARY KEY (evaluationcontrolmethodid);


--
-- Name: acdevaluationenroll_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdevaluationenroll
    ADD CONSTRAINT acdevaluationenroll_pkey PRIMARY KEY (evaluationenrollid);


--
-- Name: acdevaluationtype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdevaluationtype
    ADD CONSTRAINT acdevaluationtype_pkey PRIMARY KEY (evaluationtypeid);


--
-- Name: acdevent_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdevent
    ADD CONSTRAINT acdevent_pkey PRIMARY KEY (eventid);


--
-- Name: acdeventparticipation_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdeventparticipation
    ADD CONSTRAINT acdeventparticipation_pkey PRIMARY KEY (eventid, personid);


--
-- Name: acdexamdate_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdexamdate
    ADD CONSTRAINT acdexamdate_pkey PRIMARY KEY (learningperiodid, weekdayid);


--
-- Name: acdexploitation_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdexploitation
    ADD CONSTRAINT acdexploitation_pkey PRIMARY KEY (exploitationid);


--
-- Name: acdexternalcourse_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdexternalcourse
    ADD CONSTRAINT acdexternalcourse_pkey PRIMARY KEY (externalcourseid);


--
-- Name: acdfinalexaminationdirectors_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdfinalexaminationdirectors
    ADD CONSTRAINT acdfinalexaminationdirectors_pkey PRIMARY KEY (enrollid, personid);


--
-- Name: acdfinalexaminationexaminingboard_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdfinalexaminationexaminingboard
    ADD CONSTRAINT acdfinalexaminationexaminingboard_pkey PRIMARY KEY (enrollid, personid);


--
-- Name: acdfinalexaminationknowledgearea_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdfinalexaminationknowledgearea
    ADD CONSTRAINT acdfinalexaminationknowledgearea_pkey PRIMARY KEY (enrollid, knowledgeareaid);


--
-- Name: acdformationlevel_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdformationlevel
    ADD CONSTRAINT acdformationlevel_pkey PRIMARY KEY (formationlevelid);


--
-- Name: acdfrequenceenroll_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdfrequenceenroll
    ADD CONSTRAINT acdfrequenceenroll_pkey PRIMARY KEY (enrollid, scheduleid, frequencydate, timeid);


--
-- Name: acdgroup_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdgroup
    ADD CONSTRAINT acdgroup_pkey PRIMARY KEY (groupid);


--
-- Name: acdgroupunblock_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdgroupunblock
    ADD CONSTRAINT acdgroupunblock_pkey PRIMARY KEY (groupunblockid);


--
-- Name: acdinterchange_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdinterchange
    ADD CONSTRAINT acdinterchange_pkey PRIMARY KEY (interchangeid);


--
-- Name: acdinterchangetype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdinterchangetype
    ADD CONSTRAINT acdinterchangetype_pkey PRIMARY KEY (interchangetypeid);


--
-- Name: acdknowledgearea_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdknowledgearea
    ADD CONSTRAINT acdknowledgearea_pkey PRIMARY KEY (knowledgeareaid);


--
-- Name: acdlearningperiod_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdlearningperiod
    ADD CONSTRAINT acdlearningperiod_pkey PRIMARY KEY (learningperiodid);


--
-- Name: acdmessagecontractrenewal_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdmessagecontractrenewal
    ADD CONSTRAINT acdmessagecontractrenewal_pkey PRIMARY KEY (messagecontractrenewalid);


--
-- Name: acdmoodlesubscription_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdmoodlesubscription
    ADD CONSTRAINT acdmoodlesubscription_pkey PRIMARY KEY (personid, groupid);


--
-- Name: acdmovementcontract_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdmovementcontract
    ADD CONSTRAINT acdmovementcontract_pkey PRIMARY KEY (contractid, statecontractid, statetime);


--
-- Name: acdmovementcontractcomplement_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdmovementcontractcomplement
    ADD CONSTRAINT acdmovementcontractcomplement_pkey PRIMARY KEY (contractid, statecontractid, statetime, statecontractfieldid);


--
-- Name: acdperiod_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdperiod
    ADD CONSTRAINT acdperiod_pkey PRIMARY KEY (periodid);


--
-- Name: acdperiodenrolldate_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdperiodenrolldate
    ADD CONSTRAINT acdperiodenrolldate_pkey PRIMARY KEY (periodenrolldateid);


--
-- Name: acdprofessorcurricularcomponent_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdprofessorcurricularcomponent
    ADD CONSTRAINT acdprofessorcurricularcomponent_pkey PRIMARY KEY (professorcurricularcomponentid);


--
-- Name: acdproject_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdproject
    ADD CONSTRAINT acdproject_pkey PRIMARY KEY (projectid);


--
-- Name: acdreason_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdreason
    ADD CONSTRAINT acdreason_pkey PRIMARY KEY (reasonid);


--
-- Name: acdreasoncancellation_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdreasoncancellation
    ADD CONSTRAINT acdreasoncancellation_pkey PRIMARY KEY (reasoncancellationid);


--
-- Name: acdreconhecimentodecurso_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdreconhecimentodecurso
    ADD CONSTRAINT acdreconhecimentodecurso_pkey PRIMARY KEY (reconhecimentodecursoid);


--
-- Name: acdregimedomiciliar_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdregimedomiciliar
    ADD CONSTRAINT acdregimedomiciliar_pkey PRIMARY KEY (regimedomiciliarid);


--
-- Name: acdregimen_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdregimen
    ADD CONSTRAINT acdregimen_pkey PRIMARY KEY (regimenid);


--
-- Name: acdrestricteddocuments_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdrestricteddocuments
    ADD CONSTRAINT acdrestricteddocuments_pkey PRIMARY KEY (restricteddocumentid);


--
-- Name: acdschedule_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdschedule
    ADD CONSTRAINT acdschedule_pkey PRIMARY KEY (scheduleid);


--
-- Name: acdscheduleprofessor_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdscheduleprofessor
    ADD CONSTRAINT acdscheduleprofessor_pkey PRIMARY KEY (scheduleprofessorid);


--
-- Name: acdscheduleprofessorcontent_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdscheduleprofessorcontent
    ADD CONSTRAINT acdscheduleprofessorcontent_pkey PRIMARY KEY (scheduleprofessorcontentid);


--
-- Name: acdsemestercontractperiod_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdsemestercontractperiod
    ADD CONSTRAINT acdsemestercontractperiod_pkey PRIMARY KEY (semestercontractperiodid);


--
-- Name: acdstatecontract_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdstatecontract
    ADD CONSTRAINT acdstatecontract_pkey PRIMARY KEY (statecontractid);


--
-- Name: acdstatecontractfield_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdstatecontractfield
    ADD CONSTRAINT acdstatecontractfield_pkey PRIMARY KEY (statecontractfieldid);


--
-- Name: acdstateenrollbook_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdstateenrollbook
    ADD CONSTRAINT acdstateenrollbook_pkey PRIMARY KEY (stateenrollbookid);


--
-- Name: acdstateenrollbookrules_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdstateenrollbookrules
    ADD CONSTRAINT acdstateenrollbookrules_pkey PRIMARY KEY (stateenrollbookrulesid);


--
-- Name: acdstatetransition_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdstatetransition
    ADD CONSTRAINT acdstatetransition_pkey PRIMARY KEY (beginstateid, endstateid);


--
-- Name: acdsubclass_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdsubclass
    ADD CONSTRAINT acdsubclass_pkey PRIMARY KEY (subclassid);


--
-- Name: acdtestendcoursecontract_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdtestendcoursecontract
    ADD CONSTRAINT acdtestendcoursecontract_pkey PRIMARY KEY (testendcoursetypeid, contractid, testendcoursedate);


--
-- Name: acdtestendcoursetype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdtestendcoursetype
    ADD CONSTRAINT acdtestendcoursetype_pkey PRIMARY KEY (testendcoursetypeid);


--
-- Name: acdtime_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdtime
    ADD CONSTRAINT acdtime_pkey PRIMARY KEY (timeid);


--
-- Name: acdtimesheet_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdtimesheet
    ADD CONSTRAINT acdtimesheet_pkey PRIMARY KEY (timesheetid);


--
-- Name: acdtrainingdetail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdtrainingdetail
    ADD CONSTRAINT acdtrainingdetail_pkey PRIMARY KEY (trainingdetailid);


--
-- Name: acdtrainingemphasis_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdtrainingemphasis
    ADD CONSTRAINT acdtrainingemphasis_pkey PRIMARY KEY (trainingemphasisid);


--
-- Name: acompanhamentodedisciplina_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acompanhamentodedisciplina
    ADD CONSTRAINT acompanhamentodedisciplina_pkey PRIMARY KEY (acompanhamentodedisciplinaid);


--
-- Name: acpareaconhecimento_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpareaconhecimento
    ADD CONSTRAINT acpareaconhecimento_pkey PRIMARY KEY (areadeconhecimentoid);


--
-- Name: acpatoregulatorio_pkey; Type: CONSTRAINT; Schema: public; Owner: solis; Tablespace: 
--

ALTER TABLE ONLY acpatoregulatorio
    ADD CONSTRAINT acpatoregulatorio_pkey PRIMARY KEY (atoregulatorioid);


--
-- Name: acpavaliacao_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpavaliacao
    ADD CONSTRAINT acpavaliacao_pkey PRIMARY KEY (avaliacaoid);


--
-- Name: acpcamposadicionaiscurso_camposadicionaiscursoid; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpcamposadicionaiscurso
    ADD CONSTRAINT acpcamposadicionaiscurso_camposadicionaiscursoid PRIMARY KEY (camposadicionaiscursoid);


--
-- Name: acpcomponentecurricular_componentecurricularid; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpcomponentecurricular
    ADD CONSTRAINT acpcomponentecurricular_componentecurricularid PRIMARY KEY (componentecurricularid);


--
-- Name: acpcomponentecurricularbibliografia_componentecurricularbibliog; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpcomponentecurricularbibliografia
    ADD CONSTRAINT acpcomponentecurricularbibliografia_componentecurricularbibliog PRIMARY KEY (componentecurricularbibliografiaid);


--
-- Name: acpcomponentecurriculardisciplina_componentecurriculardisciplin; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpcomponentecurriculardisciplina
    ADD CONSTRAINT acpcomponentecurriculardisciplina_componentecurriculardisciplin PRIMARY KEY (componentecurriculardisciplinaid);


--
-- Name: acpcomponentecurricularmatriz_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpcomponentecurricularmatriz
    ADD CONSTRAINT acpcomponentecurricularmatriz_pkey PRIMARY KEY (componentecurricularmatrizid);


--
-- Name: acpcomponentecurriculartrabalhoconclusao_componentecurriculartr; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpcomponentecurriculartrabalhoconclusao
    ADD CONSTRAINT acpcomponentecurriculartrabalhoconclusao_componentecurriculartr PRIMARY KEY (componentecurriculartrabalhoconclusaoid);


--
-- Name: acpcomponentedeavaliacao_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpcomponentedeavaliacao
    ADD CONSTRAINT acpcomponentedeavaliacao_pkey PRIMARY KEY (componentedeavaliacaoid);


--
-- Name: acpcomponentedeavaliacaoconceito_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpcomponentedeavaliacaoconceito
    ADD CONSTRAINT acpcomponentedeavaliacaoconceito_pkey PRIMARY KEY (componentedeavaliacaoconceitoid);


--
-- Name: acpcomponentedeavaliacaonota_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpcomponentedeavaliacaonota
    ADD CONSTRAINT acpcomponentedeavaliacaonota_pkey PRIMARY KEY (componentedeavaliacaonotaid);


--
-- Name: acpcomponentedeavaliacaonotarecuperacao_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpcomponentedeavaliacaonotarecuperacao
    ADD CONSTRAINT acpcomponentedeavaliacaonotarecuperacao_pkey PRIMARY KEY (componentedeavaliacaonotarecuperacaoid);


--
-- Name: acpconceitosdeavaliacao_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpconceitosdeavaliacao
    ADD CONSTRAINT acpconceitosdeavaliacao_pkey PRIMARY KEY (conceitodeavaliacaoid);


--
-- Name: acpconjuntodeconceitos_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpconjuntodeconceitos
    ADD CONSTRAINT acpconjuntodeconceitos_pkey PRIMARY KEY (conjuntodeconceitosid);


--
-- Name: acpcontroledefrequencia_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpcontroledefrequencia
    ADD CONSTRAINT acpcontroledefrequencia_pkey PRIMARY KEY (controledefrequenciaid);


--
-- Name: acpcoordenadores_coordenadorcursoid; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpcoordenadores
    ADD CONSTRAINT acpcoordenadores_coordenadorcursoid PRIMARY KEY (coordenadorcursoid);


--
-- Name: acpcurso_cursoid; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpcurso
    ADD CONSTRAINT acpcurso_cursoid PRIMARY KEY (cursoid);


--
-- Name: acpcursodocente_cursodocenteid; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpcursodocente
    ADD CONSTRAINT acpcursodocente_cursodocenteid PRIMARY KEY (cursodocenteid);


--
-- Name: acpestadodematricula_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpestadodematricula
    ADD CONSTRAINT acpestadodematricula_pkey PRIMARY KEY (estadodematriculaid);


--
-- Name: acpfrequencia_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpfrequencia
    ADD CONSTRAINT acpfrequencia_pkey PRIMARY KEY (frequenciaid);


--
-- Name: acpgradehorario_gradehorarioid; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpgradehorario
    ADD CONSTRAINT acpgradehorario_gradehorarioid PRIMARY KEY (gradehorarioid);


--
-- Name: acpgrauacademico_grauacademicoid; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpgrauacademico
    ADD CONSTRAINT acpgrauacademico_grauacademicoid PRIMARY KEY (grauacademicoid);


--
-- Name: acphorario_horarioid; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acphorario
    ADD CONSTRAINT acphorario_horarioid PRIMARY KEY (horarioid);


--
-- Name: acphorarioofertacomponentecurricular_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acphorarioofertacomponentecurricular
    ADD CONSTRAINT acphorarioofertacomponentecurricular_pkey PRIMARY KEY (horarioofertacomponentecurricularid);


--
-- Name: acpinscricao_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpinscricao
    ADD CONSTRAINT acpinscricao_pkey PRIMARY KEY (inscricaoid);


--
-- Name: acpinscricaoturmagrupo_pkey; Type: CONSTRAINT; Schema: public; Owner: solis; Tablespace: 
--

ALTER TABLE ONLY acpinscricaoturmagrupo
    ADD CONSTRAINT acpinscricaoturmagrupo_pkey PRIMARY KEY (inscricaoturmagrupoid);


--
-- Name: acpmatricula_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpmatricula
    ADD CONSTRAINT acpmatricula_pkey PRIMARY KEY (matriculaid);


--
-- Name: acpmatrizcurricular_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpmatrizcurricular
    ADD CONSTRAINT acpmatrizcurricular_pkey PRIMARY KEY (matrizcurricularid);


--
-- Name: acpmatrizcurriculargrupo_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpmatrizcurriculargrupo
    ADD CONSTRAINT acpmatrizcurriculargrupo_pkey PRIMARY KEY (matrizcurriculargrupoid);


--
-- Name: acpmodelodeavaliacao_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpmodelodeavaliacao
    ADD CONSTRAINT acpmodelodeavaliacao_pkey PRIMARY KEY (modelodeavaliacaoid);


--
-- Name: acpmovimentoinscricao_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpmovimentoinscricao
    ADD CONSTRAINT acpmovimentoinscricao_pkey PRIMARY KEY (movimentoinscricaoid);


--
-- Name: acpmovimentomatricula_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpmovimentomatricula
    ADD CONSTRAINT acpmovimentomatricula_pkey PRIMARY KEY (movimentomatriculaid);


--
-- Name: acpocorrenciacurso_ocorrenciacursoid; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpocorrenciacurso
    ADD CONSTRAINT acpocorrenciacurso_ocorrenciacursoid PRIMARY KEY (ocorrenciacursoid);


--
-- Name: acpocorrenciahorariooferta_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpocorrenciahorariooferta
    ADD CONSTRAINT acpocorrenciahorariooferta_pkey PRIMARY KEY (ocorrenciahorarioofertaid);


--
-- Name: acpofertacomponentecurricular_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpofertacomponentecurricular
    ADD CONSTRAINT acpofertacomponentecurricular_pkey PRIMARY KEY (ofertacomponentecurricularid);


--
-- Name: acpofertacurso_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpofertacurso
    ADD CONSTRAINT acpofertacurso_pkey PRIMARY KEY (ofertacursoid);


--
-- Name: acpofertaturma_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpofertaturma
    ADD CONSTRAINT acpofertaturma_pkey PRIMARY KEY (ofertaturmaid);


--
-- Name: acpperfilcurso_perfilcursoid; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpperfilcurso
    ADD CONSTRAINT acpperfilcurso_perfilcursoid PRIMARY KEY (perfilcursoid);


--
-- Name: acpperfilcursocamposadicionais_perfilcursocamposadicionaisid; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpperfilcursocamposadicionais
    ADD CONSTRAINT acpperfilcursocamposadicionais_perfilcursocamposadicionaisid PRIMARY KEY (perfilcursocamposadicionaisid);


--
-- Name: acpperfilcursocomponentecurricular_pcccid; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpperfilcursocomponentecurricular
    ADD CONSTRAINT acpperfilcursocomponentecurricular_pcccid PRIMARY KEY (perfilcursocomponentecurricularid);


--
-- Name: acprecuperacao_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acprecuperacao
    ADD CONSTRAINT acprecuperacao_pkey PRIMARY KEY (recuperacaoid);


--
-- Name: acpregrasmatriculaperfilcurso_regrasmatriculaperfilcursoid; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acpregrasmatriculaperfilcurso
    ADD CONSTRAINT acpregrasmatriculaperfilcurso_regrasmatriculaperfilcursoid PRIMARY KEY (regrasmatriculaperfilcursoid);


--
-- Name: acprelacionamentodecomponentes_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acprelacionamentodecomponentes
    ADD CONSTRAINT acprelacionamentodecomponentes_pkey PRIMARY KEY (componentedeavaliacaopai, componentedeavaliacaofilho);


--
-- Name: acptipocomponentecurricular_componentecurricularid; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acptipocomponentecurricular
    ADD CONSTRAINT acptipocomponentecurricular_componentecurricularid PRIMARY KEY (tipocomponentecurricularid);


--
-- Name: acptipodocumento_perfilcursotipodocumentoid; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acptipodocumento
    ADD CONSTRAINT acptipodocumento_perfilcursotipodocumentoid PRIMARY KEY (perfilcursotipodocumentoid);


--
-- Name: ava_atributos_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ava_atributos
    ADD CONSTRAINT ava_atributos_pkey PRIMARY KEY (id_atributos);


--
-- Name: ava_avaliacao_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ava_avaliacao
    ADD CONSTRAINT ava_avaliacao_pkey PRIMARY KEY (id_avaliacao);


--
-- Name: ava_avaliacao_widget_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ava_avaliacao_perfil_widget
    ADD CONSTRAINT ava_avaliacao_widget_pkey PRIMARY KEY (id_avaliacao_perfil_widget);


--
-- Name: ava_bloco_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ava_bloco
    ADD CONSTRAINT ava_bloco_pkey PRIMARY KEY (id_bloco);


--
-- Name: ava_bloco_questoes_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ava_bloco_questoes
    ADD CONSTRAINT ava_bloco_questoes_pkey PRIMARY KEY (id_bloco_questoes);


--
-- Name: ava_config_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ava_config
    ADD CONSTRAINT ava_config_pkey PRIMARY KEY (chave);


--
-- Name: ava_estatisticas_atributos_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ava_totalizadores_atributos
    ADD CONSTRAINT ava_estatisticas_atributos_pkey PRIMARY KEY (id_totalizador_atributo);


--
-- Name: ava_estatisticas_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ava_totalizadores
    ADD CONSTRAINT ava_estatisticas_pkey PRIMARY KEY (id_totalizador);


--
-- Name: ava_form_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ava_form_log
    ADD CONSTRAINT ava_form_log_pkey PRIMARY KEY (id_form_log);


--
-- Name: ava_formulario_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ava_formulario
    ADD CONSTRAINT ava_formulario_pkey PRIMARY KEY (id_formulario);


--
-- Name: ava_granularidade_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ava_granularidade
    ADD CONSTRAINT ava_granularidade_pkey PRIMARY KEY (id_granularidade);


--
-- Name: ava_mail_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ava_mail_log
    ADD CONSTRAINT ava_mail_log_pkey PRIMARY KEY (id_mail_log);


--
-- Name: ava_mail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ava_mail
    ADD CONSTRAINT ava_mail_pkey PRIMARY KEY (id_mail);


--
-- Name: ava_perfil_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ava_perfil
    ADD CONSTRAINT ava_perfil_pkey PRIMARY KEY (id_perfil);


--
-- Name: ava_perfil_widget_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ava_perfil_widget
    ADD CONSTRAINT ava_perfil_widget_pkey PRIMARY KEY (id_perfil_widget);


--
-- Name: ava_questoes_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ava_questoes
    ADD CONSTRAINT ava_questoes_pkey PRIMARY KEY (id_questoes);


--
-- Name: ava_respostas_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ava_respostas
    ADD CONSTRAINT ava_respostas_pkey PRIMARY KEY (id_respostas);


--
-- Name: ava_servico_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ava_servico
    ADD CONSTRAINT ava_servico_pkey PRIMARY KEY (id_servico);


--
-- Name: ava_widget_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ava_widget
    ADD CONSTRAINT ava_widget_pkey PRIMARY KEY (id_widget);


--
-- Name: basatuacaoprofessor_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basatuacaoprofessor
    ADD CONSTRAINT basatuacaoprofessor_pkey PRIMARY KEY (atuacaoprofessorid);


--
-- Name: basbadge_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basbadge
    ADD CONSTRAINT basbadge_pkey PRIMARY KEY (badgeid);


--
-- Name: basbadgeloan_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basbadgeloan
    ADD CONSTRAINT basbadgeloan_pkey PRIMARY KEY (loanid);


--
-- Name: basbadgestatus_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basbadgestatus
    ADD CONSTRAINT basbadgestatus_pkey PRIMARY KEY (badgestatusid);


--
-- Name: basbuscadinamica_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basbuscadinamica
    ADD CONSTRAINT basbuscadinamica_pkey PRIMARY KEY (codigo, identificador);


--
-- Name: bascadastrodinamico_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bascadastrodinamico
    ADD CONSTRAINT bascadastrodinamico_pkey PRIMARY KEY (codigo);


--
-- Name: bascity_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bascity
    ADD CONSTRAINT bascity_pkey PRIMARY KEY (cityid);


--
-- Name: bascitysquare_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bascitysquare
    ADD CONSTRAINT bascitysquare_pkey PRIMARY KEY (cityid, square);


--
-- Name: bascompanyconf_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bascompanyconf
    ADD CONSTRAINT bascompanyconf_pkey PRIMARY KEY (companyid);


--
-- Name: basconfig_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basconfig
    ADD CONSTRAINT basconfig_pkey PRIMARY KEY (moduleconfig, parameter);


--
-- Name: basconfiguracaodatelainicial_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basconfiguracaodatelainicial
    ADD CONSTRAINT basconfiguracaodatelainicial_pkey PRIMARY KEY (configuracaoid);


--
-- Name: basconfiguracaotrocadesenha_pkey; Type: CONSTRAINT; Schema: public; Owner: solis; Tablespace: 
--

ALTER TABLE ONLY basconfiguracaotrocadesenha
    ADD CONSTRAINT basconfiguracaotrocadesenha_pkey PRIMARY KEY (configuracaotrocadesenhaid);


--
-- Name: bascountry_countryid_key; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bascountry
    ADD CONSTRAINT bascountry_countryid_key UNIQUE (countryid);


--
-- Name: bascountry_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bascountry
    ADD CONSTRAINT bascountry_pkey PRIMARY KEY (countryid);


--
-- Name: bascsvimportation_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bascsvimportation
    ADD CONSTRAINT bascsvimportation_pkey PRIMARY KEY (csvimportationid);


--
-- Name: bascsvlog_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bascsvlog
    ADD CONSTRAINT bascsvlog_pkey PRIMARY KEY (bascsvlogid);


--
-- Name: bascvslog_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bascvslog
    ADD CONSTRAINT bascvslog_pkey PRIMARY KEY (cvslogid);


--
-- Name: basdocument_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basdocument
    ADD CONSTRAINT basdocument_pkey PRIMARY KEY (personid, documenttypeid);


--
-- Name: basdocumentogerado_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basdocumentogerado
    ADD CONSTRAINT basdocumentogerado_pkey PRIMARY KEY (documentogeradoid);


--
-- Name: basdocumenttype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basdocumenttype
    ADD CONSTRAINT basdocumenttype_pkey PRIMARY KEY (documenttypeid);


--
-- Name: basemail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basemail
    ADD CONSTRAINT basemail_pkey PRIMARY KEY (emailid);


--
-- Name: basemployee_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basemployee
    ADD CONSTRAINT basemployee_pkey PRIMARY KEY (employeeid);


--
-- Name: basemployeetype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basemployeetype
    ADD CONSTRAINT basemployeetype_pkey PRIMARY KEY (employeetypeid);


--
-- Name: basethnicorigin_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basethnicorigin
    ADD CONSTRAINT basethnicorigin_pkey PRIMARY KEY (ethnicoriginid);


--
-- Name: basetiquetadatabela_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basetiquetadatabela
    ADD CONSTRAINT basetiquetadatabela_pkey PRIMARY KEY (etiquetadatabelaid);


--
-- Name: basfile_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basfile
    ADD CONSTRAINT basfile_pkey PRIMARY KEY (fileid);


--
-- Name: basgrupotrocadesenha_pkey; Type: CONSTRAINT; Schema: public; Owner: solis; Tablespace: 
--

ALTER TABLE ONLY basgrupotrocadesenha
    ADD CONSTRAINT basgrupotrocadesenha_pkey PRIMARY KEY (grupostrocadesenhaid);


--
-- Name: bashistoricoferias_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bashistoricoferias
    ADD CONSTRAINT bashistoricoferias_pkey PRIMARY KEY (historicoferiasid);


--
-- Name: bashistoricofuncional_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bashistoricofuncional
    ADD CONSTRAINT bashistoricofuncional_pkey PRIMARY KEY (historicofuncionalid);


--
-- Name: baskinship_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY baskinship
    ADD CONSTRAINT baskinship_pkey PRIMARY KEY (kinshipid);


--
-- Name: baslegalperson_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY baslegalperson
    ADD CONSTRAINT baslegalperson_pkey PRIMARY KEY (personid);


--
-- Name: baslegalpersontype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY baslegalpersontype
    ADD CONSTRAINT baslegalpersontype_pkey PRIMARY KEY (legalpersontypeid);


--
-- Name: baslink_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY baslink
    ADD CONSTRAINT baslink_pkey PRIMARY KEY (linkid);


--
-- Name: baslocation_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY baslocation
    ADD CONSTRAINT baslocation_pkey PRIMARY KEY (locationid);


--
-- Name: baslocationtype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY baslocationtype
    ADD CONSTRAINT baslocationtype_pkey PRIMARY KEY (locationtypeid);


--
-- Name: basmaritalstatus_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basmaritalstatus
    ADD CONSTRAINT basmaritalstatus_pkey PRIMARY KEY (maritalstatusid);


--
-- Name: basneighborhood_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basneighborhood
    ADD CONSTRAINT basneighborhood_pkey PRIMARY KEY (neighborhoodid);


--
-- Name: basperson_email_key; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basperson
    ADD CONSTRAINT basperson_email_key UNIQUE (email);


--
-- Name: basperson_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basperson
    ADD CONSTRAINT basperson_pkey PRIMARY KEY (personid);


--
-- Name: baspersontitle_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY baspersontitle
    ADD CONSTRAINT baspersontitle_pkey PRIMARY KEY (persontitleid);


--
-- Name: basphysicalperson_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basphysicalperson
    ADD CONSTRAINT basphysicalperson_pkey PRIMARY KEY (personid);


--
-- Name: basphysicalpersonemployee_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basphysicalpersonemployee
    ADD CONSTRAINT basphysicalpersonemployee_pkey PRIMARY KEY (personid);


--
-- Name: basphysicalpersonkinship_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basphysicalpersonkinship
    ADD CONSTRAINT basphysicalpersonkinship_pkey PRIMARY KEY (personid, kinshipid, relativepersonid);


--
-- Name: basphysicalpersonprofessor_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basphysicalpersonprofessor
    ADD CONSTRAINT basphysicalpersonprofessor_pkey PRIMARY KEY (personid);


--
-- Name: basphysicalpersonstudent_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basphysicalpersonstudent
    ADD CONSTRAINT basphysicalpersonstudent_pkey PRIMARY KEY (personid);


--
-- Name: basprofessionalactivity_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basprofessionalactivity
    ADD CONSTRAINT basprofessionalactivity_pkey PRIMARY KEY (professionalactivityid);


--
-- Name: basprofessionalactivityagent_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basprofessionalactivityagent
    ADD CONSTRAINT basprofessionalactivityagent_pkey PRIMARY KEY (professionalactivityagentid);


--
-- Name: basprofessionalactivitylinktype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basprofessionalactivitylinktype
    ADD CONSTRAINT basprofessionalactivitylinktype_pkey PRIMARY KEY (professionalactivitylinktypeid);


--
-- Name: basprofessionalactivitypeople_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basprofessionalactivitypeople
    ADD CONSTRAINT basprofessionalactivitypeople_pkey PRIMARY KEY (professionalactivitypeopleid);


--
-- Name: basprofessorcenter_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdprofessorcenter
    ADD CONSTRAINT basprofessorcenter_pkey PRIMARY KEY (professorid, centerid, begindate);


--
-- Name: basprofessorcommitment_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basprofessorcommitment
    ADD CONSTRAINT basprofessorcommitment_pkey PRIMARY KEY (personid, begindate);


--
-- Name: basprofessorformation_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdprofessorformation
    ADD CONSTRAINT basprofessorformation_pkey PRIMARY KEY (professorid, formationlevelid, externalcourseid);


--
-- Name: basreport_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basreport
    ADD CONSTRAINT basreport_pkey PRIMARY KEY (reportid);


--
-- Name: basreportparameter_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basreportparameter
    ADD CONSTRAINT basreportparameter_pkey PRIMARY KEY (reportparameterid);


--
-- Name: basresetpassword_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basresetpassword
    ADD CONSTRAINT basresetpassword_pkey PRIMARY KEY (resetpasswordid);


--
-- Name: bassector_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bassector
    ADD CONSTRAINT bassector_pkey PRIMARY KEY (sectorid);


--
-- Name: bassectorboss_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bassectorboss
    ADD CONSTRAINT bassectorboss_pkey PRIMARY KEY (bossid, sectorid);


--
-- Name: bassessao_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bassessao
    ADD CONSTRAINT bassessao_pkey PRIMARY KEY (sessaoid);


--
-- Name: basspecialnecessity_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basspecialnecessity
    ADD CONSTRAINT basspecialnecessity_pkey PRIMARY KEY (specialnecessityid);


--
-- Name: basstamp_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basstamp
    ADD CONSTRAINT basstamp_pkey PRIMARY KEY (stampid);


--
-- Name: basstate_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basstate
    ADD CONSTRAINT basstate_pkey PRIMARY KEY (stateid, countryid);


--
-- Name: basstickynote_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basstickynote
    ADD CONSTRAINT basstickynote_pkey PRIMARY KEY (stickynoteid);


--
-- Name: bastaskhistory_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bastaskhistory
    ADD CONSTRAINT bastaskhistory_pkey PRIMARY KEY (taskhistoryid);


--
-- Name: bastaskstatus_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bastaskstatus
    ADD CONSTRAINT bastaskstatus_pkey PRIMARY KEY (taskstatusid);


--
-- Name: bastipoatuacaoprofessor_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY bastipoatuacaoprofessor
    ADD CONSTRAINT bastipoatuacaoprofessor_pkey PRIMARY KEY (tipoatuacaoprofessorid);


--
-- Name: basturn_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basturn
    ADD CONSTRAINT basturn_pkey PRIMARY KEY (turnid);


--
-- Name: basunit_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basunit
    ADD CONSTRAINT basunit_pkey PRIMARY KEY (unitid);


--
-- Name: basunitconfig_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basunitconfig
    ADD CONSTRAINT basunitconfig_pkey PRIMARY KEY (unitconfigid);


--
-- Name: basupdate_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basupdate
    ADD CONSTRAINT basupdate_pkey PRIMARY KEY (updatetime);


--
-- Name: basuploadreportinfo_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basuploadreportinfo
    ADD CONSTRAINT basuploadreportinfo_pkey PRIMARY KEY (uploadreportinfoid);


--
-- Name: basuploadreportinfo_report_key; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basuploadreportinfo
    ADD CONSTRAINT basuploadreportinfo_report_key UNIQUE (report);


--
-- Name: basweekday_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basweekday
    ADD CONSTRAINT basweekday_pkey PRIMARY KEY (weekdayid);


--
-- Name: buscadinamica_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY buscadinamica
    ADD CONSTRAINT buscadinamica_pkey PRIMARY KEY (buscadinamicaid);


--
-- Name: cadastrodinamico_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY cadastrodinamico
    ADD CONSTRAINT cadastrodinamico_pkey PRIMARY KEY (cadastrodinamicoid);


--
-- Name: campobuscadinamica_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY campobuscadinamica
    ADD CONSTRAINT campobuscadinamica_pkey PRIMARY KEY (campobuscadinamicaid);


--
-- Name: capformadepagamento_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY capformadepagamento
    ADD CONSTRAINT capformadepagamento_pkey PRIMARY KEY (formadepagamentoid);


--
-- Name: caphistorico_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY caphistorico
    ADD CONSTRAINT caphistorico_pkey PRIMARY KEY (historicoid);


--
-- Name: caplancamento_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY caplancamento
    ADD CONSTRAINT caplancamento_pkey PRIMARY KEY (lancamentoid);


--
-- Name: capsolicitacao_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY capsolicitacao
    ADD CONSTRAINT capsolicitacao_pkey PRIMARY KEY (solicitacaoid);


--
-- Name: capsolicitacaoestado_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY capsolicitacaoestado
    ADD CONSTRAINT capsolicitacaoestado_pkey PRIMARY KEY (solicitacaoestadoid);


--
-- Name: capsolicitacaoparcela_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY capsolicitacaoparcela
    ADD CONSTRAINT capsolicitacaoparcela_pkey PRIMARY KEY (solicitacaoparcelaid);


--
-- Name: captipolancamento_tipolancamentoid_key; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY captipolancamento
    ADD CONSTRAINT captipolancamento_tipolancamentoid_key UNIQUE (tipolancamentoid);


--
-- Name: captitulo_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY captitulo
    ADD CONSTRAINT captitulo_pkey PRIMARY KEY (tituloid);


--
-- Name: ccpcopy_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ccpcopy
    ADD CONSTRAINT ccpcopy_pkey PRIMARY KEY (copyid);


--
-- Name: ccppayrolldiscount_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ccppayrolldiscount
    ADD CONSTRAINT ccppayrolldiscount_pkey PRIMARY KEY (payrolldiscountid);


--
-- Name: ccpperiod_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ccpperiod
    ADD CONSTRAINT ccpperiod_pkey PRIMARY KEY (periodid);


--
-- Name: ccpperson_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ccpperson
    ADD CONSTRAINT ccpperson_pkey PRIMARY KEY (personid);


--
-- Name: ccppersoncopy_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ccppersoncopy
    ADD CONSTRAINT ccppersoncopy_pkey PRIMARY KEY (copyid);


--
-- Name: ccppersonperiod_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ccppersonperiod
    ADD CONSTRAINT ccppersonperiod_pkey PRIMARY KEY (personperiodid);


--
-- Name: ccppersonprinter_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ccppersonprinter
    ADD CONSTRAINT ccppersonprinter_pkey PRIMARY KEY (personprinterid);


--
-- Name: ccppersonsector_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ccppersonsector
    ADD CONSTRAINT ccppersonsector_pkey PRIMARY KEY (sectorpersonid);


--
-- Name: ccpprinter_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ccpprinter
    ADD CONSTRAINT ccpprinter_pkey PRIMARY KEY (printerid);


--
-- Name: ccprequest_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ccprequest
    ADD CONSTRAINT ccprequest_pkey PRIMARY KEY (requestid);


--
-- Name: ccprequestfax_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ccprequestfax
    ADD CONSTRAINT ccprequestfax_pkey PRIMARY KEY (requestid);


--
-- Name: ccprule_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ccprule
    ADD CONSTRAINT ccprule_pkey PRIMARY KEY (ruleid);


--
-- Name: ccpsector_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ccpsector
    ADD CONSTRAINT ccpsector_pkey PRIMARY KEY (sectorid);


--
-- Name: ccpsectorcopy_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ccpsectorcopy
    ADD CONSTRAINT ccpsectorcopy_pkey PRIMARY KEY (copyid);


--
-- Name: ccpsectorperiod_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ccpsectorperiod
    ADD CONSTRAINT ccpsectorperiod_pkey PRIMARY KEY (sectorperiodid);


--
-- Name: ccpsectorprinter_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ccpsectorprinter
    ADD CONSTRAINT ccpsectorprinter_pkey PRIMARY KEY (personsectorid);


--
-- Name: ccpservice_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ccpservice
    ADD CONSTRAINT ccpservice_pkey PRIMARY KEY (serviceid);


--
-- Name: domain_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY basdomain
    ADD CONSTRAINT domain_pkey PRIMARY KEY (domainid, sequence);


--
-- Name: finagreementcomments_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finagreementcomments
    ADD CONSTRAINT finagreementcomments_pkey PRIMARY KEY (agreementcommentsid);


--
-- Name: finbank_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finbank
    ADD CONSTRAINT finbank_pkey PRIMARY KEY (bankid);


--
-- Name: finbankaccount_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finbankaccount
    ADD CONSTRAINT finbankaccount_pkey PRIMARY KEY (bankaccountid);


--
-- Name: finbankaccountinvoiceinfo_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finbankaccountinvoiceinfo
    ADD CONSTRAINT finbankaccountinvoiceinfo_pkey PRIMARY KEY (bankaccountid);


--
-- Name: finbankinvoiceinfo_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finbankinvoiceinfo
    ADD CONSTRAINT finbankinvoiceinfo_pkey PRIMARY KEY (bankaccountid, invoiceid);


--
-- Name: finbankmovementnotfound_pkey; Type: CONSTRAINT; Schema: public; Owner: solis; Tablespace: 
--

ALTER TABLE ONLY finbankmovementnotfound
    ADD CONSTRAINT finbankmovementnotfound_pkey PRIMARY KEY (bankmovementnotfoundid);


--
-- Name: finbanktarget_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finbanktarget
    ADD CONSTRAINT finbanktarget_pkey PRIMARY KEY (contractid);


--
-- Name: fincamporemessa_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fincamporemessa
    ADD CONSTRAINT fincamporemessa_pkey PRIMARY KEY (camporemessaid);


--
-- Name: fincheque_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fincheque
    ADD CONSTRAINT fincheque_pkey PRIMARY KEY (chequeid);


--
-- Name: finclosecounter_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finclosecounter
    ADD CONSTRAINT finclosecounter_pkey PRIMARY KEY (closecounterid);


--
-- Name: fincobrancabancaria_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fincobrancabancaria
    ADD CONSTRAINT fincobrancabancaria_pkey PRIMARY KEY (cobrancabancariaid);


--
-- Name: fincollectiontype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fincollectiontype
    ADD CONSTRAINT fincollectiontype_pkey PRIMARY KEY (collectiontypeid);


--
-- Name: finconfiguracaoremessa_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finconfiguracaoremessa
    ADD CONSTRAINT finconfiguracaoremessa_pkey PRIMARY KEY (configuracaoremessaid);


--
-- Name: finconvenant_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finconvenant
    ADD CONSTRAINT finconvenant_pkey PRIMARY KEY (convenantid);


--
-- Name: finconvenantperson_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finconvenantperson
    ADD CONSTRAINT finconvenantperson_pkey PRIMARY KEY (convenantpersonid);


--
-- Name: fincounter_description_key; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fincounter
    ADD CONSTRAINT fincounter_description_key UNIQUE (description);


--
-- Name: fincounter_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fincounter
    ADD CONSTRAINT fincounter_pkey PRIMARY KEY (counterid);


--
-- Name: fincountermovement_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fincountermovement
    ADD CONSTRAINT fincountermovement_pkey PRIMARY KEY (countermovementid);


--
-- Name: fincountermovementcheque_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fincountermovementcheque
    ADD CONSTRAINT fincountermovementcheque_pkey PRIMARY KEY (movementchequeid);


--
-- Name: findadosbancariosdapessoa_pkey; Type: CONSTRAINT; Schema: public; Owner: solis; Tablespace: 
--

ALTER TABLE ONLY findadosbancariosdapessoa
    ADD CONSTRAINT findadosbancariosdapessoa_pkey PRIMARY KEY (dadosbancariosdapessoa);


--
-- Name: finemissiontype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finemissiontype
    ADD CONSTRAINT finemissiontype_pkey PRIMARY KEY (emissiontypeid);


--
-- Name: finenrollfee_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finenrollfee
    ADD CONSTRAINT finenrollfee_pkey PRIMARY KEY (learningperiodid, operationid, isfreshman);


--
-- Name: finentry_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finentry
    ADD CONSTRAINT finentry_pkey PRIMARY KEY (entryid);


--
-- Name: finfile_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finfile
    ADD CONSTRAINT finfile_pkey PRIMARY KEY (fileid);


--
-- Name: finfinancialaid_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finfinancialaid
    ADD CONSTRAINT finfinancialaid_pkey PRIMARY KEY (incentivetypeid);


--
-- Name: finfluxoaprovacao_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finfluxoaprovacao
    ADD CONSTRAINT finfluxoaprovacao_pkey PRIMARY KEY (fluxoaprovacaoid);


--
-- Name: finfluxoaprovacaoconfiguracao_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finfluxoaprovacaoconfiguracao
    ADD CONSTRAINT finfluxoaprovacaoconfiguracao_pkey PRIMARY KEY (fluxoaprovacaoconfiguracaoid);


--
-- Name: finfluxoaprovacaonivel_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finfluxoaprovacaonivel
    ADD CONSTRAINT finfluxoaprovacaonivel_pkey PRIMARY KEY (fluxoaprovacaonivelid);


--
-- Name: finfluxoaprovacaoprocesso_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finfluxoaprovacaoprocesso
    ADD CONSTRAINT finfluxoaprovacaoprocesso_pkey PRIMARY KEY (fluxoaprovacaoprocessoid);


--
-- Name: finfluxoaprovacaostatus_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finfluxoaprovacaostatus
    ADD CONSTRAINT finfluxoaprovacaostatus_pkey PRIMARY KEY (fluxoaprovacaostatusid);


--
-- Name: finfluxosolicitacao_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finfluxosolicitacao
    ADD CONSTRAINT finfluxosolicitacao_pkey PRIMARY KEY (fluxosolicitacaoid);


--
-- Name: finfluxosolicitacaoregistro_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finfluxosolicitacaoregistro
    ADD CONSTRAINT finfluxosolicitacaoregistro_pkey PRIMARY KEY (fluxosolicitacaoregistroid);


--
-- Name: finhistoricoremessa_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finhistoricoremessa
    ADD CONSTRAINT finhistoricoremessa_pkey PRIMARY KEY (historicoremessaid);


--
-- Name: finincentive_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finincentive
    ADD CONSTRAINT finincentive_pkey PRIMARY KEY (incentiveid);


--
-- Name: finincentivetype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finincentivetype
    ADD CONSTRAINT finincentivetype_pkey PRIMARY KEY (incentivetypeid);


--
-- Name: finincomeforecast_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finincomeforecast
    ADD CONSTRAINT finincomeforecast_pkey PRIMARY KEY (incomeforecastid);


--
-- Name: finincomesource_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finincomesource
    ADD CONSTRAINT finincomesource_pkey PRIMARY KEY (incomesourceid);


--
-- Name: fininfotitulo_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fininfotitulo
    ADD CONSTRAINT fininfotitulo_pkey PRIMARY KEY (titulo);


--
-- Name: fininvoice_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fininvoice
    ADD CONSTRAINT fininvoice_pkey PRIMARY KEY (invoiceid);


--
-- Name: fininvoicelog_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fininvoicelog
    ADD CONSTRAINT fininvoicelog_pkey PRIMARY KEY (month, year, generationtype);


--
-- Name: fininvoicemessage_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fininvoicemessage
    ADD CONSTRAINT fininvoicemessage_pkey PRIMARY KEY (invoicemessageid);


--
-- Name: fininvoicemessagetype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fininvoicemessagetype
    ADD CONSTRAINT fininvoicemessagetype_pkey PRIMARY KEY (invoicemessagetypeid);


--
-- Name: fininvoicespecie_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fininvoicespecie
    ADD CONSTRAINT fininvoicespecie_pkey PRIMARY KEY (invoicespecieid);


--
-- Name: fininvoicetarget_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fininvoicetarget
    ADD CONSTRAINT fininvoicetarget_pkey PRIMARY KEY (contractid);


--
-- Name: fininvoicetype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fininvoicetype
    ADD CONSTRAINT fininvoicetype_pkey PRIMARY KEY (invoicetypeid);


--
-- Name: finloan_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finloan
    ADD CONSTRAINT finloan_pkey PRIMARY KEY (incentivetypeid);


--
-- Name: finmovimentacaocheque_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finmovimentacaocheque
    ADD CONSTRAINT finmovimentacaocheque_pkey PRIMARY KEY (movimentacaochequeid);


--
-- Name: finoccurrenceoperation_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finoccurrenceoperation
    ADD CONSTRAINT finoccurrenceoperation_pkey PRIMARY KEY (occurrenceoperationid);


--
-- Name: finopencounter_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finopencounter
    ADD CONSTRAINT finopencounter_pkey PRIMARY KEY (opencounterid);


--
-- Name: finoperation_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finoperation
    ADD CONSTRAINT finoperation_pkey PRIMARY KEY (operationid);


--
-- Name: finoperationgroup_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finoperationgroup
    ADD CONSTRAINT finoperationgroup_pkey PRIMARY KEY (operationgroupid);


--
-- Name: finpayableinvoice_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finpayableinvoice
    ADD CONSTRAINT finpayableinvoice_pkey PRIMARY KEY (invoiceid);


--
-- Name: finpayableinvoicestatus_status_key; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finpayableinvoicestatus
    ADD CONSTRAINT finpayableinvoicestatus_status_key UNIQUE (status);


--
-- Name: finpayrolldiscounttarget_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finpayrolldiscounttarget
    ADD CONSTRAINT finpayrolldiscounttarget_pkey PRIMARY KEY (contractid);


--
-- Name: finpersoninformation_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finpersoninformation
    ADD CONSTRAINT finpersoninformation_pkey PRIMARY KEY (personid);


--
-- Name: finphysicaltarget_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finphysicaltarget
    ADD CONSTRAINT finphysicaltarget_pkey PRIMARY KEY (contractid);


--
-- Name: finpolicy_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finpolicy
    ADD CONSTRAINT finpolicy_pkey PRIMARY KEY (policyid);


--
-- Name: finpolicydiscount_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finpolicydiscount
    ADD CONSTRAINT finpolicydiscount_pkey PRIMARY KEY (discountid);


--
-- Name: finprice_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finprice
    ADD CONSTRAINT finprice_pkey PRIMARY KEY (courseid, courseversion, turnid, unitid, startdate);


--
-- Name: finpricepolicy_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finpricepolicy
    ADD CONSTRAINT finpricepolicy_pkey PRIMARY KEY (pricepolicyid);


--
-- Name: finreasoncancellation_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finreasoncancellation
    ADD CONSTRAINT finreasoncancellation_pkey PRIMARY KEY (reasoncancellationid);


--
-- Name: finreceivableinvoice_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finreceivableinvoice
    ADD CONSTRAINT finreceivableinvoice_pkey PRIMARY KEY (invoiceid);


--
-- Name: finreceivableinvoicecommunication_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finreceivableinvoicecommunication
    ADD CONSTRAINT finreceivableinvoicecommunication_pkey PRIMARY KEY (receivableinvoicecommunicationid);


--
-- Name: finreemissaodetituloslog_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finreemissaodetituloslog
    ADD CONSTRAINT finreemissaodetituloslog_pkey PRIMARY KEY (reemissaodetituloslogid);


--
-- Name: finrelease_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finrelease
    ADD CONSTRAINT finrelease_pkey PRIMARY KEY (releaseid);


--
-- Name: finspc_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finspc
    ADD CONSTRAINT finspc_pkey PRIMARY KEY (personid, entrydate);


--
-- Name: finspcmovement_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finspcmovement
    ADD CONSTRAINT finspcmovement_pkey PRIMARY KEY (movementid);


--
-- Name: finspcreason_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finspcreason
    ADD CONSTRAINT finspcreason_pkey PRIMARY KEY (reasonid);


--
-- Name: finspecies_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finspecies
    ADD CONSTRAINT finspecies_pkey PRIMARY KEY (speciesid);


--
-- Name: finspeciestype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finspeciestype
    ADD CONSTRAINT finspeciestype_pkey PRIMARY KEY (speciestypeid);


--
-- Name: finstatuscheque_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finstatuscheque
    ADD CONSTRAINT finstatuscheque_pkey PRIMARY KEY (statuschequeid);


--
-- Name: finstatusdotitulo_pkey; Type: CONSTRAINT; Schema: public; Owner: solis; Tablespace: 
--

ALTER TABLE ONLY finstatusdotitulo
    ADD CONSTRAINT finstatusdotitulo_pkey PRIMARY KEY (statusdotituloid);


--
-- Name: finstatusdotitulolog_pkey; Type: CONSTRAINT; Schema: public; Owner: solis; Tablespace: 
--

ALTER TABLE ONLY finstatusdotitulolog
    ADD CONSTRAINT finstatusdotitulolog_pkey PRIMARY KEY (statusdotitulologid);


--
-- Name: finstudentfinancing_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finstudentfinancing
    ADD CONSTRAINT finstudentfinancing_pkey PRIMARY KEY (studentfinancingid);


--
-- Name: finsupport_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finsupport
    ADD CONSTRAINT finsupport_pkey PRIMARY KEY (incentivetypeid);


--
-- Name: fintipovalorvariavelremessa_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fintipovalorvariavelremessa
    ADD CONSTRAINT fintipovalorvariavelremessa_pkey PRIMARY KEY (tipovalorvariavelremessaid);


--
-- Name: fintransferenciadecaixa_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fintransferenciadecaixa
    ADD CONSTRAINT fintransferenciadecaixa_pkey PRIMARY KEY (transferenciadecaixaid);


--
-- Name: finvouchermessages_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY finvouchermessages
    ADD CONSTRAINT finvouchermessages_pkey PRIMARY KEY (operationid);


--
-- Name: form_subform_key; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtchelp
    ADD CONSTRAINT form_subform_key UNIQUE (form, subform);


--
-- Name: gtcanalytics_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcanalytics
    ADD CONSTRAINT gtcanalytics_pkey PRIMARY KEY (analyticsid);


--
-- Name: gtcassociation_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcassociation
    ADD CONSTRAINT gtcassociation_pkey PRIMARY KEY (associationid);


--
-- Name: gtcbackgroundtasklog_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcbackgroundtasklog
    ADD CONSTRAINT gtcbackgroundtasklog_pkey PRIMARY KEY (backgroundtasklogid);


--
-- Name: gtccataloguingformat_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtccataloguingformat
    ADD CONSTRAINT gtccataloguingformat_pkey PRIMARY KEY (cataloguingformatid);


--
-- Name: gtcclassificationarea_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcclassificationarea
    ADD CONSTRAINT gtcclassificationarea_pkey PRIMARY KEY (classificationareaid);


--
-- Name: gtccontrolfielddetail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtccontrolfielddetail
    ADD CONSTRAINT gtccontrolfielddetail_pkey PRIMARY KEY (controlfielddetailid);


--
-- Name: gtccostcenter_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtccostcenter
    ADD CONSTRAINT gtccostcenter_pkey PRIMARY KEY (costcenterid);


--
-- Name: gtcdictionary_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcdictionary
    ADD CONSTRAINT gtcdictionary_pkey PRIMARY KEY (dictionaryid);


--
-- Name: gtcdictionarycontent_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcdictionarycontent
    ADD CONSTRAINT gtcdictionarycontent_pkey PRIMARY KEY (dictionarycontentid);


--
-- Name: gtcdictionaryrelatedcontent_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcdictionaryrelatedcontent
    ADD CONSTRAINT gtcdictionaryrelatedcontent_pkey PRIMARY KEY (dictionaryrelatedcontentid);


--
-- Name: gtcexemplarycontrol_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcexemplarycontrol
    ADD CONSTRAINT gtcexemplarycontrol_pkey PRIMARY KEY (controlnumber, itemnumber);


--
-- Name: gtcexemplaryfuturestatusdefined_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcexemplaryfuturestatusdefined
    ADD CONSTRAINT gtcexemplaryfuturestatusdefined_pkey PRIMARY KEY (exemplaryfuturestatusdefinedid);


--
-- Name: gtcexemplarystatus_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcexemplarystatus
    ADD CONSTRAINT gtcexemplarystatus_pkey PRIMARY KEY (exemplarystatusid);


--
-- Name: gtcfavorite_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcfavorite
    ADD CONSTRAINT gtcfavorite_pkey PRIMARY KEY (personid, controlnumber);


--
-- Name: gtcfine_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcfine
    ADD CONSTRAINT gtcfine_pkey PRIMARY KEY (fineid);


--
-- Name: gtcfinestatus_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcfinestatus
    ADD CONSTRAINT gtcfinestatus_pkey PRIMARY KEY (finestatusid);


--
-- Name: gtcformatbackofbook_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcformatbackofbook
    ADD CONSTRAINT gtcformatbackofbook_pkey PRIMARY KEY (formatbackofbookid);


--
-- Name: gtcformcontent_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcformcontent
    ADD CONSTRAINT gtcformcontent_pkey PRIMARY KEY (formcontentid);


--
-- Name: gtcformcontentdetail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcformcontentdetail
    ADD CONSTRAINT gtcformcontentdetail_pkey PRIMARY KEY (formcontentid, field);


--
-- Name: gtcformcontenttype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcformcontenttype
    ADD CONSTRAINT gtcformcontenttype_pkey PRIMARY KEY (formcontenttypeid);


--
-- Name: gtcgeneralpolicy_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcgeneralpolicy
    ADD CONSTRAINT gtcgeneralpolicy_pkey PRIMARY KEY (privilegegroupid, linkid);


--
-- Name: gtchelp_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtchelp
    ADD CONSTRAINT gtchelp_pkey PRIMARY KEY (helpid);


--
-- Name: gtcholiday_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcholiday
    ADD CONSTRAINT gtcholiday_pkey PRIMARY KEY (holidayid);


--
-- Name: gtcinterchange_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcinterchange
    ADD CONSTRAINT gtcinterchange_pkey PRIMARY KEY (interchangeid);


--
-- Name: gtcinterchangeitem_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcinterchangeitem
    ADD CONSTRAINT gtcinterchangeitem_pkey PRIMARY KEY (interchangeitemid);


--
-- Name: gtcinterchangeobservation_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcinterchangeobservation
    ADD CONSTRAINT gtcinterchangeobservation_pkey PRIMARY KEY (interchangeobservationid);


--
-- Name: gtcinterchangestatus_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcinterchangestatus
    ADD CONSTRAINT gtcinterchangestatus_pkey PRIMARY KEY (interchangestatusid);


--
-- Name: gtcinterchangetype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcinterchangetype
    ADD CONSTRAINT gtcinterchangetype_pkey PRIMARY KEY (interchangetypeid);


--
-- Name: gtcinterestsarea_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcinterestsarea
    ADD CONSTRAINT gtcinterestsarea_pkey PRIMARY KEY (personid, classificationareaid);


--
-- Name: gtclabellayout_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtclabellayout
    ADD CONSTRAINT gtclabellayout_pkey PRIMARY KEY (labellayoutid);


--
-- Name: gtclibperson_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtclibperson
    ADD CONSTRAINT gtclibperson_pkey PRIMARY KEY (personid);


--
-- Name: gtclibraryassociation_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtclibraryassociation
    ADD CONSTRAINT gtclibraryassociation_pkey PRIMARY KEY (associationid, libraryunitid);


--
-- Name: gtclibrarygroup_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtclibrarygroup
    ADD CONSTRAINT gtclibrarygroup_pkey PRIMARY KEY (librarygroupid);


--
-- Name: gtclibraryunit_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtclibraryunit
    ADD CONSTRAINT gtclibraryunit_pkey PRIMARY KEY (libraryunitid);


--
-- Name: gtclibraryunitaccess_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtclibraryunitaccess
    ADD CONSTRAINT gtclibraryunitaccess_pkey PRIMARY KEY (libraryunitid, linkid);


--
-- Name: gtclibraryunitconfig_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtclibraryunitconfig
    ADD CONSTRAINT gtclibraryunitconfig_pkey PRIMARY KEY (libraryunitid, parameter);


--
-- Name: gtclibraryunitisclosed_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtclibraryunitisclosed
    ADD CONSTRAINT gtclibraryunitisclosed_pkey PRIMARY KEY (libraryunitid, weekdayid);


--
-- Name: gtclinkoffieldsbetweenspreadsheets_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtclinkoffieldsbetweenspreadsheets
    ADD CONSTRAINT gtclinkoffieldsbetweenspreadsheets_pkey PRIMARY KEY (linkoffieldsbetweenspreadsheetsid);


--
-- Name: gtcloan_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcloan
    ADD CONSTRAINT gtcloan_pkey PRIMARY KEY (loanid);


--
-- Name: gtcloanbetweenlibrary_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcloanbetweenlibrary
    ADD CONSTRAINT gtcloanbetweenlibrary_pkey PRIMARY KEY (loanbetweenlibraryid);


--
-- Name: gtcloanbetweenlibrarycomposition_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcloanbetweenlibrarycomposition
    ADD CONSTRAINT gtcloanbetweenlibrarycomposition_pkey PRIMARY KEY (loanbetweenlibraryid, itemnumber);


--
-- Name: gtcloanbetweenlibrarystatus_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcloanbetweenlibrarystatus
    ADD CONSTRAINT gtcloanbetweenlibrarystatus_pkey PRIMARY KEY (loanbetweenlibrarystatusid);


--
-- Name: gtcloantype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcloantype
    ADD CONSTRAINT gtcloantype_pkey PRIMARY KEY (loantypeid);


--
-- Name: gtclocationformaterialmovement_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtclocationformaterialmovement
    ADD CONSTRAINT gtclocationformaterialmovement_pkey PRIMARY KEY (locationformaterialmovementid);


--
-- Name: gtcmarctaglisting_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcmarctaglisting
    ADD CONSTRAINT gtcmarctaglisting_pkey PRIMARY KEY (marctaglistingid);


--
-- Name: gtcmaterial_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcmaterial
    ADD CONSTRAINT gtcmaterial_pkey PRIMARY KEY (controlnumber, fieldid, subfieldid, line);


--
-- Name: gtcmaterialcontrol_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcmaterialcontrol
    ADD CONSTRAINT gtcmaterialcontrol_pkey PRIMARY KEY (controlnumber);


--
-- Name: gtcmaterialevaluation_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcmaterialevaluation
    ADD CONSTRAINT gtcmaterialevaluation_pkey PRIMARY KEY (materialevaluationid);


--
-- Name: gtcmaterialgender_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcmaterialgender
    ADD CONSTRAINT gtcmaterialgender_pkey PRIMARY KEY (materialgenderid);


--
-- Name: gtcmaterialhistory_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcmaterialhistory
    ADD CONSTRAINT gtcmaterialhistory_pkey PRIMARY KEY (materialhistoryid);


--
-- Name: gtcmateriallocation_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcmateriallocation
    ADD CONSTRAINT gtcmateriallocation_pkey PRIMARY KEY (materiallocationid);


--
-- Name: gtcmateriallocationtag_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcmateriallocationtag
    ADD CONSTRAINT gtcmateriallocationtag_pkey PRIMARY KEY (materiallocationtagid);


--
-- Name: gtcmaterialphysicaltype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcmaterialphysicaltype
    ADD CONSTRAINT gtcmaterialphysicaltype_pkey PRIMARY KEY (materialphysicaltypeid);


--
-- Name: gtcmaterialtype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcmaterialtype
    ADD CONSTRAINT gtcmaterialtype_pkey PRIMARY KEY (materialtypeid);


--
-- Name: gtcmylibrary_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcmylibrary
    ADD CONSTRAINT gtcmylibrary_pkey PRIMARY KEY (mylibraryid);


--
-- Name: gtcnews_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcnews
    ADD CONSTRAINT gtcnews_pkey PRIMARY KEY (newsid);


--
-- Name: gtcnewsaccess_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcnewsaccess
    ADD CONSTRAINT gtcnewsaccess_pkey PRIMARY KEY (newsid, linkid);


--
-- Name: gtcoperation_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcoperation
    ADD CONSTRAINT gtcoperation_pkey PRIMARY KEY (operationid);


--
-- Name: gtcpenalty_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcpenalty
    ADD CONSTRAINT gtcpenalty_pkey PRIMARY KEY (penaltyid);


--
-- Name: gtcpersonconfig_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcpersonconfig
    ADD CONSTRAINT gtcpersonconfig_pkey PRIMARY KEY (personid, parameter);


--
-- Name: gtcpersonlibraryunit_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcpersonlibraryunit
    ADD CONSTRAINT gtcpersonlibraryunit_pkey PRIMARY KEY (libraryunitid, personid);


--
-- Name: gtcpolicy_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcpolicy
    ADD CONSTRAINT gtcpolicy_pkey PRIMARY KEY (privilegegroupid, linkid, materialgenderid);


--
-- Name: gtcprecatalogue_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcprecatalogue
    ADD CONSTRAINT gtcprecatalogue_pkey PRIMARY KEY (controlnumber, fieldid, subfieldid, line);


--
-- Name: gtcprefixsuffix_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcprefixsuffix
    ADD CONSTRAINT gtcprefixsuffix_pkey PRIMARY KEY (prefixsuffixid);


--
-- Name: gtcprivilegegroup_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcprivilegegroup
    ADD CONSTRAINT gtcprivilegegroup_pkey PRIMARY KEY (privilegegroupid);


--
-- Name: gtcpurchaserequest_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcpurchaserequest
    ADD CONSTRAINT gtcpurchaserequest_pkey PRIMARY KEY (purchaserequestid);


--
-- Name: gtcpurchaserequestmaterial_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcpurchaserequestmaterial
    ADD CONSTRAINT gtcpurchaserequestmaterial_pkey PRIMARY KEY (purchaserequestid, fieldid, subfieldid);


--
-- Name: gtcpurchaserequestquotation_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcpurchaserequestquotation
    ADD CONSTRAINT gtcpurchaserequestquotation_pkey PRIMARY KEY (purchaserequestid, supplierid);


--
-- Name: gtcrenew_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcrenew
    ADD CONSTRAINT gtcrenew_pkey PRIMARY KEY (renewid);


--
-- Name: gtcrenewtype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcrenewtype
    ADD CONSTRAINT gtcrenewtype_pkey PRIMARY KEY (renewtypeid);


--
-- Name: gtcreport_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcreport
    ADD CONSTRAINT gtcreport_pkey PRIMARY KEY (reportid);


--
-- Name: gtcreportparameter_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcreportparameter
    ADD CONSTRAINT gtcreportparameter_pkey PRIMARY KEY (reportparameterid);


--
-- Name: gtcrequestchangeexemplarystatus_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcrequestchangeexemplarystatus
    ADD CONSTRAINT gtcrequestchangeexemplarystatus_pkey PRIMARY KEY (requestchangeexemplarystatusid);


--
-- Name: gtcrequestchangeexemplarystatusaccess_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcrequestchangeexemplarystatusaccess
    ADD CONSTRAINT gtcrequestchangeexemplarystatusaccess_pkey PRIMARY KEY (baslinkid, exemplarystatusid);


--
-- Name: gtcrequestchangeexemplarystatuscomposition_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcrequestchangeexemplarystatuscomposition
    ADD CONSTRAINT gtcrequestchangeexemplarystatuscomposition_pkey PRIMARY KEY (requestchangeexemplarystatusid, itemnumber);


--
-- Name: gtcrequestchangeexemplarystatusstatus_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcrequestchangeexemplarystatusstatus
    ADD CONSTRAINT gtcrequestchangeexemplarystatusstatus_pkey PRIMARY KEY (requestchangeexemplarystatusstatusid);


--
-- Name: gtcreserve_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcreserve
    ADD CONSTRAINT gtcreserve_pkey PRIMARY KEY (reserveid);


--
-- Name: gtcreservecomposition_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcreservecomposition
    ADD CONSTRAINT gtcreservecomposition_pkey PRIMARY KEY (reserveid, itemnumber);


--
-- Name: gtcreservestatus_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcreservestatus
    ADD CONSTRAINT gtcreservestatus_pkey PRIMARY KEY (reservestatusid);


--
-- Name: gtcreservetype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcreservetype
    ADD CONSTRAINT gtcreservetype_pkey PRIMARY KEY (reservetypeid);


--
-- Name: gtcreturnregister_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcreturnregister
    ADD CONSTRAINT gtcreturnregister_pkey PRIMARY KEY (returnregisterid);


--
-- Name: gtcreturntype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcreturntype
    ADD CONSTRAINT gtcreturntype_pkey PRIMARY KEY (returntypeid);


--
-- Name: gtcright_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcright
    ADD CONSTRAINT gtcright_pkey PRIMARY KEY (privilegegroupid, linkid, materialgenderid, operationid);


--
-- Name: gtcrulesformaterialmovement_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcrulesformaterialmovement
    ADD CONSTRAINT gtcrulesformaterialmovement_pkey PRIMARY KEY (currentstate, operationid, locationformaterialmovementid);


--
-- Name: gtcrulestocompletefieldsmarc_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcrulestocompletefieldsmarc
    ADD CONSTRAINT gtcrulestocompletefieldsmarc_pkey PRIMARY KEY (rulestocompletefieldsmarcid);


--
-- Name: gtcschedulecycle_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcschedulecycle
    ADD CONSTRAINT gtcschedulecycle_pkey PRIMARY KEY (schedulecycleid);


--
-- Name: gtcscheduletask_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcscheduletask
    ADD CONSTRAINT gtcscheduletask_pkey PRIMARY KEY (scheduletaskid);


--
-- Name: gtcsearchablefield_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcsearchablefield
    ADD CONSTRAINT gtcsearchablefield_pkey PRIMARY KEY (searchablefieldid);


--
-- Name: gtcsearchablefieldaccess_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcsearchablefieldaccess
    ADD CONSTRAINT gtcsearchablefieldaccess_pkey PRIMARY KEY (searchablefieldid, linkid);


--
-- Name: gtcsearchformat_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcsearchformat
    ADD CONSTRAINT gtcsearchformat_pkey PRIMARY KEY (searchformatid);


--
-- Name: gtcsearchformataccess_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcsearchformataccess
    ADD CONSTRAINT gtcsearchformataccess_pkey PRIMARY KEY (searchformatid, linkid);


--
-- Name: gtcsearchformatcolumn_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcsearchformatcolumn
    ADD CONSTRAINT gtcsearchformatcolumn_pkey PRIMARY KEY (searchformatid, "column");


--
-- Name: gtcsearchpresentationformat_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcsearchpresentationformat
    ADD CONSTRAINT gtcsearchpresentationformat_pkey PRIMARY KEY (searchformatid, category);


--
-- Name: gtcseparator_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcseparator
    ADD CONSTRAINT gtcseparator_pkey PRIMARY KEY (separatorid);


--
-- Name: gtcsession_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcsession
    ADD CONSTRAINT gtcsession_pkey PRIMARY KEY (sessionid);


--
-- Name: gtcsessionoperation_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcsessionoperation
    ADD CONSTRAINT gtcsessionoperation_pkey PRIMARY KEY (sessionoperationid);


--
-- Name: gtcsipcirculationstatus_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcsipcirculationstatus
    ADD CONSTRAINT gtcsipcirculationstatus_pkey PRIMARY KEY (sipcirculationstatusid);


--
-- Name: gtcsipequipament_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcsipequipament
    ADD CONSTRAINT gtcsipequipament_pkey PRIMARY KEY (sipequipamentid);


--
-- Name: gtcsipequipamentbinrules_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcsipequipamentbinrules
    ADD CONSTRAINT gtcsipequipamentbinrules_pkey PRIMARY KEY (sipequipamentid, exemplarystatusid);


--
-- Name: gtcsipequipamentlog_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcsipequipamentlog
    ADD CONSTRAINT gtcsipequipamentlog_pkey PRIMARY KEY (sipequipamentlogid);


--
-- Name: gtcsoapaccess_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcsoapaccess
    ADD CONSTRAINT gtcsoapaccess_pkey PRIMARY KEY (soapclientid, webserviceid);


--
-- Name: gtcsoapclient_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcsoapclient
    ADD CONSTRAINT gtcsoapclient_pkey PRIMARY KEY (soapclientid);


--
-- Name: gtcspreadsheet_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcspreadsheet
    ADD CONSTRAINT gtcspreadsheet_pkey PRIMARY KEY (category, level);


--
-- Name: gtcsupplier_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcsupplier
    ADD CONSTRAINT gtcsupplier_pkey PRIMARY KEY (supplierid);


--
-- Name: gtcsuppliertypeandlocation_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcsuppliertypeandlocation
    ADD CONSTRAINT gtcsuppliertypeandlocation_pkey PRIMARY KEY (supplierid, type);


--
-- Name: gtctag_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtctag
    ADD CONSTRAINT gtctag_pkey PRIMARY KEY (fieldid, subfieldid);


--
-- Name: gtctask_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtctask
    ADD CONSTRAINT gtctask_pkey PRIMARY KEY (taskid);


--
-- Name: gtcwebservice_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcwebservice
    ADD CONSTRAINT gtcwebservice_pkey PRIMARY KEY (webserviceid);


--
-- Name: gtcweekday_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcweekday
    ADD CONSTRAINT gtcweekday_pkey PRIMARY KEY (weekdayid);


--
-- Name: gtcworkflowinstance_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcworkflowinstance
    ADD CONSTRAINT gtcworkflowinstance_pkey PRIMARY KEY (workflowinstanceid);


--
-- Name: gtcworkflowtransition_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcworkflowtransition
    ADD CONSTRAINT gtcworkflowtransition_pkey PRIMARY KEY (previousworkflowstatusid, nextworkflowstatusid);


--
-- Name: gtcz3950servers_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcz3950servers
    ADD CONSTRAINT gtcz3950servers_pkey PRIMARY KEY (serverid);


--
-- Name: insareatype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY insareatype
    ADD CONSTRAINT insareatype_pkey PRIMARY KEY (areatypeid);


--
-- Name: insgrouptype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY insgrouptype
    ADD CONSTRAINT insgrouptype_pkey PRIMARY KEY (grouptypeid);


--
-- Name: insphysicalresource_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY insphysicalresource
    ADD CONSTRAINT insphysicalresource_pkey PRIMARY KEY (physicalresourceid, physicalresourceversion);


--
-- Name: miolo_audit_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY miolo_audit
    ADD CONSTRAINT miolo_audit_pkey PRIMARY KEY (audit_id);


--
-- Name: miolo_custom_value_customized_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY miolo_custom_value
    ADD CONSTRAINT miolo_custom_value_customized_id_key UNIQUE (customized_id, custom_field_id);


--
-- Name: miolo_group_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY miolo_group
    ADD CONSTRAINT miolo_group_pkey PRIMARY KEY (idgroup);


--
-- Name: miolo_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY miolo_log
    ADD CONSTRAINT miolo_log_pkey PRIMARY KEY (idlog);


--
-- Name: miolo_module_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY miolo_module
    ADD CONSTRAINT miolo_module_pkey PRIMARY KEY (idmodule);


--
-- Name: miolo_sequence_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY miolo_sequence
    ADD CONSTRAINT miolo_sequence_pkey PRIMARY KEY (sequence);


--
-- Name: miolo_session_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY miolo_session
    ADD CONSTRAINT miolo_session_pkey PRIMARY KEY (idsession);


--
-- Name: miolo_transaction_m_transaction_key; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY miolo_transaction
    ADD CONSTRAINT miolo_transaction_m_transaction_key UNIQUE (m_transaction);


--
-- Name: miolo_transaction_m_transaction_key1; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY miolo_transaction
    ADD CONSTRAINT miolo_transaction_m_transaction_key1 UNIQUE (m_transaction);


--
-- Name: miolo_transaction_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY miolo_transaction
    ADD CONSTRAINT miolo_transaction_pkey PRIMARY KEY (idtransaction);


--
-- Name: miolo_user_login_key; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY miolo_user
    ADD CONSTRAINT miolo_user_login_key UNIQUE (login);


--
-- Name: miolo_user_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY miolo_user
    ADD CONSTRAINT miolo_user_pkey PRIMARY KEY (iduser);


--
-- Name: pk_fincielomovement; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fincielomovement
    ADD CONSTRAINT pk_fincielomovement PRIMARY KEY (tid, countermovementid);


--
-- Name: pk_fincielostatus; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fincielostatus
    ADD CONSTRAINT pk_fincielostatus PRIMARY KEY (cielostatusid);


--
-- Name: pk_fincielotransaction; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY fincielotransaction
    ADD CONSTRAINT pk_fincielotransaction PRIMARY KEY (cielotransactionid);


--
-- Name: pk_miolo_custom_field; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY miolo_custom_field
    ADD CONSTRAINT pk_miolo_custom_field PRIMARY KEY (id);


--
-- Name: pk_miolo_custom_value; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY miolo_custom_value
    ADD CONSTRAINT pk_miolo_custom_value PRIMARY KEY (id);


--
-- Name: pk_prtanexo; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY prtanexo
    ADD CONSTRAINT pk_prtanexo PRIMARY KEY (fileid, mensagemid);


--
-- Name: pk_prtmensagem; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY prtmensagem
    ADD CONSTRAINT pk_prtmensagem PRIMARY KEY (mensagemid);


--
-- Name: pk_prtmensagemdestinatario; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY prtmensagemdestinatario
    ADD CONSTRAINT pk_prtmensagemdestinatario PRIMARY KEY (mensagemdestinatarioid);


--
-- Name: pk_prtmensagemmural; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY prtmensagemmural
    ADD CONSTRAINT pk_prtmensagemmural PRIMARY KEY (mensagemmuralid);


--
-- Name: pk_prtpreferenciaaluno; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY prtpreferenciaaluno
    ADD CONSTRAINT pk_prtpreferenciaaluno PRIMARY KEY (preferenciaalunoid);


--
-- Name: pk_prtpreferenciaprofessor; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY prtpreferenciaprofessor
    ADD CONSTRAINT pk_prtpreferenciaprofessor PRIMARY KEY (preferenciaprofessorid);


--
-- Name: pk_prtpreferenciascoordenador; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY prtpreferenciascoordenador
    ADD CONSTRAINT pk_prtpreferenciascoordenador PRIMARY KEY (preferenciacoordenadorid);


--
-- Name: pk_ptcsubjectavailableto; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ptcsubjectavailableto
    ADD CONSTRAINT pk_ptcsubjectavailableto PRIMARY KEY (subjectid, availableto);


--
-- Name: prccondicaodepagamento_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY prccondicaodepagamento
    ADD CONSTRAINT prccondicaodepagamento_pkey PRIMARY KEY (condicaodepagamentoid);


--
-- Name: prcdiadevencimento_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY prcdiadevencimento
    ADD CONSTRAINT prcdiadevencimento_pkey PRIMARY KEY (diadevencimentoid);


--
-- Name: prcformadepagamentodopreco_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY prcformadepagamentodopreco
    ADD CONSTRAINT prcformadepagamentodopreco_pkey PRIMARY KEY (formadepagamentodoprecoid);


--
-- Name: prcmovimentoprecocurso_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY prcmovimentoprecocurso
    ADD CONSTRAINT prcmovimentoprecocurso_pkey PRIMARY KEY (movimentoprecocursoid);


--
-- Name: prcprecocondicao_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY prcprecocondicao
    ADD CONSTRAINT prcprecocondicao_pkey PRIMARY KEY (precocondicaoid);


--
-- Name: prcprecocurso_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY prcprecocurso
    ADD CONSTRAINT prcprecocurso_pkey PRIMARY KEY (precocursoid);


--
-- Name: prcprecocursogrupo_pkey; Type: CONSTRAINT; Schema: public; Owner: solis; Tablespace: 
--

ALTER TABLE ONLY prcprecocursogrupo
    ADD CONSTRAINT prcprecocursogrupo_pkey PRIMARY KEY (precocursogrupoid);


--
-- Name: prctituloinscricao_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY prctituloinscricao
    ADD CONSTRAINT prctituloinscricao_pkey PRIMARY KEY (tituloinscricaoid);


--
-- Name: ptcdispatch_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ptcdispatch
    ADD CONSTRAINT ptcdispatch_pkey PRIMARY KEY (requestid, dispatchdatetime);


--
-- Name: ptcdocument_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ptcdocument
    ADD CONSTRAINT ptcdocument_pkey PRIMARY KEY (documentid);


--
-- Name: ptcrequest_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ptcrequest
    ADD CONSTRAINT ptcrequest_pkey PRIMARY KEY (requestid);


--
-- Name: ptcrequeststatus_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ptcrequeststatus
    ADD CONSTRAINT ptcrequeststatus_pkey PRIMARY KEY (requeststatusid);


--
-- Name: ptcrequireddocument_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ptcrequireddocument
    ADD CONSTRAINT ptcrequireddocument_pkey PRIMARY KEY (requireddocumentid);


--
-- Name: ptcsubject_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ptcsubject
    ADD CONSTRAINT ptcsubject_pkey PRIMARY KEY (subjectid);


--
-- Name: ptcsubjectsector_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ptcsubjectsector
    ADD CONSTRAINT ptcsubjectsector_pkey PRIMARY KEY (subjectid, sectorid, level);


--
-- Name: rccassuntodecontato_descricao_key; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rccassuntodecontato
    ADD CONSTRAINT rccassuntodecontato_descricao_key UNIQUE (descricao);


--
-- Name: rccassuntodecontato_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rccassuntodecontato
    ADD CONSTRAINT rccassuntodecontato_pkey PRIMARY KEY (assuntodecontatoid);


--
-- Name: rcccontato_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rcccontato
    ADD CONSTRAINT rcccontato_pkey PRIMARY KEY (contatoid);


--
-- Name: rccinteresse_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rccinteresse
    ADD CONSTRAINT rccinteresse_pkey PRIMARY KEY (interesseid);


--
-- Name: rccmensagemouvidoria_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rccmensagemouvidoria
    ADD CONSTRAINT rccmensagemouvidoria_pkey PRIMARY KEY (mensagemouvidoriaid);


--
-- Name: rccorigemdecontato_descricao_key; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rccorigemdecontato
    ADD CONSTRAINT rccorigemdecontato_descricao_key UNIQUE (descricao);


--
-- Name: rccorigemdecontato_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rccorigemdecontato
    ADD CONSTRAINT rccorigemdecontato_pkey PRIMARY KEY (origemdecontatoid);


--
-- Name: rccregistroemail_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rccregistroemail
    ADD CONSTRAINT rccregistroemail_pkey PRIMARY KEY (registrodeemailid);


--
-- Name: rccrespostaouvidoria_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rccrespostaouvidoria
    ADD CONSTRAINT rccrespostaouvidoria_pkey PRIMARY KEY (respostaouvidoriaid);


--
-- Name: rcctipodecontato_descricao_key; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rcctipodecontato
    ADD CONSTRAINT rcctipodecontato_descricao_key UNIQUE (descricao);


--
-- Name: rcctipodecontato_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rcctipodecontato
    ADD CONSTRAINT rcctipodecontato_pkey PRIMARY KEY (tipodecontatoid);


--
-- Name: rccvinculodecontato_descricao_key; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rccvinculodecontato
    ADD CONSTRAINT rccvinculodecontato_descricao_key UNIQUE (descricao);


--
-- Name: rccvinculodecontato_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rccvinculodecontato
    ADD CONSTRAINT rccvinculodecontato_pkey PRIMARY KEY (vinculodecontatoid);


--
-- Name: rshanswer_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rshanswer
    ADD CONSTRAINT rshanswer_pkey PRIMARY KEY (answerid);


--
-- Name: rshanswertype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rshanswertype
    ADD CONSTRAINT rshanswertype_pkey PRIMARY KEY (answertypeid);


--
-- Name: rshform_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rshform
    ADD CONSTRAINT rshform_pkey PRIMARY KEY (formid);


--
-- Name: rshoption_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rshoption
    ADD CONSTRAINT rshoption_pkey PRIMARY KEY (optionid);


--
-- Name: rshquestion_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rshquestion
    ADD CONSTRAINT rshquestion_pkey PRIMARY KEY (questionid);


--
-- Name: rshquestioncategory_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rshquestioncategory
    ADD CONSTRAINT rshquestioncategory_pkey PRIMARY KEY (questioncategoryid);


--
-- Name: rshwho_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rshwho
    ADD CONSTRAINT rshwho_pkey PRIMARY KEY (formid, personid);


--
-- Name: semestercontractperiod_pk; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY acdsemestercontractperiod
    ADD CONSTRAINT semestercontractperiod_pk UNIQUE (contractid, periodid);


--
-- Name: temp_bank_movement_entries_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY temp_bank_movement_entries
    ADD CONSTRAINT temp_bank_movement_entries_pkey PRIMARY KEY (tempentryid);


--
-- Name: temp_bank_movement_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY temp_bank_movement
    ADD CONSTRAINT temp_bank_movement_pkey PRIMARY KEY (tempbankmovementid);


--
-- Name: uniq_customfield_name; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY miolo_custom_field
    ADD CONSTRAINT uniq_customfield_name UNIQUE (name);


--
-- Name: workflowhistoryid_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcworkflowhistory
    ADD CONSTRAINT workflowhistoryid_pkey PRIMARY KEY (workflowhistoryid);


--
-- Name: workflowstatusid_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY gtcworkflowstatus
    ADD CONSTRAINT workflowstatusid_pkey PRIMARY KEY (workflowstatusid);


SET search_path = res, pg_catalog;

--
-- Name: atividadeextra_pkey; Type: CONSTRAINT; Schema: res; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY atividadeextra
    ADD CONSTRAINT atividadeextra_pkey PRIMARY KEY (atividadeextraid);


--
-- Name: cargahorariacomplementar_pkey; Type: CONSTRAINT; Schema: res; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY cargahorariacomplementar
    ADD CONSTRAINT cargahorariacomplementar_pkey PRIMARY KEY (cargahorariacomplementarid);


--
-- Name: coorientador_pkey; Type: CONSTRAINT; Schema: res; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY coorientador
    ADD CONSTRAINT coorientador_pkey PRIMARY KEY (personid, trabalhodeconclusaoid);


--
-- Name: encontro_pkey; Type: CONSTRAINT; Schema: res; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY encontro
    ADD CONSTRAINT encontro_pkey PRIMARY KEY (encontroid);


--
-- Name: enfase_pkey; Type: CONSTRAINT; Schema: res; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY enfase
    ADD CONSTRAINT enfase_pkey PRIMARY KEY (enfaseid);


--
-- Name: enfasedaunidadetematica_pkey; Type: CONSTRAINT; Schema: res; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY enfasedaunidadetematica
    ADD CONSTRAINT enfasedaunidadetematica_pkey PRIMARY KEY (unidadetematicaid, enfaseid);


--
-- Name: frequencia_pkey; Type: CONSTRAINT; Schema: res; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY frequencia
    ADD CONSTRAINT frequencia_pkey PRIMARY KEY (encontroid, residenteid);


--
-- Name: membrodabanca_pkey; Type: CONSTRAINT; Schema: res; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY membrodabanca
    ADD CONSTRAINT membrodabanca_pkey PRIMARY KEY (personid, trabalhodeconclusaoid);


--
-- Name: nucleodaunidadetematica_pkey; Type: CONSTRAINT; Schema: res; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY nucleodaunidadetematica
    ADD CONSTRAINT nucleodaunidadetematica_pkey PRIMARY KEY (unidadetematicaid, nucleoprofissionalid);


--
-- Name: nucleoprofissional_pkey; Type: CONSTRAINT; Schema: res; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY nucleoprofissional
    ADD CONSTRAINT nucleoprofissional_pkey PRIMARY KEY (nucleoprofissionalid);


--
-- Name: ocorrenciadecontrato_pkey; Type: CONSTRAINT; Schema: res; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ocorrenciadecontrato
    ADD CONSTRAINT ocorrenciadecontrato_pkey PRIMARY KEY (ocorrenciadecontratoid);


--
-- Name: ocorrenciadeoferta_pkey; Type: CONSTRAINT; Schema: res; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ocorrenciadeoferta
    ADD CONSTRAINT ocorrenciadeoferta_pkey PRIMARY KEY (ocorrenciadeofertaid);


--
-- Name: ofertadeunidadetematica_pkey; Type: CONSTRAINT; Schema: res; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ofertadeunidadetematica
    ADD CONSTRAINT ofertadeunidadetematica_pkey PRIMARY KEY (ofertadeunidadetematicaid);


--
-- Name: ofertadoresidente_pkey; Type: CONSTRAINT; Schema: res; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY ofertadoresidente
    ADD CONSTRAINT ofertadoresidente_pkey PRIMARY KEY (ofertadoresidenteid);


--
-- Name: participacaoematividadeextra_pkey; Type: CONSTRAINT; Schema: res; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY participacaoematividadeextra
    ADD CONSTRAINT participacaoematividadeextra_pkey PRIMARY KEY (atividadeextraid, residenteid);


--
-- Name: preceptoria_pkey; Type: CONSTRAINT; Schema: res; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY preceptoria
    ADD CONSTRAINT preceptoria_pkey PRIMARY KEY (preceptorid);


--
-- Name: residente_pkey; Type: CONSTRAINT; Schema: res; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY residente
    ADD CONSTRAINT residente_pkey PRIMARY KEY (residenteid);


--
-- Name: statusdaocorrenciadecontrato_pkey; Type: CONSTRAINT; Schema: res; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY statusdaocorrenciadecontrato
    ADD CONSTRAINT statusdaocorrenciadecontrato_pkey PRIMARY KEY (statusdaocorrenciadecontratoid);


--
-- Name: tema_pkey; Type: CONSTRAINT; Schema: res; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tema
    ADD CONSTRAINT tema_pkey PRIMARY KEY (temaid);


--
-- Name: tipodecargahorariacomplementar_pkey; Type: CONSTRAINT; Schema: res; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tipodecargahorariacomplementar
    ADD CONSTRAINT tipodecargahorariacomplementar_pkey PRIMARY KEY (tipodecargahorariacomplementarid);


--
-- Name: trabalhodeconclusao_pkey; Type: CONSTRAINT; Schema: res; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY trabalhodeconclusao
    ADD CONSTRAINT trabalhodeconclusao_pkey PRIMARY KEY (trabalhodeconclusaoid);


--
-- Name: unidadetematica_pkey; Type: CONSTRAINT; Schema: res; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY unidadetematica
    ADD CONSTRAINT unidadetematica_pkey PRIMARY KEY (unidadetematicaid);


SET search_path = spr, pg_catalog;

--
-- Name: attachment_pkey; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY attachment
    ADD CONSTRAINT attachment_pkey PRIMARY KEY (fileid, evaluationoptionid, subscriptionid);


--
-- Name: evaluation_pkey; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY evaluation
    ADD CONSTRAINT evaluation_pkey PRIMARY KEY (evaluationid);


--
-- Name: evaluationoption_pkey; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY evaluationoption
    ADD CONSTRAINT evaluationoption_pkey PRIMARY KEY (evaluationoptionid);


--
-- Name: evaluationpoints_pkey; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY evaluationpoints
    ADD CONSTRAINT evaluationpoints_pkey PRIMARY KEY (evaluationid, subscriptionid);


--
-- Name: examiningboard_pkey; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY examiningboard
    ADD CONSTRAINT examiningboard_pkey PRIMARY KEY (examiningboardid);


--
-- Name: examiningboardmember_pkey; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY examiningboardmember
    ADD CONSTRAINT examiningboardmember_pkey PRIMARY KEY (personid, examiningboardid);


--
-- Name: financeinformation_pkey; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY financeinformation
    ADD CONSTRAINT financeinformation_pkey PRIMARY KEY (financeinformationid);


--
-- Name: idx_selectiveprocessid_personid_unique; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY subscription
    ADD CONSTRAINT idx_selectiveprocessid_personid_unique UNIQUE (selectiveprocessid, personid);


--
-- Name: option_pkey; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY option
    ADD CONSTRAINT option_pkey PRIMARY KEY (optionid);


--
-- Name: optioncourse_pkey; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY optioncourse
    ADD CONSTRAINT optioncourse_pkey PRIMARY KEY (optionid, courseid, courseversion, unitid, turnid);


--
-- Name: optionnucleoenfase_pkey; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY optionnucleoenfase
    ADD CONSTRAINT optionnucleoenfase_pkey PRIMARY KEY (enfaseid, optionid, nucleoprofissionalid);


--
-- Name: selectiveprocess_pkey; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY selectiveprocess
    ADD CONSTRAINT selectiveprocess_pkey PRIMARY KEY (selectiveprocessid);


--
-- Name: step_pkey; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY step
    ADD CONSTRAINT step_pkey PRIMARY KEY (stepid);


--
-- Name: stepdocument_pkey; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY stepdocument
    ADD CONSTRAINT stepdocument_pkey PRIMARY KEY (stepdocumentid);


--
-- Name: stepplace_pkey; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY stepplace
    ADD CONSTRAINT stepplace_pkey PRIMARY KEY (stepplaceid);


--
-- Name: steptiebreak_pkey; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY steptiebreak
    ADD CONSTRAINT steptiebreak_pkey PRIMARY KEY (steptiebreakid);


--
-- Name: subscription_pkey; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY subscription
    ADD CONSTRAINT subscription_pkey PRIMARY KEY (subscriptionid);


--
-- Name: subscriptiondocument_pkey; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY subscriptiondocument
    ADD CONSTRAINT subscriptiondocument_pkey PRIMARY KEY (subscriptionid, stepdocumentid);


--
-- Name: subscriptionevaluationoption_pkey; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY subscriptionevaluationoption
    ADD CONSTRAINT subscriptionevaluationoption_pkey PRIMARY KEY (evaluationoptionid, subscriptionid);


--
-- Name: subscriptionoption_pkey; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY subscriptionoption
    ADD CONSTRAINT subscriptionoption_pkey PRIMARY KEY (optionid, subscriptionid);


--
-- Name: subscriptionstatus_pkey; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY subscriptionstatus
    ADD CONSTRAINT subscriptionstatus_pkey PRIMARY KEY (subscriptionstatusid);


--
-- Name: subscriptionstepinfo_pkey; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY subscriptionstepinfo
    ADD CONSTRAINT subscriptionstepinfo_pkey PRIMARY KEY (subscriptionid, stepid);


--
-- Name: subscriptionstepplace_pkey; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY subscriptionstepplace
    ADD CONSTRAINT subscriptionstepplace_pkey PRIMARY KEY (subscriptionid, stepplaceid);


--
-- Name: subscriptionsubstitutescall_pkey; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY subscriptionsubstitutescall
    ADD CONSTRAINT subscriptionsubstitutescall_pkey PRIMARY KEY (subscriptionsubstitutescallid);


--
-- Name: substitutescall_pkey; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY substitutescall
    ADD CONSTRAINT substitutescall_pkey PRIMARY KEY (substitutescallid);


--
-- Name: tiebreak_pkey; Type: CONSTRAINT; Schema: spr; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY tiebreak
    ADD CONSTRAINT tiebreak_pkey PRIMARY KEY (tiebreakid);


SET search_path = tra, pg_catalog;

--
-- Name: addendum_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY addendum
    ADD CONSTRAINT addendum_pkey PRIMARY KEY (addendumid);


--
-- Name: addendumcourse_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY addendumcourse
    ADD CONSTRAINT addendumcourse_pkey PRIMARY KEY (addendumcourseid);


--
-- Name: addendumcourseadmin_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY addendumcourseadmin
    ADD CONSTRAINT addendumcourseadmin_pkey PRIMARY KEY (addendumcourseadminid);


--
-- Name: addendumcoursearea_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY addendumcoursearea
    ADD CONSTRAINT addendumcoursearea_pkey PRIMARY KEY (addendumcourseareaid);


--
-- Name: addendumfile_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY addendumfile
    ADD CONSTRAINT addendumfile_pkey PRIMARY KEY (addendumfileid);


--
-- Name: agreement_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY agreement
    ADD CONSTRAINT agreement_pkey PRIMARY KEY (agreementid);


--
-- Name: agreementfile_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY agreementfile
    ADD CONSTRAINT agreementfile_pkey PRIMARY KEY (agreementfileid);


--
-- Name: area_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY area
    ADD CONSTRAINT area_pkey PRIMARY KEY (areaid);


--
-- Name: concept_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY concept
    ADD CONSTRAINT concept_pkey PRIMARY KEY (conceptid);


--
-- Name: counterpart_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY counterpart
    ADD CONSTRAINT counterpart_pkey PRIMARY KEY (counterpartid);


--
-- Name: counterparttype_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY counterparttype
    ADD CONSTRAINT counterparttype_pkey PRIMARY KEY (counterparttypeid);


--
-- Name: counterpartuse_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY counterpartuse
    ADD CONSTRAINT counterpartuse_pkey PRIMARY KEY (counterpartuseid);


--
-- Name: course_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY course
    ADD CONSTRAINT course_pkey PRIMARY KEY (courseid);


--
-- Name: coursearea_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY coursearea
    ADD CONSTRAINT coursearea_pkey PRIMARY KEY (courseareaid);


--
-- Name: degreeequivalence_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY degreeequivalence
    ADD CONSTRAINT degreeequivalence_pkey PRIMARY KEY (degreeequivalenceid);


--
-- Name: delivereddocument_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY delivereddocument
    ADD CONSTRAINT delivereddocument_pkey PRIMARY KEY (delivereddocumentid);


--
-- Name: delivereddocumentfile_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY delivereddocumentfile
    ADD CONSTRAINT delivereddocumentfile_pkey PRIMARY KEY (delivereddocumentfileid);


--
-- Name: document_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY document
    ADD CONSTRAINT document_pkey PRIMARY KEY (documentid);


--
-- Name: evaluationgroup_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY evaluationgroup
    ADD CONSTRAINT evaluationgroup_pkey PRIMARY KEY (evaluationgroupid);


--
-- Name: evaluationitem_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY evaluationitem
    ADD CONSTRAINT evaluationitem_pkey PRIMARY KEY (evaluationitemid);


--
-- Name: evaluationtype_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY evaluationtype
    ADD CONSTRAINT evaluationtype_pkey PRIMARY KEY (evaluationtypeid);


--
-- Name: preceptorsubstitution_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY preceptorsubstitution
    ADD CONSTRAINT preceptorsubstitution_pkey PRIMARY KEY (preceptorsubstitutionid);


--
-- Name: request_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY request
    ADD CONSTRAINT request_pkey PRIMARY KEY (requestid);


--
-- Name: requestadjustment_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY requestadjustment
    ADD CONSTRAINT requestadjustment_pkey PRIMARY KEY (requestadjustmentid);


--
-- Name: subscription_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY subscription
    ADD CONSTRAINT subscription_pkey PRIMARY KEY (subscriptionid);


--
-- Name: subscriptionteam_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY subscriptionteam
    ADD CONSTRAINT subscriptionteam_pkey PRIMARY KEY (subscriptionteamid);


--
-- Name: subscriptionteamevaluation_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY subscriptionteamevaluation
    ADD CONSTRAINT subscriptionteamevaluation_pkey PRIMARY KEY (subscriptionteamevaluationid);


--
-- Name: team_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY team
    ADD CONSTRAINT team_pkey PRIMARY KEY (teamid);


--
-- Name: teamorganizer_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY teamorganizer
    ADD CONSTRAINT teamorganizer_pkey PRIMARY KEY (teamorganizerid);


--
-- Name: trainingevaluationanswer_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY trainingevaluationanswer
    ADD CONSTRAINT trainingevaluationanswer_pkey PRIMARY KEY (trainingevaluationanswerid);


--
-- Name: trainingtype_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY trainingtype
    ADD CONSTRAINT trainingtype_pkey PRIMARY KEY (trainingtypeid);


--
-- Name: trainingtypearea_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY trainingtypearea
    ADD CONSTRAINT trainingtypearea_pkey PRIMARY KEY (trainingtypeareaid);


--
-- Name: unit_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY unit
    ADD CONSTRAINT unit_pkey PRIMARY KEY (unitid);


--
-- Name: unitareacourse_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY unitarea
    ADD CONSTRAINT unitareacourse_pkey PRIMARY KEY (unitareaid);


--
-- Name: unitlegalperson_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY unitlegalperson
    ADD CONSTRAINT unitlegalperson_pkey PRIMARY KEY (unitid, personid);


--
-- Name: unituser_pkey; Type: CONSTRAINT; Schema: tra; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY unituser
    ADD CONSTRAINT unituser_pkey PRIMARY KEY (unitid, iduser);


SET search_path = fin, pg_catalog;

--
-- Name: idx_finbankmovement_fileid; Type: INDEX; Schema: fin; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finbankmovement_fileid ON bankmovement USING btree (fileid);


--
-- Name: idx_finbankmovement_invoiceid; Type: INDEX; Schema: fin; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finbankmovement_invoiceid ON bankmovement USING btree (invoiceid);


SET search_path = public, pg_catalog;

--
-- Name: acdexploitation_acdenroll_idx; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX acdexploitation_acdenroll_idx ON acdexploitation USING btree (exploitationenrollid);


--
-- Name: acpcontroledefrequencia_controledefrequenciaid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX acpcontroledefrequencia_controledefrequenciaid ON acpcontroledefrequencia USING btree (controledefrequenciaid);


--
-- Name: action_timestamp_utc_idx; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX action_timestamp_utc_idx ON miolo_audit USING btree (action_timestamp_utc);


--
-- Name: audit_id_detail_idx; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX audit_id_detail_idx ON miolo_audit_detail USING btree (audit_id);


--
-- Name: audit_id_idx; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX audit_id_idx ON miolo_audit USING btree (audit_id);


--
-- Name: ava_atributos_chave; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX ava_atributos_chave ON ava_atributos USING btree (chave);


--
-- Name: ava_atributos_ref_resposta; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX ava_atributos_ref_resposta ON ava_atributos USING btree (ref_resposta);


--
-- Name: ava_atributos_ref_respostas_chave; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX ava_atributos_ref_respostas_chave ON ava_atributos USING btree (ref_resposta, ((chave)::text));


--
-- Name: ava_atributos_valor; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX ava_atributos_valor ON ava_atributos USING btree (valor);


--
-- Name: ava_avaliacao_dt_fim; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX ava_avaliacao_dt_fim ON ava_avaliacao USING btree (dt_fim);


--
-- Name: ava_avaliacao_dt_inicio; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX ava_avaliacao_dt_inicio ON ava_avaliacao USING btree (dt_inicio);


--
-- Name: ava_avaliacao_dt_inicio_dt_fim; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX ava_avaliacao_dt_inicio_dt_fim ON ava_avaliacao USING btree (dt_inicio, dt_fim);


--
-- Name: ava_bloco_questoes_ordem; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX ava_bloco_questoes_ordem ON ava_bloco_questoes USING btree (ordem);


--
-- Name: ava_bloco_questoes_ref_bloco; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX ava_bloco_questoes_ref_bloco ON ava_bloco_questoes USING btree (ref_bloco);


--
-- Name: ava_bloco_ref_granularidade; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX ava_bloco_ref_granularidade ON ava_bloco USING btree (ref_granularidade);


--
-- Name: ava_form_log_ref_formulario_tipo_acao_tentativa; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX ava_form_log_ref_formulario_tipo_acao_tentativa ON ava_form_log USING btree (ref_formulario, tipo_acao, tentativa);


--
-- Name: ava_form_log_tipo_acao_ref_formulario; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX ava_form_log_tipo_acao_ref_formulario ON ava_form_log USING btree (tipo_acao, ref_formulario);


--
-- Name: ava_respostas_questao; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX ava_respostas_questao ON ava_respostas USING btree (questao);


--
-- Name: ava_respostas_ref_avaliador_questao; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX ava_respostas_ref_avaliador_questao ON ava_respostas USING btree (ref_avaliador, questao);


--
-- Name: ava_respostas_ref_bloco_questoes; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX ava_respostas_ref_bloco_questoes ON ava_respostas USING btree (ref_bloco_questoes);


--
-- Name: ava_totalizadores_atributos_ref_totalizador_chave; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX ava_totalizadores_atributos_ref_totalizador_chave ON ava_totalizadores_atributos USING btree (ref_totalizador, chave);


--
-- Name: basphysicalperson_namesearch; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX basphysicalperson_namesearch ON basphysicalperson USING btree (namesearch);


--
-- Name: idx_acccoursebalance_balancedate; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acccoursebalance_balancedate ON acccoursebalance USING btree (balancedate);


--
-- Name: idx_accpersonbalance_unique; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX idx_accpersonbalance_unique ON accpersonbalance USING btree (accountschemeid, personid, source, balancedate, courseid, unitid, courseversion);


--
-- Name: idx_acdacademiccalendar_unitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdacademiccalendar_unitid ON acdacademiccalendar USING btree (unitid);


--
-- Name: idx_acdcertified_certifiedtypeid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdcertified_certifiedtypeid ON acdcertified USING btree (certifiedtypeid);


--
-- Name: idx_acdclass_unitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdclass_unitid ON acdclass USING btree (unitid);


--
-- Name: idx_acdclasspupil_begindate; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdclasspupil_begindate ON acdclasspupil USING btree (begindate);


--
-- Name: idx_acdclasspupil_contractid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdclasspupil_contractid ON acdclasspupil USING btree (contractid);


--
-- Name: idx_acdclasspupil_enddate; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdclasspupil_enddate ON acdclasspupil USING btree (enddate);


--
-- Name: idx_acdclasspupil_unitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdclasspupil_unitid ON acdclasspupil USING btree (unitid);


--
-- Name: idx_acdcondition_conditioncurriculumid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdcondition_conditioncurriculumid ON acdcondition USING btree (conditioncurriculumid);


--
-- Name: idx_acdcondition_curriculumid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdcondition_curriculumid ON acdcondition USING btree (curriculumid);


--
-- Name: idx_acdcondition_curriculumid_type; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdcondition_curriculumid_type ON acdcondition USING btree (curriculumid, type);


--
-- Name: idx_acdcondition_type; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdcondition_type ON acdcondition USING btree (type);


--
-- Name: idx_acdcondition_unitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdcondition_unitid ON acdcondition USING btree (unitid);


--
-- Name: idx_acdcontract_contractid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdcontract_contractid ON acdcontract USING btree (contractid);


--
-- Name: idx_acdcontract_personid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdcontract_personid ON acdcontract USING btree (personid);


--
-- Name: idx_acdcontractexaminingboard_unitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdcontractexaminingboard_unitid ON acdcontractexaminingboard USING btree (unitid);


--
-- Name: idx_acdcourseoccurrence_idcursoinep; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdcourseoccurrence_idcursoinep ON acdcourseoccurrence USING btree (idcursoinep);


--
-- Name: idx_acdcourseparent_unique; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX idx_acdcourseparent_unique ON acdcourseparent USING btree (courseid, courseversion, turnid, unitid, parentcourseid, parentcourseversion, parentturnid, parentunitid);


--
-- Name: idx_acdcourseversiontype_unitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdcourseversiontype_unitid ON acdcourseversiontype USING btree (unitid);


--
-- Name: idx_acdcurricularcomponentgroup_unitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdcurricularcomponentgroup_unitid ON acdcurricularcomponentgroup USING btree (unitid);


--
-- Name: idx_acdcurricularcomponentunblock_1; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdcurricularcomponentunblock_1 ON acdcurricularcomponentunblock USING btree (curriculumid, curricularcomponentid, curricularcomponentversion);


--
-- Name: idx_acdcurricularcomponentunblock_flminimumcredits; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdcurricularcomponentunblock_flminimumcredits ON acdcurricularcomponentunblock USING btree (flminimumcredits);


--
-- Name: idx_acdcurricularcomponentunblock_flminimumturn; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdcurricularcomponentunblock_flminimumturn ON acdcurricularcomponentunblock USING btree (flminimumturn);


--
-- Name: idx_acdcurricularcomponentunblock_isconditionbreak; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdcurricularcomponentunblock_isconditionbreak ON acdcurricularcomponentunblock USING btree (isconditionbreak);


--
-- Name: idx_acdcurricularcomponentunblock_isscheduleshock; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdcurricularcomponentunblock_isscheduleshock ON acdcurricularcomponentunblock USING btree (isscheduleshock);


--
-- Name: idx_acdcurricularcomponentunblock_issubstituted; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdcurricularcomponentunblock_issubstituted ON acdcurricularcomponentunblock USING btree (issubstituted);


--
-- Name: idx_acdcurriculum_course; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdcurriculum_course ON acdcurriculum USING btree (courseid, courseversion);


--
-- Name: idx_acdcurriculum_curricularcomponentgroupdocumentendcourseid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdcurriculum_curricularcomponentgroupdocumentendcourseid ON acdcurriculum USING btree (curricularcomponentgroupdocumentendcourseid);


--
-- Name: idx_acdcurriculum_curricularcomponentgroupelectiveid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdcurriculum_curricularcomponentgroupelectiveid ON acdcurriculum USING btree (curricularcomponentgroupelectiveid);


--
-- Name: idx_acdcurriculum_curricularcomponentid_curricularcomponentvers; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdcurriculum_curricularcomponentid_curricularcomponentvers ON acdcurriculum USING btree (curricularcomponentid, curricularcomponentversion);


--
-- Name: idx_acdcurriculum_unique; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX idx_acdcurriculum_unique ON acdcurriculum USING btree (courseid, courseversion, turnid, unitid, curricularcomponentid, curricularcomponentversion);


--
-- Name: idx_acdcurriculumconcurrence_unitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdcurriculumconcurrence_unitid ON acdcurriculumconcurrence USING btree (unitid);


--
-- Name: idx_acdcurriculumlink_unitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdcurriculumlink_unitid ON acdcurriculumlink USING btree (unitid);


--
-- Name: idx_acddegree_degreenumber; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acddegree_degreenumber ON acddegree USING btree (degreenumber);


--
-- Name: idx_acddegree_learningperiodid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acddegree_learningperiodid ON acddegree USING btree (learningperiodid);


--
-- Name: idx_acddegree_unique; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX idx_acddegree_unique ON acddegree USING btree (learningperiodid, parentdegreeid, degreenumber);


--
-- Name: idx_acddegreeenroll_enrollid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acddegreeenroll_enrollid ON acddegreeenroll USING btree (enrollid);


--
-- Name: idx_acddegreeenroll_unique; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX idx_acddegreeenroll_unique ON acddegreeenroll USING btree (degreeid, enrollid, recorddate);


--
-- Name: idx_acdenroll_contractid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdenroll_contractid ON acdenroll USING btree (contractid);


--
-- Name: idx_acdenroll_contractid_curriculumid_statusid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdenroll_contractid_curriculumid_statusid ON acdenroll USING btree (contractid, curriculumid, statusid);


--
-- Name: idx_acdenroll_curriculumid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdenroll_curriculumid ON acdenroll USING btree (curriculumid);


--
-- Name: idx_acdenroll_dateenroll; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdenroll_dateenroll ON acdenroll USING btree (dateenroll);


--
-- Name: idx_acdenroll_groupid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdenroll_groupid ON acdenroll USING btree (groupid);


--
-- Name: idx_acdenroll_statusid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdenroll_statusid ON acdenroll USING btree (statusid);


--
-- Name: idx_acdenroll_unitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdenroll_unitid ON acdenroll USING btree (unitid);


--
-- Name: idx_acdevaluation_unitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdevaluation_unitid ON acdevaluation USING btree (unitid);


--
-- Name: idx_acdevaluationenroll_unique; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX idx_acdevaluationenroll_unique ON acdevaluationenroll USING btree (evaluationid, enrollid, recorddate);


--
-- Name: idx_acdevent_unitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdevent_unitid ON acdevent USING btree (unitid);


--
-- Name: idx_acdeventparticipation_unitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdeventparticipation_unitid ON acdeventparticipation USING btree (unitid);


--
-- Name: idx_acdexploitation_unitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdexploitation_unitid ON acdexploitation USING btree (unitid);


--
-- Name: idx_acdfrequenceenroll_enrollid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdfrequenceenroll_enrollid ON acdfrequenceenroll USING btree (enrollid);


--
-- Name: idx_acdfrequenceenroll_scheduleid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdfrequenceenroll_scheduleid ON acdfrequenceenroll USING btree (scheduleid);


--
-- Name: idx_acdfrequenceenroll_timeid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdfrequenceenroll_timeid ON acdfrequenceenroll USING btree (timeid);


--
-- Name: idx_acdgroup_curriculumid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdgroup_curriculumid ON acdgroup USING btree (curriculumid);


--
-- Name: idx_acdgroup_learningperiodid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdgroup_learningperiodid ON acdgroup USING btree (learningperiodid);


--
-- Name: idx_acdgroup_unitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdgroup_unitid ON acdgroup USING btree (unitid);


--
-- Name: idx_acdlearningperiod_courseid_unitid_sagu1periodid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdlearningperiod_courseid_unitid_sagu1periodid ON acdlearningperiod USING btree (courseid, unitid, sagu1periodid);


--
-- Name: idx_acdlearningperiod_periodid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdlearningperiod_periodid ON acdlearningperiod USING btree (periodid);


--
-- Name: idx_acdmessagecontractrenewal_unitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdmessagecontractrenewal_unitid ON acdmessagecontractrenewal USING btree (unitid);


--
-- Name: idx_acdmovementcontract_contractid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdmovementcontract_contractid ON acdmovementcontract USING btree (contractid);


--
-- Name: idx_acdmovementcontract_statecontractid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdmovementcontract_statecontractid ON acdmovementcontract USING btree (statecontractid);


--
-- Name: idx_acdmovementcontract_statetime; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdmovementcontract_statetime ON acdmovementcontract USING btree (statetime);


--
-- Name: idx_acdperiodenrolldate_unitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdperiodenrolldate_unitid ON acdperiodenrolldate USING btree (unitid);


--
-- Name: idx_acdschedule_groupid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdschedule_groupid ON acdschedule USING btree (groupid);


--
-- Name: idx_acdscheduleprofessor_professorid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdscheduleprofessor_professorid ON acdscheduleprofessor USING btree (professorid);


--
-- Name: idx_acdscheduleprofessor_scheduleid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdscheduleprofessor_scheduleid ON acdscheduleprofessor USING btree (scheduleid);


--
-- Name: idx_acdscheduleprofessorcontent_scheduleprofessorid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdscheduleprofessorcontent_scheduleprofessorid ON acdscheduleprofessorcontent USING btree (scheduleprofessorid);


--
-- Name: idx_acdscheduleprofessorcontent_timeid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdscheduleprofessorcontent_timeid ON acdscheduleprofessorcontent USING btree (timeid);


--
-- Name: idx_acdsubclass_unitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdsubclass_unitid ON acdsubclass USING btree (unitid);


--
-- Name: idx_acdtestendcoursetype_unitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdtestendcoursetype_unitid ON acdtestendcoursetype USING btree (unitid);


--
-- Name: idx_acdtimesheet_unitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdtimesheet_unitid ON acdtimesheet USING btree (unitid);


--
-- Name: idx_acdtrainingemphasis_unitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_acdtrainingemphasis_unitid ON acdtrainingemphasis USING btree (unitid);


--
-- Name: idx_ava_bloco_questoes_ref_questao_text; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_ava_bloco_questoes_ref_questao_text ON ava_bloco_questoes USING btree (((ref_questao)::character varying));


--
-- Name: idx_ava_formulario_ref_avaliacao; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_ava_formulario_ref_avaliacao ON ava_formulario USING btree (ref_avaliacao);


--
-- Name: idx_ava_opcoes_questoes_questao; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_ava_opcoes_questoes_questao ON ava_opcoes_questoes USING btree (questao);


--
-- Name: idx_ava_opcoes_questoes_questao_valor; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_ava_opcoes_questoes_questao_valor ON ava_opcoes_questoes USING btree (((questao)::text), ((valor)::text));


--
-- Name: idx_ava_respostas_ref_avaliador; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_ava_respostas_ref_avaliador ON ava_respostas USING btree (ref_avaliador);


--
-- Name: idx_ava_respostas_valor; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_ava_respostas_valor ON ava_respostas USING btree (valor);


--
-- Name: idx_basaccess_count; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_basaccess_count ON basaccess USING btree (login, moduleaccess, label, image, handler);


--
-- Name: idx_basaccess_datetime; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_basaccess_datetime ON basaccess USING btree (datetime);


--
-- Name: idx_basaccess_login; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_basaccess_login ON basaccess USING btree (upper(login));


--
-- Name: idx_basaccess_login_isbookmark; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_basaccess_login_isbookmark ON basaccess USING btree (login, isbookmark);


--
-- Name: idx_basdocument_documenttypeid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_basdocument_documenttypeid ON basdocument USING btree (documenttypeid);


--
-- Name: idx_basdocument_personid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_basdocument_personid ON basdocument USING btree (personid);


--
-- Name: idx_basemployee_personid_externalid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX idx_basemployee_personid_externalid ON basemployee USING btree (personid, externalid);


--
-- Name: idx_baslocation_cityid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_baslocation_cityid ON baslocation USING btree (cityid);


--
-- Name: idx_baslocation_zipcode; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_baslocation_zipcode ON baslocation USING btree (zipcode);


--
-- Name: idx_basperson_name; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_basperson_name ON basperson USING btree (unaccent((name)::text));


--
-- Name: idx_basperson_personid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_basperson_personid ON basperson USING btree (personid);


--
-- Name: idx_baspersonlink_linkid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_baspersonlink_linkid ON baspersonlink USING btree (linkid);


--
-- Name: idx_baspersonlink_personid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_baspersonlink_personid ON baspersonlink USING btree (personid);


--
-- Name: idx_basphysicalperson_miolousername; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_basphysicalperson_miolousername ON basphysicalperson USING btree (miolousername);


--
-- Name: idx_basphysicalperson_name; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_basphysicalperson_name ON basphysicalperson USING btree (name);


--
-- Name: idx_basphysicalperson_name_datebirth; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_basphysicalperson_name_datebirth ON basphysicalperson USING btree (name, datebirth);


--
-- Name: idx_basphysicalpersonemployee_name; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_basphysicalpersonemployee_name ON basphysicalpersonemployee USING btree (unaccent((name)::text));


--
-- Name: idx_basphysicalpersonkinship_relativeperson; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_basphysicalpersonkinship_relativeperson ON basphysicalpersonkinship USING btree (relativepersonid);


--
-- Name: idx_basphysicalpersonprofessor_name; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_basphysicalpersonprofessor_name ON basphysicalpersonprofessor USING btree (unaccent((name)::text));


--
-- Name: idx_basphysicalpersonstudent_name; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_basphysicalpersonstudent_name ON basphysicalpersonstudent USING btree (unaccent((name)::text));


--
-- Name: idx_basreportparameter_unique; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX idx_basreportparameter_unique ON basreportparameter USING btree (reportid, parameternumber);


--
-- Name: idx_basstamp_personid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_basstamp_personid ON basstamp USING btree (personid);


--
-- Name: idx_finbankinvoiceinfo_ournumber; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finbankinvoiceinfo_ournumber ON finbankinvoiceinfo USING btree (ltrim((ournumber)::text, '0'::text));


--
-- Name: idx_finbankmovementnotfound_datetime; Type: INDEX; Schema: public; Owner: solis; Tablespace: 
--

CREATE INDEX idx_finbankmovementnotfound_datetime ON finbankmovementnotfound USING btree (datetime);


--
-- Name: idx_finbankmovementnotfound_id; Type: INDEX; Schema: public; Owner: solis; Tablespace: 
--

CREATE INDEX idx_finbankmovementnotfound_id ON finbankmovementnotfound USING btree (bankmovementnotfoundid);


--
-- Name: idx_finbankmovementnotfound_ournumber; Type: INDEX; Schema: public; Owner: solis; Tablespace: 
--

CREATE INDEX idx_finbankmovementnotfound_ournumber ON finbankmovementnotfound USING btree (ournumber);


--
-- Name: idx_finentry_contractid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finentry_contractid ON finentry USING btree (contractid);


--
-- Name: idx_finentry_entrydate; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finentry_entrydate ON finentry USING btree (entrydate);


--
-- Name: idx_finentry_invoiceid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finentry_invoiceid ON finentry USING btree (invoiceid);


--
-- Name: idx_finentry_invoiceid_contractid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finentry_invoiceid_contractid ON finentry USING btree (invoiceid, contractid);


--
-- Name: idx_finentry_invoiceid_learningperiodid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finentry_invoiceid_learningperiodid ON finentry USING btree (invoiceid, learningperiodid);


--
-- Name: idx_finentry_learningperiodid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finentry_learningperiodid ON finentry USING btree (learningperiodid);


--
-- Name: idx_finentry_operationid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finentry_operationid ON finentry USING btree (operationid);


--
-- Name: idx_finincentive_cancellationdate; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finincentive_cancellationdate ON finincentive USING btree (cancellationdate);


--
-- Name: idx_finincentive_contractid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finincentive_contractid ON finincentive USING btree (contractid);


--
-- Name: idx_finincentive_enddate; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finincentive_enddate ON finincentive USING btree (enddate);


--
-- Name: idx_finincentive_startdate; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finincentive_startdate ON finincentive USING btree (startdate);


--
-- Name: idx_finincomeforecast_contractid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finincomeforecast_contractid ON finincomeforecast USING btree (contractid);


--
-- Name: idx_finincomeforecast_maturitydate; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finincomeforecast_maturitydate ON finincomeforecast USING btree (maturitydate);


--
-- Name: idx_finincomeforecast_recorddate; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finincomeforecast_recorddate ON finincomeforecast USING btree (recorddate);


--
-- Name: idx_fininvoice_accountschemeid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_fininvoice_accountschemeid ON fininvoice USING btree (accountschemeid);


--
-- Name: idx_fininvoice_bankinvoiceid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_fininvoice_bankinvoiceid ON fininvoice USING btree (bankinvoiceid);


--
-- Name: idx_fininvoice_invoiceid_maturitydate; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_fininvoice_invoiceid_maturitydate ON fininvoice USING btree (invoiceid, maturitydate);


--
-- Name: idx_fininvoice_maturitydate; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_fininvoice_maturitydate ON fininvoice USING btree (maturitydate);


--
-- Name: idx_fininvoice_personid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_fininvoice_personid ON fininvoice USING btree (personid);


--
-- Name: idx_fininvoice_sagu1invoiceid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_fininvoice_sagu1invoiceid ON fininvoice USING btree (sagu1invoiceid);


--
-- Name: idx_finoperation_operationgroupid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finoperation_operationgroupid ON finoperation USING btree (operationgroupid);


--
-- Name: idx_finreceivableinvoice_accountschemeid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finreceivableinvoice_accountschemeid ON finreceivableinvoice USING btree (accountschemeid);


--
-- Name: idx_finreceivableinvoice_bankinvoiceid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finreceivableinvoice_bankinvoiceid ON finreceivableinvoice USING btree (bankinvoiceid);


--
-- Name: idx_finreceivableinvoice_emissiondate; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finreceivableinvoice_emissiondate ON finreceivableinvoice USING btree (emissiondate);


--
-- Name: idx_finreceivableinvoice_invoiceid_maturitydate; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finreceivableinvoice_invoiceid_maturitydate ON finreceivableinvoice USING btree (invoiceid, maturitydate);


--
-- Name: idx_finreceivableinvoice_iscanceled; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finreceivableinvoice_iscanceled ON finreceivableinvoice USING btree (iscanceled);


--
-- Name: idx_finreceivableinvoice_maturitydate; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finreceivableinvoice_maturitydate ON finreceivableinvoice USING btree (maturitydate);


--
-- Name: idx_finreceivableinvoice_parcelnumber; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finreceivableinvoice_parcelnumber ON finreceivableinvoice USING btree (parcelnumber);


--
-- Name: idx_finreceivableinvoice_personid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finreceivableinvoice_personid ON finreceivableinvoice USING btree (personid);


--
-- Name: idx_finreceivableinvoice_referencematuritydate; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finreceivableinvoice_referencematuritydate ON finreceivableinvoice USING btree (referencematuritydate);


--
-- Name: idx_finreceivableinvoice_sagu1invoiceid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finreceivableinvoice_sagu1invoiceid ON finreceivableinvoice USING btree (sagu1invoiceid);


--
-- Name: idx_finrelease_begindate_enddate; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finrelease_begindate_enddate ON finrelease USING btree (begindate, enddate);


--
-- Name: idx_finrelease_invoiceid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_finrelease_invoiceid ON finrelease USING btree (invoiceid);


--
-- Name: idx_finstudentfinancing_unique; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX idx_finstudentfinancing_unique ON finstudentfinancing USING btree (contractid);


--
-- Name: idx_miolo_access_idgroup; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_miolo_access_idgroup ON miolo_access USING btree (idgroup);


--
-- Name: idx_miolo_access_rights; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_miolo_access_rights ON miolo_access USING btree (rights);


--
-- Name: idx_miolo_group_idgroup; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_miolo_group_idgroup ON miolo_group USING btree (idgroup);


--
-- Name: idx_miolo_groupuser_iduser; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_miolo_groupuser_iduser ON miolo_groupuser USING btree (iduser);


--
-- Name: idx_miolo_transaction_idtransaction; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_miolo_transaction_idtransaction ON miolo_transaction USING btree (idtransaction);


--
-- Name: idx_miolo_transaction_m_transaction; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_miolo_transaction_m_transaction ON miolo_transaction USING btree (lower(m_transaction) text_pattern_ops);


--
-- Name: idx_miolo_user_login; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX idx_miolo_user_login ON miolo_user USING btree (login);


--
-- Name: idx_ptcrequest_starttime; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_ptcrequest_starttime ON ptcrequest USING btree (starttime);


--
-- Name: idx_temp_bank_movement; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_temp_bank_movement ON temp_bank_movement USING btree (invoiceid);


--
-- Name: idx_temp_bank_movement_entries; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX idx_temp_bank_movement_entries ON temp_bank_movement_entries USING btree (invoiceid);


--
-- Name: idx_unique_complementaryactivitiescategoryrules; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX idx_unique_complementaryactivitiescategoryrules ON acdcomplementaryactivitiescategoryrules USING btree (curriculumid, complementaryactivitiescategoryid);


--
-- Name: idx_unique_professor_curricular_component; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX idx_unique_professor_curricular_component ON acdprofessorcurricularcomponent USING btree (professorid, curricularcomponentid, curricularcomponentversion);


--
-- Name: idx_unq_rshanswer; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX idx_unq_rshanswer ON rshanswer USING btree (personid, questionid, optionid);


--
-- Name: index_gtcanalytics_libraryunitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcanalytics_libraryunitid ON gtcanalytics USING btree (libraryunitid);


--
-- Name: index_gtcanalytics_personid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcanalytics_personid ON gtcanalytics USING btree (personid);


--
-- Name: index_gtcbackgroundtasklog_libraryunitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcbackgroundtasklog_libraryunitid ON gtcbackgroundtasklog USING btree (libraryunitid);


--
-- Name: index_gtccontrolfielddetail; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtccontrolfielddetail ON gtccontrolfielddetail USING btree (fieldid, subfieldid, categoryid, isactive);


--
-- Name: index_gtccontrolfielddetail_1; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtccontrolfielddetail_1 ON gtccontrolfielddetail USING btree (fieldid, subfieldid, categoryid, isactive);


--
-- Name: index_gtccontrolfielddetail_fieldid_subfieldid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtccontrolfielddetail_fieldid_subfieldid ON gtccontrolfielddetail USING btree (fieldid, subfieldid);


--
-- Name: index_gtccontrolfielddetail_marctaglistid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtccontrolfielddetail_marctaglistid ON gtccontrolfielddetail USING btree (marctaglistid);


--
-- Name: index_gtcdictionarycontent_dictionarycontent; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcdictionarycontent_dictionarycontent ON gtcdictionarycontent USING btree (dictionarycontent);


--
-- Name: index_gtcdictionarycontent_dictionaryid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcdictionarycontent_dictionaryid ON gtcdictionarycontent USING btree (dictionaryid);


--
-- Name: index_gtcdictionaryrelatedcontent_dictionarycontentid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcdictionaryrelatedcontent_dictionarycontentid ON gtcdictionaryrelatedcontent USING btree (dictionarycontentid);


--
-- Name: index_gtcdictionaryrelatedcontent_relatedcontent; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcdictionaryrelatedcontent_relatedcontent ON gtcdictionaryrelatedcontent USING btree (relatedcontent);


--
-- Name: index_gtcemailcontroldelayedloan_loanid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcemailcontroldelayedloan_loanid ON gtcemailcontroldelayedloan USING btree (loanid);


--
-- Name: index_gtcemailcontrolnotifyaquisition_personid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcemailcontrolnotifyaquisition_personid ON gtcemailcontrolnotifyaquisition USING btree (personid);


--
-- Name: index_gtcexemplarycontrol_controlnumber; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcexemplarycontrol_controlnumber ON gtcexemplarycontrol USING btree (controlnumber);


--
-- Name: index_gtcexemplarycontrol_exemplarystatusid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcexemplarycontrol_exemplarystatusid ON gtcexemplarycontrol USING btree (exemplarystatusid);


--
-- Name: index_gtcexemplarycontrol_library; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcexemplarycontrol_library ON gtcexemplarycontrol USING btree (controlnumber, libraryunitid);


--
-- Name: index_gtcexemplarycontrol_libraryunitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcexemplarycontrol_libraryunitid ON gtcexemplarycontrol USING btree (libraryunitid);


--
-- Name: index_gtcexemplarycontrol_materialgenderid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcexemplarycontrol_materialgenderid ON gtcexemplarycontrol USING btree (materialgenderid);


--
-- Name: index_gtcexemplarycontrol_materialphysicaltypeid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcexemplarycontrol_materialphysicaltypeid ON gtcexemplarycontrol USING btree (materialphysicaltypeid);


--
-- Name: index_gtcexemplarycontrol_materialtypeid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcexemplarycontrol_materialtypeid ON gtcexemplarycontrol USING btree (materialtypeid);


--
-- Name: index_gtcexemplarycontrol_originallibraryunitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcexemplarycontrol_originallibraryunitid ON gtcexemplarycontrol USING btree (originallibraryunitid);


--
-- Name: index_gtcexemplarycontrol_status; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcexemplarycontrol_status ON gtcexemplarycontrol USING btree (controlnumber, exemplarystatusid);


--
-- Name: index_gtcexemplaryfuturestatusdefined_exemplarystatusid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcexemplaryfuturestatusdefined_exemplarystatusid ON gtcexemplaryfuturestatusdefined USING btree (exemplarystatusid);


--
-- Name: index_gtcexemplarystatushistory_exemplarystatusid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcexemplarystatushistory_exemplarystatusid ON gtcexemplarystatushistory USING btree (exemplarystatusid);


--
-- Name: index_gtcexemplarystatushistory_libraryunitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcexemplarystatushistory_libraryunitid ON gtcexemplarystatushistory USING btree (libraryunitid);


--
-- Name: index_gtcfavorite_personid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcfavorite_personid ON gtcfavorite USING btree (personid);


--
-- Name: index_gtcfine_finestatusid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcfine_finestatusid ON gtcfine USING btree (finestatusid);


--
-- Name: index_gtcfine_loanid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcfine_loanid ON gtcfine USING btree (loanid);


--
-- Name: index_gtcfinestatushistory; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcfinestatushistory ON gtcfinestatushistory USING btree (fineid);


--
-- Name: index_gtcfinestatushistory_fineid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcfinestatushistory_fineid ON gtcfinestatushistory USING btree (fineid);


--
-- Name: index_gtcfinestatushistory_finestatusid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcfinestatushistory_finestatusid ON gtcfinestatushistory USING btree (finestatusid);


--
-- Name: index_gtcformcontent_formcontenttype; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcformcontent_formcontenttype ON gtcformcontent USING btree (formcontenttype);


--
-- Name: index_gtcgeneralpolicy_linkid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcgeneralpolicy_linkid ON gtcgeneralpolicy USING btree (linkid);


--
-- Name: index_gtcgeneralpolicy_privilegegroupid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcgeneralpolicy_privilegegroupid ON gtcgeneralpolicy USING btree (privilegegroupid);


--
-- Name: index_gtcholiday_libraryunitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcholiday_libraryunitid ON gtcholiday USING btree (libraryunitid);


--
-- Name: index_gtcinterchange_interchangestatusid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcinterchange_interchangestatusid ON gtcinterchange USING btree (interchangestatusid);


--
-- Name: index_gtcinterchange_interchangetypeid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcinterchange_interchangetypeid ON gtcinterchange USING btree (interchangetypeid);


--
-- Name: index_gtcinterchangeitem_interchangeid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcinterchangeitem_interchangeid ON gtcinterchangeitem USING btree (interchangeid);


--
-- Name: index_gtcinterchangeobservation_interchangeid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcinterchangeobservation_interchangeid ON gtcinterchangeobservation USING btree (interchangeid);


--
-- Name: index_gtcinterchangestatus_interchangetypeid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcinterchangestatus_interchangetypeid ON gtcinterchangestatus USING btree (interchangetypeid);


--
-- Name: index_gtcinterestsarea_classificationareaid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcinterestsarea_classificationareaid ON gtcinterestsarea USING btree (classificationareaid);


--
-- Name: index_gtcinterestsarea_personid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcinterestsarea_personid ON gtcinterestsarea USING btree (personid);


--
-- Name: index_gtckardexcontrol; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX index_gtckardexcontrol ON gtckardexcontrol USING btree (controlnumber, codigodeassinante, libraryunitid);


--
-- Name: index_gtckardexcontrol_libraryunitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtckardexcontrol_libraryunitid ON gtckardexcontrol USING btree (libraryunitid);


--
-- Name: index_gtclibraryassociation_associationid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtclibraryassociation_associationid ON gtclibraryassociation USING btree (associationid);


--
-- Name: index_gtclibraryassociation_libraryunitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtclibraryassociation_libraryunitid ON gtclibraryassociation USING btree (libraryunitid);


--
-- Name: index_gtclibraryunit_librarygroupid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtclibraryunit_librarygroupid ON gtclibraryunit USING btree (librarygroupid);


--
-- Name: index_gtclibraryunit_privilegegroupid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtclibraryunit_privilegegroupid ON gtclibraryunit USING btree (privilegegroupid);


--
-- Name: index_gtclibraryunitaccess_libraryunitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtclibraryunitaccess_libraryunitid ON gtclibraryunitaccess USING btree (libraryunitid);


--
-- Name: index_gtclibraryunitaccess_linkid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtclibraryunitaccess_linkid ON gtclibraryunitaccess USING btree (linkid);


--
-- Name: index_gtclibraryunitconfig_libraryunitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtclibraryunitconfig_libraryunitid ON gtclibraryunitconfig USING btree (libraryunitid);


--
-- Name: index_gtclibraryunitisclosed_libraryunitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtclibraryunitisclosed_libraryunitid ON gtclibraryunitisclosed USING btree (libraryunitid);


--
-- Name: index_gtclibraryunitisclosed_weekdayid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtclibraryunitisclosed_weekdayid ON gtclibraryunitisclosed USING btree (weekdayid);


--
-- Name: index_gtcloan_itemnumber_returndate; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcloan_itemnumber_returndate ON gtcloan USING btree (itemnumber);


--
-- Name: index_gtcloan_libraryunitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcloan_libraryunitid ON gtcloan USING btree (libraryunitid);


--
-- Name: index_gtcloan_linkid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcloan_linkid ON gtcloan USING btree (linkid);


--
-- Name: index_gtcloan_loantypeid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcloan_loantypeid ON gtcloan USING btree (loantypeid);


--
-- Name: index_gtcloan_personid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcloan_personid ON gtcloan USING btree (personid);


--
-- Name: index_gtcloan_privilegegroupid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcloan_privilegegroupid ON gtcloan USING btree (privilegegroupid);


--
-- Name: index_gtcloanbetweenlibrary_libraryunitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcloanbetweenlibrary_libraryunitid ON gtcloanbetweenlibrary USING btree (libraryunitid);


--
-- Name: index_gtcloanbetweenlibrary_loanbetweenlibrarystatusid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcloanbetweenlibrary_loanbetweenlibrarystatusid ON gtcloanbetweenlibrary USING btree (loanbetweenlibrarystatusid);


--
-- Name: index_gtcloanbetweenlibrary_personid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcloanbetweenlibrary_personid ON gtcloanbetweenlibrary USING btree (personid);


--
-- Name: index_gtcloanbetweenlibrarycomposition_loanbetweenlibraryid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcloanbetweenlibrarycomposition_loanbetweenlibraryid ON gtcloanbetweenlibrarycomposition USING btree (loanbetweenlibraryid);


--
-- Name: index_gtcloanbetweenlibrarystatushistory_loanbetweenlibrarystat; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcloanbetweenlibrarystatushistory_loanbetweenlibrarystat ON gtcloanbetweenlibrarystatushistory USING btree (loanbetweenlibrarystatusid);


--
-- Name: index_gtcmarctaglistingoption_marctaglistingid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmarctaglistingoption_marctaglistingid ON gtcmarctaglistingoption USING btree (marctaglistingid);


--
-- Name: index_gtcmaterial_3; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterial_3 ON gtcmaterial USING btree (fieldid, subfieldid, searchcontent varchar_pattern_ops);


--
-- Name: index_gtcmaterial_3forsearchmodule; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterial_3forsearchmodule ON gtcmaterial USING btree (fieldid, subfieldid, searchcontentforsearchmodule varchar_pattern_ops);


--
-- Name: index_gtcmaterial_content; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterial_content ON gtcmaterial USING btree (controlnumber, content);


--
-- Name: index_gtcmaterial_controlnumbersearch; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterial_controlnumbersearch ON gtcmaterial USING btree (controlnumber, fieldid, subfieldid, searchcontent);


--
-- Name: index_gtcmaterial_controlnumbersearchforsearchmodule; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterial_controlnumbersearchforsearchmodule ON gtcmaterial USING btree (controlnumber, fieldid, subfieldid, searchcontentforsearchmodule);


--
-- Name: index_gtcmaterial_fieldid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterial_fieldid ON gtcmaterial USING btree (controlnumber, fieldid);


--
-- Name: index_gtcmaterial_fieldid_subfieldid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterial_fieldid_subfieldid ON gtcmaterial USING btree (fieldid, subfieldid);


--
-- Name: index_gtcmaterial_fieldsubfield; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterial_fieldsubfield ON gtcmaterial USING btree (controlnumber, fieldid, subfieldid);


--
-- Name: index_gtcmaterial_indice4; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterial_indice4 ON gtcmaterial USING btree (fieldid, subfieldid, searchcontent varchar_pattern_ops);


--
-- Name: index_gtcmaterial_indice4forsearchmodule; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterial_indice4forsearchmodule ON gtcmaterial USING btree (fieldid, subfieldid, searchcontentforsearchmodule varchar_pattern_ops);


--
-- Name: index_gtcmaterial_only_searchcontentforsearchmodule; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterial_only_searchcontentforsearchmodule ON gtcmaterial USING btree (searchcontentforsearchmodule varchar_pattern_ops);


--
-- Name: index_gtcmaterial_prefixid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterial_prefixid ON gtcmaterial USING btree (prefixid);


--
-- Name: index_gtcmaterial_searchcontent; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterial_searchcontent ON gtcmaterial USING btree (controlnumber, searchcontent);


--
-- Name: index_gtcmaterial_searchcontent_fulltext; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterial_searchcontent_fulltext ON gtcmaterial USING gin (to_tsvector('portuguese'::regconfig, searchcontent));


--
-- Name: index_gtcmaterial_searchcontentforsearchmodule; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterial_searchcontentforsearchmodule ON gtcmaterial USING btree (controlnumber, searchcontentforsearchmodule);


--
-- Name: index_gtcmaterial_searchcontentforsearchmodule_fulltext; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterial_searchcontentforsearchmodule_fulltext ON gtcmaterial USING gin (to_tsvector('portuguese'::regconfig, searchcontentforsearchmodule));


--
-- Name: index_gtcmaterial_separatorid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterial_separatorid ON gtcmaterial USING btree (separatorid);


--
-- Name: index_gtcmaterial_subfieldid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterial_subfieldid ON gtcmaterial USING btree (controlnumber, subfieldid);


--
-- Name: index_gtcmaterial_suffixid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterial_suffixid ON gtcmaterial USING btree (suffixid);


--
-- Name: index_gtcmaterialcontrol_category; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterialcontrol_category ON gtcmaterialcontrol USING btree (controlnumber, category);


--
-- Name: index_gtcmaterialcontrol_category_level; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterialcontrol_category_level ON gtcmaterialcontrol USING btree (category, level);


--
-- Name: index_gtcmaterialcontrol_controlnumber; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterialcontrol_controlnumber ON gtcmaterialcontrol USING btree (controlnumber, category, level);


--
-- Name: index_gtcmaterialcontrol_entrancedate; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterialcontrol_entrancedate ON gtcmaterialcontrol USING btree (controlnumber, entrancedate);


--
-- Name: index_gtcmaterialcontrol_father; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterialcontrol_father ON gtcmaterialcontrol USING btree (controlnumberfather);


--
-- Name: index_gtcmaterialcontrol_fathercatlev; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterialcontrol_fathercatlev ON gtcmaterialcontrol USING btree (controlnumberfather, category, level);


--
-- Name: index_gtcmaterialcontrol_gender; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterialcontrol_gender ON gtcmaterialcontrol USING btree (controlnumber, materialgenderid);


--
-- Name: index_gtcmaterialcontrol_level; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterialcontrol_level ON gtcmaterialcontrol USING btree (controlnumber, level);


--
-- Name: index_gtcmaterialcontrol_materialgenderid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterialcontrol_materialgenderid ON gtcmaterialcontrol USING btree (materialgenderid);


--
-- Name: index_gtcmaterialcontrol_materialphysicaltypeid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterialcontrol_materialphysicaltypeid ON gtcmaterialcontrol USING btree (materialphysicaltypeid);


--
-- Name: index_gtcmaterialcontrol_materialtypeid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterialcontrol_materialtypeid ON gtcmaterialcontrol USING btree (materialtypeid);


--
-- Name: index_gtcmaterialcontrol_physical; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterialcontrol_physical ON gtcmaterialcontrol USING btree (controlnumber, materialphysicaltypeid);


--
-- Name: index_gtcmaterialcontrol_type; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterialcontrol_type ON gtcmaterialcontrol USING btree (controlnumber, materialtypeid);


--
-- Name: index_gtcmaterialevaluation_controlnumber; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterialevaluation_controlnumber ON gtcmaterialevaluation USING btree (controlnumber);


--
-- Name: index_gtcmaterialevaluation_personid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterialevaluation_personid ON gtcmaterialevaluation USING btree (personid);


--
-- Name: index_gtcmaterialhistory_controlnumber; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterialhistory_controlnumber ON gtcmaterialhistory USING btree (controlnumber);


--
-- Name: index_gtcmaterialhistory_fieldid_subfieldid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterialhistory_fieldid_subfieldid ON gtcmaterialhistory USING btree (fieldid, subfieldid);


--
-- Name: index_gtcmaterialhsitory_controlnumber; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmaterialhsitory_controlnumber ON gtcmaterialhistory USING btree (controlnumber);


--
-- Name: index_gtcmylibrary_personid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmylibrary_personid ON gtcmylibrary USING btree (personid);


--
-- Name: index_gtcmylibrary_tablename_tableid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcmylibrary_tablename_tableid ON gtcmylibrary USING btree (tablename, tableid);


--
-- Name: index_gtcnews_libraryunitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcnews_libraryunitid ON gtcnews USING btree (libraryunitid);


--
-- Name: index_gtcnewsaccess_linkid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcnewsaccess_linkid ON gtcnewsaccess USING btree (linkid);


--
-- Name: index_gtcnewsaccess_newsid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcnewsaccess_newsid ON gtcnewsaccess USING btree (newsid);


--
-- Name: index_gtcoperatorlibraryunit_libraryunitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcoperatorlibraryunit_libraryunitid ON gtcoperatorlibraryunit USING btree (libraryunitid);


--
-- Name: index_gtcoperatorlibraryunit_operator; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcoperatorlibraryunit_operator ON gtcoperatorlibraryunit USING btree (operator);


--
-- Name: index_gtcpenalty_libraryunitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcpenalty_libraryunitid ON gtcpenalty USING btree (libraryunitid);


--
-- Name: index_gtcpenalty_personid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcpenalty_personid ON gtcpenalty USING btree (personid);


--
-- Name: index_gtcpersonconfig_personid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcpersonconfig_personid ON gtcpersonconfig USING btree (personid);


--
-- Name: index_gtcpersonlibraryunit_libraryunitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcpersonlibraryunit_libraryunitid ON gtcpersonlibraryunit USING btree (libraryunitid);


--
-- Name: index_gtcpersonlibraryunit_personid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcpersonlibraryunit_personid ON gtcpersonlibraryunit USING btree (personid);


--
-- Name: index_gtcpolicy_linkid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcpolicy_linkid ON gtcpolicy USING btree (linkid);


--
-- Name: index_gtcpolicy_materialgenderid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcpolicy_materialgenderid ON gtcpolicy USING btree (materialgenderid);


--
-- Name: index_gtcpolicy_privilegegroupid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcpolicy_privilegegroupid ON gtcpolicy USING btree (privilegegroupid);


--
-- Name: index_gtcprecatalogue_prefixid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcprecatalogue_prefixid ON gtcprecatalogue USING btree (prefixid);


--
-- Name: index_gtcprecatalogue_separatorid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcprecatalogue_separatorid ON gtcprecatalogue USING btree (separatorid);


--
-- Name: index_gtcprecatalogue_suffixid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcprecatalogue_suffixid ON gtcprecatalogue USING btree (suffixid);


--
-- Name: index_gtcprefixsuffix_fieldid_subfieldid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcprefixsuffix_fieldid_subfieldid ON gtcprefixsuffix USING btree (fieldid, subfieldid);


--
-- Name: index_gtcpurchaserequest_libraryunitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcpurchaserequest_libraryunitid ON gtcpurchaserequest USING btree (libraryunitid);


--
-- Name: index_gtcpurchaserequest_personid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcpurchaserequest_personid ON gtcpurchaserequest USING btree (personid);


--
-- Name: index_gtcrenew_loanid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcrenew_loanid ON gtcrenew USING btree (loanid);


--
-- Name: index_gtcrenew_renewtypeid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcrenew_renewtypeid ON gtcrenew USING btree (renewtypeid);


--
-- Name: index_gtcreportparameter_reportid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcreportparameter_reportid ON gtcreportparameter USING btree (reportid);


--
-- Name: index_gtcrequestchangeexemplarystatus_futurestatusid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcrequestchangeexemplarystatus_futurestatusid ON gtcrequestchangeexemplarystatus USING btree (futurestatusid);


--
-- Name: index_gtcrequestchangeexemplarystatus_libraryunitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcrequestchangeexemplarystatus_libraryunitid ON gtcrequestchangeexemplarystatus USING btree (libraryunitid);


--
-- Name: index_gtcrequestchangeexemplarystatus_personid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcrequestchangeexemplarystatus_personid ON gtcrequestchangeexemplarystatus USING btree (personid);


--
-- Name: index_gtcrequestchangeexemplarystatusaccess_baslinkid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcrequestchangeexemplarystatusaccess_baslinkid ON gtcrequestchangeexemplarystatusaccess USING btree (baslinkid);


--
-- Name: index_gtcrequestchangeexemplarystatusaccess_exemplarystatusid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcrequestchangeexemplarystatusaccess_exemplarystatusid ON gtcrequestchangeexemplarystatusaccess USING btree (exemplarystatusid);


--
-- Name: index_gtcrequestchangeexemplarystatuscomposition_exemplaryfutur; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcrequestchangeexemplarystatuscomposition_exemplaryfutur ON gtcrequestchangeexemplarystatuscomposition USING btree (exemplaryfuturestatusdefinedid);


--
-- Name: index_gtcrequestchangeexemplarystatuscomposition_requestchangee; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcrequestchangeexemplarystatuscomposition_requestchangee ON gtcrequestchangeexemplarystatuscomposition USING btree (requestchangeexemplarystatusid);


--
-- Name: index_gtcrequestchangeexemplarystatusstatushistory_requestchang; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcrequestchangeexemplarystatusstatushistory_requestchang ON gtcrequestchangeexemplarystatusstatushistory USING btree (requestchangeexemplarystatusstatusid);


--
-- Name: index_gtcreserve_libraryunitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcreserve_libraryunitid ON gtcreserve USING btree (libraryunitid);


--
-- Name: index_gtcreserve_personid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcreserve_personid ON gtcreserve USING btree (personid);


--
-- Name: index_gtcreserve_reservestatusid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcreserve_reservestatusid ON gtcreserve USING btree (reservestatusid);


--
-- Name: index_gtcreserve_reservetypeid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcreserve_reservetypeid ON gtcreserve USING btree (reservetypeid);


--
-- Name: index_gtcreservecomposition_itemnumber; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcreservecomposition_itemnumber ON gtcreservecomposition USING btree (itemnumber);


--
-- Name: index_gtcreservecomposition_reserveid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcreservecomposition_reserveid ON gtcreservecomposition USING btree (reserveid);


--
-- Name: index_gtcreservestatushistory_reserveid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcreservestatushistory_reserveid ON gtcreservestatushistory USING btree (reserveid);


--
-- Name: index_gtcreservestatushistory_reservestatusid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcreservestatushistory_reservestatusid ON gtcreservestatushistory USING btree (reservestatusid);


--
-- Name: index_gtcreturnregister_returntypeid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcreturnregister_returntypeid ON gtcreturnregister USING btree (returntypeid);


--
-- Name: index_gtcright_linkid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcright_linkid ON gtcright USING btree (linkid);


--
-- Name: index_gtcright_materialgenderid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcright_materialgenderid ON gtcright USING btree (materialgenderid);


--
-- Name: index_gtcright_operationid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcright_operationid ON gtcright USING btree (operationid);


--
-- Name: index_gtcright_privilegegroupid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcright_privilegegroupid ON gtcright USING btree (privilegegroupid);


--
-- Name: index_gtcrulesformaterialmovement_currentstate; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcrulesformaterialmovement_currentstate ON gtcrulesformaterialmovement USING btree (currentstate);


--
-- Name: index_gtcrulesformaterialmovement_futurestate; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcrulesformaterialmovement_futurestate ON gtcrulesformaterialmovement USING btree (futurestate);


--
-- Name: index_gtcrulesformaterialmovement_locationformaterialmovementid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcrulesformaterialmovement_locationformaterialmovementid ON gtcrulesformaterialmovement USING btree (locationformaterialmovementid);


--
-- Name: index_gtcrulesformaterialmovement_operationid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcrulesformaterialmovement_operationid ON gtcrulesformaterialmovement USING btree (operationid);


--
-- Name: index_gtcscheduletask_schedulecycleid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcscheduletask_schedulecycleid ON gtcscheduletask USING btree (schedulecycleid);


--
-- Name: index_gtcscheduletask_taskid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcscheduletask_taskid ON gtcscheduletask USING btree (taskid);


--
-- Name: index_gtcscheduletasklog_scheduletaskid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcscheduletasklog_scheduletaskid ON gtcscheduletasklog USING btree (scheduletaskid);


--
-- Name: index_gtcsearchablefieldaccess_linkid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcsearchablefieldaccess_linkid ON gtcsearchablefieldaccess USING btree (linkid);


--
-- Name: index_gtcsearchablefieldaccess_searchablefieldid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcsearchablefieldaccess_searchablefieldid ON gtcsearchablefieldaccess USING btree (searchablefieldid);


--
-- Name: index_gtcsearchformataccess_linkid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcsearchformataccess_linkid ON gtcsearchformataccess USING btree (linkid);


--
-- Name: index_gtcsearchformataccess_searchformatid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcsearchformataccess_searchformatid ON gtcsearchformataccess USING btree (searchformatid);


--
-- Name: index_gtcsearchformatcolumn_searchformatid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcsearchformatcolumn_searchformatid ON gtcsearchformatcolumn USING btree (searchformatid);


--
-- Name: index_gtcsearchmaterialview_controlnumber; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcsearchmaterialview_controlnumber ON gtcsearchmaterialview USING btree (controlnumber);


--
-- Name: index_gtcsearchmaterialview_exemplarylibraryunitid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcsearchmaterialview_exemplarylibraryunitid ON gtcsearchmaterialview USING btree (exemplarylibraryunitid);


--
-- Name: index_gtcsearchmaterialview_exemplaryoriginallibraryunitidd; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcsearchmaterialview_exemplaryoriginallibraryunitidd ON gtcsearchmaterialview USING btree (exemplaryoriginallibraryunitid);


--
-- Name: index_gtcsearchpresentationformat_searchformatid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcsearchpresentationformat_searchformatid ON gtcsearchpresentationformat USING btree (searchformatid);


--
-- Name: index_gtcseparator_cataloguingformatid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcseparator_cataloguingformatid ON gtcseparator USING btree (cataloguingformatid);


--
-- Name: index_gtcsession_isclosed; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcsession_isclosed ON gtcsession USING btree (isclosed);


--
-- Name: index_gtcsession_personid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcsession_personid ON gtcsession USING btree (personid);


--
-- Name: index_gtcsession_sipequipamentid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcsession_sipequipamentid ON gtcsession USING btree (sipequipamentid);


--
-- Name: index_gtcsessionoperation_sessionid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcsessionoperation_sessionid ON gtcsessionoperation USING btree (sessionid);


--
-- Name: index_gtcsipequipamentlog_sipequipamentid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcsipequipamentlog_sipequipamentid ON gtcsipequipamentlog USING btree (sipequipamentid);


--
-- Name: index_gtcsoapaccess_soapclientid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcsoapaccess_soapclientid ON gtcsoapaccess USING btree (soapclientid);


--
-- Name: index_gtcsoapaccess_webserviceid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcsoapaccess_webserviceid ON gtcsoapaccess USING btree (webserviceid);


--
-- Name: index_gtcsuppliertypeandlocation_supplierid; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX index_gtcsuppliertypeandlocation_supplierid ON gtcsuppliertypeandlocation USING btree (supplierid);


--
-- Name: ptcrequest_number_uniq; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX ptcrequest_number_uniq ON ptcrequest USING btree (number);


--
-- Name: table_name_idx; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX table_name_idx ON miolo_audit USING btree (table_name);


--
-- Name: unq_miolo_groupuser; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE UNIQUE INDEX unq_miolo_groupuser ON miolo_groupuser USING btree (iduser, idgroup, unitid);


--
-- Name: user_name_idx; Type: INDEX; Schema: public; Owner: postgres; Tablespace: 
--

CREATE INDEX user_name_idx ON miolo_audit USING btree (user_name);


SET search_path = res, pg_catalog;

--
-- Name: cargaHorariaComplementar_residenteid; Type: INDEX; Schema: res; Owner: postgres; Tablespace: 
--

CREATE INDEX "cargaHorariaComplementar_residenteid" ON cargahorariacomplementar USING btree (residenteid);


--
-- Name: cargaHorariaComplementar_unidadetematicaid; Type: INDEX; Schema: res; Owner: postgres; Tablespace: 
--

CREATE INDEX "cargaHorariaComplementar_unidadetematicaid" ON cargahorariacomplementar USING btree (unidadetematicaid);


--
-- Name: encontro_ofertadeunidadetematicaid; Type: INDEX; Schema: res; Owner: postgres; Tablespace: 
--

CREATE INDEX encontro_ofertadeunidadetematicaid ON encontro USING btree (ofertadeunidadetematicaid);


--
-- Name: frequencia_encontroid; Type: INDEX; Schema: res; Owner: postgres; Tablespace: 
--

CREATE INDEX frequencia_encontroid ON frequencia USING btree (encontroid);


--
-- Name: frequencia_presenca; Type: INDEX; Schema: res; Owner: postgres; Tablespace: 
--

CREATE INDEX frequencia_presenca ON frequencia USING btree (presenca);


--
-- Name: frequencia_residenteid; Type: INDEX; Schema: res; Owner: postgres; Tablespace: 
--

CREATE INDEX frequencia_residenteid ON frequencia USING btree (residenteid);


--
-- Name: ocorrenciaDeOferta_ofertadoresidenteid; Type: INDEX; Schema: res; Owner: postgres; Tablespace: 
--

CREATE INDEX "ocorrenciaDeOferta_ofertadoresidenteid" ON ocorrenciadeoferta USING btree (ofertadoresidenteid);


--
-- Name: ocorrenciaDeoferta_status; Type: INDEX; Schema: res; Owner: postgres; Tablespace: 
--

CREATE INDEX "ocorrenciaDeoferta_status" ON ocorrenciadeoferta USING btree (status);


--
-- Name: ofertadeunidadetematica_unidadetematicaid; Type: INDEX; Schema: res; Owner: postgres; Tablespace: 
--

CREATE INDEX ofertadeunidadetematica_unidadetematicaid ON ofertadeunidadetematica USING btree (unidadetematicaid);


--
-- Name: ofertadoresidente_ofertadeunidadetematicaid; Type: INDEX; Schema: res; Owner: postgres; Tablespace: 
--

CREATE INDEX ofertadoresidente_ofertadeunidadetematicaid ON ofertadoresidente USING btree (ofertadeunidadetematicaid);


--
-- Name: ofertadoresidente_residenteid; Type: INDEX; Schema: res; Owner: postgres; Tablespace: 
--

CREATE INDEX ofertadoresidente_residenteid ON ofertadoresidente USING btree (residenteid);


SET search_path = fin, pg_catalog;

--
-- Name: valid_invoicenegociationconfig; Type: TRIGGER; Schema: fin; Owner: postgres
--

CREATE TRIGGER valid_invoicenegociationconfig BEFORE INSERT ON invoicenegociationconfig FOR EACH ROW EXECUTE PROCEDURE public.validate_costcenter();


SET search_path = public, pg_catalog;

--
-- Name: acdcontractglobalaverage; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER acdcontractglobalaverage AFTER INSERT OR UPDATE ON acdmovementcontract FOR EACH ROW EXECUTE PROCEDURE calculamediaglobal();


--
-- Name: acdenrollconfig_checkenroll_tkey; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER acdenrollconfig_checkenroll_tkey BEFORE INSERT OR UPDATE ON acdenrollconfig FOR EACH ROW EXECUTE PROCEDURE acdenrollconfig_checkenroll();


--
-- Name: acdfrequenceenrollsynctoacdenroll; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER acdfrequenceenrollsynctoacdenroll AFTER INSERT OR DELETE OR UPDATE ON acdfrequenceenroll FOR EACH ROW EXECUTE PROCEDURE syncacdenrollfrequencytoacdfrequenceenroll();


--
-- Name: acdschedule_occurrencedates_tkey; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER acdschedule_occurrencedates_tkey AFTER INSERT OR UPDATE ON acdschedule FOR EACH ROW EXECUTE PROCEDURE acdschedule_checktimeids();


--
-- Name: acdtime_occurrencedates_tkey; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER acdtime_occurrencedates_tkey AFTER DELETE OR UPDATE ON acdtime FOR EACH ROW EXECUTE PROCEDURE acdtime_checktimeids();


--
-- Name: certifiednumber_generate; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER certifiednumber_generate AFTER INSERT ON acdcertified FOR EACH ROW EXECUTE PROCEDURE certifiednumber_generate();


--
-- Name: check_acphorarioofertacomponentecurricular; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER check_acphorarioofertacomponentecurricular BEFORE INSERT ON acphorarioofertacomponentecurricular FOR EACH ROW EXECUTE PROCEDURE check_acphorarioofertacomponentecurricular();


--
-- Name: chk_timeids_dependance; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER chk_timeids_dependance BEFORE DELETE OR UPDATE ON acdschedule FOR EACH ROW EXECUTE PROCEDURE checktimeiddependance();


--
-- Name: gtctgrupdatematerialsontrigger; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER gtctgrupdatematerialsontrigger AFTER INSERT OR DELETE OR UPDATE ON gtcmaterial FOR EACH ROW EXECUTE PROCEDURE gtcfncupdatematerialson();


--
-- Name: gtcthelp; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER gtcthelp BEFORE INSERT OR UPDATE ON gtchelp FOR EACH ROW EXECUTE PROCEDURE gtcgnccheckhelp('form', 'subform');


--
-- Name: insere_data_competencia_invoice; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER insere_data_competencia_invoice AFTER INSERT ON fininvoice FOR EACH ROW EXECUTE PROCEDURE insere_data_de_competencia();


--
-- Name: setinvoicebalance; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER setinvoicebalance AFTER INSERT OR DELETE OR UPDATE ON finentry FOR EACH ROW EXECUTE PROCEDURE setinvoicebalance();


--
-- Name: setinvoicenominalvalue; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER setinvoicenominalvalue AFTER INSERT OR DELETE OR UPDATE ON finentry FOR EACH ROW EXECUTE PROCEDURE setinvoicenominalvalue();


--
-- Name: settotalenrolled; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER settotalenrolled AFTER INSERT OR DELETE OR UPDATE ON acdenroll FOR EACH ROW EXECUTE PROCEDURE settotalenrolled();


--
-- Name: syncpassword_tkey; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER syncpassword_tkey AFTER INSERT OR DELETE OR UPDATE ON basperson FOR EACH ROW EXECUTE PROCEDURE syncpassword();


--
-- Name: syncpassword_tkey; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER syncpassword_tkey AFTER INSERT OR DELETE OR UPDATE ON miolo_user FOR EACH ROW EXECUTE PROCEDURE syncpassword();


--
-- Name: syncphones_tkey; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER syncphones_tkey AFTER INSERT OR UPDATE ON basphysicalperson FOR EACH ROW EXECUTE PROCEDURE syncphones();


--
-- Name: syncphones_tkey; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER syncphones_tkey AFTER INSERT OR UPDATE ON basphone FOR EACH ROW EXECUTE PROCEDURE syncphones();


--
-- Name: trg_acdenroll_detail_update; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_acdenroll_detail_update BEFORE INSERT OR UPDATE ON acdenroll FOR EACH ROW EXECUTE PROCEDURE acdenroll_detail_update();


--
-- Name: trg_acdlearningperiod; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_acdlearningperiod BEFORE INSERT OR UPDATE ON acdlearningperiod FOR EACH ROW EXECUTE PROCEDURE trg_acdlearningperiod_proc();


--
-- Name: trg_atualiza_fininfotitulo; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_atualiza_fininfotitulo AFTER INSERT OR DELETE OR UPDATE ON finentry FOR EACH ROW EXECUTE PROCEDURE atualiza_fininfotitulo();


--
-- Name: trg_atualiza_identificador; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_atualiza_identificador BEFORE UPDATE ON basdocument FOR EACH ROW EXECUTE PROCEDURE trg_atualiza_identificador();


--
-- Name: trg_atualizabalanco; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_atualizabalanco AFTER INSERT OR DELETE OR UPDATE ON caplancamento FOR EACH ROW EXECUTE PROCEDURE atualizabalanco();


--
-- Name: trg_atualizavinculoaluno; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_atualizavinculoaluno AFTER INSERT ON acdmovementcontract FOR EACH ROW EXECUTE PROCEDURE atualizavinculoaluno();


--
-- Name: trg_atualizavinculofuncionario; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_atualizavinculofuncionario AFTER INSERT OR DELETE ON basphysicalpersonemployee FOR EACH ROW EXECUTE PROCEDURE atualizavinculofuncionario();


--
-- Name: trg_atualizavinculoprofessor; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_atualizavinculoprofessor AFTER INSERT OR DELETE ON basphysicalpersonprofessor FOR EACH ROW EXECUTE PROCEDURE atualizavinculoprofessor();


--
-- Name: trg_basdocumentnoduplicateddocuments; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_basdocumentnoduplicateddocuments BEFORE INSERT OR UPDATE ON basdocument FOR EACH ROW EXECUTE PROCEDURE trg_noduplicateddocuments();


--
-- Name: trg_basprofessorcommitment; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_basprofessorcommitment BEFORE INSERT OR UPDATE ON basprofessorcommitment FOR EACH ROW EXECUTE PROCEDURE trg_professorcommitment();


--
-- Name: trg_can_delete_option; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_can_delete_option BEFORE DELETE ON rshoption FOR EACH ROW EXECUTE PROCEDURE trg_can_delete_option_proc();


--
-- Name: trg_can_delete_question; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_can_delete_question BEFORE DELETE ON rshquestion FOR EACH ROW EXECUTE PROCEDURE trg_can_delete_question_proc();


--
-- Name: trg_degreelearningperiodunique; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_degreelearningperiodunique BEFORE INSERT OR UPDATE ON acddegree FOR EACH ROW EXECUTE PROCEDURE degreelearningperiodunique();


--
-- Name: trg_exclui_fininfotitulo; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_exclui_fininfotitulo BEFORE DELETE ON finreceivableinvoice FOR EACH ROW EXECUTE PROCEDURE exclui_fininfotitulo();


--
-- Name: trg_finprice_unique_proc; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_finprice_unique_proc BEFORE INSERT OR UPDATE ON finprice FOR EACH ROW EXECUTE PROCEDURE trg_finprice_unique_proc();


--
-- Name: trg_insere_fininfotitulo; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_insere_fininfotitulo AFTER INSERT OR UPDATE ON finreceivableinvoice FOR EACH ROW EXECUTE PROCEDURE insere_fininfotitulo();


--
-- Name: trg_pessoasduplicadas; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_pessoasduplicadas BEFORE INSERT OR UPDATE ON basphysicalperson FOR EACH ROW EXECUTE PROCEDURE atualizabuscapessoa();


--
-- Name: trg_trocaexamemenornota; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_trocaexamemenornota AFTER INSERT OR UPDATE ON acddegreeenroll FOR EACH ROW EXECUTE PROCEDURE trgdigitacaodenotastrocaexamepormenornota();


--
-- Name: trg_unidade_acdacademiccalendar; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdacademiccalendar BEFORE INSERT OR DELETE OR UPDATE ON acdacademiccalendar FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdclass; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdclass BEFORE INSERT OR DELETE OR UPDATE ON acdclass FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdclasspupil; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdclasspupil BEFORE INSERT OR DELETE OR UPDATE ON acdclasspupil FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdcondition; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdcondition BEFORE INSERT OR DELETE OR UPDATE ON acdcondition FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdcontract; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdcontract BEFORE INSERT OR DELETE OR UPDATE ON acdcontract FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdcontractexaminingboard; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdcontractexaminingboard BEFORE INSERT OR DELETE OR UPDATE ON acdcontractexaminingboard FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdcourseoccurrence; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdcourseoccurrence BEFORE INSERT OR DELETE OR UPDATE ON acdcourseoccurrence FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdcourseparent; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdcourseparent BEFORE INSERT OR DELETE OR UPDATE ON acdcourseparent FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdcourseversiontype; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdcourseversiontype BEFORE INSERT OR DELETE OR UPDATE ON acdcourseversiontype FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdcurricularcomponentgroup; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdcurricularcomponentgroup BEFORE INSERT OR DELETE OR UPDATE ON acdcurricularcomponentgroup FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdcurriculum; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdcurriculum BEFORE INSERT OR DELETE OR UPDATE ON acdcurriculum FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdcurriculumconcurrence; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdcurriculumconcurrence BEFORE INSERT OR DELETE OR UPDATE ON acdcurriculumconcurrence FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdcurriculumlink; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdcurriculumlink BEFORE INSERT OR DELETE OR UPDATE ON acdcurriculumlink FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdenroll; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdenroll BEFORE INSERT OR DELETE OR UPDATE ON acdenroll FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdenrollconfig; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdenrollconfig BEFORE INSERT OR DELETE OR UPDATE ON acdenrollconfig FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdevaluation; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdevaluation BEFORE INSERT OR DELETE OR UPDATE ON acdevaluation FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdevent; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdevent BEFORE INSERT OR DELETE OR UPDATE ON acdevent FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdeventparticipation; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdeventparticipation BEFORE INSERT OR DELETE OR UPDATE ON acdeventparticipation FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdexploitation; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdexploitation BEFORE INSERT OR DELETE OR UPDATE ON acdexploitation FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdgroup; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdgroup BEFORE INSERT OR DELETE OR UPDATE ON acdgroup FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdlearningperiod; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdlearningperiod BEFORE INSERT OR DELETE OR UPDATE ON acdlearningperiod FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdmessagecontractrenewal; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdmessagecontractrenewal BEFORE INSERT OR DELETE OR UPDATE ON acdmessagecontractrenewal FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdperiodenrolldate; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdperiodenrolldate BEFORE INSERT OR DELETE OR UPDATE ON acdperiodenrolldate FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdrestricteddocuments; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdrestricteddocuments BEFORE INSERT OR DELETE OR UPDATE ON acdrestricteddocuments FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdsubclass; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdsubclass BEFORE INSERT OR DELETE OR UPDATE ON acdsubclass FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdtestendcoursetype; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdtestendcoursetype BEFORE INSERT OR DELETE OR UPDATE ON acdtestendcoursetype FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdtimesheet; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdtimesheet BEFORE INSERT OR DELETE OR UPDATE ON acdtimesheet FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unidade_acdtrainingemphasis; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unidade_acdtrainingemphasis BEFORE INSERT OR DELETE OR UPDATE ON acdtrainingemphasis FOR EACH ROW EXECUTE PROCEDURE verificarunidade();


--
-- Name: trg_unique_course_occurrence; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_unique_course_occurrence BEFORE INSERT OR UPDATE ON acdcontract FOR EACH ROW EXECUTE PROCEDURE acdunique_course_occurrence();


--
-- Name: trg_updateinvoideiddependence; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_updateinvoideiddependence AFTER INSERT ON finentry FOR EACH ROW EXECUTE PROCEDURE trg_updateinvoideiddependence();


--
-- Name: trg_updateournumber; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_updateournumber BEFORE UPDATE ON finbankaccount FOR EACH ROW EXECUTE PROCEDURE updateournumber();


--
-- Name: valid_acccostcenter; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER valid_acccostcenter BEFORE INSERT ON acccostcenter FOR EACH ROW EXECUTE PROCEDURE validate_acccostcenter();


--
-- Name: valid_acccourseaccount; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER valid_acccourseaccount BEFORE INSERT ON acccourseaccount FOR EACH ROW EXECUTE PROCEDURE validate_costcenter();


--
-- Name: valid_acdcourseoccurrence; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER valid_acdcourseoccurrence BEFORE INSERT ON acdcourseoccurrence FOR EACH ROW EXECUTE PROCEDURE validate_costcenter();


--
-- Name: valid_acdevent; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER valid_acdevent BEFORE INSERT ON acdevent FOR EACH ROW EXECUTE PROCEDURE validate_costcenter();


--
-- Name: valid_capsolicitacao; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER valid_capsolicitacao BEFORE INSERT ON capsolicitacao FOR EACH ROW EXECUTE PROCEDURE validate_costcenter();


--
-- Name: valid_fincountermovement; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER valid_fincountermovement BEFORE INSERT ON fincountermovement FOR EACH ROW EXECUTE PROCEDURE validate_costcenter();


--
-- Name: valid_finentry; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER valid_finentry BEFORE INSERT ON finentry FOR EACH ROW EXECUTE PROCEDURE validate_costcenter();


--
-- Name: valid_finincentive; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER valid_finincentive BEFORE INSERT ON finincentive FOR EACH ROW EXECUTE PROCEDURE validate_costcenter();


--
-- Name: valid_finincomeforecast; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER valid_finincomeforecast BEFORE INSERT ON finincomeforecast FOR EACH ROW EXECUTE PROCEDURE validate_costcenter();


--
-- Name: valid_fininvoice; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER valid_fininvoice BEFORE INSERT ON fininvoice FOR EACH ROW EXECUTE PROCEDURE validate_costcenter();


--
-- Name: valid_prcprecocurso; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER valid_prcprecocurso BEFORE INSERT ON prcprecocurso FOR EACH ROW EXECUTE PROCEDURE validate_costcenter();


--
-- Name: valida_data_cancelamento; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER valida_data_cancelamento BEFORE UPDATE ON acdenroll FOR EACH ROW EXECUTE PROCEDURE trg_valida_data_cancelamento();


SET search_path = spr, pg_catalog;

--
-- Name: valid_financeinformation; Type: TRIGGER; Schema: spr; Owner: postgres
--

CREATE TRIGGER valid_financeinformation BEFORE INSERT ON financeinformation FOR EACH ROW EXECUTE PROCEDURE public.validate_costcenter();


SET search_path = bas, pg_catalog;

--
-- Name: bastask_taskstatusid_fkey; Type: FK CONSTRAINT; Schema: bas; Owner: postgres
--

ALTER TABLE ONLY task
    ADD CONSTRAINT bastask_taskstatusid_fkey FOREIGN KEY (taskstatusid) REFERENCES public.bastaskstatus(taskstatusid);


--
-- Name: fk_bastask_assignedto; Type: FK CONSTRAINT; Schema: bas; Owner: postgres
--

ALTER TABLE ONLY task
    ADD CONSTRAINT fk_bastask_assignedto FOREIGN KEY (assignedto) REFERENCES public.miolo_user(iduser);


--
-- Name: fk_bastask_creatoriduser; Type: FK CONSTRAINT; Schema: bas; Owner: postgres
--

ALTER TABLE ONLY task
    ADD CONSTRAINT fk_bastask_creatoriduser FOREIGN KEY (creatoriduser) REFERENCES public.miolo_user(iduser);


--
-- Name: fkdocumentre386245; Type: FK CONSTRAINT; Schema: bas; Owner: postgres
--

ALTER TABLE ONLY taskconfig
    ADD CONSTRAINT fkdocumentre386245 FOREIGN KEY (iduser) REFERENCES public.miolo_user(iduser);


--
-- Name: fkdocumentre775780; Type: FK CONSTRAINT; Schema: bas; Owner: postgres
--

ALTER TABLE ONLY taskconfig
    ADD CONSTRAINT fkdocumentre775780 FOREIGN KEY (idgroup) REFERENCES public.miolo_group(idgroup);


--
-- Name: fksystemtask450446; Type: FK CONSTRAINT; Schema: bas; Owner: postgres
--

ALTER TABLE ONLY systemtask
    ADD CONSTRAINT fksystemtask450446 FOREIGN KEY (taskconfigid) REFERENCES taskconfig(taskconfigid);


--
-- Name: fktaskconfig379827; Type: FK CONSTRAINT; Schema: bas; Owner: postgres
--

ALTER TABLE ONLY taskconfiggroup
    ADD CONSTRAINT fktaskconfig379827 FOREIGN KEY (taskconfigid) REFERENCES taskconfig(taskconfigid);


--
-- Name: fktaskconfig891583; Type: FK CONSTRAINT; Schema: bas; Owner: postgres
--

ALTER TABLE ONLY taskconfiggroup
    ADD CONSTRAINT fktaskconfig891583 FOREIGN KEY (idgroup) REFERENCES public.miolo_group(idgroup);


--
-- Name: systemtask_emailid_fkey; Type: FK CONSTRAINT; Schema: bas; Owner: postgres
--

ALTER TABLE ONLY systemtask
    ADD CONSTRAINT systemtask_emailid_fkey FOREIGN KEY (emailid) REFERENCES public.basemail(emailid);


--
-- Name: task_taskconfigid_fkey; Type: FK CONSTRAINT; Schema: bas; Owner: postgres
--

ALTER TABLE ONLY task
    ADD CONSTRAINT task_taskconfigid_fkey FOREIGN KEY (taskconfigid) REFERENCES taskconfig(taskconfigid);


SET search_path = fin, pg_catalog;

--
-- Name: bankmovement_bankmovementstatusid_fkey; Type: FK CONSTRAINT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY bankmovement
    ADD CONSTRAINT bankmovement_bankmovementstatusid_fkey FOREIGN KEY (bankmovementstatusid) REFERENCES bankmovementstatus(bankmovementstatusid);


--
-- Name: bankmovement_fileid_fkey; Type: FK CONSTRAINT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY bankmovement
    ADD CONSTRAINT bankmovement_fileid_fkey FOREIGN KEY (fileid) REFERENCES public.finfile(fileid);


--
-- Name: bankmovement_invoiceid_fkey; Type: FK CONSTRAINT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY bankmovement
    ADD CONSTRAINT bankmovement_invoiceid_fkey FOREIGN KEY (invoiceid) REFERENCES public.finreceivableinvoice(invoiceid);


--
-- Name: filelog_bankaccountid_fkey; Type: FK CONSTRAINT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY filelog
    ADD CONSTRAINT filelog_bankaccountid_fkey FOREIGN KEY (bankaccountid) REFERENCES public.finbankaccount(bankaccountid);


--
-- Name: filelog_fileid_fkey; Type: FK CONSTRAINT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY filelog
    ADD CONSTRAINT filelog_fileid_fkey FOREIGN KEY (fileid) REFERENCES public.finfile(fileid);


--
-- Name: filelog_invoiceid_fkey; Type: FK CONSTRAINT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY filelog
    ADD CONSTRAINT filelog_invoiceid_fkey FOREIGN KEY (invoiceid) REFERENCES public.finreceivableinvoice(invoiceid);


--
-- Name: invoicenegociationconfig_bankaccountid_fkey; Type: FK CONSTRAINT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY invoicenegociationconfig
    ADD CONSTRAINT invoicenegociationconfig_bankaccountid_fkey FOREIGN KEY (bankaccountid) REFERENCES public.finbankaccount(bankaccountid);


--
-- Name: invoicenegociationconfig_costcenterid_fkey; Type: FK CONSTRAINT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY invoicenegociationconfig
    ADD CONSTRAINT invoicenegociationconfig_costcenterid_fkey FOREIGN KEY (costcenterid) REFERENCES public.acccostcenter(costcenterid);


--
-- Name: invoicenegociationconfig_operationid_fkey; Type: FK CONSTRAINT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY invoicenegociationconfig
    ADD CONSTRAINT invoicenegociationconfig_operationid_fkey FOREIGN KEY (operationid) REFERENCES public.finoperation(operationid);


--
-- Name: invoicenegociationconfig_policyid_fkey; Type: FK CONSTRAINT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY invoicenegociationconfig
    ADD CONSTRAINT invoicenegociationconfig_policyid_fkey FOREIGN KEY (policyid) REFERENCES public.finpolicy(policyid);


--
-- Name: invoicespeciebank_bankid_fkey; Type: FK CONSTRAINT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY invoicespeciebank
    ADD CONSTRAINT invoicespeciebank_bankid_fkey FOREIGN KEY (bankid) REFERENCES public.finbank(bankid);


--
-- Name: invoicespeciebank_invoicespecieid_fkey; Type: FK CONSTRAINT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY invoicespeciebank
    ADD CONSTRAINT invoicespeciebank_invoicespecieid_fkey FOREIGN KEY (invoicespecieid) REFERENCES public.fininvoicespecie(invoicespecieid);


--
-- Name: negotiation_policyid_fkey; Type: FK CONSTRAINT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY negotiation
    ADD CONSTRAINT negotiation_policyid_fkey FOREIGN KEY (policyid) REFERENCES public.finpolicy(policyid);


--
-- Name: negotiationgeneratedentries_entryid_fkey; Type: FK CONSTRAINT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY negotiationgeneratedentries
    ADD CONSTRAINT negotiationgeneratedentries_entryid_fkey FOREIGN KEY (entryid) REFERENCES public.finentry(entryid);


--
-- Name: negotiationgeneratedentries_negotiationid_fkey; Type: FK CONSTRAINT; Schema: fin; Owner: postgres
--

ALTER TABLE ONLY negotiationgeneratedentries
    ADD CONSTRAINT negotiationgeneratedentries_negotiationid_fkey FOREIGN KEY (negotiationid) REFERENCES negotiation(negotiationid);


SET search_path = hur, pg_catalog;

--
-- Name: realizedactivity_activitytypeid_fkey; Type: FK CONSTRAINT; Schema: hur; Owner: postgres
--

ALTER TABLE ONLY realizedactivity
    ADD CONSTRAINT realizedactivity_activitytypeid_fkey FOREIGN KEY (activitytypeid) REFERENCES activitytype(activitytypeid);


--
-- Name: realizedactivity_scheduledactivityid_fkey; Type: FK CONSTRAINT; Schema: hur; Owner: postgres
--

ALTER TABLE ONLY realizedactivity
    ADD CONSTRAINT realizedactivity_scheduledactivityid_fkey FOREIGN KEY (scheduledactivityid) REFERENCES scheduledactivity(scheduledactivityid);


--
-- Name: realizedactivityparticipant_personid_fkey; Type: FK CONSTRAINT; Schema: hur; Owner: postgres
--

ALTER TABLE ONLY realizedactivityparticipant
    ADD CONSTRAINT realizedactivityparticipant_personid_fkey FOREIGN KEY (personid) REFERENCES public.basperson(personid);


--
-- Name: realizedactivityparticipant_realizedactivityid_fkey; Type: FK CONSTRAINT; Schema: hur; Owner: postgres
--

ALTER TABLE ONLY realizedactivityparticipant
    ADD CONSTRAINT realizedactivityparticipant_realizedactivityid_fkey FOREIGN KEY (realizedactivityid) REFERENCES realizedactivity(realizedactivityid);


--
-- Name: scheduledactivity_activitytypeid_fkey; Type: FK CONSTRAINT; Schema: hur; Owner: postgres
--

ALTER TABLE ONLY scheduledactivity
    ADD CONSTRAINT scheduledactivity_activitytypeid_fkey FOREIGN KEY (activitytypeid) REFERENCES activitytype(activitytypeid);


--
-- Name: scheduledactivityparticipant_personid_fkey; Type: FK CONSTRAINT; Schema: hur; Owner: postgres
--

ALTER TABLE ONLY scheduledactivityparticipant
    ADD CONSTRAINT scheduledactivityparticipant_personid_fkey FOREIGN KEY (personid) REFERENCES public.basperson(personid);


--
-- Name: scheduledactivityparticipant_scheduledactivityid_fkey; Type: FK CONSTRAINT; Schema: hur; Owner: postgres
--

ALTER TABLE ONLY scheduledactivityparticipant
    ADD CONSTRAINT scheduledactivityparticipant_scheduledactivityid_fkey FOREIGN KEY (scheduledactivityid) REFERENCES scheduledactivity(scheduledactivityid);


SET search_path = ins, pg_catalog;

--
-- Name: fkmaterial140242; Type: FK CONSTRAINT; Schema: ins; Owner: postgres
--

ALTER TABLE ONLY material
    ADD CONSTRAINT fkmaterial140242 FOREIGN KEY (physicalresourceid, physicalresourceversion) REFERENCES public.insphysicalresource(physicalresourceid, physicalresourceversion);


--
-- Name: fkmaterial960026; Type: FK CONSTRAINT; Schema: ins; Owner: postgres
--

ALTER TABLE ONLY material
    ADD CONSTRAINT fkmaterial960026 FOREIGN KEY (materialtypeid) REFERENCES materialtype(materialtypeid);


--
-- Name: fkmateriallo508196; Type: FK CONSTRAINT; Schema: ins; Owner: postgres
--

ALTER TABLE ONLY materialloan
    ADD CONSTRAINT fkmateriallo508196 FOREIGN KEY (materialrequestid) REFERENCES materialrequest(materialrequestid);


--
-- Name: fkmateriallo750983; Type: FK CONSTRAINT; Schema: ins; Owner: postgres
--

ALTER TABLE ONLY materialloan
    ADD CONSTRAINT fkmateriallo750983 FOREIGN KEY (personid) REFERENCES public.basphysicalperson(personid);


--
-- Name: fkmaterialre379978; Type: FK CONSTRAINT; Schema: ins; Owner: postgres
--

ALTER TABLE ONLY materialrequest
    ADD CONSTRAINT fkmaterialre379978 FOREIGN KEY (materialtypeid) REFERENCES materialtype(materialtypeid);


--
-- Name: fkmaterialre417259; Type: FK CONSTRAINT; Schema: ins; Owner: postgres
--

ALTER TABLE ONLY materialrequest
    ADD CONSTRAINT fkmaterialre417259 FOREIGN KEY (personid) REFERENCES public.basphysicalperson(personid);


--
-- Name: fkmaterialre983048; Type: FK CONSTRAINT; Schema: ins; Owner: postgres
--

ALTER TABLE ONLY materialrequest
    ADD CONSTRAINT fkmaterialre983048 FOREIGN KEY (materialid) REFERENCES material(materialid);


--
-- Name: materialloan_personid_fkey; Type: FK CONSTRAINT; Schema: ins; Owner: postgres
--

ALTER TABLE ONLY materialloan
    ADD CONSTRAINT materialloan_personid_fkey FOREIGN KEY (personid) REFERENCES public.basperson(personid);


--
-- Name: materialrequest_personid_fkey; Type: FK CONSTRAINT; Schema: ins; Owner: postgres
--

ALTER TABLE ONLY materialrequest
    ADD CONSTRAINT materialrequest_personid_fkey FOREIGN KEY (personid) REFERENCES public.basperson(personid);


SET search_path = public, pg_catalog;

--
-- Name: __pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcurso
    ADD CONSTRAINT __pk FOREIGN KEY (cursorepresentanteid) REFERENCES acpcurso(cursoid);


--
-- Name: accaccountbalance_accountschemeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY accaccountbalance
    ADD CONSTRAINT accaccountbalance_accountschemeid_fkey FOREIGN KEY (accountschemeid) REFERENCES accaccountscheme(accountschemeid);


--
-- Name: accaccountbalance_accountschemeid_fkey1; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY accaccountbalance
    ADD CONSTRAINT accaccountbalance_accountschemeid_fkey1 FOREIGN KEY (accountschemeid) REFERENCES accaccountscheme(accountschemeid);


--
-- Name: accaccountscheme_accountschemeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY accaccountscheme
    ADD CONSTRAINT accaccountscheme_accountschemeid_fkey FOREIGN KEY (parentaccountschemeid) REFERENCES accaccountscheme(accountschemeid);


--
-- Name: acccostcenter_parentcostcenterid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acccostcenter
    ADD CONSTRAINT acccostcenter_parentcostcenterid_fkey FOREIGN KEY (parentcostcenterid) REFERENCES acccostcenter(costcenterid);


--
-- Name: acccostcenter_personidowner_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acccostcenter
    ADD CONSTRAINT acccostcenter_personidowner_fkey FOREIGN KEY (personidowner) REFERENCES basphysicalpersonemployee(personid);


--
-- Name: acccourseaccount_accountschemeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acccourseaccount
    ADD CONSTRAINT acccourseaccount_accountschemeid_fkey FOREIGN KEY (accountschemeid) REFERENCES accaccountscheme(accountschemeid);


--
-- Name: acccourseaccount_costcenterid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acccourseaccount
    ADD CONSTRAINT acccourseaccount_costcenterid_fkey FOREIGN KEY (costcenterid) REFERENCES acccostcenter(costcenterid);


--
-- Name: acccourseaccount_courseversion_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acccourseaccount
    ADD CONSTRAINT acccourseaccount_courseversion_fkey FOREIGN KEY (courseversion, courseid) REFERENCES acdcourseversion(courseversion, courseid);


--
-- Name: acccourseaccount_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acccourseaccount
    ADD CONSTRAINT acccourseaccount_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acccoursebalance_accountschemeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acccoursebalance
    ADD CONSTRAINT acccoursebalance_accountschemeid_fkey FOREIGN KEY (accountschemeid, source, balancedate) REFERENCES accaccountbalance(accountschemeid, source, balancedate);


--
-- Name: acccoursebalance_courseid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acccoursebalance
    ADD CONSTRAINT acccoursebalance_courseid_fkey FOREIGN KEY (courseid, courseversion, unitid) REFERENCES acccourseaccount(courseid, courseversion, unitid);


--
-- Name: accintegration_operationid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY accintegration
    ADD CONSTRAINT accintegration_operationid_fkey FOREIGN KEY (operationid) REFERENCES finoperation(operationid);


--
-- Name: accpersonbalance_accountschemeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY accpersonbalance
    ADD CONSTRAINT accpersonbalance_accountschemeid_fkey FOREIGN KEY (accountschemeid) REFERENCES accaccountscheme(accountschemeid);


--
-- Name: accpersonbalance_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY accpersonbalance
    ADD CONSTRAINT accpersonbalance_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: acdacademiccalendar_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdacademiccalendar
    ADD CONSTRAINT acdacademiccalendar_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acdacademiccalendarevent_acdcourseoccurrence_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdacademiccalendarevent
    ADD CONSTRAINT acdacademiccalendarevent_acdcourseoccurrence_fkey FOREIGN KEY (courseid, courseversion, turnid, unitid) REFERENCES acdcourseoccurrence(courseid, courseversion, turnid, unitid);


--
-- Name: acdacademiccalendarevent_calendaryear_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdacademiccalendarevent
    ADD CONSTRAINT acdacademiccalendarevent_calendaryear_fkey FOREIGN KEY (calendaryear) REFERENCES acdacademiccalendar(calendaryear);


--
-- Name: acdacademiccalendarevent_ocorrenciacursoid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdacademiccalendarevent
    ADD CONSTRAINT acdacademiccalendarevent_ocorrenciacursoid_fkey FOREIGN KEY (ocorrenciacursoid) REFERENCES acpocorrenciacurso(ocorrenciacursoid);


--
-- Name: acdcenter_directorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcenter
    ADD CONSTRAINT acdcenter_directorid_fkey FOREIGN KEY (directorid) REFERENCES basphysicalpersonprofessor(personid);


--
-- Name: acdcertified_certifiedtypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcertified
    ADD CONSTRAINT acdcertified_certifiedtypeid_fkey FOREIGN KEY (certifiedtypeid) REFERENCES acdcertifiedtype(certifiedtypeid);


--
-- Name: acdcertified_courseid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcertified
    ADD CONSTRAINT acdcertified_courseid_fkey FOREIGN KEY (courseid, courseversion, unitid, turnid) REFERENCES acdcourseoccurrence(courseid, courseversion, unitid, turnid);


--
-- Name: acdcertified_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcertified
    ADD CONSTRAINT acdcertified_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: acdclass_initiallearningperiodid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdclass
    ADD CONSTRAINT acdclass_initiallearningperiodid_fkey FOREIGN KEY (initiallearningperiodid) REFERENCES acdlearningperiod(learningperiodid);


--
-- Name: acdclass_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdclass
    ADD CONSTRAINT acdclass_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acdclasspupil_classid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdclasspupil
    ADD CONSTRAINT acdclasspupil_classid_fkey FOREIGN KEY (classid) REFERENCES acdclass(classid);


--
-- Name: acdclasspupil_contractid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdclasspupil
    ADD CONSTRAINT acdclasspupil_contractid_fkey FOREIGN KEY (contractid) REFERENCES acdcontract(contractid);


--
-- Name: acdclasspupil_reasonid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdclasspupil
    ADD CONSTRAINT acdclasspupil_reasonid_fkey FOREIGN KEY (reasonid) REFERENCES acdreason(reasonid);


--
-- Name: acdclasspupil_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdclasspupil
    ADD CONSTRAINT acdclasspupil_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acdcomplementaryactivities_complementaryactivitiescategory_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcomplementaryactivities
    ADD CONSTRAINT acdcomplementaryactivities_complementaryactivitiescategory_fkey FOREIGN KEY (complementaryactivitiescategoryid) REFERENCES acdcomplementaryactivitiescategory(complementaryactivitiescategoryid);


--
-- Name: acdcomplementaryactivities_curriculumidold_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcomplementaryactivities
    ADD CONSTRAINT acdcomplementaryactivities_curriculumidold_fkey FOREIGN KEY (curriculumidold) REFERENCES acdcurriculum(curriculumid);


--
-- Name: acdcomplementaryactivities_enrollid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcomplementaryactivities
    ADD CONSTRAINT acdcomplementaryactivities_enrollid_fkey FOREIGN KEY (enrollid) REFERENCES acdenroll(enrollid);


--
-- Name: acdcomplementaryactivities_periodid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcomplementaryactivities
    ADD CONSTRAINT acdcomplementaryactivities_periodid_fkey FOREIGN KEY (periodid) REFERENCES acdperiod(periodid);


--
-- Name: acdcomplementaryactivitiescat_complementaryactivitiescateg_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcomplementaryactivitiescategoryrules
    ADD CONSTRAINT acdcomplementaryactivitiescat_complementaryactivitiescateg_fkey FOREIGN KEY (complementaryactivitiescategoryid) REFERENCES acdcomplementaryactivitiescategory(complementaryactivitiescategoryid);


--
-- Name: acdcomplementaryactivitiescategoryrules_curriculumid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcomplementaryactivitiescategoryrules
    ADD CONSTRAINT acdcomplementaryactivitiescategoryrules_curriculumid_fkey FOREIGN KEY (curriculumid) REFERENCES acdcurriculum(curriculumid);


--
-- Name: acdcomplementaryenroll_contractid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcomplementaryenroll
    ADD CONSTRAINT acdcomplementaryenroll_contractid_fkey FOREIGN KEY (contractid) REFERENCES acdcontract(contractid);


--
-- Name: acdcomplementaryenroll_curriculumid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcomplementaryenroll
    ADD CONSTRAINT acdcomplementaryenroll_curriculumid_fkey FOREIGN KEY (curriculumid) REFERENCES acdcurriculum(curriculumid);


--
-- Name: acdcomplementaryenroll_enrollstatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcomplementaryenroll
    ADD CONSTRAINT acdcomplementaryenroll_enrollstatusid_fkey FOREIGN KEY (enrollstatusid) REFERENCES acdenrollstatus(statusid);


--
-- Name: acdcomplementaryenroll_institutionid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcomplementaryenroll
    ADD CONSTRAINT acdcomplementaryenroll_institutionid_fkey FOREIGN KEY (institutionid) REFERENCES baslegalperson(personid);


--
-- Name: acdconcept_conceptgroupid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdconcept
    ADD CONSTRAINT acdconcept_conceptgroupid_fkey FOREIGN KEY (conceptgroupid) REFERENCES acdconceptgroup(conceptgroupid);


--
-- Name: acdconcept_enrollstatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdconcept
    ADD CONSTRAINT acdconcept_enrollstatusid_fkey FOREIGN KEY (enrollstatusid) REFERENCES acdenrollstatus(statusid);


--
-- Name: acdcondition_conditioncurriculumid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcondition
    ADD CONSTRAINT acdcondition_conditioncurriculumid_fkey FOREIGN KEY (conditioncurriculumid) REFERENCES acdcurriculum(curriculumid);


--
-- Name: acdcondition_curriculumid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcondition
    ADD CONSTRAINT acdcondition_curriculumid_fkey FOREIGN KEY (curriculumid) REFERENCES acdcurriculum(curriculumid);


--
-- Name: acdcondition_educationareaid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcondition
    ADD CONSTRAINT acdcondition_educationareaid_fkey FOREIGN KEY (educationareaid) REFERENCES acdeducationarea(educationareaid);


--
-- Name: acdcondition_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcondition
    ADD CONSTRAINT acdcondition_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acdcontract_bankaccountid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcontract
    ADD CONSTRAINT acdcontract_bankaccountid_fkey FOREIGN KEY (bankaccountid) REFERENCES finbankaccountinvoiceinfo(bankaccountid);


--
-- Name: acdcontract_cityid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcontract
    ADD CONSTRAINT acdcontract_cityid_fkey FOREIGN KEY (cityid) REFERENCES bascity(cityid);


--
-- Name: acdcontract_courseversion_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcontract
    ADD CONSTRAINT acdcontract_courseversion_fkey FOREIGN KEY (courseversion, courseid, turnid, unitid) REFERENCES acdcourseoccurrence(courseversion, courseid, turnid, unitid);


--
-- Name: acdcontract_enadestatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcontract
    ADD CONSTRAINT acdcontract_enadestatusid_fkey FOREIGN KEY (enadestatusid) REFERENCES acdenadestatus(enadestatusid);


--
-- Name: acdcontract_externalcontractid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcontract
    ADD CONSTRAINT acdcontract_externalcontractid_fkey FOREIGN KEY (internalcontractid) REFERENCES acdcontract(contractid);


--
-- Name: acdcontract_externalcourseid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcontract
    ADD CONSTRAINT acdcontract_externalcourseid_fkey FOREIGN KEY (externalcourseid) REFERENCES acdexternalcourse(externalcourseid);


--
-- Name: acdcontract_externaloccurrencecourseid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcontract
    ADD CONSTRAINT acdcontract_externaloccurrencecourseid_fkey FOREIGN KEY (internalcourseoccurrenceid, internalcourseoccurrenceversion, internalunitid, internalturnid) REFERENCES acdcourseoccurrence(courseid, courseversion, unitid, turnid);


--
-- Name: acdcontract_formationperiodid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcontract
    ADD CONSTRAINT acdcontract_formationperiodid_fkey FOREIGN KEY (formationperiodid) REFERENCES acdperiod(periodid);


--
-- Name: acdcontract_institutionid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcontract
    ADD CONSTRAINT acdcontract_institutionid_fkey FOREIGN KEY (externalconclusioninstitutionid) REFERENCES baslegalperson(personid);


--
-- Name: acdcontract_institutionid_fkey1; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcontract
    ADD CONSTRAINT acdcontract_institutionid_fkey1 FOREIGN KEY (institutionid) REFERENCES baslegalperson(personid);


--
-- Name: acdcontract_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcontract
    ADD CONSTRAINT acdcontract_personid_fkey FOREIGN KEY (personid) REFERENCES basphysicalpersonstudent(personid);


--
-- Name: acdcontract_subscriptionid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcontract
    ADD CONSTRAINT acdcontract_subscriptionid_fkey FOREIGN KEY (subscriptionid) REFERENCES spr.subscription(subscriptionid);


--
-- Name: acdcontractexaminingboard_contractid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcontractexaminingboard
    ADD CONSTRAINT acdcontractexaminingboard_contractid_fkey FOREIGN KEY (contractid) REFERENCES acdcontract(contractid);


--
-- Name: acdcontractexaminingboard_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcontractexaminingboard
    ADD CONSTRAINT acdcontractexaminingboard_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acdcourse_centerid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourse
    ADD CONSTRAINT acdcourse_centerid_fkey FOREIGN KEY (centerid) REFERENCES acdcenter(centerid);


--
-- Name: acdcourse_educationareaid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourse
    ADD CONSTRAINT acdcourse_educationareaid_fkey FOREIGN KEY (educationareaid) REFERENCES acdeducationarea(educationareaid);


--
-- Name: acdcourse_formationlevelid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourse
    ADD CONSTRAINT acdcourse_formationlevelid_fkey FOREIGN KEY (formationlevelid) REFERENCES acdformationlevel(formationlevelid);


--
-- Name: acdcourse_incomesourceid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourse
    ADD CONSTRAINT acdcourse_incomesourceid_fkey FOREIGN KEY (incomesourceid) REFERENCES finincomesource(incomesourceid);


--
-- Name: acdcourse_knowledgeareaid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourse
    ADD CONSTRAINT acdcourse_knowledgeareaid_fkey FOREIGN KEY (knowledgeareaid) REFERENCES acdknowledgearea(knowledgeareaid);


--
-- Name: acdcourseability_courseversion_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourseability
    ADD CONSTRAINT acdcourseability_courseversion_fkey FOREIGN KEY (courseversion, courseid) REFERENCES acdcourseversion(courseversion, courseid);


--
-- Name: acdcoursecoordinator_coordinatorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcoursecoordinator
    ADD CONSTRAINT acdcoursecoordinator_coordinatorid_fkey FOREIGN KEY (coordinatorid) REFERENCES basphysicalpersonprofessor(personid);


--
-- Name: acdcoursecoordinator_courseid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcoursecoordinator
    ADD CONSTRAINT acdcoursecoordinator_courseid_fkey FOREIGN KEY (courseid, courseversion, turnid, unitid) REFERENCES acdcourseoccurrence(courseid, courseversion, turnid, unitid);


--
-- Name: acdcourseoccurrence_costcenterid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourseoccurrence
    ADD CONSTRAINT acdcourseoccurrence_costcenterid_fkey FOREIGN KEY (costcenterid) REFERENCES acccostcenter(costcenterid);


--
-- Name: acdcourseoccurrence_courseversion_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourseoccurrence
    ADD CONSTRAINT acdcourseoccurrence_courseversion_fkey FOREIGN KEY (courseversion, courseid) REFERENCES acdcourseversion(courseversion, courseid);


--
-- Name: acdcourseoccurrence_turnid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourseoccurrence
    ADD CONSTRAINT acdcourseoccurrence_turnid_fkey FOREIGN KEY (turnid) REFERENCES basturn(turnid);


--
-- Name: acdcourseoccurrence_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourseoccurrence
    ADD CONSTRAINT acdcourseoccurrence_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acdcourseversion_courseid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourseversion
    ADD CONSTRAINT acdcourseversion_courseid_fkey FOREIGN KEY (courseid) REFERENCES acdcourse(courseid);


--
-- Name: acdcourseversion_courseversiontypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourseversion
    ADD CONSTRAINT acdcourseversion_courseversiontypeid_fkey FOREIGN KEY (courseversiontypeid) REFERENCES acdcourseversiontype(courseversiontypeid);


--
-- Name: acdcourseversiontype_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourseversiontype
    ADD CONSTRAINT acdcourseversiontype_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acdcurricularcomponent_centerid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurricularcomponent
    ADD CONSTRAINT acdcurricularcomponent_centerid_fkey FOREIGN KEY (centerid) REFERENCES acdcenter(centerid);


--
-- Name: acdcurricularcomponent_educationareaid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurricularcomponent
    ADD CONSTRAINT acdcurricularcomponent_educationareaid_fkey FOREIGN KEY (educationareaid) REFERENCES acdeducationarea(educationareaid);


--
-- Name: acdcurricularcomponentcategor_curricularcomponentcategoryi_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurricularcomponentcategorycredit
    ADD CONSTRAINT acdcurricularcomponentcategor_curricularcomponentcategoryi_fkey FOREIGN KEY (curricularcomponentcategoryid) REFERENCES acdcurricularcomponentcategory(curricularcomponentcategoryid);


--
-- Name: acdcurricularcomponentcategorycredi_curricularcomponentid_fkey1; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurricularcomponentcategorycredit
    ADD CONSTRAINT acdcurricularcomponentcategorycredi_curricularcomponentid_fkey1 FOREIGN KEY (curricularcomponentid, curricularcomponentversion) REFERENCES acdcurricularcomponent(curricularcomponentid, curricularcomponentversion);


--
-- Name: acdcurricularcomponentcategorycredit_curricularcomponentid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurricularcomponentcategorycredit
    ADD CONSTRAINT acdcurricularcomponentcategorycredit_curricularcomponentid_fkey FOREIGN KEY (curricularcomponentid, curricularcomponentversion) REFERENCES acdcurricularcomponent(curricularcomponentid, curricularcomponentversion);


--
-- Name: acdcurricularcomponentgroup_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurricularcomponentgroup
    ADD CONSTRAINT acdcurricularcomponentgroup_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acdcurricularcomponentunblock_contractid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurricularcomponentunblock
    ADD CONSTRAINT acdcurricularcomponentunblock_contractid_fkey FOREIGN KEY (contractid) REFERENCES acdcontract(contractid);


--
-- Name: acdcurricularcomponentunblock_curricularcomponentid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurricularcomponentunblock
    ADD CONSTRAINT acdcurricularcomponentunblock_curricularcomponentid_fkey FOREIGN KEY (curricularcomponentid, curricularcomponentversion) REFERENCES acdcurricularcomponent(curricularcomponentid, curricularcomponentversion);


--
-- Name: acdcurricularcomponentunblock_curriculumid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurricularcomponentunblock
    ADD CONSTRAINT acdcurricularcomponentunblock_curriculumid_fkey FOREIGN KEY (curriculumid) REFERENCES acdcurriculum(curriculumid);


--
-- Name: acdcurricularcomponentunblock_learningperiodid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurricularcomponentunblock
    ADD CONSTRAINT acdcurricularcomponentunblock_learningperiodid_fkey FOREIGN KEY (learningperiodid) REFERENCES acdlearningperiod(learningperiodid);


--
-- Name: acdcurriculum_courseid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurriculum
    ADD CONSTRAINT acdcurriculum_courseid_fkey FOREIGN KEY (courseid, courseversion, turnid, unitid) REFERENCES acdcourseoccurrence(courseid, courseversion, turnid, unitid);


--
-- Name: acdcurriculum_curricularcomponentgroupdocumentendcourseid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurriculum
    ADD CONSTRAINT acdcurriculum_curricularcomponentgroupdocumentendcourseid_fkey FOREIGN KEY (curricularcomponentgroupdocumentendcourseid) REFERENCES acdcurricularcomponentgroup(curricularcomponentgroupid);


--
-- Name: acdcurriculum_curricularcomponentgroupelectiveid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurriculum
    ADD CONSTRAINT acdcurriculum_curricularcomponentgroupelectiveid_fkey FOREIGN KEY (curricularcomponentgroupelectiveid) REFERENCES acdcurricularcomponentgroup(curricularcomponentgroupid);


--
-- Name: acdcurriculum_curricularcomponentid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurriculum
    ADD CONSTRAINT acdcurriculum_curricularcomponentid_fkey FOREIGN KEY (curricularcomponentid, curricularcomponentversion) REFERENCES acdcurricularcomponent(curricularcomponentid, curricularcomponentversion);


--
-- Name: acdcurriculum_curricularcomponenttypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurriculum
    ADD CONSTRAINT acdcurriculum_curricularcomponenttypeid_fkey FOREIGN KEY (curricularcomponenttypeid) REFERENCES acdcurricularcomponenttype(curricularcomponenttypeid);


--
-- Name: acdcurriculum_curriculumtypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurriculum
    ADD CONSTRAINT acdcurriculum_curriculumtypeid_fkey FOREIGN KEY (curriculumtypeid) REFERENCES acdcurriculumtype(curriculumtypeid);


--
-- Name: acdcurriculumconcurrence_curriculuminid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurriculumconcurrence
    ADD CONSTRAINT acdcurriculumconcurrence_curriculuminid_fkey FOREIGN KEY (curriculuminid) REFERENCES acdcurriculum(curriculumid);


--
-- Name: acdcurriculumconcurrence_curriculumoutid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurriculumconcurrence
    ADD CONSTRAINT acdcurriculumconcurrence_curriculumoutid_fkey FOREIGN KEY (curriculumoutid) REFERENCES acdcurriculum(curriculumid);


--
-- Name: acdcurriculumconcurrence_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurriculumconcurrence
    ADD CONSTRAINT acdcurriculumconcurrence_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acdcurriculumlink_curriculumid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurriculumlink
    ADD CONSTRAINT acdcurriculumlink_curriculumid_fkey FOREIGN KEY (curriculumid) REFERENCES acdcurriculum(curriculumid);


--
-- Name: acdcurriculumlink_curriculumlinkid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurriculumlink
    ADD CONSTRAINT acdcurriculumlink_curriculumlinkid_fkey FOREIGN KEY (curriculumlinkid) REFERENCES acdcurriculum(curriculumid);


--
-- Name: acdcurriculumlink_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcurriculumlink
    ADD CONSTRAINT acdcurriculumlink_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acddegree_learningperiodid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acddegree
    ADD CONSTRAINT acddegree_learningperiodid_fkey FOREIGN KEY (learningperiodid) REFERENCES acdlearningperiod(learningperiodid);


--
-- Name: acddegree_parentdegreeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acddegree
    ADD CONSTRAINT acddegree_parentdegreeid_fkey FOREIGN KEY (parentdegreeid) REFERENCES acddegree(degreeid);


--
-- Name: acddegreecurricularcomponentgro_curricularcomponentgroupid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acddegreecurricularcomponentgroup
    ADD CONSTRAINT acddegreecurricularcomponentgro_curricularcomponentgroupid_fkey FOREIGN KEY (curricularcomponentgroupid) REFERENCES acdcurricularcomponentgroup(curricularcomponentgroupid);


--
-- Name: acddegreecurricularcomponentgroup_contractid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acddegreecurricularcomponentgroup
    ADD CONSTRAINT acddegreecurricularcomponentgroup_contractid_fkey FOREIGN KEY (contractid) REFERENCES acdcontract(contractid);


--
-- Name: acddegreecurricularcomponentgroup_enrollstatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acddegreecurricularcomponentgroup
    ADD CONSTRAINT acddegreecurricularcomponentgroup_enrollstatusid_fkey FOREIGN KEY (enrollstatusid) REFERENCES acdenrollstatus(statusid);


--
-- Name: acddegreecurricularcomponentgroup_learningperiodid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acddegreecurricularcomponentgroup
    ADD CONSTRAINT acddegreecurricularcomponentgroup_learningperiodid_fkey FOREIGN KEY (learningperiodid) REFERENCES acdlearningperiod(learningperiodid);


--
-- Name: acddegreeenroll_degreeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acddegreeenroll
    ADD CONSTRAINT acddegreeenroll_degreeid_fkey FOREIGN KEY (degreeid) REFERENCES acddegree(degreeid);


--
-- Name: acddegreeenroll_enrollid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acddegreeenroll
    ADD CONSTRAINT acddegreeenroll_enrollid_fkey FOREIGN KEY (enrollid) REFERENCES acdenroll(enrollid);


--
-- Name: acddetailenrollstatus_parentstatus_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acddetailenrollstatus
    ADD CONSTRAINT acddetailenrollstatus_parentstatus_fkey FOREIGN KEY (parentstatus) REFERENCES acdenrollstatus(statusid);


--
-- Name: acddiploma_contractid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acddiploma
    ADD CONSTRAINT acddiploma_contractid_fkey FOREIGN KEY (contractid) REFERENCES acdcontract(contractid);


--
-- Name: acdenroll_contractid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenroll
    ADD CONSTRAINT acdenroll_contractid_fkey FOREIGN KEY (contractid) REFERENCES acdcontract(contractid);


--
-- Name: acdenroll_curriculumid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenroll
    ADD CONSTRAINT acdenroll_curriculumid_fkey FOREIGN KEY (curriculumid) REFERENCES acdcurriculum(curriculumid);


--
-- Name: acdenroll_detailenrollstatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenroll
    ADD CONSTRAINT acdenroll_detailenrollstatusid_fkey FOREIGN KEY (detailenrollstatusid) REFERENCES acddetailenrollstatus(detailenrollstatusid);


--
-- Name: acdenroll_exploitationinstitutionid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenroll
    ADD CONSTRAINT acdenroll_exploitationinstitutionid_fkey FOREIGN KEY (exploitationinstitutionid) REFERENCES baslegalperson(personid);


--
-- Name: acdenroll_groupid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenroll
    ADD CONSTRAINT acdenroll_groupid_fkey FOREIGN KEY (groupid) REFERENCES acdgroup(groupid);


--
-- Name: acdenroll_learningperiodid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenroll
    ADD CONSTRAINT acdenroll_learningperiodid_fkey FOREIGN KEY (learningperiodid) REFERENCES acdlearningperiod(learningperiodid);


--
-- Name: acdenroll_reasoncancellationid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenroll
    ADD CONSTRAINT acdenroll_reasoncancellationid_fkey FOREIGN KEY (reasoncancellationid) REFERENCES acdreasoncancellation(reasoncancellationid);


--
-- Name: acdenroll_statusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenroll
    ADD CONSTRAINT acdenroll_statusid_fkey FOREIGN KEY (statusid) REFERENCES acdenrollstatus(statusid);


--
-- Name: acdenroll_subclassid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenroll
    ADD CONSTRAINT acdenroll_subclassid_fkey FOREIGN KEY (subclassid) REFERENCES acdsubclass(subclassid);


--
-- Name: acdenroll_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenroll
    ADD CONSTRAINT acdenroll_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acdenrollbookdata_courseid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenrollbookdata
    ADD CONSTRAINT acdenrollbookdata_courseid_fkey FOREIGN KEY (courseid, courseversion, turnid, unitid) REFERENCES acdcourseoccurrence(courseid, courseversion, turnid, unitid);


--
-- Name: acdenrollbookdata_periodid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenrollbookdata
    ADD CONSTRAINT acdenrollbookdata_periodid_fkey FOREIGN KEY (periodid) REFERENCES acdperiod(periodid);


--
-- Name: acdenrollbookdata_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenrollbookdata
    ADD CONSTRAINT acdenrollbookdata_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: acdenrollbookdata_prevcourseid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenrollbookdata
    ADD CONSTRAINT acdenrollbookdata_prevcourseid_fkey FOREIGN KEY (prevcourseid, prevcourseversion, prevturnid, prevunitid) REFERENCES acdcourseoccurrence(courseid, courseversion, turnid, unitid);


--
-- Name: acdenrollconfig_confirmationemailid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenrollconfig
    ADD CONSTRAINT acdenrollconfig_confirmationemailid_fkey FOREIGN KEY (confirmationemailid) REFERENCES basemail(emailid);


--
-- Name: acdenrollconfirm_contractid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenrollconfirm
    ADD CONSTRAINT acdenrollconfirm_contractid_fkey FOREIGN KEY (contractid) REFERENCES acdcontract(contractid);


--
-- Name: acdenrollconfirm_learningperiodid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenrollconfirm
    ADD CONSTRAINT acdenrollconfirm_learningperiodid_fkey FOREIGN KEY (learningperiodid) REFERENCES acdlearningperiod(learningperiodid);


--
-- Name: acdenrollsummary_contractid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenrollsummary
    ADD CONSTRAINT acdenrollsummary_contractid_fkey FOREIGN KEY (contractid) REFERENCES acdcontract(contractid);


--
-- Name: acdenrollsummary_learningperiodid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdenrollsummary
    ADD CONSTRAINT acdenrollsummary_learningperiodid_fkey FOREIGN KEY (learningperiodid) REFERENCES acdlearningperiod(learningperiodid);


--
-- Name: acdevaluation_degreeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdevaluation
    ADD CONSTRAINT acdevaluation_degreeid_fkey FOREIGN KEY (degreeid) REFERENCES acddegree(degreeid);


--
-- Name: acdevaluation_groupid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdevaluation
    ADD CONSTRAINT acdevaluation_groupid_fkey FOREIGN KEY (groupid) REFERENCES acdgroup(groupid);


--
-- Name: acdevaluation_professorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdevaluation
    ADD CONSTRAINT acdevaluation_professorid_fkey FOREIGN KEY (professorid) REFERENCES basphysicalpersonprofessor(personid);


--
-- Name: acdevaluation_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdevaluation
    ADD CONSTRAINT acdevaluation_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acdevaluationenroll_enrollid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdevaluationenroll
    ADD CONSTRAINT acdevaluationenroll_enrollid_fkey FOREIGN KEY (enrollid) REFERENCES acdenroll(enrollid);


--
-- Name: acdevaluationenroll_evaluationid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdevaluationenroll
    ADD CONSTRAINT acdevaluationenroll_evaluationid_fkey FOREIGN KEY (evaluationid) REFERENCES acdevaluation(evaluationid);


--
-- Name: acdevent_accountschemeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdevent
    ADD CONSTRAINT acdevent_accountschemeid_fkey FOREIGN KEY (accountschemeid) REFERENCES accaccountscheme(accountschemeid);


--
-- Name: acdevent_costcenterid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdevent
    ADD CONSTRAINT acdevent_costcenterid_fkey FOREIGN KEY (costcenterid) REFERENCES acccostcenter(costcenterid);


--
-- Name: acdevent_incomesourceid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdevent
    ADD CONSTRAINT acdevent_incomesourceid_fkey FOREIGN KEY (incomesourceid) REFERENCES finincomesource(incomesourceid);


--
-- Name: acdevent_policyid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdevent
    ADD CONSTRAINT acdevent_policyid_fkey FOREIGN KEY (policyid) REFERENCES finpolicy(policyid);


--
-- Name: acdevent_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdevent
    ADD CONSTRAINT acdevent_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acdeventparticipation_eventid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdeventparticipation
    ADD CONSTRAINT acdeventparticipation_eventid_fkey FOREIGN KEY (eventid) REFERENCES acdevent(eventid);


--
-- Name: acdeventparticipation_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdeventparticipation
    ADD CONSTRAINT acdeventparticipation_personid_fkey FOREIGN KEY (personid) REFERENCES basphysicalperson(personid);


--
-- Name: acdeventparticipation_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdeventparticipation
    ADD CONSTRAINT acdeventparticipation_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acdexamdate_learningperiodid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdexamdate
    ADD CONSTRAINT acdexamdate_learningperiodid_fkey FOREIGN KEY (learningperiodid) REFERENCES acdlearningperiod(learningperiodid);


--
-- Name: acdexamdate_weekdayid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdexamdate
    ADD CONSTRAINT acdexamdate_weekdayid_fkey FOREIGN KEY (weekdayid) REFERENCES basweekday(weekdayid);


--
-- Name: acdexploitation_electivecurriculumid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdexploitation
    ADD CONSTRAINT acdexploitation_electivecurriculumid_fkey FOREIGN KEY (electivecurriculumid) REFERENCES acdcurriculum(curriculumid);


--
-- Name: acdexploitation_enrollid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdexploitation
    ADD CONSTRAINT acdexploitation_enrollid_fkey FOREIGN KEY (enrollid) REFERENCES acdenroll(enrollid);


--
-- Name: acdexploitation_exploitationenrollid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdexploitation
    ADD CONSTRAINT acdexploitation_exploitationenrollid_fkey FOREIGN KEY (exploitationenrollid) REFERENCES acdenroll(enrollid);


--
-- Name: acdexploitation_institutionid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdexploitation
    ADD CONSTRAINT acdexploitation_institutionid_fkey FOREIGN KEY (institutionid) REFERENCES baslegalperson(personid);


--
-- Name: acdexploitation_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdexploitation
    ADD CONSTRAINT acdexploitation_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acdexternalcourse_knowledgeareaid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdexternalcourse
    ADD CONSTRAINT acdexternalcourse_knowledgeareaid_fkey FOREIGN KEY (knowledgeareaid) REFERENCES acdknowledgearea(knowledgeareaid);


--
-- Name: acdexternalcourse_knowledgeareaid_fkey1; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdexternalcourse
    ADD CONSTRAINT acdexternalcourse_knowledgeareaid_fkey1 FOREIGN KEY (knowledgeareaid) REFERENCES acdknowledgearea(knowledgeareaid);


--
-- Name: acdfinalexaminationdirectors_enrollid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdfinalexaminationdirectors
    ADD CONSTRAINT acdfinalexaminationdirectors_enrollid_fkey FOREIGN KEY (enrollid) REFERENCES acdenroll(enrollid);


--
-- Name: acdfinalexaminationdirectors_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdfinalexaminationdirectors
    ADD CONSTRAINT acdfinalexaminationdirectors_personid_fkey FOREIGN KEY (personid) REFERENCES basphysicalperson(personid);


--
-- Name: acdfinalexaminationexaminingboard_enrollid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdfinalexaminationexaminingboard
    ADD CONSTRAINT acdfinalexaminationexaminingboard_enrollid_fkey FOREIGN KEY (enrollid) REFERENCES acdenroll(enrollid);


--
-- Name: acdfinalexaminationexaminingboard_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdfinalexaminationexaminingboard
    ADD CONSTRAINT acdfinalexaminationexaminingboard_personid_fkey FOREIGN KEY (personid) REFERENCES basphysicalperson(personid);


--
-- Name: acdfinalexaminationknowledgearea_enrollid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdfinalexaminationknowledgearea
    ADD CONSTRAINT acdfinalexaminationknowledgearea_enrollid_fkey FOREIGN KEY (enrollid) REFERENCES acdenroll(enrollid);


--
-- Name: acdfinalexaminationknowledgearea_knowledgeareaid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdfinalexaminationknowledgearea
    ADD CONSTRAINT acdfinalexaminationknowledgearea_knowledgeareaid_fkey FOREIGN KEY (knowledgeareaid) REFERENCES acdknowledgearea(knowledgeareaid);


--
-- Name: acdfrequenceenroll_enrollid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdfrequenceenroll
    ADD CONSTRAINT acdfrequenceenroll_enrollid_fkey FOREIGN KEY (enrollid) REFERENCES acdenroll(enrollid);


--
-- Name: acdfrequenceenroll_scheduleid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdfrequenceenroll
    ADD CONSTRAINT acdfrequenceenroll_scheduleid_fkey FOREIGN KEY (scheduleid) REFERENCES acdschedule(scheduleid);


--
-- Name: acdfrequenceenroll_timeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdfrequenceenroll
    ADD CONSTRAINT acdfrequenceenroll_timeid_fkey FOREIGN KEY (timeid) REFERENCES acdtime(timeid);


--
-- Name: acdgroup_classid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdgroup
    ADD CONSTRAINT acdgroup_classid_fkey FOREIGN KEY (classid) REFERENCES acdclass(classid);


--
-- Name: acdgroup_conceptgroupid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdgroup
    ADD CONSTRAINT acdgroup_conceptgroupid_fkey FOREIGN KEY (conceptgroupid) REFERENCES acdconceptgroup(conceptgroupid);


--
-- Name: acdgroup_curriculumid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdgroup
    ADD CONSTRAINT acdgroup_curriculumid_fkey FOREIGN KEY (curriculumid) REFERENCES acdcurriculum(curriculumid);


--
-- Name: acdgroup_leaderid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdgroup
    ADD CONSTRAINT acdgroup_leaderid_fkey FOREIGN KEY (leaderid) REFERENCES basphysicalpersonstudent(personid);


--
-- Name: acdgroup_learningperiodid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdgroup
    ADD CONSTRAINT acdgroup_learningperiodid_fkey FOREIGN KEY (learningperiodid) REFERENCES acdlearningperiod(learningperiodid);


--
-- Name: acdgroup_professorresponsible_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdgroup
    ADD CONSTRAINT acdgroup_professorresponsible_fkey FOREIGN KEY (professorresponsible) REFERENCES basphysicalpersonprofessor(personid);


--
-- Name: acdgroup_regimenid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdgroup
    ADD CONSTRAINT acdgroup_regimenid_fkey FOREIGN KEY (regimenid) REFERENCES acdregimen(regimenid);


--
-- Name: acdgroup_subleaderid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdgroup
    ADD CONSTRAINT acdgroup_subleaderid_fkey FOREIGN KEY (subleaderid) REFERENCES basphysicalpersonstudent(personid);


--
-- Name: acdgroup_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdgroup
    ADD CONSTRAINT acdgroup_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acdgroupunblock_groupid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdgroupunblock
    ADD CONSTRAINT acdgroupunblock_groupid_fkey FOREIGN KEY (groupid) REFERENCES acdgroup(groupid);


--
-- Name: acdinterchange_contractid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdinterchange
    ADD CONSTRAINT acdinterchange_contractid_fkey FOREIGN KEY (contractid) REFERENCES acdcontract(contractid);


--
-- Name: acdinterchange_destinationcountryid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdinterchange
    ADD CONSTRAINT acdinterchange_destinationcountryid_fkey FOREIGN KEY (destinationcountryid) REFERENCES bascountry(countryid);


--
-- Name: acdinterchange_destinationinstitutionid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdinterchange
    ADD CONSTRAINT acdinterchange_destinationinstitutionid_fkey FOREIGN KEY (destinationinstitutionid) REFERENCES baslegalperson(personid);


--
-- Name: acdinterchange_interchangetypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdinterchange
    ADD CONSTRAINT acdinterchange_interchangetypeid_fkey FOREIGN KEY (interchangetypeid) REFERENCES acdinterchangetype(interchangetypeid);


--
-- Name: acdinterchange_origincountryid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdinterchange
    ADD CONSTRAINT acdinterchange_origincountryid_fkey FOREIGN KEY (origincountryid) REFERENCES bascountry(countryid);


--
-- Name: acdinterchange_origininstitutionid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdinterchange
    ADD CONSTRAINT acdinterchange_origininstitutionid_fkey FOREIGN KEY (origininstitutionid) REFERENCES baslegalperson(personid);


--
-- Name: acdinterchange_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdinterchange
    ADD CONSTRAINT acdinterchange_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: acdlearningperiod_courseid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdlearningperiod
    ADD CONSTRAINT acdlearningperiod_courseid_fkey FOREIGN KEY (courseid, courseversion, turnid, unitid) REFERENCES acdcourseoccurrence(courseid, courseversion, turnid, unitid);


--
-- Name: acdlearningperiod_evaluationcontrolmethodid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdlearningperiod
    ADD CONSTRAINT acdlearningperiod_evaluationcontrolmethodid_fkey FOREIGN KEY (evaluationcontrolmethodid) REFERENCES acdevaluationcontrolmethod(evaluationcontrolmethodid);


--
-- Name: acdlearningperiod_formationlevelid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdlearningperiod
    ADD CONSTRAINT acdlearningperiod_formationlevelid_fkey FOREIGN KEY (formationlevelid) REFERENCES acdformationlevel(formationlevelid);


--
-- Name: acdlearningperiod_periodid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdlearningperiod
    ADD CONSTRAINT acdlearningperiod_periodid_fkey FOREIGN KEY (periodid) REFERENCES acdperiod(periodid);


--
-- Name: acdmessagecontractrenewal_learningperiodid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdmessagecontractrenewal
    ADD CONSTRAINT acdmessagecontractrenewal_learningperiodid_fkey FOREIGN KEY (learningperiodid) REFERENCES acdlearningperiod(learningperiodid);


--
-- Name: acdmessagecontractrenewal_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdmessagecontractrenewal
    ADD CONSTRAINT acdmessagecontractrenewal_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acdmoodlesubscription_groupid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdmoodlesubscription
    ADD CONSTRAINT acdmoodlesubscription_groupid_fkey FOREIGN KEY (groupid) REFERENCES acdgroup(groupid);


--
-- Name: acdmoodlesubscription_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdmoodlesubscription
    ADD CONSTRAINT acdmoodlesubscription_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: acdmovementcontract_contractid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdmovementcontract
    ADD CONSTRAINT acdmovementcontract_contractid_fkey FOREIGN KEY (contractid) REFERENCES acdcontract(contractid);


--
-- Name: acdmovementcontract_learningperiodid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdmovementcontract
    ADD CONSTRAINT acdmovementcontract_learningperiodid_fkey FOREIGN KEY (learningperiodid) REFERENCES acdlearningperiod(learningperiodid);


--
-- Name: acdmovementcontract_reasonid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdmovementcontract
    ADD CONSTRAINT acdmovementcontract_reasonid_fkey FOREIGN KEY (reasonid) REFERENCES acdreason(reasonid);


--
-- Name: acdmovementcontract_statecontractid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdmovementcontract
    ADD CONSTRAINT acdmovementcontract_statecontractid_fkey FOREIGN KEY (statecontractid) REFERENCES acdstatecontract(statecontractid);


--
-- Name: acdmovementcontractcomplement_contractid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdmovementcontractcomplement
    ADD CONSTRAINT acdmovementcontractcomplement_contractid_fkey FOREIGN KEY (contractid, statecontractid, statetime) REFERENCES acdmovementcontract(contractid, statecontractid, statetime) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: acdmovementcontractcomplement_statecontractfieldid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdmovementcontractcomplement
    ADD CONSTRAINT acdmovementcontractcomplement_statecontractfieldid_fkey FOREIGN KEY (statecontractfieldid) REFERENCES acdstatecontractfield(statecontractfieldid);


--
-- Name: acdperiodenrolldate_learningperiodid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdperiodenrolldate
    ADD CONSTRAINT acdperiodenrolldate_learningperiodid_fkey FOREIGN KEY (learningperiodid) REFERENCES acdlearningperiod(learningperiodid);


--
-- Name: acdperiodenrolldate_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdperiodenrolldate
    ADD CONSTRAINT acdperiodenrolldate_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acdprofessorcurricularcomponent_curricularcomponentid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdprofessorcurricularcomponent
    ADD CONSTRAINT acdprofessorcurricularcomponent_curricularcomponentid_fkey FOREIGN KEY (curricularcomponentid, curricularcomponentversion) REFERENCES acdcurricularcomponent(curricularcomponentid, curricularcomponentversion);


--
-- Name: acdprofessorcurricularcomponent_professorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdprofessorcurricularcomponent
    ADD CONSTRAINT acdprofessorcurricularcomponent_professorid_fkey FOREIGN KEY (professorid) REFERENCES basphysicalpersonprofessor(personid);


--
-- Name: acdreason_statecontractid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdreason
    ADD CONSTRAINT acdreason_statecontractid_fkey FOREIGN KEY (statecontractid) REFERENCES acdstatecontract(statecontractid);


--
-- Name: acdreconhecimentodecurso_courseversion_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdreconhecimentodecurso
    ADD CONSTRAINT acdreconhecimentodecurso_courseversion_fkey FOREIGN KEY (courseversion, courseid, turnid, unitid) REFERENCES acdcourseoccurrence(courseversion, courseid, turnid, unitid);


--
-- Name: acdregimedomiciliar_enrollid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdregimedomiciliar
    ADD CONSTRAINT acdregimedomiciliar_enrollid_fkey FOREIGN KEY (enrollid) REFERENCES acdenroll(enrollid);


--
-- Name: acdrestricteddocuments_courseid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdrestricteddocuments
    ADD CONSTRAINT acdrestricteddocuments_courseid_fkey FOREIGN KEY (courseid, courseversion) REFERENCES acdcourseversion(courseid, courseversion);


--
-- Name: acdrestricteddocuments_documenttypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdrestricteddocuments
    ADD CONSTRAINT acdrestricteddocuments_documenttypeid_fkey FOREIGN KEY (documenttypeid) REFERENCES basdocumenttype(documenttypeid);


--
-- Name: acdrestricteddocuments_formationlevelid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdrestricteddocuments
    ADD CONSTRAINT acdrestricteddocuments_formationlevelid_fkey FOREIGN KEY (formationlevelid) REFERENCES acdformationlevel(formationlevelid);


--
-- Name: acdrestricteddocuments_turnid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdrestricteddocuments
    ADD CONSTRAINT acdrestricteddocuments_turnid_fkey FOREIGN KEY (turnid) REFERENCES basturn(turnid);


--
-- Name: acdrestricteddocuments_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdrestricteddocuments
    ADD CONSTRAINT acdrestricteddocuments_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acdschedule_groupid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdschedule
    ADD CONSTRAINT acdschedule_groupid_fkey FOREIGN KEY (groupid) REFERENCES acdgroup(groupid);


--
-- Name: acdschedule_physicalresourceid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdschedule
    ADD CONSTRAINT acdschedule_physicalresourceid_fkey FOREIGN KEY (physicalresourceid, physicalresourceversion) REFERENCES insphysicalresource(physicalresourceid, physicalresourceversion);


--
-- Name: acdschedule_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdschedule
    ADD CONSTRAINT acdschedule_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acdschedule_weekdayid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdschedule
    ADD CONSTRAINT acdschedule_weekdayid_fkey FOREIGN KEY (weekdayid) REFERENCES basweekday(weekdayid);


--
-- Name: acdschedule_weekdayid_fkey1; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdschedule
    ADD CONSTRAINT acdschedule_weekdayid_fkey1 FOREIGN KEY (weekdayid) REFERENCES basweekday(weekdayid);


--
-- Name: acdscheduleprofessor_professorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdscheduleprofessor
    ADD CONSTRAINT acdscheduleprofessor_professorid_fkey FOREIGN KEY (professorid) REFERENCES basphysicalpersonprofessor(personid);


--
-- Name: acdscheduleprofessor_scheduleid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdscheduleprofessor
    ADD CONSTRAINT acdscheduleprofessor_scheduleid_fkey FOREIGN KEY (scheduleid) REFERENCES acdschedule(scheduleid);


--
-- Name: acdscheduleprofessorcontent_scheduleprofessorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdscheduleprofessorcontent
    ADD CONSTRAINT acdscheduleprofessorcontent_scheduleprofessorid_fkey FOREIGN KEY (scheduleprofessorid) REFERENCES acdscheduleprofessor(scheduleprofessorid);


--
-- Name: acdscheduleprofessorcontent_timeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdscheduleprofessorcontent
    ADD CONSTRAINT acdscheduleprofessorcontent_timeid_fkey FOREIGN KEY (timeid) REFERENCES acdtime(timeid);


--
-- Name: acdscheduleprofessorcontent_visitingprofessorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdscheduleprofessorcontent
    ADD CONSTRAINT acdscheduleprofessorcontent_visitingprofessorid_fkey FOREIGN KEY (visitingprofessorid) REFERENCES basphysicalperson(personid);


--
-- Name: acdsemestercontractperiod_contractid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdsemestercontractperiod
    ADD CONSTRAINT acdsemestercontractperiod_contractid_fkey FOREIGN KEY (contractid) REFERENCES acdcontract(contractid);


--
-- Name: acdsemestercontractperiod_periodid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdsemestercontractperiod
    ADD CONSTRAINT acdsemestercontractperiod_periodid_fkey FOREIGN KEY (periodid) REFERENCES acdperiod(periodid);


--
-- Name: acdstatecontractfield_statecontractid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdstatecontractfield
    ADD CONSTRAINT acdstatecontractfield_statecontractid_fkey FOREIGN KEY (statecontractid) REFERENCES acdstatecontract(statecontractid);


--
-- Name: acdstatetransition_beginstateid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdstatetransition
    ADD CONSTRAINT acdstatetransition_beginstateid_fkey FOREIGN KEY (beginstateid) REFERENCES acdstatecontract(statecontractid);


--
-- Name: acdstatetransition_endstateid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdstatetransition
    ADD CONSTRAINT acdstatetransition_endstateid_fkey FOREIGN KEY (endstateid) REFERENCES acdstatecontract(statecontractid);


--
-- Name: acdsubclass_classid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdsubclass
    ADD CONSTRAINT acdsubclass_classid_fkey FOREIGN KEY (classid) REFERENCES acdclass(classid);


--
-- Name: acdsubclass_groupid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdsubclass
    ADD CONSTRAINT acdsubclass_groupid_fkey FOREIGN KEY (groupid) REFERENCES acdgroup(groupid);


--
-- Name: acdsubclass_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdsubclass
    ADD CONSTRAINT acdsubclass_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: acdsubclass_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdsubclass
    ADD CONSTRAINT acdsubclass_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acdtestendcoursecontract_contractid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtestendcoursecontract
    ADD CONSTRAINT acdtestendcoursecontract_contractid_fkey FOREIGN KEY (contractid) REFERENCES acdcontract(contractid);


--
-- Name: acdtestendcoursecontract_testendcoursetypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtestendcoursecontract
    ADD CONSTRAINT acdtestendcoursecontract_testendcoursetypeid_fkey FOREIGN KEY (testendcoursetypeid) REFERENCES acdtestendcoursetype(testendcoursetypeid);


--
-- Name: acdtestendcoursetype_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtestendcoursetype
    ADD CONSTRAINT acdtestendcoursetype_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acdtime_timesheetid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtime
    ADD CONSTRAINT acdtime_timesheetid_fkey FOREIGN KEY (timesheetid) REFERENCES acdtimesheet(timesheetid);


--
-- Name: acdtime_turnid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtime
    ADD CONSTRAINT acdtime_turnid_fkey FOREIGN KEY (turnid) REFERENCES basturn(turnid);


--
-- Name: acdtimesheet_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtimesheet
    ADD CONSTRAINT acdtimesheet_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acdtrainingemphasis_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtrainingemphasis
    ADD CONSTRAINT acdtrainingemphasis_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acompanhamentodedisciplina_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acompanhamentodedisciplina
    ADD CONSTRAINT acompanhamentodedisciplina_personid_fkey FOREIGN KEY (personid, enrollid) REFERENCES acdfinalexaminationdirectors(personid, enrollid);


--
-- Name: acompanhamentodedisciplina_personid_fkey1; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acompanhamentodedisciplina
    ADD CONSTRAINT acompanhamentodedisciplina_personid_fkey1 FOREIGN KEY (personid, enrollid) REFERENCES acdfinalexaminationdirectors(personid, enrollid);


--
-- Name: acompanhamentodedisciplina_personid_fkey2; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acompanhamentodedisciplina
    ADD CONSTRAINT acompanhamentodedisciplina_personid_fkey2 FOREIGN KEY (personid, enrollid) REFERENCES acdfinalexaminationdirectors(personid, enrollid);


--
-- Name: acpcamposadicionaiscurso_cursoid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcamposadicionaiscurso
    ADD CONSTRAINT acpcamposadicionaiscurso_cursoid_pk FOREIGN KEY (cursoid) REFERENCES acpcurso(cursoid);


--
-- Name: acpcamposadicionaiscurso_perfilcursocamposadicionaisid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcamposadicionaiscurso
    ADD CONSTRAINT acpcamposadicionaiscurso_perfilcursocamposadicionaisid_pk FOREIGN KEY (perfilcursocamposadicionaisid) REFERENCES acpperfilcursocamposadicionais(perfilcursocamposadicionaisid);


--
-- Name: acpcanr_cdanid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentedeavaliacaonotarecuperacao
    ADD CONSTRAINT acpcanr_cdanid_pk FOREIGN KEY (componentedeavaliacaonotaid) REFERENCES acpcomponentedeavaliacaonota(componentedeavaliacaonotaid);


--
-- Name: acpcomponentecurricularbibliografia_componentecurricularid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentecurricularbibliografia
    ADD CONSTRAINT acpcomponentecurricularbibliografia_componentecurricularid_pk FOREIGN KEY (componentecurricularid) REFERENCES acpcomponentecurricular(componentecurricularid);


--
-- Name: acpcomponentecurriculardisciplina_componentecurricularid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentecurriculardisciplina
    ADD CONSTRAINT acpcomponentecurriculardisciplina_componentecurricularid_pk FOREIGN KEY (componentecurricularid) REFERENCES acpcomponentecurricular(componentecurricularid);


--
-- Name: acpcomponentecurriculartrabalhoconclusao_componentecurricularid; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentecurriculartrabalhoconclusao
    ADD CONSTRAINT acpcomponentecurriculartrabalhoconclusao_componentecurricularid FOREIGN KEY (componentecurricularid) REFERENCES acpcomponentecurricular(componentecurricularid);


--
-- Name: acpcomponentedeavaliacao_modelodeavaliacaoid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentedeavaliacao
    ADD CONSTRAINT acpcomponentedeavaliacao_modelodeavaliacaoid_pk FOREIGN KEY (modelodeavaliacaoid) REFERENCES acpmodelodeavaliacao(modelodeavaliacaoid);


--
-- Name: acpcomponentedeavaliacaoconceito_componentedeavaliacaoid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentedeavaliacaoconceito
    ADD CONSTRAINT acpcomponentedeavaliacaoconceito_componentedeavaliacaoid_pk FOREIGN KEY (componentedeavaliacaoid) REFERENCES acpcomponentedeavaliacao(componentedeavaliacaoid);


--
-- Name: acpcomponentedeavaliacaoconceito_conjuntodeconceitosid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentedeavaliacaoconceito
    ADD CONSTRAINT acpcomponentedeavaliacaoconceito_conjuntodeconceitosid_pk FOREIGN KEY (conjuntodeconceitosid) REFERENCES acpconjuntodeconceitos(conjuntodeconceitosid);


--
-- Name: acpcomponentedeavaliacaonota_componentedeavaliacaoid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentedeavaliacaonota
    ADD CONSTRAINT acpcomponentedeavaliacaonota_componentedeavaliacaoid_pk FOREIGN KEY (componentedeavaliacaoid) REFERENCES acpcomponentedeavaliacao(componentedeavaliacaoid);


--
-- Name: acpconjuntodeconceitos_conceitodeavaliacaoid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpconceitosdeavaliacao
    ADD CONSTRAINT acpconjuntodeconceitos_conceitodeavaliacaoid_pk FOREIGN KEY (conjuntodeconceitosid) REFERENCES acpconjuntodeconceitos(conjuntodeconceitosid);


--
-- Name: acpcontroledefrequencia_estadodematriculaid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcontroledefrequencia
    ADD CONSTRAINT acpcontroledefrequencia_estadodematriculaid_pk FOREIGN KEY (estadodematriculaid) REFERENCES acpestadodematricula(estadodematriculaid);


--
-- Name: acpcoordenadores_cursoid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcoordenadores
    ADD CONSTRAINT acpcoordenadores_cursoid_pk FOREIGN KEY (ocorrenciacursoid) REFERENCES acpocorrenciacurso(ocorrenciacursoid);


--
-- Name: acpcoordenadores_personid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcoordenadores
    ADD CONSTRAINT acpcoordenadores_personid_pk FOREIGN KEY (personid) REFERENCES basphysicalpersonprofessor(personid);


--
-- Name: acpcurso_cursoid_pk2; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpmatrizcurricular
    ADD CONSTRAINT acpcurso_cursoid_pk2 FOREIGN KEY (cursoid) REFERENCES acpcurso(cursoid);


--
-- Name: acpcurso_cursorepresentanteid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcurso
    ADD CONSTRAINT acpcurso_cursorepresentanteid_pk FOREIGN KEY (cursorepresentanteid) REFERENCES acpcurso(cursoid);


--
-- Name: acpcurso_grauacademicoid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcurso
    ADD CONSTRAINT acpcurso_grauacademicoid_pk FOREIGN KEY (grauacademicoid) REFERENCES acpgrauacademico(grauacademicoid);


--
-- Name: acpcurso_ocorrenciacursoid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpocorrenciacurso
    ADD CONSTRAINT acpcurso_ocorrenciacursoid_pk FOREIGN KEY (cursoid) REFERENCES acpcurso(cursoid);


--
-- Name: acpgradehorario_horarioid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acphorario
    ADD CONSTRAINT acpgradehorario_horarioid_pk FOREIGN KEY (gradehorarioid) REFERENCES acpgradehorario(gradehorarioid);


--
-- Name: acphorarioofertacomponentecurricular_horarioid; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acphorarioofertacomponentecurricular
    ADD CONSTRAINT acphorarioofertacomponentecurricular_horarioid FOREIGN KEY (horarioid) REFERENCES acphorario(horarioid);


--
-- Name: acpmatrizcurricular_matrizcurricularid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpmatrizcurriculargrupo
    ADD CONSTRAINT acpmatrizcurricular_matrizcurricularid_pk FOREIGN KEY (matrizcurricularid) REFERENCES acpmatrizcurricular(matrizcurricularid);


--
-- Name: acpmatrizcurriculargrupo_matrizcurriculargrupoid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentecurricular
    ADD CONSTRAINT acpmatrizcurriculargrupo_matrizcurriculargrupoid_pk FOREIGN KEY (matrizcurriculargrupoid) REFERENCES acpmatrizcurriculargrupo(matrizcurriculargrupoid);


--
-- Name: acpmda_cdfid_mdaid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcontroledefrequencia
    ADD CONSTRAINT acpmda_cdfid_mdaid_pk FOREIGN KEY (modelodeavaliacaoid) REFERENCES acpmodelodeavaliacao(modelodeavaliacaoid);


--
-- Name: acpmodelodeavaliacao_estadodematriculaid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpmodelodeavaliacao
    ADD CONSTRAINT acpmodelodeavaliacao_estadodematriculaid_pk FOREIGN KEY (estadodematriculaaprovacaoid) REFERENCES acpestadodematricula(estadodematriculaid);


--
-- Name: acpmodelodeavaliacao_estadodematriculaid_pk2; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpmodelodeavaliacao
    ADD CONSTRAINT acpmodelodeavaliacao_estadodematriculaid_pk2 FOREIGN KEY (estadodematriculareprovacaoid) REFERENCES acpestadodematricula(estadodematriculaid);


--
-- Name: acpmodelodeavaliacao_modelodeavaliacaoid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpperfilcurso
    ADD CONSTRAINT acpmodelodeavaliacao_modelodeavaliacaoid_pk FOREIGN KEY (modelodeavaliacaoseriado) REFERENCES acpmodelodeavaliacao(modelodeavaliacaoid);


--
-- Name: acpocorrenciacurso_cursoid; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpocorrenciacurso
    ADD CONSTRAINT acpocorrenciacurso_cursoid FOREIGN KEY (cursoid) REFERENCES acpcurso(cursoid);


--
-- Name: acpocorrenciacurso_unitid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpocorrenciacurso
    ADD CONSTRAINT acpocorrenciacurso_unitid_pk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: acpperfilcurso_cursoid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcurso
    ADD CONSTRAINT acpperfilcurso_cursoid_pk FOREIGN KEY (perfilcursoid) REFERENCES acpperfilcurso(perfilcursoid);


--
-- Name: acpperfilcurso_modelodeavaliacaoid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpperfilcurso
    ADD CONSTRAINT acpperfilcurso_modelodeavaliacaoid_pk FOREIGN KEY (modelodeavaliacaogeral) REFERENCES acpmodelodeavaliacao(modelodeavaliacaoid);


--
-- Name: acpperfilcursocamposadicionais_perfilcursoid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpperfilcursocamposadicionais
    ADD CONSTRAINT acpperfilcursocamposadicionais_perfilcursoid_pk FOREIGN KEY (perfilcursoid) REFERENCES acpperfilcurso(perfilcursoid);


--
-- Name: acpperfilcursocomponentecurricular_componentecurricularid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpperfilcursocomponentecurricular
    ADD CONSTRAINT acpperfilcursocomponentecurricular_componentecurricularid_pk FOREIGN KEY (tipocomponentecurricularid) REFERENCES acptipocomponentecurricular(tipocomponentecurricularid);


--
-- Name: acpperfilcursocomponentecurricular_modelodeavaliacaoid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpperfilcursocomponentecurricular
    ADD CONSTRAINT acpperfilcursocomponentecurricular_modelodeavaliacaoid_pk FOREIGN KEY (modelodeavaliacaoid) REFERENCES acpmodelodeavaliacao(modelodeavaliacaoid);


--
-- Name: acpperfilcursocomponentecurricular_perfilcursoid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpperfilcursocomponentecurricular
    ADD CONSTRAINT acpperfilcursocomponentecurricular_perfilcursoid_pk FOREIGN KEY (perfilcursoid) REFERENCES acpperfilcurso(perfilcursoid);


--
-- Name: acprecuperacao_componentedeavaliacaoid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acprecuperacao
    ADD CONSTRAINT acprecuperacao_componentedeavaliacaoid_pk FOREIGN KEY (componentedeavaliacaoid) REFERENCES acpcomponentedeavaliacao(componentedeavaliacaoid);


--
-- Name: acprecuperacao_estadodematriculaid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpmodelodeavaliacao
    ADD CONSTRAINT acprecuperacao_estadodematriculaid_pk FOREIGN KEY (estadodematriculaaprovacaorecuperacaoid) REFERENCES acpestadodematricula(estadodematriculaid);


--
-- Name: acprecuperacao_estadodematriculaid_pk2; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpmodelodeavaliacao
    ADD CONSTRAINT acprecuperacao_estadodematriculaid_pk2 FOREIGN KEY (estadodematriculareprovacaorecuperacaoid) REFERENCES acpestadodematricula(estadodematriculaid);


--
-- Name: acpregrasmatriculaperfilcurso_perfilcursoid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpregrasmatriculaperfilcurso
    ADD CONSTRAINT acpregrasmatriculaperfilcurso_perfilcursoid_pk FOREIGN KEY (perfilcursoid) REFERENCES acpperfilcurso(perfilcursoid);


--
-- Name: acprelacionamentodecomponentes_componentedeavaliacaoid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acprelacionamentodecomponentes
    ADD CONSTRAINT acprelacionamentodecomponentes_componentedeavaliacaoid_pk FOREIGN KEY (componentedeavaliacaofilho) REFERENCES acpcomponentedeavaliacao(componentedeavaliacaoid);


--
-- Name: acprelacionamentodecomponentes_componentedeavaliacaoid_pk2; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acprelacionamentodecomponentes
    ADD CONSTRAINT acprelacionamentodecomponentes_componentedeavaliacaoid_pk2 FOREIGN KEY (componentedeavaliacaopai) REFERENCES acpcomponentedeavaliacao(componentedeavaliacaoid);


--
-- Name: acptipodocumento_perfilcursoid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acptipodocumento
    ADD CONSTRAINT acptipodocumento_perfilcursoid_pk FOREIGN KEY (perfilcursoid) REFERENCES acpperfilcurso(perfilcursoid);


--
-- Name: acptipodocumento_tipodedocumentoid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acptipodocumento
    ADD CONSTRAINT acptipodocumento_tipodedocumentoid_pk FOREIGN KEY (documenttypeid) REFERENCES basdocumenttype(documenttypeid);


--
-- Name: assunto2; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rccmensagemouvidoria
    ADD CONSTRAINT assunto2 FOREIGN KEY (assuntodecontatoid) REFERENCES rccassuntodecontato(assuntodecontatoid);


--
-- Name: assunto3; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rcccontato
    ADD CONSTRAINT assunto3 FOREIGN KEY (assuntodecontato) REFERENCES rccassuntodecontato(assuntodecontatoid);


--
-- Name: ava_atributos_ref_resposta_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_atributos
    ADD CONSTRAINT ava_atributos_ref_resposta_fkey FOREIGN KEY (ref_resposta) REFERENCES ava_respostas(id_respostas);


--
-- Name: ava_avaliacao_perfil_widget_ref_perfil_widget_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_avaliacao_perfil_widget
    ADD CONSTRAINT ava_avaliacao_perfil_widget_ref_perfil_widget_fkey FOREIGN KEY (ref_perfil_widget) REFERENCES ava_perfil_widget(id_perfil_widget);


--
-- Name: ava_avaliacao_widget_ref_avaliacao_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_avaliacao_perfil_widget
    ADD CONSTRAINT ava_avaliacao_widget_ref_avaliacao_fkey FOREIGN KEY (ref_avaliacao) REFERENCES ava_avaliacao(id_avaliacao);


--
-- Name: ava_bloco_questoes_ref_bloco_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_bloco_questoes
    ADD CONSTRAINT ava_bloco_questoes_ref_bloco_fkey FOREIGN KEY (ref_bloco) REFERENCES ava_bloco(id_bloco);


--
-- Name: ava_bloco_questoes_ref_questao_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_bloco_questoes
    ADD CONSTRAINT ava_bloco_questoes_ref_questao_fkey FOREIGN KEY (ref_questao) REFERENCES ava_questoes(id_questoes);


--
-- Name: ava_bloco_ref_formulario_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_bloco
    ADD CONSTRAINT ava_bloco_ref_formulario_fkey FOREIGN KEY (ref_formulario) REFERENCES ava_formulario(id_formulario);


--
-- Name: ava_bloco_ref_granularidade_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_bloco
    ADD CONSTRAINT ava_bloco_ref_granularidade_fkey FOREIGN KEY (ref_granularidade) REFERENCES ava_granularidade(id_granularidade);


--
-- Name: ava_estatisticas_atributos_ref_estatistica_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_totalizadores_atributos
    ADD CONSTRAINT ava_estatisticas_atributos_ref_estatistica_fkey FOREIGN KEY (ref_totalizador) REFERENCES ava_totalizadores(id_totalizador);


--
-- Name: ava_estatisticas_ref_granularidade_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_totalizadores
    ADD CONSTRAINT ava_estatisticas_ref_granularidade_fkey FOREIGN KEY (ref_granularidade) REFERENCES ava_granularidade(id_granularidade);


--
-- Name: ava_form_log_ref_formulario_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_form_log
    ADD CONSTRAINT ava_form_log_ref_formulario_fkey FOREIGN KEY (ref_formulario) REFERENCES ava_formulario(id_formulario);


--
-- Name: ava_formulario_ref_avaliacao_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_formulario
    ADD CONSTRAINT ava_formulario_ref_avaliacao_fkey FOREIGN KEY (ref_avaliacao) REFERENCES ava_avaliacao(id_avaliacao);


--
-- Name: ava_formulario_ref_perfil_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_formulario
    ADD CONSTRAINT ava_formulario_ref_perfil_fkey FOREIGN KEY (ref_perfil) REFERENCES ava_perfil(id_perfil);


--
-- Name: ava_formulario_ref_servico_email_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_formulario
    ADD CONSTRAINT ava_formulario_ref_servico_email_fkey FOREIGN KEY (ref_servico_email) REFERENCES ava_servico(id_servico);


--
-- Name: ava_formulario_ref_servico_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_formulario
    ADD CONSTRAINT ava_formulario_ref_servico_fkey FOREIGN KEY (ref_servico) REFERENCES ava_servico(id_servico);


--
-- Name: ava_granularidade_ref_servico_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_granularidade
    ADD CONSTRAINT ava_granularidade_ref_servico_fkey FOREIGN KEY (ref_servico) REFERENCES ava_servico(id_servico);


--
-- Name: ava_mail_log_ref_mail_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_mail_log
    ADD CONSTRAINT ava_mail_log_ref_mail_fkey FOREIGN KEY (ref_mail) REFERENCES ava_mail(id_mail);


--
-- Name: ava_mail_ref_avaliacao_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_mail
    ADD CONSTRAINT ava_mail_ref_avaliacao_fkey FOREIGN KEY (ref_avaliacao) REFERENCES ava_avaliacao(id_avaliacao);


--
-- Name: ava_mail_ref_formulario_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_mail
    ADD CONSTRAINT ava_mail_ref_formulario_fkey FOREIGN KEY (ref_formulario) REFERENCES ava_formulario(id_formulario);


--
-- Name: ava_mail_ref_perfil_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_mail
    ADD CONSTRAINT ava_mail_ref_perfil_fkey FOREIGN KEY (ref_perfil) REFERENCES ava_perfil(id_perfil);


--
-- Name: ava_perfil_widget_ref_perfil_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_perfil_widget
    ADD CONSTRAINT ava_perfil_widget_ref_perfil_fkey FOREIGN KEY (ref_perfil) REFERENCES ava_perfil(id_perfil);


--
-- Name: ava_perfil_widget_ref_widget_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_perfil_widget
    ADD CONSTRAINT ava_perfil_widget_ref_widget_fkey FOREIGN KEY (ref_widget) REFERENCES ava_widget(id_widget);


--
-- Name: ava_respostas_ref_ava_bloco_questao_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_respostas
    ADD CONSTRAINT ava_respostas_ref_ava_bloco_questao_fkey FOREIGN KEY (ref_bloco_questoes) REFERENCES ava_bloco_questoes(id_bloco_questoes);


--
-- Name: ava_totalizadores_ref_avaliacao_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ava_totalizadores
    ADD CONSTRAINT ava_totalizadores_ref_avaliacao_fkey FOREIGN KEY (ref_avaliacao) REFERENCES ava_avaliacao(id_avaliacao);


--
-- Name: basatuacaoprofessor_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basatuacaoprofessor
    ADD CONSTRAINT basatuacaoprofessor_personid_fkey FOREIGN KEY (personid) REFERENCES basphysicalpersonprofessor(personid);


--
-- Name: basatuacaoprofessor_tipoatuacaoprofessorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basatuacaoprofessor
    ADD CONSTRAINT basatuacaoprofessor_tipoatuacaoprofessorid_fkey FOREIGN KEY (tipoatuacaoprofessorid) REFERENCES bastipoatuacaoprofessor(tipoatuacaoprofessorid);


--
-- Name: basbadgeloan_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basbadgeloan
    ADD CONSTRAINT basbadgeloan_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: bascity_countryid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascity
    ADD CONSTRAINT bascity_countryid_fkey FOREIGN KEY (countryid) REFERENCES bascountry(countryid);


--
-- Name: bascity_stateid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascity
    ADD CONSTRAINT bascity_stateid_fkey FOREIGN KEY (stateid, countryid) REFERENCES basstate(stateid, countryid);


--
-- Name: bascitysquare_cityid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascitysquare
    ADD CONSTRAINT bascitysquare_cityid_fkey FOREIGN KEY (cityid) REFERENCES bascity(cityid);


--
-- Name: bascompanyconf_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascompanyconf
    ADD CONSTRAINT bascompanyconf_personid_fkey FOREIGN KEY (personid) REFERENCES baslegalperson(personid);


--
-- Name: basconfiguracaodatelainicial_login_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basconfiguracaodatelainicial
    ADD CONSTRAINT basconfiguracaodatelainicial_login_fkey FOREIGN KEY (login) REFERENCES miolo_user(login);


--
-- Name: bascsvimportation_fileid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascsvimportation
    ADD CONSTRAINT bascsvimportation_fileid_fkey FOREIGN KEY (fileid) REFERENCES basfile(fileid);


--
-- Name: bascsvimportation_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascsvimportation
    ADD CONSTRAINT bascsvimportation_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: bascsvlog_csvimportationid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bascsvlog
    ADD CONSTRAINT bascsvlog_csvimportationid_fkey FOREIGN KEY (csvimportationid) REFERENCES bascsvimportation(csvimportationid);


--
-- Name: basdocument_cityid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basdocument
    ADD CONSTRAINT basdocument_cityid_fkey FOREIGN KEY (cityid) REFERENCES bascity(cityid);


--
-- Name: basdocument_documenttypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basdocument
    ADD CONSTRAINT basdocument_documenttypeid_fkey FOREIGN KEY (documenttypeid) REFERENCES basdocumenttype(documenttypeid);


--
-- Name: basdocument_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basdocument
    ADD CONSTRAINT basdocument_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: basdocumentogerado_fileid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basdocumentogerado
    ADD CONSTRAINT basdocumentogerado_fileid_fkey FOREIGN KEY (fileid) REFERENCES basfile(fileid);


--
-- Name: basdocumentogerado_personiddocumento_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basdocumentogerado
    ADD CONSTRAINT basdocumentogerado_personiddocumento_fkey FOREIGN KEY (personiddocumento) REFERENCES basperson(personid);


--
-- Name: basemployee_bankid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basemployee
    ADD CONSTRAINT basemployee_bankid_fkey FOREIGN KEY (bankid) REFERENCES finbank(bankid);


--
-- Name: basemployee_employeetypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basemployee
    ADD CONSTRAINT basemployee_employeetypeid_fkey FOREIGN KEY (employeetypeid) REFERENCES basemployeetype(employeetypeid);


--
-- Name: basemployee_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basemployee
    ADD CONSTRAINT basemployee_personid_fkey FOREIGN KEY (personid) REFERENCES basphysicalpersonemployee(personid);


--
-- Name: basemployee_sectorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basemployee
    ADD CONSTRAINT basemployee_sectorid_fkey FOREIGN KEY (sectorid) REFERENCES bassector(sectorid);


--
-- Name: basemployee_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basemployee
    ADD CONSTRAINT basemployee_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: basgrupotrocadesenha_configuracaotrocadesenhaid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: solis
--

ALTER TABLE ONLY basgrupotrocadesenha
    ADD CONSTRAINT basgrupotrocadesenha_configuracaotrocadesenhaid_fkey FOREIGN KEY (configuracaotrocadesenhaid) REFERENCES basconfiguracaotrocadesenha(configuracaotrocadesenhaid);


--
-- Name: basgrupotrocadesenha_idgroup_fkey; Type: FK CONSTRAINT; Schema: public; Owner: solis
--

ALTER TABLE ONLY basgrupotrocadesenha
    ADD CONSTRAINT basgrupotrocadesenha_idgroup_fkey FOREIGN KEY (idgroup) REFERENCES miolo_group(idgroup);


--
-- Name: bashistoricoferias_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bashistoricoferias
    ADD CONSTRAINT bashistoricoferias_personid_fkey FOREIGN KEY (personid) REFERENCES basphysicalpersonemployee(personid);


--
-- Name: bashistoricofuncional_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bashistoricofuncional
    ADD CONSTRAINT bashistoricofuncional_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: baslegalperson_legalpersontypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baslegalperson
    ADD CONSTRAINT baslegalperson_legalpersontypeid_fkey FOREIGN KEY (legalpersontypeid) REFERENCES baslegalpersontype(legalpersontypeid);


--
-- Name: baslocation_cityid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baslocation
    ADD CONSTRAINT baslocation_cityid_fkey FOREIGN KEY (cityid) REFERENCES bascity(cityid);


--
-- Name: baslocation_neighborhoodid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baslocation
    ADD CONSTRAINT baslocation_neighborhoodid_fkey FOREIGN KEY (neighborhoodid) REFERENCES basneighborhood(neighborhoodid);


--
-- Name: basperson2; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rccrespostaouvidoria
    ADD CONSTRAINT basperson2 FOREIGN KEY (respondente) REFERENCES basperson(personid);


--
-- Name: basperson_cityid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basperson
    ADD CONSTRAINT basperson_cityid_fkey FOREIGN KEY (cityid) REFERENCES bascity(cityid);


--
-- Name: basperson_locationtypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basperson
    ADD CONSTRAINT basperson_locationtypeid_fkey FOREIGN KEY (locationtypeid) REFERENCES baslocationtype(locationtypeid);


--
-- Name: basperson_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basperson
    ADD CONSTRAINT basperson_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: basperson_photoid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basperson
    ADD CONSTRAINT basperson_photoid_fkey FOREIGN KEY (photoid) REFERENCES basfile(fileid);


--
-- Name: baspersonfk2; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rcccontato
    ADD CONSTRAINT baspersonfk2 FOREIGN KEY (pessoa) REFERENCES basperson(personid);


--
-- Name: baspersonlink_linkid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baspersonlink
    ADD CONSTRAINT baspersonlink_linkid_fkey FOREIGN KEY (linkid) REFERENCES baslink(linkid);


--
-- Name: baspersonlink_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baspersonlink
    ADD CONSTRAINT baspersonlink_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: basphone_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphone
    ADD CONSTRAINT basphone_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: basphysicalperson_cityidbirth_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalperson
    ADD CONSTRAINT basphysicalperson_cityidbirth_fkey FOREIGN KEY (cityidbirth) REFERENCES bascity(cityid);


--
-- Name: basphysicalperson_countryidbirth_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalperson
    ADD CONSTRAINT basphysicalperson_countryidbirth_fkey FOREIGN KEY (countryidbirth) REFERENCES bascountry(countryid);


--
-- Name: basphysicalperson_ethnicoriginid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalperson
    ADD CONSTRAINT basphysicalperson_ethnicoriginid_fkey FOREIGN KEY (ethnicoriginid) REFERENCES basethnicorigin(ethnicoriginid);


--
-- Name: basphysicalperson_locationtypeidwork_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalperson
    ADD CONSTRAINT basphysicalperson_locationtypeidwork_fkey FOREIGN KEY (locationtypeidwork) REFERENCES baslocationtype(locationtypeid);


--
-- Name: basphysicalperson_maritalstatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalperson
    ADD CONSTRAINT basphysicalperson_maritalstatusid_fkey FOREIGN KEY (maritalstatusid) REFERENCES basmaritalstatus(maritalstatusid);


--
-- Name: basphysicalperson_persontitleid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalperson
    ADD CONSTRAINT basphysicalperson_persontitleid_fkey FOREIGN KEY (persontitleid) REFERENCES baspersontitle(persontitleid);


--
-- Name: basphysicalperson_responsablelegalid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalperson
    ADD CONSTRAINT basphysicalperson_responsablelegalid_fkey FOREIGN KEY (responsablelegalid) REFERENCES basperson(personid);


--
-- Name: basphysicalperson_specialnecessityid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalperson
    ADD CONSTRAINT basphysicalperson_specialnecessityid_fkey FOREIGN KEY (specialnecessityid) REFERENCES basspecialnecessity(specialnecessityid);


--
-- Name: basphysicalpersonemployee_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonemployee
    ADD CONSTRAINT basphysicalpersonemployee_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: basphysicalpersonkinship_kinshipid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonkinship
    ADD CONSTRAINT basphysicalpersonkinship_kinshipid_fkey FOREIGN KEY (kinshipid) REFERENCES baskinship(kinshipid);


--
-- Name: basphysicalpersonkinship_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonkinship
    ADD CONSTRAINT basphysicalpersonkinship_personid_fkey FOREIGN KEY (personid) REFERENCES basphysicalperson(personid);


--
-- Name: basphysicalpersonkinship_relativepersonid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonkinship
    ADD CONSTRAINT basphysicalpersonkinship_relativepersonid_fkey FOREIGN KEY (relativepersonid) REFERENCES basperson(personid);


--
-- Name: basphysicalpersonprofessor_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonprofessor
    ADD CONSTRAINT basphysicalpersonprofessor_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: basphysicalpersonstudent_cityidhs_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonstudent
    ADD CONSTRAINT basphysicalpersonstudent_cityidhs_fkey FOREIGN KEY (cityidhs) REFERENCES bascity(cityid);


--
-- Name: basphysicalpersonstudent_externalcourseidhs_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonstudent
    ADD CONSTRAINT basphysicalpersonstudent_externalcourseidhs_fkey FOREIGN KEY (externalcourseidhs) REFERENCES acdexternalcourse(externalcourseid);


--
-- Name: basphysicalpersonstudent_institutionidhs_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonstudent
    ADD CONSTRAINT basphysicalpersonstudent_institutionidhs_fkey FOREIGN KEY (institutionidhs) REFERENCES baslegalperson(personid);


--
-- Name: basphysicalpersonstudent_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonstudent
    ADD CONSTRAINT basphysicalpersonstudent_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: basphysicalpersonstudent_responsablelegalid; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basphysicalpersonstudent
    ADD CONSTRAINT basphysicalpersonstudent_responsablelegalid FOREIGN KEY (responsablelegalid) REFERENCES basphysicalperson(personid);


--
-- Name: basprofessionalactivitypeople_legalpersonid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basprofessionalactivitypeople
    ADD CONSTRAINT basprofessionalactivitypeople_legalpersonid_fkey FOREIGN KEY (legalpersonid) REFERENCES baslegalperson(personid);


--
-- Name: basprofessionalactivitypeople_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basprofessionalactivitypeople
    ADD CONSTRAINT basprofessionalactivitypeople_personid_fkey FOREIGN KEY (personid) REFERENCES basphysicalperson(personid);


--
-- Name: basprofessionalactivitypeople_professionalactivityagentid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basprofessionalactivitypeople
    ADD CONSTRAINT basprofessionalactivitypeople_professionalactivityagentid_fkey FOREIGN KEY (professionalactivityagentid) REFERENCES basprofessionalactivityagent(professionalactivityagentid);


--
-- Name: basprofessionalactivitypeople_professionalactivityid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basprofessionalactivitypeople
    ADD CONSTRAINT basprofessionalactivitypeople_professionalactivityid_fkey FOREIGN KEY (professionalactivityid) REFERENCES basprofessionalactivity(professionalactivityid);


--
-- Name: basprofessionalactivitypeople_professionalactivitylinktype_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basprofessionalactivitypeople
    ADD CONSTRAINT basprofessionalactivitypeople_professionalactivitylinktype_fkey FOREIGN KEY (professionalactivitylinktypeid) REFERENCES basprofessionalactivitylinktype(professionalactivitylinktypeid);


--
-- Name: basprofessorcenter_centerid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdprofessorcenter
    ADD CONSTRAINT basprofessorcenter_centerid_fkey FOREIGN KEY (centerid) REFERENCES acdcenter(centerid);


--
-- Name: basprofessorcenter_professorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdprofessorcenter
    ADD CONSTRAINT basprofessorcenter_professorid_fkey FOREIGN KEY (professorid) REFERENCES basphysicalpersonprofessor(personid);


--
-- Name: basprofessorcommitment_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basprofessorcommitment
    ADD CONSTRAINT basprofessorcommitment_personid_fkey FOREIGN KEY (personid) REFERENCES basphysicalpersonprofessor(personid);


--
-- Name: basprofessorcommitment_sectorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basprofessorcommitment
    ADD CONSTRAINT basprofessorcommitment_sectorid_fkey FOREIGN KEY (sectorid) REFERENCES bassector(sectorid);


--
-- Name: basprofessorcommitment_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basprofessorcommitment
    ADD CONSTRAINT basprofessorcommitment_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: basprofessorformation_externalcourseid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdprofessorformation
    ADD CONSTRAINT basprofessorformation_externalcourseid_fkey FOREIGN KEY (externalcourseid) REFERENCES acdexternalcourse(externalcourseid);


--
-- Name: basprofessorformation_formationlevelid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdprofessorformation
    ADD CONSTRAINT basprofessorformation_formationlevelid_fkey FOREIGN KEY (formationlevelid) REFERENCES acdformationlevel(formationlevelid);


--
-- Name: basprofessorformation_institutionid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdprofessorformation
    ADD CONSTRAINT basprofessorformation_institutionid_fkey FOREIGN KEY (institutionid) REFERENCES baslegalperson(personid);


--
-- Name: basprofessorformation_professorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdprofessorformation
    ADD CONSTRAINT basprofessorformation_professorid_fkey FOREIGN KEY (professorid) REFERENCES basphysicalpersonprofessor(personid);


--
-- Name: basreport_fileid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basreport
    ADD CONSTRAINT basreport_fileid_fkey FOREIGN KEY (fileid) REFERENCES basfile(fileid);


--
-- Name: basreportparameter_reportid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basreportparameter
    ADD CONSTRAINT basreportparameter_reportid_fkey FOREIGN KEY (reportid) REFERENCES basreport(reportid);


--
-- Name: basresetpassword_iduser_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basresetpassword
    ADD CONSTRAINT basresetpassword_iduser_fkey FOREIGN KEY (iduser) REFERENCES miolo_user(iduser);


--
-- Name: bassectorboss_bossid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bassectorboss
    ADD CONSTRAINT bassectorboss_bossid_fkey FOREIGN KEY (bossid) REFERENCES basphysicalperson(personid);


--
-- Name: bassectorboss_sectorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bassectorboss
    ADD CONSTRAINT bassectorboss_sectorid_fkey FOREIGN KEY (sectorid) REFERENCES bassector(sectorid);


--
-- Name: bassessao_iduser_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bassessao
    ADD CONSTRAINT bassessao_iduser_fkey FOREIGN KEY (iduser) REFERENCES miolo_user(iduser);


--
-- Name: bassessao_login_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bassessao
    ADD CONSTRAINT bassessao_login_fkey FOREIGN KEY (login) REFERENCES miolo_user(login);


--
-- Name: bassessao_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bassessao
    ADD CONSTRAINT bassessao_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: bassolicitacaotrocadesenha_configuracaotrocadesenhaid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: solis
--

ALTER TABLE ONLY bassolicitacaotrocadesenha
    ADD CONSTRAINT bassolicitacaotrocadesenha_configuracaotrocadesenhaid_fkey FOREIGN KEY (configuracaotrocadesenhaid) REFERENCES basconfiguracaotrocadesenha(configuracaotrocadesenhaid);


--
-- Name: bassolicitacaotrocadesenha_userid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: solis
--

ALTER TABLE ONLY bassolicitacaotrocadesenha
    ADD CONSTRAINT bassolicitacaotrocadesenha_userid_fkey FOREIGN KEY (userid) REFERENCES miolo_user(iduser);


--
-- Name: basstamp_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basstamp
    ADD CONSTRAINT basstamp_personid_fkey FOREIGN KEY (personid) REFERENCES basphysicalperson(personid);


--
-- Name: basstate_countryid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basstate
    ADD CONSTRAINT basstate_countryid_fkey FOREIGN KEY (countryid) REFERENCES bascountry(countryid);


--
-- Name: bastaskhistory_taskid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bastaskhistory
    ADD CONSTRAINT bastaskhistory_taskid_fkey FOREIGN KEY (taskid) REFERENCES bas.task(taskid);


--
-- Name: bastaskhistory_taskstatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY bastaskhistory
    ADD CONSTRAINT bastaskhistory_taskstatusid_fkey FOREIGN KEY (taskstatusid) REFERENCES bastaskstatus(taskstatusid);


--
-- Name: basturn_ocorrenciacursoid_pk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpocorrenciacurso
    ADD CONSTRAINT basturn_ocorrenciacursoid_pk FOREIGN KEY (turnid) REFERENCES basturn(turnid);


--
-- Name: basunit_locationid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basunit
    ADD CONSTRAINT basunit_locationid_fkey FOREIGN KEY (locationid) REFERENCES baslocation(locationid);


--
-- Name: basunit_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basunit
    ADD CONSTRAINT basunit_personid_fkey FOREIGN KEY (personid) REFERENCES baslegalperson(personid);


--
-- Name: basunitconfig_moduleconfig_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basunitconfig
    ADD CONSTRAINT basunitconfig_moduleconfig_fkey FOREIGN KEY (moduleconfig, parameter) REFERENCES basconfig(moduleconfig, parameter);


--
-- Name: basunitconfig_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basunitconfig
    ADD CONSTRAINT basunitconfig_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: buscadinamica2; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY campobuscadinamica
    ADD CONSTRAINT buscadinamica2 FOREIGN KEY (buscadinamicaid) REFERENCES buscadinamica(buscadinamicaid);


--
-- Name: caphistorico_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY caphistorico
    ADD CONSTRAINT caphistorico_personid_fkey FOREIGN KEY (personid) REFERENCES basphysicalperson(personid);


--
-- Name: caphistorico_solicitacaoestadoid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY caphistorico
    ADD CONSTRAINT caphistorico_solicitacaoestadoid_fkey FOREIGN KEY (solicitacaoestadoid) REFERENCES capsolicitacaoestado(solicitacaoestadoid);


--
-- Name: caphistorico_solicitacaoid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY caphistorico
    ADD CONSTRAINT caphistorico_solicitacaoid_fkey FOREIGN KEY (solicitacaoid) REFERENCES capsolicitacao(solicitacaoid);


--
-- Name: caplancamento_tituloid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY caplancamento
    ADD CONSTRAINT caplancamento_tituloid_fkey FOREIGN KEY (tituloid) REFERENCES captitulo(tituloid);


--
-- Name: capsolicitacao_formadepagamentoid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY capsolicitacao
    ADD CONSTRAINT capsolicitacao_formadepagamentoid_fkey FOREIGN KEY (formadepagamentoid) REFERENCES capformadepagamento(formadepagamentoid);


--
-- Name: capsolicitacao_fornecedorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY capsolicitacao
    ADD CONSTRAINT capsolicitacao_fornecedorid_fkey FOREIGN KEY (fornecedorid) REFERENCES basperson(personid);


--
-- Name: captitulo_solicitacaoparcelaid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY captitulo
    ADD CONSTRAINT captitulo_solicitacaoparcelaid_fkey FOREIGN KEY (solicitacaoparcelaid) REFERENCES capsolicitacaoparcela(solicitacaoparcelaid);


--
-- Name: ccpcopy_periodid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpcopy
    ADD CONSTRAINT ccpcopy_periodid_fkey FOREIGN KEY (periodid) REFERENCES ccpperiod(periodid);


--
-- Name: ccpcopy_printerid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpcopy
    ADD CONSTRAINT ccpcopy_printerid_fkey FOREIGN KEY (printerid) REFERENCES ccpprinter(printerid);


--
-- Name: ccppayrolldiscount_operatorsectorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccppayrolldiscount
    ADD CONSTRAINT ccppayrolldiscount_operatorsectorid_fkey FOREIGN KEY (operatorsectorid) REFERENCES ccpsector(sectorid);


--
-- Name: ccppayrolldiscount_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccppayrolldiscount
    ADD CONSTRAINT ccppayrolldiscount_personid_fkey FOREIGN KEY (personid) REFERENCES basphysicalpersonemployee(personid);


--
-- Name: ccppayrolldiscount_sectorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccppayrolldiscount
    ADD CONSTRAINT ccppayrolldiscount_sectorid_fkey FOREIGN KEY (sectorid) REFERENCES bassector(sectorid);


--
-- Name: ccpperson_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpperson
    ADD CONSTRAINT ccpperson_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: ccppersoncopy_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccppersoncopy
    ADD CONSTRAINT ccppersoncopy_personid_fkey FOREIGN KEY (personid) REFERENCES ccpperson(personid);


--
-- Name: ccppersonperiod_periodid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccppersonperiod
    ADD CONSTRAINT ccppersonperiod_periodid_fkey FOREIGN KEY (periodid) REFERENCES ccpperiod(periodid);


--
-- Name: ccppersonperiod_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccppersonperiod
    ADD CONSTRAINT ccppersonperiod_personid_fkey FOREIGN KEY (personid) REFERENCES ccpperson(personid);


--
-- Name: ccppersonprinter_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccppersonprinter
    ADD CONSTRAINT ccppersonprinter_personid_fkey FOREIGN KEY (personid) REFERENCES ccpperson(personid);


--
-- Name: ccppersonprinter_printerid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccppersonprinter
    ADD CONSTRAINT ccppersonprinter_printerid_fkey FOREIGN KEY (printerid) REFERENCES ccpprinter(printerid);


--
-- Name: ccppersonsector_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccppersonsector
    ADD CONSTRAINT ccppersonsector_personid_fkey FOREIGN KEY (personid) REFERENCES ccpperson(personid);


--
-- Name: ccppersonsector_sectorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccppersonsector
    ADD CONSTRAINT ccppersonsector_sectorid_fkey FOREIGN KEY (sectorid) REFERENCES ccpsector(sectorid);


--
-- Name: ccpprinter_physicalresourceid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpprinter
    ADD CONSTRAINT ccpprinter_physicalresourceid_fkey FOREIGN KEY (physicalresourceid, physicalresourceversion) REFERENCES insphysicalresource(physicalresourceid, physicalresourceversion);


--
-- Name: ccprequest_centerid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccprequest
    ADD CONSTRAINT ccprequest_centerid_fkey FOREIGN KEY (centerid) REFERENCES acdcenter(centerid);


--
-- Name: ccprequest_operatorsectorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccprequest
    ADD CONSTRAINT ccprequest_operatorsectorid_fkey FOREIGN KEY (operatorsectorid) REFERENCES ccpsector(sectorid);


--
-- Name: ccprequest_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccprequest
    ADD CONSTRAINT ccprequest_personid_fkey FOREIGN KEY (personid) REFERENCES basphysicalpersonemployee(personid);


--
-- Name: ccprequest_sectorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccprequest
    ADD CONSTRAINT ccprequest_sectorid_fkey FOREIGN KEY (sectorid) REFERENCES bassector(sectorid);


--
-- Name: ccprule_formationlevel_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccprule
    ADD CONSTRAINT ccprule_formationlevel_fkey FOREIGN KEY (formationlevel) REFERENCES acdformationlevel(formationlevelid);


--
-- Name: ccpsectorcopy_sectorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpsectorcopy
    ADD CONSTRAINT ccpsectorcopy_sectorid_fkey FOREIGN KEY (sectorid) REFERENCES ccpsector(sectorid);


--
-- Name: ccpsectorperiod_periodid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpsectorperiod
    ADD CONSTRAINT ccpsectorperiod_periodid_fkey FOREIGN KEY (periodid) REFERENCES ccpperiod(periodid);


--
-- Name: ccpsectorperiod_sectorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpsectorperiod
    ADD CONSTRAINT ccpsectorperiod_sectorid_fkey FOREIGN KEY (sectorid) REFERENCES ccpsector(sectorid);


--
-- Name: ccpsectorprinter_printerid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpsectorprinter
    ADD CONSTRAINT ccpsectorprinter_printerid_fkey FOREIGN KEY (printerid) REFERENCES ccpprinter(printerid);


--
-- Name: ccpsectorprinter_sectorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ccpsectorprinter
    ADD CONSTRAINT ccpsectorprinter_sectorid_fkey FOREIGN KEY (sectorid) REFERENCES ccpsector(sectorid);


--
-- Name: cityidfk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY baslegalperson
    ADD CONSTRAINT cityidfk FOREIGN KEY (cityid) REFERENCES bascity(cityid);


--
-- Name: cobrancabancaria; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finconfiguracaoremessa
    ADD CONSTRAINT cobrancabancaria FOREIGN KEY (cobrancabancariaid) REFERENCES fincobrancabancaria(cobrancabancariaid);


--
-- Name: contato2; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rcccontato
    ADD CONSTRAINT contato2 FOREIGN KEY (tipodecontatoid) REFERENCES rcctipodecontato(tipodecontatoid);


--
-- Name: contato3; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rcccontato
    ADD CONSTRAINT contato3 FOREIGN KEY (origemdecontatoid) REFERENCES rccorigemdecontato(origemdecontatoid);


--
-- Name: finagreementcomments_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finagreementcomments
    ADD CONSTRAINT finagreementcomments_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: finbankaccount_bankid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finbankaccount
    ADD CONSTRAINT finbankaccount_bankid_fkey FOREIGN KEY (bankid) REFERENCES finbank(bankid);


--
-- Name: finbankaccount_invoicemessage1_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finbankaccount
    ADD CONSTRAINT finbankaccount_invoicemessage1_fkey FOREIGN KEY (invoicemessage1) REFERENCES fininvoicemessage(invoicemessageid);


--
-- Name: finbankaccount_invoicemessage2_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finbankaccount
    ADD CONSTRAINT finbankaccount_invoicemessage2_fkey FOREIGN KEY (invoicemessage2) REFERENCES fininvoicemessage(invoicemessageid);


--
-- Name: finbankaccount_invoicetypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finbankaccount
    ADD CONSTRAINT finbankaccount_invoicetypeid_fkey FOREIGN KEY (invoicetypeid) REFERENCES fininvoicetype(invoicetypeid);


--
-- Name: finbankaccount_taxbankcreditoperation_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finbankaccount
    ADD CONSTRAINT finbankaccount_taxbankcreditoperation_fkey FOREIGN KEY (taxbankcreditoperation) REFERENCES finoperation(operationid);


--
-- Name: finbankaccount_taxbankdebtoperation_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finbankaccount
    ADD CONSTRAINT finbankaccount_taxbankdebtoperation_fkey FOREIGN KEY (taxbankdebtoperation) REFERENCES finoperation(operationid);


--
-- Name: finbankaccountinvoiceinfo_bankaccountid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finbankaccountinvoiceinfo
    ADD CONSTRAINT finbankaccountinvoiceinfo_bankaccountid_fkey FOREIGN KEY (bankaccountid) REFERENCES finbankaccount(bankaccountid);


--
-- Name: finbankaccountinvoiceinfo_invoicespecieid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finbankaccountinvoiceinfo
    ADD CONSTRAINT finbankaccountinvoiceinfo_invoicespecieid_fkey FOREIGN KEY (invoicespecieid) REFERENCES fininvoicespecie(invoicespecieid);


--
-- Name: finbankaccountmovement_bankaccountid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finbankaccountmovement
    ADD CONSTRAINT finbankaccountmovement_bankaccountid_fkey FOREIGN KEY (bankaccountid) REFERENCES finbankaccount(bankaccountid);


--
-- Name: finbankinvoiceinfo_bankaccountid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finbankinvoiceinfo
    ADD CONSTRAINT finbankinvoiceinfo_bankaccountid_fkey FOREIGN KEY (bankaccountid) REFERENCES finbankaccount(bankaccountid);


--
-- Name: finbankinvoiceinfo_invoiceid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finbankinvoiceinfo
    ADD CONSTRAINT finbankinvoiceinfo_invoiceid_fkey FOREIGN KEY (invoiceid) REFERENCES fininvoice(invoiceid);


--
-- Name: finbanktarget_bankid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finbanktarget
    ADD CONSTRAINT finbanktarget_bankid_fkey FOREIGN KEY (bankid) REFERENCES finbank(bankid);


--
-- Name: fincamporemessa_tipovalorvariavelremessaid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincamporemessa
    ADD CONSTRAINT fincamporemessa_tipovalorvariavelremessaid_fkey FOREIGN KEY (tipovalorvariavelremessaid) REFERENCES fintipovalorvariavelremessa(tipovalorvariavelremessaid);


--
-- Name: fincheque_bankid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincheque
    ADD CONSTRAINT fincheque_bankid_fkey FOREIGN KEY (bankid) REFERENCES finbank(bankid);


--
-- Name: finclosecounter_counterid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finclosecounter
    ADD CONSTRAINT finclosecounter_counterid_fkey FOREIGN KEY (counterid) REFERENCES fincounter(counterid);


--
-- Name: finconvenant_convenantoperation_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finconvenant
    ADD CONSTRAINT finconvenant_convenantoperation_fkey FOREIGN KEY (convenantoperation) REFERENCES finoperation(operationid);


--
-- Name: finconvenant_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finconvenant
    ADD CONSTRAINT finconvenant_personid_fkey FOREIGN KEY (personid) REFERENCES baslegalperson(personid);


--
-- Name: finconvenantperson_contractid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finconvenantperson
    ADD CONSTRAINT finconvenantperson_contractid_fkey FOREIGN KEY (contractid) REFERENCES acdcontract(contractid);


--
-- Name: finconvenantperson_convenantid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finconvenantperson
    ADD CONSTRAINT finconvenantperson_convenantid_fkey FOREIGN KEY (convenantid) REFERENCES finconvenant(convenantid);


--
-- Name: finconvenantperson_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finconvenantperson
    ADD CONSTRAINT finconvenantperson_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: fincounter_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincounter
    ADD CONSTRAINT fincounter_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: fincountermovement_bankaccountid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincountermovement
    ADD CONSTRAINT fincountermovement_bankaccountid_fkey FOREIGN KEY (bankaccountid) REFERENCES finbankaccount(bankaccountid);


--
-- Name: fincountermovement_costcenterid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincountermovement
    ADD CONSTRAINT fincountermovement_costcenterid_fkey FOREIGN KEY (costcenterid) REFERENCES acccostcenter(costcenterid);


--
-- Name: fincountermovement_fileid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincountermovement
    ADD CONSTRAINT fincountermovement_fileid_fkey FOREIGN KEY (fileid) REFERENCES basfile(fileid);


--
-- Name: fincountermovement_invoiceid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincountermovement
    ADD CONSTRAINT fincountermovement_invoiceid_fkey FOREIGN KEY (invoiceid) REFERENCES fininvoice(invoiceid);


--
-- Name: fincountermovement_operationid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincountermovement
    ADD CONSTRAINT fincountermovement_operationid_fkey FOREIGN KEY (operationid) REFERENCES finoperation(operationid);


--
-- Name: fincountermovement_speciesid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincountermovement
    ADD CONSTRAINT fincountermovement_speciesid_fkey FOREIGN KEY (speciesid) REFERENCES finspecies(speciesid);


--
-- Name: fincountermovement_transferenciadecaixaid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincountermovement
    ADD CONSTRAINT fincountermovement_transferenciadecaixaid_fkey FOREIGN KEY (transferenciadecaixaid) REFERENCES fintransferenciadecaixa(transferenciadecaixaid);


--
-- Name: fincountermovementcheque_chequeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincountermovementcheque
    ADD CONSTRAINT fincountermovementcheque_chequeid_fkey FOREIGN KEY (chequeid) REFERENCES fincheque(chequeid);


--
-- Name: fincountermovementcheque_countermovementid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincountermovementcheque
    ADD CONSTRAINT fincountermovementcheque_countermovementid_fkey FOREIGN KEY (countermovementid) REFERENCES fincountermovement(countermovementid);


--
-- Name: findadosbancariosdapessoa_bankid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: solis
--

ALTER TABLE ONLY findadosbancariosdapessoa
    ADD CONSTRAINT findadosbancariosdapessoa_bankid_fkey FOREIGN KEY (bankid) REFERENCES finbank(bankid);


--
-- Name: findadosbancariosdapessoa_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: solis
--

ALTER TABLE ONLY findadosbancariosdapessoa
    ADD CONSTRAINT findadosbancariosdapessoa_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: findefaultoperations_addcurricularcomponentoperation_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY findefaultoperations
    ADD CONSTRAINT findefaultoperations_addcurricularcomponentoperation_fkey FOREIGN KEY (addcurricularcomponentoperation) REFERENCES finoperation(operationid);


--
-- Name: findefaultoperations_agreementoperation_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY findefaultoperations
    ADD CONSTRAINT findefaultoperations_agreementoperation_fkey FOREIGN KEY (agreementoperation) REFERENCES finoperation(operationid);


--
-- Name: findefaultoperations_bankclosingtaxoperation_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY findefaultoperations
    ADD CONSTRAINT findefaultoperations_bankclosingtaxoperation_fkey FOREIGN KEY (bankclosingtaxoperation) REFERENCES finoperation(operationid);


--
-- Name: findefaultoperations_banktaxoperation_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY findefaultoperations
    ADD CONSTRAINT findefaultoperations_banktaxoperation_fkey FOREIGN KEY (banktaxoperation) REFERENCES finoperation(operationid);


--
-- Name: findefaultoperations_cancelcurricularcomponentoperation_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY findefaultoperations
    ADD CONSTRAINT findefaultoperations_cancelcurricularcomponentoperation_fkey FOREIGN KEY (cancelcurricularcomponentoperation) REFERENCES finoperation(operationid);


--
-- Name: findefaultoperations_closeincomeforecastoperation_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY findefaultoperations
    ADD CONSTRAINT findefaultoperations_closeincomeforecastoperation_fkey FOREIGN KEY (closeincomeforecastoperation) REFERENCES finoperation(operationid);


--
-- Name: findefaultoperations_coursetransferoperation_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY findefaultoperations
    ADD CONSTRAINT findefaultoperations_coursetransferoperation_fkey FOREIGN KEY (coursetransferoperation) REFERENCES finoperation(operationid);


--
-- Name: findefaultoperations_discountoperation_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY findefaultoperations
    ADD CONSTRAINT findefaultoperations_discountoperation_fkey FOREIGN KEY (discountoperation) REFERENCES finoperation(operationid);


--
-- Name: findefaultoperations_enrolloperation_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY findefaultoperations
    ADD CONSTRAINT findefaultoperations_enrolloperation_fkey FOREIGN KEY (enrolloperation) REFERENCES finoperation(operationid);


--
-- Name: findefaultoperations_interestoperation_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY findefaultoperations
    ADD CONSTRAINT findefaultoperations_interestoperation_fkey FOREIGN KEY (interestoperation) REFERENCES finoperation(operationid);


--
-- Name: findefaultoperations_libraryfineoperation_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY findefaultoperations
    ADD CONSTRAINT findefaultoperations_libraryfineoperation_fkey FOREIGN KEY (libraryfineoperation) REFERENCES finoperation(operationid);


--
-- Name: findefaultoperations_libraryfineoperation_fkey1; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY findefaultoperations
    ADD CONSTRAINT findefaultoperations_libraryfineoperation_fkey1 FOREIGN KEY (libraryfineoperation) REFERENCES finoperation(operationid);


--
-- Name: findefaultoperations_otheradditionsoperation_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY findefaultoperations
    ADD CONSTRAINT findefaultoperations_otheradditionsoperation_fkey FOREIGN KEY (otheradditionsoperation) REFERENCES finoperation(operationid);


--
-- Name: findefaultoperations_otherdiscountsoperation_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY findefaultoperations
    ADD CONSTRAINT findefaultoperations_otherdiscountsoperation_fkey FOREIGN KEY (otherdiscountsoperation) REFERENCES finoperation(operationid);


--
-- Name: findefaultoperations_paymentoperation_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY findefaultoperations
    ADD CONSTRAINT findefaultoperations_paymentoperation_fkey FOREIGN KEY (paymentoperation) REFERENCES finoperation(operationid);


--
-- Name: findefaultoperations_protocoloperation_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY findefaultoperations
    ADD CONSTRAINT findefaultoperations_protocoloperation_fkey FOREIGN KEY (protocoloperation) REFERENCES finoperation(operationid);


--
-- Name: findefaultoperations_reentryoperation_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY findefaultoperations
    ADD CONSTRAINT findefaultoperations_reentryoperation_fkey FOREIGN KEY (reentryoperation) REFERENCES finoperation(operationid);


--
-- Name: findefaultoperations_repaymentcurricularcomponentoperation_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY findefaultoperations
    ADD CONSTRAINT findefaultoperations_repaymentcurricularcomponentoperation_fkey FOREIGN KEY (repaymentcurricularcomponentoperation) REFERENCES finoperation(operationid);


--
-- Name: findefaultoperations_selectiveprocesstaxoperation_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY findefaultoperations
    ADD CONSTRAINT findefaultoperations_selectiveprocesstaxoperation_fkey FOREIGN KEY (selectiveprocesstaxoperation) REFERENCES finoperation(operationid);


--
-- Name: findefaultoperations_transferoperation_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY findefaultoperations
    ADD CONSTRAINT findefaultoperations_transferoperation_fkey FOREIGN KEY (transferoperation) REFERENCES finoperation(operationid);


--
-- Name: findefaultoperations_withdrawoperation_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY findefaultoperations
    ADD CONSTRAINT findefaultoperations_withdrawoperation_fkey FOREIGN KEY (withdrawoperation) REFERENCES finoperation(operationid);


--
-- Name: finenrollfee_learningperiodid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finenrollfee
    ADD CONSTRAINT finenrollfee_learningperiodid_fkey FOREIGN KEY (learningperiodid) REFERENCES acdlearningperiod(learningperiodid);


--
-- Name: finenrollfee_operationid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finenrollfee
    ADD CONSTRAINT finenrollfee_operationid_fkey FOREIGN KEY (operationid) REFERENCES finoperation(operationid);


--
-- Name: finentry_bankmovementid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finentry
    ADD CONSTRAINT finentry_bankmovementid_fkey FOREIGN KEY (bankmovementid) REFERENCES fin.bankmovement(bankmovementid);


--
-- Name: finentry_contractid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finentry
    ADD CONSTRAINT finentry_contractid_fkey FOREIGN KEY (contractid) REFERENCES acdcontract(contractid);


--
-- Name: finentry_costcenterid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finentry
    ADD CONSTRAINT finentry_costcenterid_fkey FOREIGN KEY (costcenterid) REFERENCES acccostcenter(costcenterid);


--
-- Name: finentry_incentivetypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finentry
    ADD CONSTRAINT finentry_incentivetypeid_fkey FOREIGN KEY (incentivetypeid) REFERENCES finincentivetype(incentivetypeid);


--
-- Name: finentry_invoiceid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finentry
    ADD CONSTRAINT finentry_invoiceid_fkey FOREIGN KEY (invoiceid) REFERENCES fininvoice(invoiceid);


--
-- Name: finentry_learningperiodid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finentry
    ADD CONSTRAINT finentry_learningperiodid_fkey FOREIGN KEY (learningperiodid) REFERENCES acdlearningperiod(learningperiodid);


--
-- Name: finentry_operationid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finentry
    ADD CONSTRAINT finentry_operationid_fkey FOREIGN KEY (operationid) REFERENCES finoperation(operationid);


--
-- Name: finfluxoaprovacao_fluxoaprovacaonivelid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxoaprovacao
    ADD CONSTRAINT finfluxoaprovacao_fluxoaprovacaonivelid_fkey FOREIGN KEY (fluxoaprovacaonivelid) REFERENCES finfluxoaprovacaonivel(fluxoaprovacaonivelid);


--
-- Name: finfluxoaprovacao_fluxoaprovacaostatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxoaprovacao
    ADD CONSTRAINT finfluxoaprovacao_fluxoaprovacaostatusid_fkey FOREIGN KEY (fluxoaprovacaostatusid) REFERENCES finfluxoaprovacaostatus(fluxoaprovacaostatusid);


--
-- Name: finfluxoaprovacao_fluxosolicitacaoid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxoaprovacao
    ADD CONSTRAINT finfluxoaprovacao_fluxosolicitacaoid_fkey FOREIGN KEY (fluxosolicitacaoid) REFERENCES finfluxosolicitacao(fluxosolicitacaoid);


--
-- Name: finfluxoaprovacao_iduser_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxoaprovacao
    ADD CONSTRAINT finfluxoaprovacao_iduser_fkey FOREIGN KEY (iduser) REFERENCES miolo_user(iduser);


--
-- Name: finfluxoaprovacaoconfiguracao_fluxoaprovacaoprocessoid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxoaprovacaoconfiguracao
    ADD CONSTRAINT finfluxoaprovacaoconfiguracao_fluxoaprovacaoprocessoid_fkey FOREIGN KEY (fluxoaprovacaoprocessoid) REFERENCES finfluxoaprovacaoprocesso(fluxoaprovacaoprocessoid);


--
-- Name: finfluxoaprovacaonivel_fluxoaprovacaoconfiguracaoid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxoaprovacaonivel
    ADD CONSTRAINT finfluxoaprovacaonivel_fluxoaprovacaoconfiguracaoid_fkey FOREIGN KEY (fluxoaprovacaoconfiguracaoid) REFERENCES finfluxoaprovacaoconfiguracao(fluxoaprovacaoconfiguracaoid);


--
-- Name: finfluxoaprovacaonivel_idgroup_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxoaprovacaonivel
    ADD CONSTRAINT finfluxoaprovacaonivel_idgroup_fkey FOREIGN KEY (idgroup) REFERENCES miolo_group(idgroup);


--
-- Name: finfluxoaprovacaonivel_iduser_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxoaprovacaonivel
    ADD CONSTRAINT finfluxoaprovacaonivel_iduser_fkey FOREIGN KEY (iduser) REFERENCES miolo_user(iduser);


--
-- Name: finfluxosolicitacao_fluxoaprovacaoprocessoid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxosolicitacao
    ADD CONSTRAINT finfluxosolicitacao_fluxoaprovacaoprocessoid_fkey FOREIGN KEY (fluxoaprovacaoprocessoid) REFERENCES finfluxoaprovacaoprocesso(fluxoaprovacaoprocessoid);


--
-- Name: finfluxosolicitacao_fluxoaprovacaostatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxosolicitacao
    ADD CONSTRAINT finfluxosolicitacao_fluxoaprovacaostatusid_fkey FOREIGN KEY (fluxoaprovacaostatusid) REFERENCES finfluxoaprovacaostatus(fluxoaprovacaostatusid);


--
-- Name: finfluxosolicitacao_iduser_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxosolicitacao
    ADD CONSTRAINT finfluxosolicitacao_iduser_fkey FOREIGN KEY (iduser) REFERENCES miolo_user(iduser);


--
-- Name: finfluxosolicitacaoregistro_fluxosolicitacaoid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finfluxosolicitacaoregistro
    ADD CONSTRAINT finfluxosolicitacaoregistro_fluxosolicitacaoid_fkey FOREIGN KEY (fluxosolicitacaoid) REFERENCES finfluxosolicitacao(fluxosolicitacaoid);


--
-- Name: finhistoricoremessa_fileid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finhistoricoremessa
    ADD CONSTRAINT finhistoricoremessa_fileid_fkey FOREIGN KEY (fileid) REFERENCES basfile(fileid);


--
-- Name: finhistoricoremessa_invoiceid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finhistoricoremessa
    ADD CONSTRAINT finhistoricoremessa_invoiceid_fkey FOREIGN KEY (invoiceid) REFERENCES fininvoice(invoiceid);


--
-- Name: finincentive_contractid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finincentive
    ADD CONSTRAINT finincentive_contractid_fkey FOREIGN KEY (contractid) REFERENCES acdcontract(contractid);


--
-- Name: finincentive_costcenterid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finincentive
    ADD CONSTRAINT finincentive_costcenterid_fkey FOREIGN KEY (costcenterid) REFERENCES acccostcenter(costcenterid);


--
-- Name: finincentive_incentivetypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finincentive
    ADD CONSTRAINT finincentive_incentivetypeid_fkey FOREIGN KEY (incentivetypeid) REFERENCES finincentivetype(incentivetypeid);


--
-- Name: finincentive_incentivetypeid_fkey1; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finincentive
    ADD CONSTRAINT finincentive_incentivetypeid_fkey1 FOREIGN KEY (incentivetypeid) REFERENCES finincentivetype(incentivetypeid);


--
-- Name: finincentive_supporterid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finincentive
    ADD CONSTRAINT finincentive_supporterid_fkey FOREIGN KEY (supporterid) REFERENCES basperson(personid);


--
-- Name: finincentivetype_operationid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finincentivetype
    ADD CONSTRAINT finincentivetype_operationid_fkey FOREIGN KEY (operationid) REFERENCES finoperation(operationid);


--
-- Name: finincentivetype_paymentoperation_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finincentivetype
    ADD CONSTRAINT finincentivetype_paymentoperation_fkey FOREIGN KEY (paymentoperation) REFERENCES finoperation(operationid);


--
-- Name: finincentivetype_repaymentoperation_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finincentivetype
    ADD CONSTRAINT finincentivetype_repaymentoperation_fkey FOREIGN KEY (repaymentoperation) REFERENCES finoperation(operationid);


--
-- Name: finincomeforecast_accountschemeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finincomeforecast
    ADD CONSTRAINT finincomeforecast_accountschemeid_fkey FOREIGN KEY (accountschemeid) REFERENCES accaccountscheme(accountschemeid);


--
-- Name: finincomeforecast_contractid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finincomeforecast
    ADD CONSTRAINT finincomeforecast_contractid_fkey FOREIGN KEY (contractid) REFERENCES acdcontract(contractid);


--
-- Name: finincomeforecast_costcenterid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finincomeforecast
    ADD CONSTRAINT finincomeforecast_costcenterid_fkey FOREIGN KEY (costcenterid) REFERENCES acccostcenter(costcenterid);


--
-- Name: finincomeforecast_incentiveid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finincomeforecast
    ADD CONSTRAINT finincomeforecast_incentiveid_fkey FOREIGN KEY (incentiveid) REFERENCES finincentive(incentiveid);


--
-- Name: finincomeforecast_invoiceid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finincomeforecast
    ADD CONSTRAINT finincomeforecast_invoiceid_fkey FOREIGN KEY (invoiceid) REFERENCES fininvoice(invoiceid);


--
-- Name: finincomeforecast_learningperiodid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finincomeforecast
    ADD CONSTRAINT finincomeforecast_learningperiodid_fkey FOREIGN KEY (learningperiodid) REFERENCES acdlearningperiod(learningperiodid);


--
-- Name: finincomeforecast_operationid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finincomeforecast
    ADD CONSTRAINT finincomeforecast_operationid_fkey FOREIGN KEY (operationid) REFERENCES finoperation(operationid);


--
-- Name: fininfotitulo_contrato_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininfotitulo
    ADD CONSTRAINT fininfotitulo_contrato_fkey FOREIGN KEY (contrato) REFERENCES acdcontract(contractid);


--
-- Name: fininfotitulo_matricula_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininfotitulo
    ADD CONSTRAINT fininfotitulo_matricula_fkey FOREIGN KEY (matricula) REFERENCES basperson(personid);


--
-- Name: fininfotitulo_periodo_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininfotitulo
    ADD CONSTRAINT fininfotitulo_periodo_fkey FOREIGN KEY (periodo) REFERENCES acdperiod(periodid);


--
-- Name: fininfotitulo_periodo_letivo_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininfotitulo
    ADD CONSTRAINT fininfotitulo_periodo_letivo_fkey FOREIGN KEY (periodo_letivo) REFERENCES acdlearningperiod(learningperiodid);


--
-- Name: fininfotitulo_titulo_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininfotitulo
    ADD CONSTRAINT fininfotitulo_titulo_fkey FOREIGN KEY (titulo) REFERENCES finreceivableinvoice(invoiceid);


--
-- Name: fininvoice_accountschemeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoice
    ADD CONSTRAINT fininvoice_accountschemeid_fkey FOREIGN KEY (accountschemeid) REFERENCES accaccountscheme(accountschemeid);


--
-- Name: fininvoice_bankaccountid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoice
    ADD CONSTRAINT fininvoice_bankaccountid_fkey FOREIGN KEY (bankaccountid) REFERENCES finbankaccount(bankaccountid);


--
-- Name: fininvoice_costcenterid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoice
    ADD CONSTRAINT fininvoice_costcenterid_fkey FOREIGN KEY (costcenterid) REFERENCES acccostcenter(costcenterid);


--
-- Name: fininvoice_emissiontypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoice
    ADD CONSTRAINT fininvoice_emissiontypeid_fkey FOREIGN KEY (emissiontypeid) REFERENCES finemissiontype(emissiontypeid);


--
-- Name: fininvoice_incomesourceid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoice
    ADD CONSTRAINT fininvoice_incomesourceid_fkey FOREIGN KEY (incomesourceid) REFERENCES finincomesource(incomesourceid);


--
-- Name: fininvoice_invoiceiddependence_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoice
    ADD CONSTRAINT fininvoice_invoiceiddependence_fkey FOREIGN KEY (invoiceiddependence) REFERENCES fininvoice(invoiceid);


--
-- Name: fininvoice_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoice
    ADD CONSTRAINT fininvoice_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: fininvoice_policyid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoice
    ADD CONSTRAINT fininvoice_policyid_fkey FOREIGN KEY (policyid) REFERENCES finpolicy(policyid);


--
-- Name: fininvoice_reasoncancellationid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoice
    ADD CONSTRAINT fininvoice_reasoncancellationid_fkey FOREIGN KEY (reasoncancellationid) REFERENCES finreasoncancellation(reasoncancellationid);


--
-- Name: fininvoice_sectorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoice
    ADD CONSTRAINT fininvoice_sectorid_fkey FOREIGN KEY (sectorid) REFERENCES bassector(sectorid);


--
-- Name: fininvoicemessage_bankid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoicemessage
    ADD CONSTRAINT fininvoicemessage_bankid_fkey FOREIGN KEY (bankid) REFERENCES finbank(bankid);


--
-- Name: fininvoicemessage_invoicemessagetypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoicemessage
    ADD CONSTRAINT fininvoicemessage_invoicemessagetypeid_fkey FOREIGN KEY (invoicemessagetypeid) REFERENCES fininvoicemessagetype(invoicemessagetypeid);


--
-- Name: fininvoicemessage_operationid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoicemessage
    ADD CONSTRAINT fininvoicemessage_operationid_fkey FOREIGN KEY (operationid) REFERENCES finoperation(operationid);


--
-- Name: fininvoicetarget_contractid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fininvoicetarget
    ADD CONSTRAINT fininvoicetarget_contractid_fkey FOREIGN KEY (contractid) REFERENCES acdcontract(contractid);


--
-- Name: finloan_accountschemeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finloan
    ADD CONSTRAINT finloan_accountschemeid_fkey FOREIGN KEY (accountschemeid) REFERENCES accaccountscheme(accountschemeid);


--
-- Name: finloan_collectionoperationid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finloan
    ADD CONSTRAINT finloan_collectionoperationid_fkey FOREIGN KEY (collectionoperationid) REFERENCES finoperation(operationid);


--
-- Name: finloan_loanerid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finloan
    ADD CONSTRAINT finloan_loanerid_fkey FOREIGN KEY (loanerid) REFERENCES baslegalperson(personid);


--
-- Name: finmovimentacaocheque_chequeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finmovimentacaocheque
    ADD CONSTRAINT finmovimentacaocheque_chequeid_fkey FOREIGN KEY (chequeid) REFERENCES fincheque(chequeid);


--
-- Name: finmovimentacaocheque_statuschequeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finmovimentacaocheque
    ADD CONSTRAINT finmovimentacaocheque_statuschequeid_fkey FOREIGN KEY (statuschequeid) REFERENCES finstatuscheque(statuschequeid);


--
-- Name: finoccurrenceoperation_bankaccountid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finoccurrenceoperation
    ADD CONSTRAINT finoccurrenceoperation_bankaccountid_fkey FOREIGN KEY (bankaccountid) REFERENCES finbankaccount(bankaccountid);


--
-- Name: finoccurrenceoperation_operationid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finoccurrenceoperation
    ADD CONSTRAINT finoccurrenceoperation_operationid_fkey FOREIGN KEY (operationid) REFERENCES finoperation(operationid);


--
-- Name: finopencounter_counterid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finopencounter
    ADD CONSTRAINT finopencounter_counterid_fkey FOREIGN KEY (counterid) REFERENCES fincounter(counterid);


--
-- Name: finopencounter_opencounterid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finclosecounter
    ADD CONSTRAINT finopencounter_opencounterid_fkey FOREIGN KEY (opencounterid) REFERENCES finopencounter(opencounterid);


--
-- Name: finopencounter_opencounterid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincountermovement
    ADD CONSTRAINT finopencounter_opencounterid_fkey FOREIGN KEY (opencounterid) REFERENCES finopencounter(opencounterid);


--
-- Name: finopencounter_operatorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finopencounter
    ADD CONSTRAINT finopencounter_operatorid_fkey FOREIGN KEY (operatorid) REFERENCES basphysicalpersonemployee(personid);


--
-- Name: finoperation_accountschemeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finoperation
    ADD CONSTRAINT finoperation_accountschemeid_fkey FOREIGN KEY (accountschemeid) REFERENCES accaccountscheme(accountschemeid);


--
-- Name: finpayableinvoice_statusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpayableinvoice
    ADD CONSTRAINT finpayableinvoice_statusid_fkey FOREIGN KEY (statusid) REFERENCES finpayableinvoicestatus(status);


--
-- Name: finpayrolldiscounttarget_employeeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpayrolldiscounttarget
    ADD CONSTRAINT finpayrolldiscounttarget_employeeid_fkey FOREIGN KEY (employeeid) REFERENCES basphysicalpersonemployee(personid);


--
-- Name: finpersoninformation_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpersoninformation
    ADD CONSTRAINT finpersoninformation_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: finphysicaltarget_cityid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finphysicaltarget
    ADD CONSTRAINT finphysicaltarget_cityid_fkey FOREIGN KEY (cityid) REFERENCES bascity(cityid);


--
-- Name: finpolicy_collectiontypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpolicy
    ADD CONSTRAINT finpolicy_collectiontypeid_fkey FOREIGN KEY (collectiontypeid) REFERENCES fincollectiontype(collectiontypeid);


--
-- Name: finpolicy_emissiontypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpolicy
    ADD CONSTRAINT finpolicy_emissiontypeid_fkey FOREIGN KEY (emissiontypeid) REFERENCES finemissiontype(emissiontypeid);


--
-- Name: finpolicy_operationid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpolicy
    ADD CONSTRAINT finpolicy_operationid_fkey FOREIGN KEY (operationid) REFERENCES finoperation(operationid);


--
-- Name: finpolicydiscount_policyid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpolicydiscount
    ADD CONSTRAINT finpolicydiscount_policyid_fkey FOREIGN KEY (policyid) REFERENCES finpolicy(policyid);


--
-- Name: finprice_acdcourseoccurrence_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finprice
    ADD CONSTRAINT finprice_acdcourseoccurrence_fkey FOREIGN KEY (courseid, courseversion, turnid, unitid) REFERENCES acdcourseoccurrence(courseid, courseversion, turnid, unitid);


--
-- Name: finprice_bankaccountid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finprice
    ADD CONSTRAINT finprice_bankaccountid_fkey FOREIGN KEY (bankaccountid) REFERENCES finbankaccount(bankaccountid);


--
-- Name: finpricepolicy_finpolicy_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpricepolicy
    ADD CONSTRAINT finpricepolicy_finpolicy_fkey FOREIGN KEY (policyid) REFERENCES finpolicy(policyid);


--
-- Name: finpricepolicy_finprice_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finpricepolicy
    ADD CONSTRAINT finpricepolicy_finprice_fkey FOREIGN KEY (courseid, courseversion, turnid, unitid, startdate) REFERENCES finprice(courseid, courseversion, turnid, unitid, startdate);


--
-- Name: finreceivableinvoice_returnfileid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finreceivableinvoice
    ADD CONSTRAINT finreceivableinvoice_returnfileid_fkey FOREIGN KEY (returnfileid) REFERENCES basfile(fileid);


--
-- Name: finreceivableinvoicecommunication_fileid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finreceivableinvoicecommunication
    ADD CONSTRAINT finreceivableinvoicecommunication_fileid_fkey FOREIGN KEY (fileid) REFERENCES finfile(fileid);


--
-- Name: finreceivableinvoicecommunication_invoiceid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finreceivableinvoicecommunication
    ADD CONSTRAINT finreceivableinvoicecommunication_invoiceid_fkey FOREIGN KEY (invoiceid) REFERENCES fininvoice(invoiceid);


--
-- Name: finreemissaodetituloslog_newinvoiceid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finreemissaodetituloslog
    ADD CONSTRAINT finreemissaodetituloslog_newinvoiceid_fkey FOREIGN KEY (newinvoiceid) REFERENCES fininvoice(invoiceid);


--
-- Name: finreemissaodetituloslog_oldinvoiceid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finreemissaodetituloslog
    ADD CONSTRAINT finreemissaodetituloslog_oldinvoiceid_fkey FOREIGN KEY (oldinvoiceid) REFERENCES fininvoice(invoiceid);


--
-- Name: finrelease_invoiceid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finrelease
    ADD CONSTRAINT finrelease_invoiceid_fkey FOREIGN KEY (invoiceid) REFERENCES fininvoice(invoiceid);


--
-- Name: finrelease_operationid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finrelease
    ADD CONSTRAINT finrelease_operationid_fkey FOREIGN KEY (operationid) REFERENCES finoperation(operationid);


--
-- Name: finspc_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finspc
    ADD CONSTRAINT finspc_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: finspcmovement_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finspcmovement
    ADD CONSTRAINT finspcmovement_personid_fkey FOREIGN KEY (personid, entrydate) REFERENCES finspc(personid, entrydate);


--
-- Name: finspcmovement_reasonid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finspcmovement
    ADD CONSTRAINT finspcmovement_reasonid_fkey FOREIGN KEY (reasonid) REFERENCES finspcreason(reasonid);


--
-- Name: finspcmovement_reasonid_fkey1; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finspcmovement
    ADD CONSTRAINT finspcmovement_reasonid_fkey1 FOREIGN KEY (reasonid) REFERENCES finspcreason(reasonid);


--
-- Name: finspecies_speciestypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finspecies
    ADD CONSTRAINT finspecies_speciestypeid_fkey FOREIGN KEY (speciestypeid) REFERENCES finspeciestype(speciestypeid);


--
-- Name: finstatusdotitulolog_invoiceid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: solis
--

ALTER TABLE ONLY finstatusdotitulolog
    ADD CONSTRAINT finstatusdotitulolog_invoiceid_fkey FOREIGN KEY (invoiceid) REFERENCES fininvoice(invoiceid);


--
-- Name: finstatusdotitulolog_statusdotituloid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: solis
--

ALTER TABLE ONLY finstatusdotitulolog
    ADD CONSTRAINT finstatusdotitulolog_statusdotituloid_fkey FOREIGN KEY (statusdotituloid) REFERENCES finstatusdotitulo(statusdotituloid);


--
-- Name: finstudentfinancing_contractid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finstudentfinancing
    ADD CONSTRAINT finstudentfinancing_contractid_fkey FOREIGN KEY (contractid) REFERENCES acdcontract(contractid);


--
-- Name: finsupport_accountschemeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finsupport
    ADD CONSTRAINT finsupport_accountschemeid_fkey FOREIGN KEY (accountschemeid) REFERENCES accaccountscheme(accountschemeid);


--
-- Name: finsupport_collectionoperationid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finsupport
    ADD CONSTRAINT finsupport_collectionoperationid_fkey FOREIGN KEY (collectionoperationid) REFERENCES finoperation(operationid);


--
-- Name: fintransferenciadecaixa_caixaabertodeorigem_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fintransferenciadecaixa
    ADD CONSTRAINT fintransferenciadecaixa_caixaabertodeorigem_fkey FOREIGN KEY (caixaabertodeorigem) REFERENCES finopencounter(opencounterid);


--
-- Name: fintransferenciadecaixa_caixadedestino_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fintransferenciadecaixa
    ADD CONSTRAINT fintransferenciadecaixa_caixadedestino_fkey FOREIGN KEY (caixadedestino) REFERENCES fincounter(counterid);


--
-- Name: finvouchermessages_operationid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY finvouchermessages
    ADD CONSTRAINT finvouchermessages_operationid_fkey FOREIGN KEY (operationid) REFERENCES finoperation(operationid);


--
-- Name: fk_acdcourse; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtmensagemdestinatario
    ADD CONSTRAINT fk_acdcourse FOREIGN KEY (courseid) REFERENCES acdcourse(courseid);


--
-- Name: fk_acdgroup; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtmensagemdestinatario
    ADD CONSTRAINT fk_acdgroup FOREIGN KEY (groupid) REFERENCES acdgroup(groupid);


--
-- Name: fk_course; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourseparent
    ADD CONSTRAINT fk_course FOREIGN KEY (courseid, courseversion, turnid, unitid) REFERENCES acdcourseoccurrence(courseid, courseversion, turnid, unitid);


--
-- Name: fk_fincielomovement; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincielomovement
    ADD CONSTRAINT fk_fincielomovement FOREIGN KEY (countermovementid) REFERENCES fincountermovement(countermovementid);


--
-- Name: fk_fincielotransaction_fincielostatus; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincielotransaction
    ADD CONSTRAINT fk_fincielotransaction_fincielostatus FOREIGN KEY (cielostatusid) REFERENCES fincielostatus(cielostatusid);


--
-- Name: fk_mensagem_vinculo; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rccmensagemouvidoria
    ADD CONSTRAINT fk_mensagem_vinculo FOREIGN KEY (vinculodecontatoid) REFERENCES rccvinculodecontato(vinculodecontatoid);


--
-- Name: fk_miolo_custom_value_field; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY miolo_custom_value
    ADD CONSTRAINT fk_miolo_custom_value_field FOREIGN KEY (custom_field_id) REFERENCES miolo_custom_field(id);


--
-- Name: fk_mural_group; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtmensagemmural
    ADD CONSTRAINT fk_mural_group FOREIGN KEY (groupid) REFERENCES acdgroup(groupid);


--
-- Name: fk_mural_person; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtmensagemmural
    ADD CONSTRAINT fk_mural_person FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: fk_parentcourse; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdcourseparent
    ADD CONSTRAINT fk_parentcourse FOREIGN KEY (parentcourseid, parentcourseversion, parentturnid, parentunitid) REFERENCES acdcourseoccurrence(courseid, courseversion, turnid, unitid);


--
-- Name: fk_prtanexo_basfile; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtanexo
    ADD CONSTRAINT fk_prtanexo_basfile FOREIGN KEY (fileid) REFERENCES basfile(fileid);


--
-- Name: fk_prtanexo_prtmensagem; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtanexo
    ADD CONSTRAINT fk_prtanexo_prtmensagem FOREIGN KEY (mensagemid) REFERENCES prtmensagem(mensagemid);


--
-- Name: fk_prtmensagem; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtmensagemdestinatario
    ADD CONSTRAINT fk_prtmensagem FOREIGN KEY (mensagemid) REFERENCES prtmensagem(mensagemid);


--
-- Name: fk_prtmensagem_basunit; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtmensagem
    ADD CONSTRAINT fk_prtmensagem_basunit FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: fk_prtmensagemdestinatario_personid; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtmensagemdestinatario
    ADD CONSTRAINT fk_prtmensagemdestinatario_personid FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: fk_prtmensagemmural_groupid; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtmensagemmural
    ADD CONSTRAINT fk_prtmensagemmural_groupid FOREIGN KEY (groupid) REFERENCES acdgroup(groupid);


--
-- Name: fk_prtpreferenciascoordenador; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prtpreferenciascoordenador
    ADD CONSTRAINT fk_prtpreferenciascoordenador FOREIGN KEY (personid) REFERENCES basperson(personid) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: fk_ptcsubjectavailableto_ptcsubject; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcsubjectavailableto
    ADD CONSTRAINT fk_ptcsubjectavailableto_ptcsubject FOREIGN KEY (subjectid) REFERENCES ptcsubject(subjectid) ON DELETE CASCADE;


--
-- Name: fk_resposta_origem; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rccrespostaouvidoria
    ADD CONSTRAINT fk_resposta_origem FOREIGN KEY (origemdecontatoid) REFERENCES rccorigemdecontato(origemdecontatoid);


--
-- Name: fk_tipolancamento; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY caplancamento
    ADD CONSTRAINT fk_tipolancamento FOREIGN KEY (tipolancamento) REFERENCES captipolancamento(tipolancamentoid);


--
-- Name: fkacdtrainin372628; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtrainingdetail
    ADD CONSTRAINT fkacdtrainin372628 FOREIGN KEY (responsibleid) REFERENCES basphysicalperson(personid);


--
-- Name: fkacdtrainin441802; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtrainingemphasis
    ADD CONSTRAINT fkacdtrainin441802 FOREIGN KEY (responsibleid) REFERENCES basphysicalperson(personid);


--
-- Name: fkacdtrainin594472; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtrainingemphasis
    ADD CONSTRAINT fkacdtrainin594472 FOREIGN KEY (groupid) REFERENCES acdgroup(groupid);


--
-- Name: fkacdtrainin760490; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtrainingdetail
    ADD CONSTRAINT fkacdtrainin760490 FOREIGN KEY (enrollid) REFERENCES acdenroll(enrollid);


--
-- Name: fkacdtrainin942392; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acdtrainingdetail
    ADD CONSTRAINT fkacdtrainin942392 FOREIGN KEY (trainingemphasisid) REFERENCES acdtrainingemphasis(trainingemphasisid);


--
-- Name: fkacpatoregu241024; Type: FK CONSTRAINT; Schema: public; Owner: solis
--

ALTER TABLE ONLY acpatoregulatorio
    ADD CONSTRAINT fkacpatoregu241024 FOREIGN KEY (ocorrenciacursoid) REFERENCES acpocorrenciacurso(ocorrenciacursoid);


--
-- Name: fkacpavaliac217921; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpavaliacao
    ADD CONSTRAINT fkacpavaliac217921 FOREIGN KEY (matriculaid) REFERENCES acpmatricula(matriculaid);


--
-- Name: fkacpavaliac585478; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpavaliacao
    ADD CONSTRAINT fkacpavaliac585478 FOREIGN KEY (componentedeavaliacaoid) REFERENCES acpcomponentedeavaliacao(componentedeavaliacaoid);


--
-- Name: fkacpavaliac793681; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpavaliacao
    ADD CONSTRAINT fkacpavaliac793681 FOREIGN KEY (conceitodeavaliacaoid) REFERENCES acpconceitosdeavaliacao(conceitodeavaliacaoid);


--
-- Name: fkacpcompone245849; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentecurricularbibliografia
    ADD CONSTRAINT fkacpcompone245849 FOREIGN KEY (componentecurricularid) REFERENCES acpcomponentecurricular(componentecurricularid);


--
-- Name: fkacpcompone437202; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentecurricularmatriz
    ADD CONSTRAINT fkacpcompone437202 FOREIGN KEY (componentecurricularid) REFERENCES acpcomponentecurricular(componentecurricularid);


--
-- Name: fkacpcompone503409; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentecurricularmatriz
    ADD CONSTRAINT fkacpcompone503409 FOREIGN KEY (matrizcurriculargrupoid) REFERENCES acpmatrizcurriculargrupo(matrizcurriculargrupoid);


--
-- Name: fkacpcompone541196; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentecurricular
    ADD CONSTRAINT fkacpcompone541196 FOREIGN KEY (matrizcurricularid) REFERENCES acpmatrizcurricular(matrizcurricularid);


--
-- Name: fkacpcompone714594; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentecurricularbibliografia
    ADD CONSTRAINT fkacpcompone714594 FOREIGN KEY (ofertacomponentecurricularid) REFERENCES acpofertacomponentecurricular(ofertacomponentecurricularid);


--
-- Name: fkacpcompone922402; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentecurricular
    ADD CONSTRAINT fkacpcompone922402 FOREIGN KEY (professorresponsavelid) REFERENCES basphysicalpersonprofessor(personid);


--
-- Name: fkacpcoorden408430; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcoordenadores
    ADD CONSTRAINT fkacpcoorden408430 FOREIGN KEY (cursoid) REFERENCES acpcurso(cursoid);


--
-- Name: fkacpcursodo357668; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcursodocente
    ADD CONSTRAINT fkacpcursodo357668 FOREIGN KEY (personid) REFERENCES basphysicalpersonprofessor(personid);


--
-- Name: fkacpfrequen171599; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpfrequencia
    ADD CONSTRAINT fkacpfrequen171599 FOREIGN KEY (horarioofertacomponentecurricularid) REFERENCES acphorarioofertacomponentecurricular(horarioofertacomponentecurricularid);


--
-- Name: fkacpfrequen748574; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpfrequencia
    ADD CONSTRAINT fkacpfrequen748574 FOREIGN KEY (matriculaid) REFERENCES acpmatricula(matriculaid);


--
-- Name: fkacpfrequen805871; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpfrequencia
    ADD CONSTRAINT fkacpfrequen805871 FOREIGN KEY (ocorrenciahorarioofertaid) REFERENCES acpocorrenciahorariooferta(ocorrenciahorarioofertaid);


--
-- Name: fkacphorario16534; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acphorarioofertacomponentecurricular
    ADD CONSTRAINT fkacphorario16534 FOREIGN KEY (physicalresourceid, physicalresourceversion) REFERENCES insphysicalresource(physicalresourceid, physicalresourceversion);


--
-- Name: fkacphorario445584; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acphorarioofertacomponentecurricular
    ADD CONSTRAINT fkacphorario445584 FOREIGN KEY (horarioid) REFERENCES acphorario(horarioid);


--
-- Name: fkacphorario46131; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acphorarioofertacomponentecurricular
    ADD CONSTRAINT fkacphorario46131 FOREIGN KEY (personid) REFERENCES basphysicalpersonprofessor(personid);


--
-- Name: fkacphorario744443; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acphorarioofertacomponentecurricular
    ADD CONSTRAINT fkacphorario744443 FOREIGN KEY (ofertacomponentecurricularid) REFERENCES acpofertacomponentecurricular(ofertacomponentecurricularid);


--
-- Name: fkacpinscric103724; Type: FK CONSTRAINT; Schema: public; Owner: solis
--

ALTER TABLE ONLY acpinscricaoturmagrupo
    ADD CONSTRAINT fkacpinscric103724 FOREIGN KEY (ofertaturmaid) REFERENCES acpofertaturma(ofertaturmaid);


--
-- Name: fkacpinscric162136; Type: FK CONSTRAINT; Schema: public; Owner: solis
--

ALTER TABLE ONLY acpinscricaoturmagrupo
    ADD CONSTRAINT fkacpinscric162136 FOREIGN KEY (matrizcurriculargrupoid) REFERENCES acpmatrizcurriculargrupo(matrizcurriculargrupoid);


--
-- Name: fkacpinscric395183; Type: FK CONSTRAINT; Schema: public; Owner: solis
--

ALTER TABLE ONLY acpinscricaoturmagrupo
    ADD CONSTRAINT fkacpinscric395183 FOREIGN KEY (inscricaoid) REFERENCES acpinscricao(inscricaoid);


--
-- Name: fkacpinscric481362; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpinscricao
    ADD CONSTRAINT fkacpinscric481362 FOREIGN KEY (personid) REFERENCES basphysicalperson(personid);


--
-- Name: fkacpinscric695444; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpinscricao
    ADD CONSTRAINT fkacpinscric695444 FOREIGN KEY (ofertacursoid) REFERENCES acpofertacurso(ofertacursoid);


--
-- Name: fkacpinscric708377; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpinscricao
    ADD CONSTRAINT fkacpinscric708377 FOREIGN KEY (diadevencimentoid) REFERENCES prcdiadevencimento(diadevencimentoid);


--
-- Name: fkacpinscric751696; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpinscricao
    ADD CONSTRAINT fkacpinscric751696 FOREIGN KEY (convenantid) REFERENCES finconvenant(convenantid);


--
-- Name: fkacpinscric942021; Type: FK CONSTRAINT; Schema: public; Owner: solis
--

ALTER TABLE ONLY acpinscricaoturmagrupo
    ADD CONSTRAINT fkacpinscric942021 FOREIGN KEY (precocondicaomatriculaid) REFERENCES prcprecocondicao(precocondicaoid);


--
-- Name: fkacpinscric969347; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpinscricao
    ADD CONSTRAINT fkacpinscric969347 FOREIGN KEY (precocondicaoinscricaoid) REFERENCES prcprecocondicao(precocondicaoid);


--
-- Name: fkacpmatricu176072; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpmatricula
    ADD CONSTRAINT fkacpmatricu176072 FOREIGN KEY (ofertacomponentecurricularid) REFERENCES acpofertacomponentecurricular(ofertacomponentecurricularid);


--
-- Name: fkacpmatricu420041; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpmatricula
    ADD CONSTRAINT fkacpmatricu420041 FOREIGN KEY (inscricaoturmagrupoid) REFERENCES acpinscricaoturmagrupo(inscricaoturmagrupoid);


--
-- Name: fkacpmatricu592874; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpmatricula
    ADD CONSTRAINT fkacpmatricu592874 FOREIGN KEY (personid) REFERENCES basphysicalpersonstudent(personid);


--
-- Name: fkacpmatricu717510; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpmatricula
    ADD CONSTRAINT fkacpmatricu717510 FOREIGN KEY (estadodematriculaid) REFERENCES acpestadodematricula(estadodematriculaid);


--
-- Name: fkacpmatricu920660; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpmatricula
    ADD CONSTRAINT fkacpmatricu920660 FOREIGN KEY (precocondicaoid) REFERENCES prcprecocondicao(precocondicaoid);


--
-- Name: fkacpocorren130187; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpocorrenciahorariooferta
    ADD CONSTRAINT fkacpocorren130187 FOREIGN KEY (physicalresourceid, physicalresourceversion) REFERENCES insphysicalresource(physicalresourceid, physicalresourceversion);


--
-- Name: fkacpocorren13018799; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpofertacomponentecurricular
    ADD CONSTRAINT fkacpocorren13018799 FOREIGN KEY (componentecurricularmatrizid) REFERENCES acpcomponentecurricularmatriz(componentecurricularmatrizid);


--
-- Name: fkacpocorren331931; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpocorrenciahorariooferta
    ADD CONSTRAINT fkacpocorren331931 FOREIGN KEY (horarioid) REFERENCES acphorario(horarioid);


--
-- Name: fkacpocorren557133; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpocorrenciahorariooferta
    ADD CONSTRAINT fkacpocorren557133 FOREIGN KEY (professorid) REFERENCES basphysicalpersonprofessor(personid);


--
-- Name: fkacpocorren630790; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpocorrenciahorariooferta
    ADD CONSTRAINT fkacpocorren630790 FOREIGN KEY (ofertacomponentecurricularid) REFERENCES acpofertacomponentecurricular(ofertacomponentecurricularid);


--
-- Name: fkacpofertac266135; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpofertacurso
    ADD CONSTRAINT fkacpofertac266135 FOREIGN KEY (ocorrenciacursoid) REFERENCES acpocorrenciacurso(ocorrenciacursoid);


--
-- Name: fkacpofertac363581; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpofertacomponentecurricular
    ADD CONSTRAINT fkacpofertac363581 FOREIGN KEY (componentecurricularmatrizid) REFERENCES acpcomponentecurricularmatriz(componentecurricularmatrizid);


--
-- Name: fkacpofertac424396; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpofertacomponentecurricular
    ADD CONSTRAINT fkacpofertac424396 FOREIGN KEY (ofertaturmaid) REFERENCES acpofertaturma(ofertaturmaid);


--
-- Name: fkacpofertat430790; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpofertaturma
    ADD CONSTRAINT fkacpofertat430790 FOREIGN KEY (ofertacursoid) REFERENCES acpofertacurso(ofertacursoid);


--
-- Name: fkacpofertat440543; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpofertaturma
    ADD CONSTRAINT fkacpofertat440543 FOREIGN KEY (gradehorarioid) REFERENCES acpgradehorario(gradehorarioid);


--
-- Name: fkacpofertat663548; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpofertaturma
    ADD CONSTRAINT fkacpofertat663548 FOREIGN KEY (ofertaturmaanteriorid) REFERENCES acpofertaturma(ofertaturmaid);


--
-- Name: fkacpperfilc232139; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpperfilcurso
    ADD CONSTRAINT fkacpperfilc232139 FOREIGN KEY (modelodeavaliacaogeral) REFERENCES acpmodelodeavaliacao(modelodeavaliacaoid);


--
-- Name: fkacpperfilc54550; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpperfilcurso
    ADD CONSTRAINT fkacpperfilc54550 FOREIGN KEY (modelodeavaliacaoseriado) REFERENCES acpmodelodeavaliacao(modelodeavaliacaoid);


--
-- Name: fkbasbadge618207; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basbadge
    ADD CONSTRAINT fkbasbadge618207 FOREIGN KEY (badgestatusid) REFERENCES basbadgestatus(badgestatusid);


--
-- Name: fkbasbadgelo129097; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basbadgeloan
    ADD CONSTRAINT fkbasbadgelo129097 FOREIGN KEY (badgeid) REFERENCES basbadge(badgeid);


--
-- Name: fkbasbadgelo996403; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basbadgeloan
    ADD CONSTRAINT fkbasbadgelo996403 FOREIGN KEY (personid) REFERENCES basphysicalperson(personid);


--
-- Name: fkcapsolicit220819; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY capsolicitacaoparcela
    ADD CONSTRAINT fkcapsolicit220819 FOREIGN KEY (solicitacaoid) REFERENCES capsolicitacao(solicitacaoid);


--
-- Name: fkcapsolicit406247; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY capsolicitacao
    ADD CONSTRAINT fkcapsolicit406247 FOREIGN KEY (personid) REFERENCES basphysicalperson(personid);


--
-- Name: fkcapsolicit528156; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY capsolicitacao
    ADD CONSTRAINT fkcapsolicit528156 FOREIGN KEY (costcenterid) REFERENCES acccostcenter(costcenterid);


--
-- Name: fkcapsolicit934368; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY capsolicitacao
    ADD CONSTRAINT fkcapsolicit934368 FOREIGN KEY (solicitacaoestadoid) REFERENCES capsolicitacaoestado(solicitacaoestadoid);


--
-- Name: fkfincampore319509; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincamporemessa
    ADD CONSTRAINT fkfincampore319509 FOREIGN KEY (configuracaoremessaid) REFERENCES finconfiguracaoremessa(configuracaoremessaid);


--
-- Name: fkfincampore809838; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincamporemessa
    ADD CONSTRAINT fkfincampore809838 FOREIGN KEY (tipovalorvariavelremessaid) REFERENCES fintipovalorvariavelremessa(tipovalorvariavelremessaid);


--
-- Name: fkfincobranc153769; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY fincobrancabancaria
    ADD CONSTRAINT fkfincobranc153769 FOREIGN KEY (bankaccountid) REFERENCES finbankaccount(bankaccountid);


--
-- Name: fkgtcsipequi824286; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcsipequipament
    ADD CONSTRAINT fkgtcsipequi824286 FOREIGN KEY (locationformaterialmovementid) REFERENCES gtclocationformaterialmovement(locationformaterialmovementid);


--
-- Name: fkprcformade807953; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prcformadepagamentodopreco
    ADD CONSTRAINT fkprcformade807953 FOREIGN KEY (precocursoid) REFERENCES prcprecocurso(precocursoid);


--
-- Name: fkprcprecoco250656; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prcprecocondicao
    ADD CONSTRAINT fkprcprecoco250656 FOREIGN KEY (operationid) REFERENCES finoperation(operationid);


--
-- Name: fkprcprecoco267624; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prcprecocondicao
    ADD CONSTRAINT fkprcprecoco267624 FOREIGN KEY (operationid) REFERENCES finoperation(operationid);


--
-- Name: fkprcprecoco519816; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prcprecocondicao
    ADD CONSTRAINT fkprcprecoco519816 FOREIGN KEY (condicaodepagamentoid) REFERENCES prccondicaodepagamento(condicaodepagamentoid);


--
-- Name: fkprcprecoco606059; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prcprecocondicao
    ADD CONSTRAINT fkprcprecoco606059 FOREIGN KEY (precocursogrupoid) REFERENCES prcprecocursogrupo(precocursogrupoid);


--
-- Name: fkprcprecoco693178; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prcprecocondicao
    ADD CONSTRAINT fkprcprecoco693178 FOREIGN KEY (precocursogrupoid) REFERENCES prcprecocursogrupo(precocursogrupoid);


--
-- Name: fkprcprecoco816343; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prcprecocondicao
    ADD CONSTRAINT fkprcprecoco816343 FOREIGN KEY (precocursoid) REFERENCES prcprecocurso(precocursoid);


--
-- Name: fkprcprecocu141168; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prcprecocurso
    ADD CONSTRAINT fkprcprecocu141168 FOREIGN KEY (bankaccountid) REFERENCES finbankaccount(bankaccountid);


--
-- Name: fkprcprecocu162342; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prcprecocurso
    ADD CONSTRAINT fkprcprecocu162342 FOREIGN KEY (incomesourceid) REFERENCES finincomesource(incomesourceid);


--
-- Name: fkprcprecocu227175; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prcprecocurso
    ADD CONSTRAINT fkprcprecocu227175 FOREIGN KEY (ofertaturmaid) REFERENCES acpofertaturma(ofertaturmaid);


--
-- Name: fkprcprecocu240117; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prcprecocurso
    ADD CONSTRAINT fkprcprecocu240117 FOREIGN KEY (operationid) REFERENCES finoperation(operationid);


--
-- Name: fkprcprecocu439542; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prcprecocurso
    ADD CONSTRAINT fkprcprecocu439542 FOREIGN KEY (ocorrenciacursoid) REFERENCES acpocorrenciacurso(ocorrenciacursoid);


--
-- Name: fkprcprecocu490900; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prcprecocurso
    ADD CONSTRAINT fkprcprecocu490900 FOREIGN KEY (costcenterid) REFERENCES acccostcenter(costcenterid);


--
-- Name: fkprcprecocu557710; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prcprecocurso
    ADD CONSTRAINT fkprcprecocu557710 FOREIGN KEY (ofertacursoid) REFERENCES acpofertacurso(ofertacursoid);


--
-- Name: fkprcprecocu701334; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prcprecocurso
    ADD CONSTRAINT fkprcprecocu701334 FOREIGN KEY (incomesourceid) REFERENCES finincomesource(incomesourceid);


--
-- Name: fkprcprecocu760841; Type: FK CONSTRAINT; Schema: public; Owner: solis
--

ALTER TABLE ONLY prcprecocursogrupo
    ADD CONSTRAINT fkprcprecocu760841 FOREIGN KEY (matrizcurriculargrupoid) REFERENCES acpmatrizcurriculargrupo(matrizcurriculargrupoid);


--
-- Name: fkprcprecocu962913; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prcprecocurso
    ADD CONSTRAINT fkprcprecocu962913 FOREIGN KEY (policyid) REFERENCES finpolicy(policyid);


--
-- Name: fkprcprecocu99319; Type: FK CONSTRAINT; Schema: public; Owner: solis
--

ALTER TABLE ONLY prcprecocursogrupo
    ADD CONSTRAINT fkprcprecocu99319 FOREIGN KEY (precocursoid) REFERENCES prcprecocurso(precocursoid);


--
-- Name: fkprctituloi464502; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prctituloinscricao
    ADD CONSTRAINT fkprctituloi464502 FOREIGN KEY (inscricaoid) REFERENCES acpinscricao(inscricaoid);


--
-- Name: fkprctituloi495271; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prctituloinscricao
    ADD CONSTRAINT fkprctituloi495271 FOREIGN KEY (inscricaoid) REFERENCES acpinscricao(inscricaoid);


--
-- Name: fkprctituloi620289; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prctituloinscricao
    ADD CONSTRAINT fkprctituloi620289 FOREIGN KEY (invoiceid) REFERENCES finreceivableinvoice(invoiceid);


--
-- Name: fkprctituloi805756; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prctituloinscricao
    ADD CONSTRAINT fkprctituloi805756 FOREIGN KEY (precocondicaoid) REFERENCES prcprecocondicao(precocondicaoid);


--
-- Name: fkprctituloi869621; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prctituloinscricao
    ADD CONSTRAINT fkprctituloi869621 FOREIGN KEY (invoiceid) REFERENCES finreceivableinvoice(invoiceid);


--
-- Name: fkrccinteres163830; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rccinteresse
    ADD CONSTRAINT fkrccinteres163830 FOREIGN KEY (rcccontatocontatoid) REFERENCES rcccontato(contatoid);


--
-- Name: fkrccmensage687809; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rccmensagemouvidoria
    ADD CONSTRAINT fkrccmensage687809 FOREIGN KEY (vinculodecontatoid) REFERENCES rccvinculodecontato(vinculodecontatoid);


--
-- Name: fkrccrespost91434; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rccrespostaouvidoria
    ADD CONSTRAINT fkrccrespost91434 FOREIGN KEY (origemdecontatoid) REFERENCES rccorigemdecontato(origemdecontatoid);


--
-- Name: gtcanalytics_libraryunit_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcanalytics
    ADD CONSTRAINT gtcanalytics_libraryunit_fkey FOREIGN KEY (libraryunitid) REFERENCES gtclibraryunit(libraryunitid);


--
-- Name: gtcanalytics_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcanalytics
    ADD CONSTRAINT gtcanalytics_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: gtcbackgroundtasklog_libraryunitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcbackgroundtasklog
    ADD CONSTRAINT gtcbackgroundtasklog_libraryunitid_fkey FOREIGN KEY (libraryunitid) REFERENCES gtclibraryunit(libraryunitid);


--
-- Name: gtccontrolfielddetail_fieldid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtccontrolfielddetail
    ADD CONSTRAINT gtccontrolfielddetail_fieldid_fkey FOREIGN KEY (fieldid, subfieldid) REFERENCES gtctag(fieldid, subfieldid);


--
-- Name: gtccontrolfielddetail_marctaglistid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtccontrolfielddetail
    ADD CONSTRAINT gtccontrolfielddetail_marctaglistid_fkey FOREIGN KEY (marctaglistid) REFERENCES gtcmarctaglisting(marctaglistingid);


--
-- Name: gtcdictionarycontent_dictionaryid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcdictionarycontent
    ADD CONSTRAINT gtcdictionarycontent_dictionaryid_fkey FOREIGN KEY (dictionaryid) REFERENCES gtcdictionary(dictionaryid);


--
-- Name: gtcdictionaryrelatedcontent_dictionarycontentid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcdictionaryrelatedcontent
    ADD CONSTRAINT gtcdictionaryrelatedcontent_dictionarycontentid_fkey FOREIGN KEY (dictionarycontentid) REFERENCES gtcdictionarycontent(dictionarycontentid);


--
-- Name: gtcemailcontroldelayedloan_loanid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcemailcontroldelayedloan
    ADD CONSTRAINT gtcemailcontroldelayedloan_loanid_fkey FOREIGN KEY (loanid) REFERENCES gtcloan(loanid);


--
-- Name: gtcemailcontrolnotifyaquisition_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcemailcontrolnotifyaquisition
    ADD CONSTRAINT gtcemailcontrolnotifyaquisition_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: gtcexemplarycontrol_exemplarystatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcexemplarycontrol
    ADD CONSTRAINT gtcexemplarycontrol_exemplarystatusid_fkey FOREIGN KEY (exemplarystatusid) REFERENCES gtcexemplarystatus(exemplarystatusid);


--
-- Name: gtcexemplarycontrol_libraryunitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcexemplarycontrol
    ADD CONSTRAINT gtcexemplarycontrol_libraryunitid_fkey FOREIGN KEY (libraryunitid) REFERENCES gtclibraryunit(libraryunitid);


--
-- Name: gtcexemplarycontrol_materialgenderid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcexemplarycontrol
    ADD CONSTRAINT gtcexemplarycontrol_materialgenderid_fkey FOREIGN KEY (materialgenderid) REFERENCES gtcmaterialgender(materialgenderid);


--
-- Name: gtcexemplarycontrol_materialphysicaltypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcexemplarycontrol
    ADD CONSTRAINT gtcexemplarycontrol_materialphysicaltypeid_fkey FOREIGN KEY (materialphysicaltypeid) REFERENCES gtcmaterialphysicaltype(materialphysicaltypeid);


--
-- Name: gtcexemplarycontrol_materialtypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcexemplarycontrol
    ADD CONSTRAINT gtcexemplarycontrol_materialtypeid_fkey FOREIGN KEY (materialtypeid) REFERENCES gtcmaterialtype(materialtypeid);


--
-- Name: gtcexemplarycontrol_originallibraryunitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcexemplarycontrol
    ADD CONSTRAINT gtcexemplarycontrol_originallibraryunitid_fkey FOREIGN KEY (originallibraryunitid) REFERENCES gtclibraryunit(libraryunitid);


--
-- Name: gtcexemplaryfuturestatusdefined_exemplarystatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcexemplaryfuturestatusdefined
    ADD CONSTRAINT gtcexemplaryfuturestatusdefined_exemplarystatusid_fkey FOREIGN KEY (exemplarystatusid) REFERENCES gtcexemplarystatus(exemplarystatusid);


--
-- Name: gtcexemplarystatushistory_exemplarystatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcexemplarystatushistory
    ADD CONSTRAINT gtcexemplarystatushistory_exemplarystatusid_fkey FOREIGN KEY (exemplarystatusid) REFERENCES gtcexemplarystatus(exemplarystatusid);


--
-- Name: gtcexemplarystatushistory_libraryunitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcexemplarystatushistory
    ADD CONSTRAINT gtcexemplarystatushistory_libraryunitid_fkey FOREIGN KEY (libraryunitid) REFERENCES gtclibraryunit(libraryunitid);


--
-- Name: gtcfavorite_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcfavorite
    ADD CONSTRAINT gtcfavorite_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: gtcfine_finestatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcfine
    ADD CONSTRAINT gtcfine_finestatusid_fkey FOREIGN KEY (finestatusid) REFERENCES gtcfinestatus(finestatusid);


--
-- Name: gtcfine_loanid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcfine
    ADD CONSTRAINT gtcfine_loanid_fkey FOREIGN KEY (loanid) REFERENCES gtcloan(loanid);


--
-- Name: gtcfinestatushistory_fineid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcfinestatushistory
    ADD CONSTRAINT gtcfinestatushistory_fineid_fkey FOREIGN KEY (fineid) REFERENCES gtcfine(fineid);


--
-- Name: gtcfinestatushistory_finestatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcfinestatushistory
    ADD CONSTRAINT gtcfinestatushistory_finestatusid_fkey FOREIGN KEY (finestatusid) REFERENCES gtcfinestatus(finestatusid);


--
-- Name: gtcformcontent_formcontenttype_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcformcontent
    ADD CONSTRAINT gtcformcontent_formcontenttype_fkey FOREIGN KEY (formcontenttype) REFERENCES gtcformcontenttype(formcontenttypeid);


--
-- Name: gtcgeneralpolicy_linkid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcgeneralpolicy
    ADD CONSTRAINT gtcgeneralpolicy_linkid_fkey FOREIGN KEY (linkid) REFERENCES baslink(linkid);


--
-- Name: gtcgeneralpolicy_privilegegroupid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcgeneralpolicy
    ADD CONSTRAINT gtcgeneralpolicy_privilegegroupid_fkey FOREIGN KEY (privilegegroupid) REFERENCES gtcprivilegegroup(privilegegroupid);


--
-- Name: gtcholiday_libraryunitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcholiday
    ADD CONSTRAINT gtcholiday_libraryunitid_fkey FOREIGN KEY (libraryunitid) REFERENCES gtclibraryunit(libraryunitid);


--
-- Name: gtcinterchange_interchangestatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcinterchange
    ADD CONSTRAINT gtcinterchange_interchangestatusid_fkey FOREIGN KEY (interchangestatusid) REFERENCES gtcinterchangestatus(interchangestatusid);


--
-- Name: gtcinterchange_interchangetypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcinterchange
    ADD CONSTRAINT gtcinterchange_interchangetypeid_fkey FOREIGN KEY (interchangetypeid) REFERENCES gtcinterchangetype(interchangetypeid);


--
-- Name: gtcinterchange_supplierid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcinterchange
    ADD CONSTRAINT gtcinterchange_supplierid_fkey FOREIGN KEY (supplierid) REFERENCES gtcsupplier(supplierid);


--
-- Name: gtcinterchangeitem_interchangeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcinterchangeitem
    ADD CONSTRAINT gtcinterchangeitem_interchangeid_fkey FOREIGN KEY (interchangeid) REFERENCES gtcinterchange(interchangeid);


--
-- Name: gtcinterchangeobservation_interchangeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcinterchangeobservation
    ADD CONSTRAINT gtcinterchangeobservation_interchangeid_fkey FOREIGN KEY (interchangeid) REFERENCES gtcinterchange(interchangeid);


--
-- Name: gtcinterchangestatus_interchangetypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcinterchangestatus
    ADD CONSTRAINT gtcinterchangestatus_interchangetypeid_fkey FOREIGN KEY (interchangetypeid) REFERENCES gtcinterchangetype(interchangetypeid);


--
-- Name: gtcinterestsarea_classificationareaid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcinterestsarea
    ADD CONSTRAINT gtcinterestsarea_classificationareaid_fkey FOREIGN KEY (classificationareaid) REFERENCES gtcclassificationarea(classificationareaid);


--
-- Name: gtcinterestsarea_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcinterestsarea
    ADD CONSTRAINT gtcinterestsarea_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: gtckardexcontrol_libraryunitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtckardexcontrol
    ADD CONSTRAINT gtckardexcontrol_libraryunitid_fkey FOREIGN KEY (libraryunitid) REFERENCES gtclibraryunit(libraryunitid);


--
-- Name: gtclibperson_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtclibperson
    ADD CONSTRAINT gtclibperson_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: gtclibraryassociation_associationid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtclibraryassociation
    ADD CONSTRAINT gtclibraryassociation_associationid_fkey FOREIGN KEY (associationid) REFERENCES gtcassociation(associationid);


--
-- Name: gtclibraryassociation_libraryunitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtclibraryassociation
    ADD CONSTRAINT gtclibraryassociation_libraryunitid_fkey FOREIGN KEY (libraryunitid) REFERENCES gtclibraryunit(libraryunitid);


--
-- Name: gtclibraryunit_librarygroupid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtclibraryunit
    ADD CONSTRAINT gtclibraryunit_librarygroupid_fkey FOREIGN KEY (librarygroupid) REFERENCES gtclibrarygroup(librarygroupid);


--
-- Name: gtclibraryunit_privilegegroupid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtclibraryunit
    ADD CONSTRAINT gtclibraryunit_privilegegroupid_fkey FOREIGN KEY (privilegegroupid) REFERENCES gtcprivilegegroup(privilegegroupid);


--
-- Name: gtclibraryunitaccess_libraryunitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtclibraryunitaccess
    ADD CONSTRAINT gtclibraryunitaccess_libraryunitid_fkey FOREIGN KEY (libraryunitid) REFERENCES gtclibraryunit(libraryunitid);


--
-- Name: gtclibraryunitaccess_linkid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtclibraryunitaccess
    ADD CONSTRAINT gtclibraryunitaccess_linkid_fkey FOREIGN KEY (linkid) REFERENCES baslink(linkid);


--
-- Name: gtclibraryunitconfig_libraryunitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtclibraryunitconfig
    ADD CONSTRAINT gtclibraryunitconfig_libraryunitid_fkey FOREIGN KEY (libraryunitid) REFERENCES gtclibraryunit(libraryunitid);


--
-- Name: gtclibraryunitisclosed_libraryunitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtclibraryunitisclosed
    ADD CONSTRAINT gtclibraryunitisclosed_libraryunitid_fkey FOREIGN KEY (libraryunitid) REFERENCES gtclibraryunit(libraryunitid);


--
-- Name: gtclibraryunitisclosed_weekdayid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtclibraryunitisclosed
    ADD CONSTRAINT gtclibraryunitisclosed_weekdayid_fkey FOREIGN KEY (weekdayid) REFERENCES gtcweekday(weekdayid);


--
-- Name: gtcloan_libraryunitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcloan
    ADD CONSTRAINT gtcloan_libraryunitid_fkey FOREIGN KEY (libraryunitid) REFERENCES gtclibraryunit(libraryunitid);


--
-- Name: gtcloan_linkid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcloan
    ADD CONSTRAINT gtcloan_linkid_fkey FOREIGN KEY (linkid) REFERENCES baslink(linkid);


--
-- Name: gtcloan_loantypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcloan
    ADD CONSTRAINT gtcloan_loantypeid_fkey FOREIGN KEY (loantypeid) REFERENCES gtcloantype(loantypeid);


--
-- Name: gtcloan_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcloan
    ADD CONSTRAINT gtcloan_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: gtcloan_privilegegroupid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcloan
    ADD CONSTRAINT gtcloan_privilegegroupid_fkey FOREIGN KEY (privilegegroupid) REFERENCES gtcprivilegegroup(privilegegroupid);


--
-- Name: gtcloanbetweenlibrary_libraryunitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcloanbetweenlibrary
    ADD CONSTRAINT gtcloanbetweenlibrary_libraryunitid_fkey FOREIGN KEY (libraryunitid) REFERENCES gtclibraryunit(libraryunitid);


--
-- Name: gtcloanbetweenlibrary_loanbetweenlibrarystatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcloanbetweenlibrary
    ADD CONSTRAINT gtcloanbetweenlibrary_loanbetweenlibrarystatusid_fkey FOREIGN KEY (loanbetweenlibrarystatusid) REFERENCES gtcloanbetweenlibrarystatus(loanbetweenlibrarystatusid);


--
-- Name: gtcloanbetweenlibrary_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcloanbetweenlibrary
    ADD CONSTRAINT gtcloanbetweenlibrary_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: gtcloanbetweenlibrarycomposition_loanbetweenlibraryid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcloanbetweenlibrarycomposition
    ADD CONSTRAINT gtcloanbetweenlibrarycomposition_loanbetweenlibraryid_fkey FOREIGN KEY (loanbetweenlibraryid) REFERENCES gtcloanbetweenlibrary(loanbetweenlibraryid);


--
-- Name: gtcloanbetweenlibrarystatushist_loanbetweenlibrarystatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcloanbetweenlibrarystatushistory
    ADD CONSTRAINT gtcloanbetweenlibrarystatushist_loanbetweenlibrarystatusid_fkey FOREIGN KEY (loanbetweenlibrarystatusid) REFERENCES gtcloanbetweenlibrarystatus(loanbetweenlibrarystatusid);


--
-- Name: gtcmarctaglistingoption_marctaglistingid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcmarctaglistingoption
    ADD CONSTRAINT gtcmarctaglistingoption_marctaglistingid_fkey FOREIGN KEY (marctaglistingid) REFERENCES gtcmarctaglisting(marctaglistingid);


--
-- Name: gtcmaterial_fieldid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcmaterial
    ADD CONSTRAINT gtcmaterial_fieldid_fkey FOREIGN KEY (fieldid, subfieldid) REFERENCES gtctag(fieldid, subfieldid);


--
-- Name: gtcmaterial_prefixid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcmaterial
    ADD CONSTRAINT gtcmaterial_prefixid_fkey FOREIGN KEY (prefixid) REFERENCES gtcprefixsuffix(prefixsuffixid);


--
-- Name: gtcmaterial_separatorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcmaterial
    ADD CONSTRAINT gtcmaterial_separatorid_fkey FOREIGN KEY (separatorid) REFERENCES gtcseparator(separatorid);


--
-- Name: gtcmaterial_suffixid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcmaterial
    ADD CONSTRAINT gtcmaterial_suffixid_fkey FOREIGN KEY (suffixid) REFERENCES gtcprefixsuffix(prefixsuffixid);


--
-- Name: gtcmaterialcontrol_category_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcmaterialcontrol
    ADD CONSTRAINT gtcmaterialcontrol_category_fkey FOREIGN KEY (category, level) REFERENCES gtcspreadsheet(category, level);


--
-- Name: gtcmaterialcontrol_materialgenderid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcmaterialcontrol
    ADD CONSTRAINT gtcmaterialcontrol_materialgenderid_fkey FOREIGN KEY (materialgenderid) REFERENCES gtcmaterialgender(materialgenderid);


--
-- Name: gtcmaterialcontrol_materialphysicaltypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcmaterialcontrol
    ADD CONSTRAINT gtcmaterialcontrol_materialphysicaltypeid_fkey FOREIGN KEY (materialphysicaltypeid) REFERENCES gtcmaterialphysicaltype(materialphysicaltypeid);


--
-- Name: gtcmaterialcontrol_materialtypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcmaterialcontrol
    ADD CONSTRAINT gtcmaterialcontrol_materialtypeid_fkey FOREIGN KEY (materialtypeid) REFERENCES gtcmaterialtype(materialtypeid);


--
-- Name: gtcmaterialevaluation_controlnumber_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcmaterialevaluation
    ADD CONSTRAINT gtcmaterialevaluation_controlnumber_fkey FOREIGN KEY (controlnumber) REFERENCES gtcmaterialcontrol(controlnumber);


--
-- Name: gtcmaterialevaluation_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcmaterialevaluation
    ADD CONSTRAINT gtcmaterialevaluation_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: gtcmaterialhistory_currentprefixid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcmaterialhistory
    ADD CONSTRAINT gtcmaterialhistory_currentprefixid_fkey FOREIGN KEY (currentprefixid) REFERENCES gtcprefixsuffix(prefixsuffixid);


--
-- Name: gtcmaterialhistory_currentseparatorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcmaterialhistory
    ADD CONSTRAINT gtcmaterialhistory_currentseparatorid_fkey FOREIGN KEY (currentseparatorid) REFERENCES gtcseparator(separatorid);


--
-- Name: gtcmaterialhistory_currentsuffixid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcmaterialhistory
    ADD CONSTRAINT gtcmaterialhistory_currentsuffixid_fkey FOREIGN KEY (currentsuffixid) REFERENCES gtcprefixsuffix(prefixsuffixid);


--
-- Name: gtcmaterialhistory_fieldid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcmaterialhistory
    ADD CONSTRAINT gtcmaterialhistory_fieldid_fkey FOREIGN KEY (fieldid, subfieldid) REFERENCES gtctag(fieldid, subfieldid);


--
-- Name: gtcmaterialhistory_previousprefixid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcmaterialhistory
    ADD CONSTRAINT gtcmaterialhistory_previousprefixid_fkey FOREIGN KEY (previousprefixid) REFERENCES gtcprefixsuffix(prefixsuffixid);


--
-- Name: gtcmaterialhistory_previousseparatorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcmaterialhistory
    ADD CONSTRAINT gtcmaterialhistory_previousseparatorid_fkey FOREIGN KEY (previousseparatorid) REFERENCES gtcseparator(separatorid);


--
-- Name: gtcmaterialhistory_previoussufixxid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcmaterialhistory
    ADD CONSTRAINT gtcmaterialhistory_previoussufixxid_fkey FOREIGN KEY (previoussuffixid) REFERENCES gtcprefixsuffix(prefixsuffixid);


--
-- Name: gtcmylibrary_mylibraryid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcmylibrary
    ADD CONSTRAINT gtcmylibrary_mylibraryid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: gtcnews_libraryunitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcnews
    ADD CONSTRAINT gtcnews_libraryunitid_fkey FOREIGN KEY (libraryunitid) REFERENCES gtclibraryunit(libraryunitid);


--
-- Name: gtcnewsaccess_linkid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcnewsaccess
    ADD CONSTRAINT gtcnewsaccess_linkid_fkey FOREIGN KEY (linkid) REFERENCES baslink(linkid);


--
-- Name: gtcnewsaccess_newsid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcnewsaccess
    ADD CONSTRAINT gtcnewsaccess_newsid_fkey FOREIGN KEY (newsid) REFERENCES gtcnews(newsid);


--
-- Name: gtcoperatorlibraryunit_libraryunitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcoperatorlibraryunit
    ADD CONSTRAINT gtcoperatorlibraryunit_libraryunitid_fkey FOREIGN KEY (libraryunitid) REFERENCES gtclibraryunit(libraryunitid);


--
-- Name: gtcpenalty_libraryunitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcpenalty
    ADD CONSTRAINT gtcpenalty_libraryunitid_fkey FOREIGN KEY (libraryunitid) REFERENCES gtclibraryunit(libraryunitid);


--
-- Name: gtcpenalty_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcpenalty
    ADD CONSTRAINT gtcpenalty_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: gtcpersonconfig_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcpersonconfig
    ADD CONSTRAINT gtcpersonconfig_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: gtcpersonlibraryunit_libraryunitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcpersonlibraryunit
    ADD CONSTRAINT gtcpersonlibraryunit_libraryunitid_fkey FOREIGN KEY (libraryunitid) REFERENCES gtclibraryunit(libraryunitid);


--
-- Name: gtcpersonlibraryunit_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcpersonlibraryunit
    ADD CONSTRAINT gtcpersonlibraryunit_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: gtcpolicy_linkid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcpolicy
    ADD CONSTRAINT gtcpolicy_linkid_fkey FOREIGN KEY (linkid) REFERENCES baslink(linkid);


--
-- Name: gtcpolicy_materialgenderid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcpolicy
    ADD CONSTRAINT gtcpolicy_materialgenderid_fkey FOREIGN KEY (materialgenderid) REFERENCES gtcmaterialgender(materialgenderid);


--
-- Name: gtcpolicy_privilegegroupid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcpolicy
    ADD CONSTRAINT gtcpolicy_privilegegroupid_fkey FOREIGN KEY (privilegegroupid) REFERENCES gtcprivilegegroup(privilegegroupid);


--
-- Name: gtcprecatalogue_prefixid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcprecatalogue
    ADD CONSTRAINT gtcprecatalogue_prefixid_fkey FOREIGN KEY (prefixid) REFERENCES gtcprefixsuffix(prefixsuffixid);


--
-- Name: gtcprecatalogue_separatorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcprecatalogue
    ADD CONSTRAINT gtcprecatalogue_separatorid_fkey FOREIGN KEY (separatorid) REFERENCES gtcseparator(separatorid);


--
-- Name: gtcprecatalogue_suffixid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcprecatalogue
    ADD CONSTRAINT gtcprecatalogue_suffixid_fkey FOREIGN KEY (suffixid) REFERENCES gtcprefixsuffix(prefixsuffixid);


--
-- Name: gtcprefixsuffix_fieldid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcprefixsuffix
    ADD CONSTRAINT gtcprefixsuffix_fieldid_fkey FOREIGN KEY (fieldid, subfieldid) REFERENCES gtctag(fieldid, subfieldid);


--
-- Name: gtcpurchaserequest_controlnumber_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcpurchaserequest
    ADD CONSTRAINT gtcpurchaserequest_controlnumber_fkey FOREIGN KEY (controlnumber) REFERENCES gtcmaterialcontrol(controlnumber);


--
-- Name: gtcpurchaserequest_costcenterid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcpurchaserequest
    ADD CONSTRAINT gtcpurchaserequest_costcenterid_fkey FOREIGN KEY (costcenterid) REFERENCES gtccostcenter(costcenterid);


--
-- Name: gtcpurchaserequest_libraryunitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcpurchaserequest
    ADD CONSTRAINT gtcpurchaserequest_libraryunitid_fkey FOREIGN KEY (libraryunitid) REFERENCES gtclibraryunit(libraryunitid);


--
-- Name: gtcpurchaserequest_purchaserequestid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcpurchaserequest
    ADD CONSTRAINT gtcpurchaserequest_purchaserequestid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: gtcpurchaserequestmaterial_gtctag_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcpurchaserequestmaterial
    ADD CONSTRAINT gtcpurchaserequestmaterial_gtctag_fkey FOREIGN KEY (fieldid, subfieldid) REFERENCES gtctag(fieldid, subfieldid);


--
-- Name: gtcpurchaserequestmaterial_purchaserequestid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcpurchaserequestmaterial
    ADD CONSTRAINT gtcpurchaserequestmaterial_purchaserequestid_fkey FOREIGN KEY (purchaserequestid) REFERENCES gtcpurchaserequest(purchaserequestid);


--
-- Name: gtcpurchaserequestquotation_purchaserequestid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcpurchaserequestquotation
    ADD CONSTRAINT gtcpurchaserequestquotation_purchaserequestid_fkey FOREIGN KEY (purchaserequestid) REFERENCES gtcpurchaserequest(purchaserequestid);


--
-- Name: gtcpurchaserequestquotation_supplierid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcpurchaserequestquotation
    ADD CONSTRAINT gtcpurchaserequestquotation_supplierid_fkey FOREIGN KEY (supplierid) REFERENCES gtcsupplier(supplierid);


--
-- Name: gtcrenew_loanid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcrenew
    ADD CONSTRAINT gtcrenew_loanid_fkey FOREIGN KEY (loanid) REFERENCES gtcloan(loanid);


--
-- Name: gtcrenew_renewtypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcrenew
    ADD CONSTRAINT gtcrenew_renewtypeid_fkey FOREIGN KEY (renewtypeid) REFERENCES gtcrenewtype(renewtypeid);


--
-- Name: gtcreportparameter_reportid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcreportparameter
    ADD CONSTRAINT gtcreportparameter_reportid_fkey FOREIGN KEY (reportid) REFERENCES gtcreport(reportid);


--
-- Name: gtcrequestchangeexemplarysta_requestchangeexemplarystatus_fkey1; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcrequestchangeexemplarystatusstatushistory
    ADD CONSTRAINT gtcrequestchangeexemplarysta_requestchangeexemplarystatus_fkey1 FOREIGN KEY (requestchangeexemplarystatusstatusid) REFERENCES gtcrequestchangeexemplarystatusstatus(requestchangeexemplarystatusstatusid);


--
-- Name: gtcrequestchangeexemplarysta_requestchangeexemplarystatus_fkey2; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcrequestchangeexemplarystatuscomposition
    ADD CONSTRAINT gtcrequestchangeexemplarysta_requestchangeexemplarystatus_fkey2 FOREIGN KEY (requestchangeexemplarystatusid) REFERENCES gtcrequestchangeexemplarystatus(requestchangeexemplarystatusid);


--
-- Name: gtcrequestchangeexemplarystat_exemplaryfuturestatusdefined_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcrequestchangeexemplarystatuscomposition
    ADD CONSTRAINT gtcrequestchangeexemplarystat_exemplaryfuturestatusdefined_fkey FOREIGN KEY (exemplaryfuturestatusdefinedid) REFERENCES gtcexemplaryfuturestatusdefined(exemplaryfuturestatusdefinedid);


--
-- Name: gtcrequestchangeexemplarystat_requestchangeexemplarystatus_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcrequestchangeexemplarystatusstatushistory
    ADD CONSTRAINT gtcrequestchangeexemplarystat_requestchangeexemplarystatus_fkey FOREIGN KEY (requestchangeexemplarystatusid) REFERENCES gtcrequestchangeexemplarystatus(requestchangeexemplarystatusid);


--
-- Name: gtcrequestchangeexemplarystatus_futurestatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcrequestchangeexemplarystatus
    ADD CONSTRAINT gtcrequestchangeexemplarystatus_futurestatusid_fkey FOREIGN KEY (futurestatusid) REFERENCES gtcexemplarystatus(exemplarystatusid);


--
-- Name: gtcrequestchangeexemplarystatus_libraryunitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcrequestchangeexemplarystatus
    ADD CONSTRAINT gtcrequestchangeexemplarystatus_libraryunitid_fkey FOREIGN KEY (libraryunitid) REFERENCES gtclibraryunit(libraryunitid);


--
-- Name: gtcrequestchangeexemplarystatus_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcrequestchangeexemplarystatus
    ADD CONSTRAINT gtcrequestchangeexemplarystatus_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: gtcrequestchangeexemplarystatusaccess_baslinkid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcrequestchangeexemplarystatusaccess
    ADD CONSTRAINT gtcrequestchangeexemplarystatusaccess_baslinkid_fkey FOREIGN KEY (baslinkid) REFERENCES baslink(linkid);


--
-- Name: gtcrequestchangeexemplarystatusaccess_exemplarystatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcrequestchangeexemplarystatusaccess
    ADD CONSTRAINT gtcrequestchangeexemplarystatusaccess_exemplarystatusid_fkey FOREIGN KEY (exemplarystatusid) REFERENCES gtcexemplarystatus(exemplarystatusid);


--
-- Name: gtcreserve_libraryunitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcreserve
    ADD CONSTRAINT gtcreserve_libraryunitid_fkey FOREIGN KEY (libraryunitid) REFERENCES gtclibraryunit(libraryunitid);


--
-- Name: gtcreserve_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcreserve
    ADD CONSTRAINT gtcreserve_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: gtcreserve_reservestatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcreserve
    ADD CONSTRAINT gtcreserve_reservestatusid_fkey FOREIGN KEY (reservestatusid) REFERENCES gtcreservestatus(reservestatusid);


--
-- Name: gtcreserve_reservetypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcreserve
    ADD CONSTRAINT gtcreserve_reservetypeid_fkey FOREIGN KEY (reservetypeid) REFERENCES gtcreservetype(reservetypeid);


--
-- Name: gtcreservecomposition_reserveid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcreservecomposition
    ADD CONSTRAINT gtcreservecomposition_reserveid_fkey FOREIGN KEY (reserveid) REFERENCES gtcreserve(reserveid);


--
-- Name: gtcreservestatushistory_reserveid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcreservestatushistory
    ADD CONSTRAINT gtcreservestatushistory_reserveid_fkey FOREIGN KEY (reserveid) REFERENCES gtcreserve(reserveid);


--
-- Name: gtcreservestatushistory_reservestatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcreservestatushistory
    ADD CONSTRAINT gtcreservestatushistory_reservestatusid_fkey FOREIGN KEY (reservestatusid) REFERENCES gtcreservestatus(reservestatusid);


--
-- Name: gtcreturnregister_returntypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcreturnregister
    ADD CONSTRAINT gtcreturnregister_returntypeid_fkey FOREIGN KEY (returntypeid) REFERENCES gtcreturntype(returntypeid);


--
-- Name: gtcright_linkid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcright
    ADD CONSTRAINT gtcright_linkid_fkey FOREIGN KEY (linkid) REFERENCES baslink(linkid);


--
-- Name: gtcright_materialgenderid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcright
    ADD CONSTRAINT gtcright_materialgenderid_fkey FOREIGN KEY (materialgenderid) REFERENCES gtcmaterialgender(materialgenderid);


--
-- Name: gtcright_operationid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcright
    ADD CONSTRAINT gtcright_operationid_fkey FOREIGN KEY (operationid) REFERENCES gtcoperation(operationid);


--
-- Name: gtcright_privilegegroupid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcright
    ADD CONSTRAINT gtcright_privilegegroupid_fkey FOREIGN KEY (privilegegroupid) REFERENCES gtcprivilegegroup(privilegegroupid);


--
-- Name: gtcrulesformaterialmovement_currentstate_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcrulesformaterialmovement
    ADD CONSTRAINT gtcrulesformaterialmovement_currentstate_fkey FOREIGN KEY (currentstate) REFERENCES gtcexemplarystatus(exemplarystatusid);


--
-- Name: gtcrulesformaterialmovement_futurestate_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcrulesformaterialmovement
    ADD CONSTRAINT gtcrulesformaterialmovement_futurestate_fkey FOREIGN KEY (futurestate) REFERENCES gtcexemplarystatus(exemplarystatusid);


--
-- Name: gtcrulesformaterialmovement_locationformaterialmovementid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcrulesformaterialmovement
    ADD CONSTRAINT gtcrulesformaterialmovement_locationformaterialmovementid_fkey FOREIGN KEY (locationformaterialmovementid) REFERENCES gtclocationformaterialmovement(locationformaterialmovementid);


--
-- Name: gtcrulesformaterialmovement_operationid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcrulesformaterialmovement
    ADD CONSTRAINT gtcrulesformaterialmovement_operationid_fkey FOREIGN KEY (operationid) REFERENCES gtcoperation(operationid);


--
-- Name: gtcscheduletask_schedulecycleid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcscheduletask
    ADD CONSTRAINT gtcscheduletask_schedulecycleid_fkey FOREIGN KEY (schedulecycleid) REFERENCES gtcschedulecycle(schedulecycleid);


--
-- Name: gtcscheduletask_taskid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcscheduletask
    ADD CONSTRAINT gtcscheduletask_taskid_fkey FOREIGN KEY (taskid) REFERENCES gtctask(taskid);


--
-- Name: gtcscheduletasklog_scheduletaskid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcscheduletasklog
    ADD CONSTRAINT gtcscheduletasklog_scheduletaskid_fkey FOREIGN KEY (scheduletaskid) REFERENCES gtcscheduletask(scheduletaskid);


--
-- Name: gtcsearchablefieldaccess_linkid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcsearchablefieldaccess
    ADD CONSTRAINT gtcsearchablefieldaccess_linkid_fkey FOREIGN KEY (linkid) REFERENCES baslink(linkid);


--
-- Name: gtcsearchablefieldaccess_searchablefieldid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcsearchablefieldaccess
    ADD CONSTRAINT gtcsearchablefieldaccess_searchablefieldid_fkey FOREIGN KEY (searchablefieldid) REFERENCES gtcsearchablefield(searchablefieldid);


--
-- Name: gtcsearchformataccess_linkid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcsearchformataccess
    ADD CONSTRAINT gtcsearchformataccess_linkid_fkey FOREIGN KEY (linkid) REFERENCES baslink(linkid);


--
-- Name: gtcsearchformataccess_searchformatid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcsearchformataccess
    ADD CONSTRAINT gtcsearchformataccess_searchformatid_fkey FOREIGN KEY (searchformatid) REFERENCES gtcsearchformat(searchformatid);


--
-- Name: gtcsearchformatcolumn_searchformatid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcsearchformatcolumn
    ADD CONSTRAINT gtcsearchformatcolumn_searchformatid_fkey FOREIGN KEY (searchformatid) REFERENCES gtcsearchformat(searchformatid);


--
-- Name: gtcsearchpresentationformat_searchformatid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcsearchpresentationformat
    ADD CONSTRAINT gtcsearchpresentationformat_searchformatid_fkey FOREIGN KEY (searchformatid) REFERENCES gtcsearchformat(searchformatid);


--
-- Name: gtcseparator_cataloguingformatid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcseparator
    ADD CONSTRAINT gtcseparator_cataloguingformatid_fkey FOREIGN KEY (cataloguingformatid) REFERENCES gtccataloguingformat(cataloguingformatid);


--
-- Name: gtcsession_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcsession
    ADD CONSTRAINT gtcsession_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: gtcsession_sipequipamentid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcsession
    ADD CONSTRAINT gtcsession_sipequipamentid_fkey FOREIGN KEY (sipequipamentid) REFERENCES gtcsipequipament(sipequipamentid);


--
-- Name: gtcsessionoperation_loanid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcsessionoperation
    ADD CONSTRAINT gtcsessionoperation_loanid_fkey FOREIGN KEY (loanid) REFERENCES gtcloan(loanid);


--
-- Name: gtcsessionoperation_renewid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcsessionoperation
    ADD CONSTRAINT gtcsessionoperation_renewid_fkey FOREIGN KEY (renewid) REFERENCES gtcrenew(renewid);


--
-- Name: gtcsessionoperation_returnregisterid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcsessionoperation
    ADD CONSTRAINT gtcsessionoperation_returnregisterid_fkey FOREIGN KEY (returnregisterid) REFERENCES gtcreturnregister(returnregisterid);


--
-- Name: gtcsessionoperation_sessionid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcsessionoperation
    ADD CONSTRAINT gtcsessionoperation_sessionid_fkey FOREIGN KEY (sessionid) REFERENCES gtcsession(sessionid);


--
-- Name: gtcsipcirculationstatus_exemplarystatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcsipcirculationstatus
    ADD CONSTRAINT gtcsipcirculationstatus_exemplarystatusid_fkey FOREIGN KEY (exemplarystatusid) REFERENCES gtcexemplarystatus(exemplarystatusid);


--
-- Name: gtcsipequipament_libraryunitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcsipequipament
    ADD CONSTRAINT gtcsipequipament_libraryunitid_fkey FOREIGN KEY (libraryunitid) REFERENCES gtclibraryunit(libraryunitid);


--
-- Name: gtcsipequipamentbinrules_exemplarystatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcsipequipamentbinrules
    ADD CONSTRAINT gtcsipequipamentbinrules_exemplarystatusid_fkey FOREIGN KEY (exemplarystatusid) REFERENCES gtcexemplarystatus(exemplarystatusid);


--
-- Name: gtcsipequipamentbinrules_sipequipamentid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcsipequipamentbinrules
    ADD CONSTRAINT gtcsipequipamentbinrules_sipequipamentid_fkey FOREIGN KEY (sipequipamentid) REFERENCES gtcsipequipament(sipequipamentid);


--
-- Name: gtcsipequipamentlog_sipequipament_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcsipequipamentlog
    ADD CONSTRAINT gtcsipequipamentlog_sipequipament_fkey FOREIGN KEY (sipequipamentid) REFERENCES gtcsipequipament(sipequipamentid);


--
-- Name: gtcsoapaccess_soapclientid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcsoapaccess
    ADD CONSTRAINT gtcsoapaccess_soapclientid_fkey FOREIGN KEY (soapclientid) REFERENCES gtcsoapclient(soapclientid);


--
-- Name: gtcsoapaccess_webserviceid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcsoapaccess
    ADD CONSTRAINT gtcsoapaccess_webserviceid_fkey FOREIGN KEY (webserviceid) REFERENCES gtcwebservice(webserviceid);


--
-- Name: gtcsuppliertypeandlocation_supplierid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcsuppliertypeandlocation
    ADD CONSTRAINT gtcsuppliertypeandlocation_supplierid_fkey FOREIGN KEY (supplierid) REFERENCES gtcsupplier(supplierid);


--
-- Name: gtcworkflowhistory_workflowinstanceid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcworkflowhistory
    ADD CONSTRAINT gtcworkflowhistory_workflowinstanceid_fkey FOREIGN KEY (workflowinstanceid) REFERENCES gtcworkflowinstance(workflowinstanceid);


--
-- Name: gtcworkflowhistory_workflowstatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcworkflowhistory
    ADD CONSTRAINT gtcworkflowhistory_workflowstatusid_fkey FOREIGN KEY (workflowstatusid) REFERENCES gtcworkflowstatus(workflowstatusid);


--
-- Name: gtcworkflowinstance_workflowstatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcworkflowinstance
    ADD CONSTRAINT gtcworkflowinstance_workflowstatusid_fkey FOREIGN KEY (workflowstatusid) REFERENCES gtcworkflowstatus(workflowstatusid);


--
-- Name: gtcworkflowtransition_nextworkflowstatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcworkflowtransition
    ADD CONSTRAINT gtcworkflowtransition_nextworkflowstatusid_fkey FOREIGN KEY (nextworkflowstatusid) REFERENCES gtcworkflowstatus(workflowstatusid);


--
-- Name: gtcworkflowtransition_previousworkflowstatusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcworkflowtransition
    ADD CONSTRAINT gtcworkflowtransition_previousworkflowstatusid_fkey FOREIGN KEY (previousworkflowstatusid) REFERENCES gtcworkflowstatus(workflowstatusid);


--
-- Name: insphysicalresource_areatypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY insphysicalresource
    ADD CONSTRAINT insphysicalresource_areatypeid_fkey FOREIGN KEY (areatypeid) REFERENCES insareatype(areatypeid);


--
-- Name: insphysicalresource_coord_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY insphysicalresource
    ADD CONSTRAINT insphysicalresource_coord_fkey FOREIGN KEY (coord) REFERENCES basphysicalperson(personid);


--
-- Name: insphysicalresource_grouptypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY insphysicalresource
    ADD CONSTRAINT insphysicalresource_grouptypeid_fkey FOREIGN KEY (grouptypeid) REFERENCES insgrouptype(grouptypeid);


--
-- Name: insphysicalresource_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY insphysicalresource
    ADD CONSTRAINT insphysicalresource_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: libraryunitfk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcmateriallocation
    ADD CONSTRAINT libraryunitfk FOREIGN KEY (libraryunitid) REFERENCES gtclibraryunit(libraryunitid);


--
-- Name: materiallocationfk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY gtcmateriallocationtag
    ADD CONSTRAINT materiallocationfk FOREIGN KEY (gtcmateriallocatioid) REFERENCES gtcmateriallocation(materiallocationid);


--
-- Name: miolo_audit_fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY miolo_audit_detail
    ADD CONSTRAINT miolo_audit_fk FOREIGN KEY (audit_id) REFERENCES miolo_audit(audit_id);


--
-- Name: miolo_groupuser_unitid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY miolo_groupuser
    ADD CONSTRAINT miolo_groupuser_unitid_fkey FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: miolo_transaction_parent_transaction_fkey1; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY miolo_transaction
    ADD CONSTRAINT miolo_transaction_parent_transaction_fkey1 FOREIGN KEY (parent_transaction) REFERENCES miolo_transaction(m_transaction);


--
-- Name: multiunidade001fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcursodocente
    ADD CONSTRAINT multiunidade001fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade002fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpmatrizcurricular
    ADD CONSTRAINT multiunidade002fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade003fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpofertaturma
    ADD CONSTRAINT multiunidade003fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade004fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpavaliacao
    ADD CONSTRAINT multiunidade004fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade005fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpmatrizcurriculargrupo
    ADD CONSTRAINT multiunidade005fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade006fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpperfilcurso
    ADD CONSTRAINT multiunidade006fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade007fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpfrequencia
    ADD CONSTRAINT multiunidade007fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade008fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpperfilcursocamposadicionais
    ADD CONSTRAINT multiunidade008fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade009fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpmovimentoinscricao
    ADD CONSTRAINT multiunidade009fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade011fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpperfilcursocomponentecurricular
    ADD CONSTRAINT multiunidade011fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade012fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcamposadicionaiscurso
    ADD CONSTRAINT multiunidade012fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade013fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpmovimentomatricula
    ADD CONSTRAINT multiunidade013fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade014fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentecurricular
    ADD CONSTRAINT multiunidade014fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade015fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpregrasmatriculaperfilcurso
    ADD CONSTRAINT multiunidade015fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade016fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentecurricularbibliografia
    ADD CONSTRAINT multiunidade016fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade017fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcontroledefrequencia
    ADD CONSTRAINT multiunidade017fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade018fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acphorarioofertacomponentecurricular
    ADD CONSTRAINT multiunidade018fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade019fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpocorrenciahorariooferta
    ADD CONSTRAINT multiunidade019fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade020fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentecurriculardisciplina
    ADD CONSTRAINT multiunidade020fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade021fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcoordenadores
    ADD CONSTRAINT multiunidade021fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade022fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpinscricao
    ADD CONSTRAINT multiunidade022fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade023fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpofertacomponentecurricular
    ADD CONSTRAINT multiunidade023fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade024fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpcomponentecurriculartrabalhoconclusao
    ADD CONSTRAINT multiunidade024fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade025fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpmatricula
    ADD CONSTRAINT multiunidade025fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade026fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY acpofertacurso
    ADD CONSTRAINT multiunidade026fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade027fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prccondicaodepagamento
    ADD CONSTRAINT multiunidade027fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade028fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prcmovimentoprecocurso
    ADD CONSTRAINT multiunidade028fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade029fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prcprecocondicao
    ADD CONSTRAINT multiunidade029fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade030fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prcprecocurso
    ADD CONSTRAINT multiunidade030fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade031fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY prctituloinscricao
    ADD CONSTRAINT multiunidade031fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: multiunidade032fk; Type: FK CONSTRAINT; Schema: public; Owner: solis
--

ALTER TABLE ONLY acpinscricaoturmagrupo
    ADD CONSTRAINT multiunidade032fk FOREIGN KEY (unitid) REFERENCES basunit(unitid);


--
-- Name: origem2; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rccmensagemouvidoria
    ADD CONSTRAINT origem2 FOREIGN KEY (origemdecontatoid) REFERENCES rccorigemdecontato(origemdecontatoid);


--
-- Name: ptcdispatch_forwardedsubjectid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcdispatch
    ADD CONSTRAINT ptcdispatch_forwardedsubjectid_fkey FOREIGN KEY (forwardedsubjectid, forwardedsectorid, forwardedlevel) REFERENCES ptcsubjectsector(subjectid, sectorid, level);


--
-- Name: ptcdispatch_requestid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcdispatch
    ADD CONSTRAINT ptcdispatch_requestid_fkey FOREIGN KEY (requestid) REFERENCES ptcrequest(requestid);


--
-- Name: ptcdispatch_subjectid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcdispatch
    ADD CONSTRAINT ptcdispatch_subjectid_fkey FOREIGN KEY (subjectid, sectorid, level) REFERENCES ptcsubjectsector(subjectid, sectorid, level);


--
-- Name: ptcdocument_fileid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcdocument
    ADD CONSTRAINT ptcdocument_fileid_fkey FOREIGN KEY (fileid) REFERENCES basfile(fileid);


--
-- Name: ptcdocument_requestid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcdocument
    ADD CONSTRAINT ptcdocument_requestid_fkey FOREIGN KEY (requestid) REFERENCES ptcrequest(requestid);


--
-- Name: ptcrequest_currentsubjectid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcrequest
    ADD CONSTRAINT ptcrequest_currentsubjectid_fkey FOREIGN KEY (currentsubjectid, currentsectorid, currentlevel) REFERENCES ptcsubjectsector(subjectid, sectorid, level);


--
-- Name: ptcrequest_invoiceid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcrequest
    ADD CONSTRAINT ptcrequest_invoiceid_fkey FOREIGN KEY (invoiceid) REFERENCES finreceivableinvoice(invoiceid);


--
-- Name: ptcrequest_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcrequest
    ADD CONSTRAINT ptcrequest_personid_fkey FOREIGN KEY (personid) REFERENCES basphysicalperson(personid);


--
-- Name: ptcrequest_sectorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcrequest
    ADD CONSTRAINT ptcrequest_sectorid_fkey FOREIGN KEY (sectorid) REFERENCES bassector(sectorid);


--
-- Name: ptcrequest_statusid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcrequest
    ADD CONSTRAINT ptcrequest_statusid_fkey FOREIGN KEY (statusid) REFERENCES ptcrequeststatus(requeststatusid);


--
-- Name: ptcrequest_subjectid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcrequest
    ADD CONSTRAINT ptcrequest_subjectid_fkey FOREIGN KEY (subjectid) REFERENCES ptcsubject(subjectid);


--
-- Name: ptcrequireddocument_subjectid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcrequireddocument
    ADD CONSTRAINT ptcrequireddocument_subjectid_fkey FOREIGN KEY (subjectid) REFERENCES ptcsubject(subjectid);


--
-- Name: ptcsubject_sectorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcsubject
    ADD CONSTRAINT ptcsubject_sectorid_fkey FOREIGN KEY (sectorid) REFERENCES bassector(sectorid);


--
-- Name: ptcsubjectsector_sectorid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcsubjectsector
    ADD CONSTRAINT ptcsubjectsector_sectorid_fkey FOREIGN KEY (sectorid) REFERENCES bassector(sectorid);


--
-- Name: ptcsubjectsector_subjectid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY ptcsubjectsector
    ADD CONSTRAINT ptcsubjectsector_subjectid_fkey FOREIGN KEY (subjectid) REFERENCES ptcsubject(subjectid);


--
-- Name: rccmensagemouvidoria2; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rccrespostaouvidoria
    ADD CONSTRAINT rccmensagemouvidoria2 FOREIGN KEY (mensagemouvidoriaid) REFERENCES rccmensagemouvidoria(mensagemouvidoriaid);


--
-- Name: rshanswer_optionid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rshanswer
    ADD CONSTRAINT rshanswer_optionid_fkey FOREIGN KEY (optionid) REFERENCES rshoption(optionid);


--
-- Name: rshanswer_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rshanswer
    ADD CONSTRAINT rshanswer_personid_fkey FOREIGN KEY (personid) REFERENCES basperson(personid);


--
-- Name: rshanswer_questionid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rshanswer
    ADD CONSTRAINT rshanswer_questionid_fkey FOREIGN KEY (questionid) REFERENCES rshquestion(questionid);


--
-- Name: rshoption_questionid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rshoption
    ADD CONSTRAINT rshoption_questionid_fkey FOREIGN KEY (questionid) REFERENCES rshquestion(questionid);


--
-- Name: rshquestion_answertypeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rshquestion
    ADD CONSTRAINT rshquestion_answertypeid_fkey FOREIGN KEY (answertypeid) REFERENCES rshanswertype(answertypeid);


--
-- Name: rshquestion_formid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rshquestion
    ADD CONSTRAINT rshquestion_formid_fkey FOREIGN KEY (formid) REFERENCES rshform(formid);


--
-- Name: rshquestion_questioncategoryid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rshquestion
    ADD CONSTRAINT rshquestion_questioncategoryid_fkey FOREIGN KEY (questioncategoryid) REFERENCES rshquestioncategory(questioncategoryid);


--
-- Name: rshwho_formid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rshwho
    ADD CONSTRAINT rshwho_formid_fkey FOREIGN KEY (formid) REFERENCES rshform(formid);


--
-- Name: rshwho_personid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rshwho
    ADD CONSTRAINT rshwho_personid_fkey FOREIGN KEY (personid) REFERENCES basphysicalperson(personid);


--
-- Name: tabelareferenciada_cadastrodinamicoid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY tabelareferenciada
    ADD CONSTRAINT tabelareferenciada_cadastrodinamicoid_fkey FOREIGN KEY (cadastrodinamicoid) REFERENCES cadastrodinamico(cadastrodinamicoid);


--
-- Name: tipo2; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY rccmensagemouvidoria
    ADD CONSTRAINT tipo2 FOREIGN KEY (tipodecontatoid) REFERENCES rcctipodecontato(tipodecontatoid);


--
-- Name: unit_location; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY basunit
    ADD CONSTRAINT unit_location FOREIGN KEY (locationid) REFERENCES baslocation(locationid) MATCH FULL;


SET search_path = res, pg_catalog;

--
-- Name: coorientador_personid_fkey; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY coorientador
    ADD CONSTRAINT coorientador_personid_fkey FOREIGN KEY (personid) REFERENCES public.basperson(personid);


--
-- Name: fkcargahorar134326; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY cargahorariacomplementar
    ADD CONSTRAINT fkcargahorar134326 FOREIGN KEY (tipodecargahorariacomplementarid) REFERENCES tipodecargahorariacomplementar(tipodecargahorariacomplementarid);


--
-- Name: fkcargahorar597456; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY cargahorariacomplementar
    ADD CONSTRAINT fkcargahorar597456 FOREIGN KEY (unidadetematicaid) REFERENCES unidadetematica(unidadetematicaid);


--
-- Name: fkcargahorar871031; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY cargahorariacomplementar
    ADD CONSTRAINT fkcargahorar871031 FOREIGN KEY (residenteid) REFERENCES residente(residenteid);


--
-- Name: fkcoorientad838498; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY coorientador
    ADD CONSTRAINT fkcoorientad838498 FOREIGN KEY (personid) REFERENCES public.basphysicalperson(personid);


--
-- Name: fkcoorientad87962; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY coorientador
    ADD CONSTRAINT fkcoorientad87962 FOREIGN KEY (trabalhodeconclusaoid) REFERENCES trabalhodeconclusao(trabalhodeconclusaoid);


--
-- Name: fkencontro647754; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY encontro
    ADD CONSTRAINT fkencontro647754 FOREIGN KEY (temaid) REFERENCES tema(temaid);


--
-- Name: fkencontro767294; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY encontro
    ADD CONSTRAINT fkencontro767294 FOREIGN KEY (ofertadeunidadetematicaid) REFERENCES ofertadeunidadetematica(ofertadeunidadetematicaid);


--
-- Name: fkenfasedaun277432; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY enfasedaunidadetematica
    ADD CONSTRAINT fkenfasedaun277432 FOREIGN KEY (unidadetematicaid) REFERENCES unidadetematica(unidadetematicaid);


--
-- Name: fkenfasedaun546785; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY enfasedaunidadetematica
    ADD CONSTRAINT fkenfasedaun546785 FOREIGN KEY (enfaseid) REFERENCES enfase(enfaseid);


--
-- Name: fkfrequencia125239; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY frequencia
    ADD CONSTRAINT fkfrequencia125239 FOREIGN KEY (encontroid) REFERENCES encontro(encontroid);


--
-- Name: fkfrequencia967830; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY frequencia
    ADD CONSTRAINT fkfrequencia967830 FOREIGN KEY (residenteid) REFERENCES residente(residenteid);


--
-- Name: fkmembrodaba339099; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY membrodabanca
    ADD CONSTRAINT fkmembrodaba339099 FOREIGN KEY (trabalhodeconclusaoid) REFERENCES trabalhodeconclusao(trabalhodeconclusaoid);


--
-- Name: fkmembrodaba412638; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY membrodabanca
    ADD CONSTRAINT fkmembrodaba412638 FOREIGN KEY (personid) REFERENCES public.basphysicalperson(personid);


--
-- Name: fknucleodaun298548; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY nucleodaunidadetematica
    ADD CONSTRAINT fknucleodaun298548 FOREIGN KEY (nucleoprofissionalid) REFERENCES nucleoprofissional(nucleoprofissionalid);


--
-- Name: fknucleodaun507563; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY nucleodaunidadetematica
    ADD CONSTRAINT fknucleodaun507563 FOREIGN KEY (unidadetematicaid) REFERENCES unidadetematica(unidadetematicaid);


--
-- Name: fkocorrencia52742; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY ocorrenciadecontrato
    ADD CONSTRAINT fkocorrencia52742 FOREIGN KEY (statusdaocorrenciadecontratoid) REFERENCES statusdaocorrenciadecontrato(statusdaocorrenciadecontratoid);


--
-- Name: fkocorrencia585881; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY ocorrenciadeoferta
    ADD CONSTRAINT fkocorrencia585881 FOREIGN KEY (ofertadoresidenteid) REFERENCES ofertadoresidente(ofertadoresidenteid);


--
-- Name: fkocorrencia797792; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY ocorrenciadecontrato
    ADD CONSTRAINT fkocorrencia797792 FOREIGN KEY (residenteid) REFERENCES residente(residenteid);


--
-- Name: fkofertadeun725745; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY ofertadeunidadetematica
    ADD CONSTRAINT fkofertadeun725745 FOREIGN KEY (personid) REFERENCES public.basphysicalperson(personid);


--
-- Name: fkofertadeun855386; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY ofertadeunidadetematica
    ADD CONSTRAINT fkofertadeun855386 FOREIGN KEY (unidadetematicaid) REFERENCES unidadetematica(unidadetematicaid);


--
-- Name: fkofertadeun947021; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY ofertadeunidadetematica
    ADD CONSTRAINT fkofertadeun947021 FOREIGN KEY (encerradopor) REFERENCES public.miolo_user(iduser);


--
-- Name: fkofertadore401370; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY ofertadoresidente
    ADD CONSTRAINT fkofertadore401370 FOREIGN KEY (ofertadeunidadetematicaid) REFERENCES ofertadeunidadetematica(ofertadeunidadetematicaid);


--
-- Name: fkofertadore672250; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY ofertadoresidente
    ADD CONSTRAINT fkofertadore672250 FOREIGN KEY (residenteid) REFERENCES residente(residenteid);


--
-- Name: fkparticipac217110; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY participacaoematividadeextra
    ADD CONSTRAINT fkparticipac217110 FOREIGN KEY (atividadeextraid) REFERENCES atividadeextra(atividadeextraid);


--
-- Name: fkparticipac563015; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY participacaoematividadeextra
    ADD CONSTRAINT fkparticipac563015 FOREIGN KEY (residenteid) REFERENCES residente(residenteid);


--
-- Name: fkpreceptori184605; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY preceptoria
    ADD CONSTRAINT fkpreceptori184605 FOREIGN KEY (personid) REFERENCES public.basphysicalperson(personid);


--
-- Name: fkpreceptori387991; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY preceptoria
    ADD CONSTRAINT fkpreceptori387991 FOREIGN KEY (enfaseid) REFERENCES enfase(enfaseid);


--
-- Name: fkpreceptori448329; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY preceptoria
    ADD CONSTRAINT fkpreceptori448329 FOREIGN KEY (nucleoprofissionalid) REFERENCES nucleoprofissional(nucleoprofissionalid);


--
-- Name: fkresidente378258; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY residente
    ADD CONSTRAINT fkresidente378258 FOREIGN KEY (unidade1) REFERENCES public.basunit(unitid);


--
-- Name: fkresidente378259; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY residente
    ADD CONSTRAINT fkresidente378259 FOREIGN KEY (unidade2) REFERENCES public.basunit(unitid);


--
-- Name: fkresidente562142; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY residente
    ADD CONSTRAINT fkresidente562142 FOREIGN KEY (nucleoprofissionalid) REFERENCES nucleoprofissional(nucleoprofissionalid);


--
-- Name: fkresidente622480; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY residente
    ADD CONSTRAINT fkresidente622480 FOREIGN KEY (enfaseid) REFERENCES enfase(enfaseid);


--
-- Name: fkresidente776513; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY residente
    ADD CONSTRAINT fkresidente776513 FOREIGN KEY (personid) REFERENCES public.basphysicalperson(personid);


--
-- Name: fkresidente866505; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY residente
    ADD CONSTRAINT fkresidente866505 FOREIGN KEY (subscriptionid) REFERENCES spr.subscription(subscriptionid);


--
-- Name: fktemadaunid130944; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY temadaunidadetematica
    ADD CONSTRAINT fktemadaunid130944 FOREIGN KEY (ofertadeunidadetematicaid) REFERENCES ofertadeunidadetematica(ofertadeunidadetematicaid);


--
-- Name: fktemadaunid644952; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY temadaunidadetematica
    ADD CONSTRAINT fktemadaunid644952 FOREIGN KEY (temaid) REFERENCES tema(temaid);


--
-- Name: fktrabalhode119803; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY trabalhodeconclusao
    ADD CONSTRAINT fktrabalhode119803 FOREIGN KEY (residenteid) REFERENCES residente(residenteid);


--
-- Name: fktrabalhode610562; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY trabalhodeconclusao
    ADD CONSTRAINT fktrabalhode610562 FOREIGN KEY (orientadorid) REFERENCES public.basphysicalperson(personid);


--
-- Name: membrodabanca_personid_fkey; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY membrodabanca
    ADD CONSTRAINT membrodabanca_personid_fkey FOREIGN KEY (personid) REFERENCES public.basperson(personid);


--
-- Name: ofertadeunidadetematica_personid_fkey; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY ofertadeunidadetematica
    ADD CONSTRAINT ofertadeunidadetematica_personid_fkey FOREIGN KEY (personid) REFERENCES public.basperson(personid);


--
-- Name: preceptoria_personid_fkey; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY preceptoria
    ADD CONSTRAINT preceptoria_personid_fkey FOREIGN KEY (personid) REFERENCES public.basperson(personid);


--
-- Name: residente_personid_fkey; Type: FK CONSTRAINT; Schema: res; Owner: postgres
--

ALTER TABLE ONLY residente
    ADD CONSTRAINT residente_personid_fkey FOREIGN KEY (personid) REFERENCES public.basperson(personid);


SET search_path = spr, pg_catalog;

--
-- Name: examiningboardmember_personid_fkey; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY examiningboardmember
    ADD CONSTRAINT examiningboardmember_personid_fkey FOREIGN KEY (personid) REFERENCES public.basperson(personid);


--
-- Name: fkattachment124101; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY attachment
    ADD CONSTRAINT fkattachment124101 FOREIGN KEY (fileid) REFERENCES public.basfile(fileid);


--
-- Name: fkattachment815945; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY attachment
    ADD CONSTRAINT fkattachment815945 FOREIGN KEY (evaluationoptionid, subscriptionid) REFERENCES subscriptionevaluationoption(evaluationoptionid, subscriptionid);


--
-- Name: fkevaluation322036; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY evaluationoption
    ADD CONSTRAINT fkevaluation322036 FOREIGN KEY (evaluationid) REFERENCES evaluation(evaluationid);


--
-- Name: fkevaluation670020; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY evaluation
    ADD CONSTRAINT fkevaluation670020 FOREIGN KEY (stepid) REFERENCES step(stepid);


--
-- Name: fkevaluation686353; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY evaluationpoints
    ADD CONSTRAINT fkevaluation686353 FOREIGN KEY (subscriptionid) REFERENCES subscription(subscriptionid);


--
-- Name: fkevaluation939114; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY evaluationpoints
    ADD CONSTRAINT fkevaluation939114 FOREIGN KEY (evaluationid) REFERENCES evaluation(evaluationid);


--
-- Name: fkexaminingb227158; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY examiningboardmember
    ADD CONSTRAINT fkexaminingb227158 FOREIGN KEY (personid) REFERENCES public.basphysicalperson(personid);


--
-- Name: fkexaminingb617211; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY examiningboardmember
    ADD CONSTRAINT fkexaminingb617211 FOREIGN KEY (examiningboardid) REFERENCES examiningboard(examiningboardid);


--
-- Name: fkexaminingb927331; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY examiningboard
    ADD CONSTRAINT fkexaminingb927331 FOREIGN KEY (stepid) REFERENCES step(stepid);


--
-- Name: fkfinanceinf216910; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY financeinformation
    ADD CONSTRAINT fkfinanceinf216910 FOREIGN KEY (bankaccountid) REFERENCES public.finbankaccount(bankaccountid);


--
-- Name: fkfinanceinf232302; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY financeinformation
    ADD CONSTRAINT fkfinanceinf232302 FOREIGN KEY (costcenterid) REFERENCES public.acccostcenter(costcenterid);


--
-- Name: fkfinanceinf329996; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY financeinformation
    ADD CONSTRAINT fkfinanceinf329996 FOREIGN KEY (operationid) REFERENCES public.finoperation(operationid);


--
-- Name: fkfinanceinf994835; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY financeinformation
    ADD CONSTRAINT fkfinanceinf994835 FOREIGN KEY (policyid) REFERENCES public.finpolicy(policyid);


--
-- Name: fkoption435919; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY option
    ADD CONSTRAINT fkoption435919 FOREIGN KEY (selectiveprocessid) REFERENCES selectiveprocess(selectiveprocessid);


--
-- Name: fkoptioncour104432; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY optioncourse
    ADD CONSTRAINT fkoptioncour104432 FOREIGN KEY (optionid) REFERENCES option(optionid);


--
-- Name: fkoptioncour610102; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY optioncourse
    ADD CONSTRAINT fkoptioncour610102 FOREIGN KEY (courseid, courseversion, unitid, turnid) REFERENCES public.acdcourseoccurrence(courseid, courseversion, unitid, turnid);


--
-- Name: fkoptionnucl610477; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY optionnucleoenfase
    ADD CONSTRAINT fkoptionnucl610477 FOREIGN KEY (optionid) REFERENCES option(optionid);


--
-- Name: fkoptionnucl66207; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY optionnucleoenfase
    ADD CONSTRAINT fkoptionnucl66207 FOREIGN KEY (nucleoprofissionalid) REFERENCES res.nucleoprofissional(nucleoprofissionalid);


--
-- Name: fkoptionnucl861826; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY optionnucleoenfase
    ADD CONSTRAINT fkoptionnucl861826 FOREIGN KEY (enfaseid) REFERENCES res.enfase(enfaseid);


--
-- Name: fkselectivep305874; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY selectiveprocess
    ADD CONSTRAINT fkselectivep305874 FOREIGN KEY (socialeconomicformid) REFERENCES public.rshform(formid);


--
-- Name: fkselectivep369667; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY selectiveprocess
    ADD CONSTRAINT fkselectivep369667 FOREIGN KEY (subscriptionemailid) REFERENCES public.basemail(emailid);


--
-- Name: fkselectivep516412; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY selectiveprocess
    ADD CONSTRAINT fkselectivep516412 FOREIGN KEY (financeinformationid) REFERENCES financeinformation(financeinformationid);


--
-- Name: fkstep242749; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY step
    ADD CONSTRAINT fkstep242749 FOREIGN KEY (selectiveprocessid) REFERENCES selectiveprocess(selectiveprocessid);


--
-- Name: fkstep612929; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY step
    ADD CONSTRAINT fkstep612929 FOREIGN KEY (confirmationemailid) REFERENCES public.basemail(emailid);


--
-- Name: fkstepdocume252991; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY stepdocument
    ADD CONSTRAINT fkstepdocume252991 FOREIGN KEY (stepid) REFERENCES step(stepid);


--
-- Name: fkstepplace123102; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY stepplace
    ADD CONSTRAINT fkstepplace123102 FOREIGN KEY (locationid) REFERENCES public.baslocation(locationid);


--
-- Name: fkstepplace549195; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY stepplace
    ADD CONSTRAINT fkstepplace549195 FOREIGN KEY (physicalresourceid, physicalresourceversion) REFERENCES public.insphysicalresource(physicalresourceid, physicalresourceversion);


--
-- Name: fkstepplace718415; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY stepplace
    ADD CONSTRAINT fkstepplace718415 FOREIGN KEY (stepid) REFERENCES step(stepid);


--
-- Name: fksteptiebre273231; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY steptiebreak
    ADD CONSTRAINT fksteptiebre273231 FOREIGN KEY (tiebreakid) REFERENCES tiebreak(tiebreakid);


--
-- Name: fksteptiebre714873; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY steptiebreak
    ADD CONSTRAINT fksteptiebre714873 FOREIGN KEY (stepid) REFERENCES step(stepid);


--
-- Name: fksubscripti153898; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionstepplace
    ADD CONSTRAINT fksubscripti153898 FOREIGN KEY (stepplaceid) REFERENCES stepplace(stepplaceid);


--
-- Name: fksubscripti172251; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptiondocument
    ADD CONSTRAINT fksubscripti172251 FOREIGN KEY (fileid) REFERENCES public.basfile(fileid);


--
-- Name: fksubscripti350934; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscription
    ADD CONSTRAINT fksubscripti350934 FOREIGN KEY (personid) REFERENCES public.basphysicalperson(personid);


--
-- Name: fksubscripti388095; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptiondocument
    ADD CONSTRAINT fksubscripti388095 FOREIGN KEY (subscriptionid) REFERENCES subscription(subscriptionid);


--
-- Name: fksubscripti44759; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionstepinfo
    ADD CONSTRAINT fksubscripti44759 FOREIGN KEY (subscriptionid) REFERENCES subscription(subscriptionid);


--
-- Name: fksubscripti46885; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscription
    ADD CONSTRAINT fksubscripti46885 FOREIGN KEY (invoiceid) REFERENCES public.finreceivableinvoice(invoiceid);


--
-- Name: fksubscripti471023; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionoption
    ADD CONSTRAINT fksubscripti471023 FOREIGN KEY (subscriptionstatusid) REFERENCES subscriptionstatus(subscriptionstatusid);


--
-- Name: fksubscripti520577; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionstepplace
    ADD CONSTRAINT fksubscripti520577 FOREIGN KEY (subscriptionid) REFERENCES subscription(subscriptionid);


--
-- Name: fksubscripti529871; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionoption
    ADD CONSTRAINT fksubscripti529871 FOREIGN KEY (optionid) REFERENCES option(optionid);


--
-- Name: fksubscripti539179; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionoption
    ADD CONSTRAINT fksubscripti539179 FOREIGN KEY (subscriptionid) REFERENCES subscription(subscriptionid);


--
-- Name: fksubscripti737891; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionevaluationoption
    ADD CONSTRAINT fksubscripti737891 FOREIGN KEY (subscriptionid) REFERENCES subscription(subscriptionid);


--
-- Name: fksubscripti754578; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionevaluationoption
    ADD CONSTRAINT fksubscripti754578 FOREIGN KEY (evaluationoptionid) REFERENCES evaluationoption(evaluationoptionid);


--
-- Name: fksubscripti776242; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptiondocument
    ADD CONSTRAINT fksubscripti776242 FOREIGN KEY (stepdocumentid) REFERENCES stepdocument(stepdocumentid);


--
-- Name: fksubscripti905631; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscription
    ADD CONSTRAINT fksubscripti905631 FOREIGN KEY (selectiveprocessid) REFERENCES selectiveprocess(selectiveprocessid);


--
-- Name: fksubscripti916628; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionstepinfo
    ADD CONSTRAINT fksubscripti916628 FOREIGN KEY (subscriptionstatusid) REFERENCES subscriptionstatus(subscriptionstatusid);


--
-- Name: fksubscripti968364; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionstepinfo
    ADD CONSTRAINT fksubscripti968364 FOREIGN KEY (stepid) REFERENCES step(stepid);


--
-- Name: fksubscripti978592; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscription
    ADD CONSTRAINT fksubscripti978592 FOREIGN KEY (formationlevelid) REFERENCES public.acdformationlevel(formationlevelid);


--
-- Name: selectiveprocess_periodid_fkey; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY selectiveprocess
    ADD CONSTRAINT selectiveprocess_periodid_fkey FOREIGN KEY (periodid) REFERENCES public.acdperiod(periodid);


--
-- Name: subscription_personid_fkey; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscription
    ADD CONSTRAINT subscription_personid_fkey FOREIGN KEY (personid) REFERENCES public.basperson(personid);


--
-- Name: subscriptionstepinfo_locationid_fkey; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionstepinfo
    ADD CONSTRAINT subscriptionstepinfo_locationid_fkey FOREIGN KEY (locationid) REFERENCES public.baslocation(locationid);


--
-- Name: subscriptionsubstitutescall_subscriptionid_fkey; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionsubstitutescall
    ADD CONSTRAINT subscriptionsubstitutescall_subscriptionid_fkey FOREIGN KEY (subscriptionid, optionid) REFERENCES subscriptionoption(subscriptionid, optionid);


--
-- Name: subscriptionsubstitutescall_substitutescallid_fkey; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY subscriptionsubstitutescall
    ADD CONSTRAINT subscriptionsubstitutescall_substitutescallid_fkey FOREIGN KEY (substitutescallid) REFERENCES substitutescall(substitutescallid);


--
-- Name: substitutescall_selectiveprocessid_fkey; Type: FK CONSTRAINT; Schema: spr; Owner: postgres
--

ALTER TABLE ONLY substitutescall
    ADD CONSTRAINT substitutescall_selectiveprocessid_fkey FOREIGN KEY (selectiveprocessid) REFERENCES selectiveprocess(selectiveprocessid);


SET search_path = tra, pg_catalog;

--
-- Name: addendumcourseadmin_personid_fkey; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY addendumcourseadmin
    ADD CONSTRAINT addendumcourseadmin_personid_fkey FOREIGN KEY (personid) REFERENCES public.basperson(personid);


--
-- Name: coursearea_unitareaid_fkey; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY coursearea
    ADD CONSTRAINT coursearea_unitareaid_fkey FOREIGN KEY (unitareaid) REFERENCES unitarea(unitareaid);


--
-- Name: fkaddendum719191; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY addendum
    ADD CONSTRAINT fkaddendum719191 FOREIGN KEY (agreementid) REFERENCES agreement(agreementid);


--
-- Name: fkaddendumco169254; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY addendumcourseadmin
    ADD CONSTRAINT fkaddendumco169254 FOREIGN KEY (personid) REFERENCES public.basphysicalperson(personid);


--
-- Name: fkaddendumco325128; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY addendumcoursearea
    ADD CONSTRAINT fkaddendumco325128 FOREIGN KEY (areaid) REFERENCES area(areaid);


--
-- Name: fkaddendumco527540; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY addendumcourse
    ADD CONSTRAINT fkaddendumco527540 FOREIGN KEY (courseid) REFERENCES course(courseid);


--
-- Name: fkaddendumco846601; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY addendumcoursearea
    ADD CONSTRAINT fkaddendumco846601 FOREIGN KEY (addendumcourseid) REFERENCES addendumcourse(addendumcourseid);


--
-- Name: fkaddendumco883861; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY addendumcourseadmin
    ADD CONSTRAINT fkaddendumco883861 FOREIGN KEY (addendumcourseid) REFERENCES addendumcourse(addendumcourseid);


--
-- Name: fkaddendumco909774; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY addendumcourse
    ADD CONSTRAINT fkaddendumco909774 FOREIGN KEY (addendumid) REFERENCES addendum(addendumid);


--
-- Name: fkaddendumfi284515; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY addendumfile
    ADD CONSTRAINT fkaddendumfi284515 FOREIGN KEY (fileid) REFERENCES public.basfile(fileid);


--
-- Name: fkaddendumfi55359; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY addendumfile
    ADD CONSTRAINT fkaddendumfi55359 FOREIGN KEY (addendumid) REFERENCES addendum(addendumid);


--
-- Name: fkagreement432626; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY agreement
    ADD CONSTRAINT fkagreement432626 FOREIGN KEY (legalpersonid) REFERENCES public.baslegalperson(personid);


--
-- Name: fkagreementf556942; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY agreementfile
    ADD CONSTRAINT fkagreementf556942 FOREIGN KEY (agreementid) REFERENCES agreement(agreementid);


--
-- Name: fkagreementf784441; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY agreementfile
    ADD CONSTRAINT fkagreementf784441 FOREIGN KEY (fileid) REFERENCES public.basfile(fileid);


--
-- Name: fkconcept899003; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY concept
    ADD CONSTRAINT fkconcept899003 FOREIGN KEY (degreeequivalenceid) REFERENCES degreeequivalence(degreeequivalenceid);


--
-- Name: fkcounterpar172726; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY counterpart
    ADD CONSTRAINT fkcounterpar172726 FOREIGN KEY (counterparttypeid) REFERENCES counterparttype(counterparttypeid);


--
-- Name: fkcounterpar234992; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY counterpart
    ADD CONSTRAINT fkcounterpar234992 FOREIGN KEY (addendumid) REFERENCES addendum(addendumid);


--
-- Name: fkcounterpar8628; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY counterpartuse
    ADD CONSTRAINT fkcounterpar8628 FOREIGN KEY (counterpartid) REFERENCES counterpart(counterpartid);


--
-- Name: fkcoursearea946174; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY coursearea
    ADD CONSTRAINT fkcoursearea946174 FOREIGN KEY (courseid) REFERENCES course(courseid);


--
-- Name: fkdeliveredd212223; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY delivereddocument
    ADD CONSTRAINT fkdeliveredd212223 FOREIGN KEY (documentid) REFERENCES document(documentid);


--
-- Name: fkdeliveredd437867; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY delivereddocumentfile
    ADD CONSTRAINT fkdeliveredd437867 FOREIGN KEY (delivereddocumentid) REFERENCES delivereddocument(delivereddocumentid);


--
-- Name: fkdeliveredd509776; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY delivereddocument
    ADD CONSTRAINT fkdeliveredd509776 FOREIGN KEY (requestid) REFERENCES request(requestid);


--
-- Name: fkdeliveredd634215; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY delivereddocumentfile
    ADD CONSTRAINT fkdeliveredd634215 FOREIGN KEY (fileid) REFERENCES public.basfile(fileid);


--
-- Name: fkdocument175355; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY document
    ADD CONSTRAINT fkdocument175355 FOREIGN KEY (unitareaid) REFERENCES unitarea(unitareaid);


--
-- Name: fkevaluation248193; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY evaluationitem
    ADD CONSTRAINT fkevaluation248193 FOREIGN KEY (evaluationgroupid) REFERENCES evaluationgroup(evaluationgroupid);


--
-- Name: fkpreceptors18347; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY preceptorsubstitution
    ADD CONSTRAINT fkpreceptors18347 FOREIGN KEY (teamid) REFERENCES team(teamid);


--
-- Name: fkpreceptors972098; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY preceptorsubstitution
    ADD CONSTRAINT fkpreceptors972098 FOREIGN KEY (personid) REFERENCES public.basphysicalperson(personid);


--
-- Name: fkrequest147673; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY request
    ADD CONSTRAINT fkrequest147673 FOREIGN KEY (unitareaid) REFERENCES unitarea(unitareaid);


--
-- Name: fkrequest441837; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY request
    ADD CONSTRAINT fkrequest441837 FOREIGN KEY (unitareaid) REFERENCES unitarea(unitareaid);


--
-- Name: fkrequest593293; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY request
    ADD CONSTRAINT fkrequest593293 FOREIGN KEY (courseid) REFERENCES course(courseid);


--
-- Name: fkrequest801361; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY request
    ADD CONSTRAINT fkrequest801361 FOREIGN KEY (trainingtypeid) REFERENCES trainingtype(trainingtypeid);


--
-- Name: fkrequest840410; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY request
    ADD CONSTRAINT fkrequest840410 FOREIGN KEY (personid) REFERENCES public.basphysicalperson(personid);


--
-- Name: fkrequestadj586708; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY requestadjustment
    ADD CONSTRAINT fkrequestadj586708 FOREIGN KEY (requestid) REFERENCES request(requestid);


--
-- Name: fkrequestadj674060; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY requestadjustment
    ADD CONSTRAINT fkrequestadj674060 FOREIGN KEY (trainingtypeid) REFERENCES trainingtype(trainingtypeid);


--
-- Name: fksubscripti204478; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY subscription
    ADD CONSTRAINT fksubscripti204478 FOREIGN KEY (requestid) REFERENCES request(requestid);


--
-- Name: fksubscripti300211; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY subscriptionteam
    ADD CONSTRAINT fksubscripti300211 FOREIGN KEY (teamid) REFERENCES team(teamid);


--
-- Name: fksubscripti828086; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY subscriptionteamevaluation
    ADD CONSTRAINT fksubscripti828086 FOREIGN KEY (evaluationitemid) REFERENCES evaluationitem(evaluationitemid);


--
-- Name: fksubscripti933371; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY subscriptionteamevaluation
    ADD CONSTRAINT fksubscripti933371 FOREIGN KEY (subscriptionteamid) REFERENCES subscriptionteam(subscriptionteamid);


--
-- Name: fksubscripti982111; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY subscriptionteam
    ADD CONSTRAINT fksubscripti982111 FOREIGN KEY (subscriptionid) REFERENCES subscription(subscriptionid);


--
-- Name: fkteam575637; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY team
    ADD CONSTRAINT fkteam575637 FOREIGN KEY (preceptorid) REFERENCES public.basphysicalperson(personid);


--
-- Name: fkteam9571; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY team
    ADD CONSTRAINT fkteam9571 FOREIGN KEY (unitareaid) REFERENCES unitarea(unitareaid);


--
-- Name: fkteamorgani147190; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY teamorganizer
    ADD CONSTRAINT fkteamorgani147190 FOREIGN KEY (personid) REFERENCES public.basphysicalperson(personid);


--
-- Name: fkteamorgani689708; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY teamorganizer
    ADD CONSTRAINT fkteamorgani689708 FOREIGN KEY (unitareaid) REFERENCES unitarea(unitareaid);


--
-- Name: fktrainingev10150; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY trainingevaluationanswer
    ADD CONSTRAINT fktrainingev10150 FOREIGN KEY (questionid) REFERENCES public.rshquestion(questionid);


--
-- Name: fktrainingev519884; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY trainingevaluationanswer
    ADD CONSTRAINT fktrainingev519884 FOREIGN KEY (subscriptionid) REFERENCES subscription(subscriptionid);


--
-- Name: fktrainingev542760; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY trainingevaluationanswer
    ADD CONSTRAINT fktrainingev542760 FOREIGN KEY (optionid) REFERENCES public.rshoption(optionid);


--
-- Name: fktrainingty749904; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY trainingtypearea
    ADD CONSTRAINT fktrainingty749904 FOREIGN KEY (trainingtypeid) REFERENCES trainingtype(trainingtypeid);


--
-- Name: fktrainingty867010; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY trainingtype
    ADD CONSTRAINT fktrainingty867010 FOREIGN KEY (evaluationtypeid) REFERENCES evaluationtype(evaluationtypeid);


--
-- Name: fkunitarea593296; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY unitarea
    ADD CONSTRAINT fkunitarea593296 FOREIGN KEY (areaid) REFERENCES area(areaid);


--
-- Name: fkunitarea732318; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY unitarea
    ADD CONSTRAINT fkunitarea732318 FOREIGN KEY (unitid) REFERENCES unit(unitid);


--
-- Name: fkunitarea746305; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY unitarea
    ADD CONSTRAINT fkunitarea746305 FOREIGN KEY (preceptorid) REFERENCES public.basphysicalperson(personid);


--
-- Name: fkunitareaco731354; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY unitarea
    ADD CONSTRAINT fkunitareaco731354 FOREIGN KEY (preceptorid) REFERENCES public.basphysicalperson(personid);


--
-- Name: fkunitareaco761611; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY unitarea
    ADD CONSTRAINT fkunitareaco761611 FOREIGN KEY (unitid) REFERENCES unit(unitid);


--
-- Name: fkunitareaco884363; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY unitarea
    ADD CONSTRAINT fkunitareaco884363 FOREIGN KEY (areaid) REFERENCES area(areaid);


--
-- Name: fkunitlegalp537201; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY unitlegalperson
    ADD CONSTRAINT fkunitlegalp537201 FOREIGN KEY (unitid) REFERENCES unit(unitid);


--
-- Name: fkunitlegalp612000; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY unitlegalperson
    ADD CONSTRAINT fkunitlegalp612000 FOREIGN KEY (personid) REFERENCES public.baslegalperson(personid);


--
-- Name: fkunituser135520; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY unituser
    ADD CONSTRAINT fkunituser135520 FOREIGN KEY (unitid) REFERENCES unit(unitid);


--
-- Name: fkunituser828308; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY unituser
    ADD CONSTRAINT fkunituser828308 FOREIGN KEY (iduser) REFERENCES public.miolo_user(iduser);


--
-- Name: preceptorsubstitution_personid_fkey; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY preceptorsubstitution
    ADD CONSTRAINT preceptorsubstitution_personid_fkey FOREIGN KEY (personid) REFERENCES public.basperson(personid);


--
-- Name: request_addendumcourseadminid_fkey; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY request
    ADD CONSTRAINT request_addendumcourseadminid_fkey FOREIGN KEY (addendumcourseadminid) REFERENCES addendumcourseadmin(addendumcourseadminid);


--
-- Name: request_agreementid_fkey; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY request
    ADD CONSTRAINT request_agreementid_fkey FOREIGN KEY (agreementid) REFERENCES agreement(agreementid);


--
-- Name: request_personid_fkey; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY request
    ADD CONSTRAINT request_personid_fkey FOREIGN KEY (personid) REFERENCES public.basperson(personid);


--
-- Name: requestadjustment_agreementid_fkey; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY requestadjustment
    ADD CONSTRAINT requestadjustment_agreementid_fkey FOREIGN KEY (agreementid) REFERENCES agreement(agreementid);


--
-- Name: requestadjustment_courseid_fkey; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY requestadjustment
    ADD CONSTRAINT requestadjustment_courseid_fkey FOREIGN KEY (courseid) REFERENCES course(courseid);


--
-- Name: requestadjustment_unitareaid_fkey; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY requestadjustment
    ADD CONSTRAINT requestadjustment_unitareaid_fkey FOREIGN KEY (unitareaid) REFERENCES unitarea(unitareaid);


--
-- Name: subscriptionteamevaluation_subscriptionid_fkey; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY subscriptionteamevaluation
    ADD CONSTRAINT subscriptionteamevaluation_subscriptionid_fkey FOREIGN KEY (subscriptionid) REFERENCES subscription(subscriptionid);


--
-- Name: teamorganizer_personid_fkey; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY teamorganizer
    ADD CONSTRAINT teamorganizer_personid_fkey FOREIGN KEY (personid) REFERENCES public.basperson(personid);


--
-- Name: trainingtype_degreeequivalenceid_fkey; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY trainingtype
    ADD CONSTRAINT trainingtype_degreeequivalenceid_fkey FOREIGN KEY (degreeequivalenceid) REFERENCES degreeequivalence(degreeequivalenceid);


--
-- Name: trainingtypearea_unitareaid_fkey; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY trainingtypearea
    ADD CONSTRAINT trainingtypearea_unitareaid_fkey FOREIGN KEY (unitareaid) REFERENCES unitarea(unitareaid);


--
-- Name: unitlegalperson_personid_fkey; Type: FK CONSTRAINT; Schema: tra; Owner: postgres
--

ALTER TABLE ONLY unitlegalperson
    ADD CONSTRAINT unitlegalperson_personid_fkey FOREIGN KEY (personid) REFERENCES public.basperson(personid);


--
-- Name: public; Type: ACL; Schema: -; Owner: postgres
--

REVOKE ALL ON SCHEMA public FROM PUBLIC;
REVOKE ALL ON SCHEMA public FROM postgres;
GRANT ALL ON SCHEMA public TO postgres;
GRANT ALL ON SCHEMA public TO PUBLIC;


SET search_path = public, pg_catalog;

--
-- Name: dblink_connect_u(text); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION dblink_connect_u(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION dblink_connect_u(text) FROM postgres;
GRANT ALL ON FUNCTION dblink_connect_u(text) TO postgres;


--
-- Name: dblink_connect_u(text, text); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION dblink_connect_u(text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION dblink_connect_u(text, text) FROM postgres;
GRANT ALL ON FUNCTION dblink_connect_u(text, text) TO postgres;


--
-- PostgreSQL database dump complete
--

