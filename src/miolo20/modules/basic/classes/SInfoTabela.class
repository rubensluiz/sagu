<?php

/**
 * <--- Copyright 2005-2012 de Solis - Cooperativa de Soluções Livres Ltda.
 *
 * Este arquivo é parte do programa Sagu.
 *
 * O Sagu é um software livre; você pode redistribuí-lo e/ou modificá-lo
 * dentro dos termos da Licença Pública Geral GNU como publicada pela Fundação
 * do Software Livre (FSF); na versão 2 da Licença.
 *
 * Este programa é distribuído na esperança que possa ser útil, mas SEM
 * NENHUMA GARANTIA; sem uma garantia implícita de ADEQUAÇÃO a qualquer MERCADO
 * ou APLICAÇÃO EM PARTICULAR. Veja a Licença Pública Geral GNU/GPL em
 * português para maiores detalhes.
 *
 * Você deve ter recebido uma cópia da Licença Pública Geral GNU, sob o título
 * "LICENCA.txt", junto com este programa, se não, acesse o Portal do Software
 * Público Brasileiro no endereço www.softwarepublico.gov.br ou escreva para a
 * Fundação do Software Livre (FSF) Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA --->
 *
 * Classe que representa uma tabela.
 *
 * @author Daniel Hartmann [daniel@solis.coop.br]
 *
 * \b Maintainers: \n
 * Daniel Hartmann [daniel@solis.coop.br]
 *
 * @since
 * Class created on 14/02/2012
 *
 */
class SInfoTabela
{
    /**
     * Constantes de tipo de tabela. pg_catalog.pg_class.relkind.
     * r = tabela, i = index, S = sequência, v = visão. 
     */
    const TIPO_INDICE = 'i';
    const TIPO_SEQUENCIA = 'S';
    const TIPO_TABELA = 'r';
    const TIPO_VISAO = 'v';

    /**
     * Obtém os esquemas presentes na base.
     *
     * @return array Vetor para ser utilizado em componentes do tipo combo.
     */
    public static function buscarEsquemas()
    {
        $sql = "SELECT nspname, 
                       CASE WHEN description IS NOT NULL THEN description ELSE nspname END
                  FROM pg_namespace
             LEFT JOIN pg_description
                    ON pg_description.objoid = pg_namespace.oid
                 WHERE nspname NOT LIKE 'pg_%' 
                   AND nspname <> 'information_schema'";

        return SDatabase::query(SAGU::prepare($sql, NULL, FALSE));
    }

    /**
     * Obtém as tabelas presentes na base.
     *
     * @param string $esquema Esquema do qual se quer obter a lista de tabelas. Padrão é public.
     * @return array Vetor para ser utilizado em componentes do tipo combo.
     */
    public static function buscarTabelas($esquema='public')
    {
        $sql = "SELECT c.relname,
                       c.relname
                  FROM pg_class c, pg_namespace n
                 WHERE c.relnamespace=n.oid
                   AND c.relkind = 'r'
                   AND n.nspname NOT LIKE 'pg_%'
                   AND n.nspname != 'information_schema' ";

        if ( $esquema )
        {
            $params[] = $esquema;
            $sql .= " AND n.nspname = ?";
        }

        $sql .= " ORDER BY relname";

        return SDatabase::query(SAGU::prepare($sql, $params, FALSE));
    }

    /**
     * Obtém as visões presentes na base.
     *
     * @param string $esquema Esquema do qual se quer obter a lista de tabelas. Padrão é public.
     * @return array Vetor para ser utilizado em componentes do tipo combo.
     */
    public static function buscarVisoes($esquema='public')
    {
        $sql = "SELECT c.relname,
                       c.relname
                  FROM pg_class c, pg_namespace n
                 WHERE c.relnamespace=n.oid
                   AND c.relkind = ?
                   AND c.relname NOT LIKE 'miolo_%'
                   AND c.relname NOT LIKE 'acdv%'
                   AND c.relname NOT LIKE 'user_%'
                   AND n.nspname NOT LIKE 'pg_%'
                   AND n.nspname != 'information_schema' ";

        $params = array( self::TIPO_VISAO );
        
        if ( $esquema )
        {
            $params[] = $esquema;
            $sql .= " AND n.nspname = ?";
        }

        $sql .= " ORDER BY relname";

        return SDatabase::query(SAGU::prepare($sql, $params, FALSE));
    }

    /**
     * Obtém as colunas presentes na tabela.
     *
     * @param string $tabela Tabela da qual se quer obter a lista de colunas.
     * @param string $esquema Esquema do qual a tabela faz parte. Padrão é public.
     * @param character $tipo Tipo de relação. Usar constantes TIPO_*.
     * @return array Vetor para ser utilizado em componentes do tipo combo.
     */
    public static function buscarColunas($tabela, $esquema='public', $tipo=self::TIPO_TABELA)
    {
        $sql = "SELECT a.attname,
                       a.attname
                  FROM pg_class c
            INNER JOIN pg_namespace AS n ON ( n.oid = c.relnamespace )
            INNER JOIN pg_attribute AS a ON ( a.attrelid = c.oid )
            INNER JOIN pg_type AS t ON ( a.atttypid = t.oid )
             LEFT JOIN pg_attrdef AS def ON ( def.adrelid = c.oid AND a.attnum = def.adnum )
             LEFT JOIN pg_description AS d ON ( d.objoid = c.oid AND d.objsubid = a.attnum )
                 WHERE c.relkind = ?
                   AND n.nspname NOT LIKE 'pg\\_%'
                   AND n.nspname != 'information_schema'
                   AND a.attnum > 0
                   AND NOT a.attisdropped
                   AND a.attname NOT IN ('username', 'datetime', 'ipaddress')
                   AND c.relname = ?";

        $params = array( $tipo, $tabela );

        if ( $esquema )
        {
            $sql .= " AND n.nspname ILIKE ?";
            $params[] = $esquema;
        }

        return SDatabase::query(SAGU::prepare($sql, $params, FALSE));
    }

    /**
     * Obtém dados das colunas presentes na tabela.
     *
     * @param string $tabela Tabela da qual se quer obter a lista de colunas.
     * @param string $esquema Esquema do qual a tabela faz parte. Padrão é public.
     * @param character $tipo Tipo de relação. Usar constantes TIPO_*.
     * @return array Vetor para ser utilizado em componentes do tipo combo.
     */
    public static function buscarDadosDasColunas($tabela, $esquema='public', $tipo=self::TIPO_TABELA)
    {
        $sql = "SELECT a.attname,
                       CASE WHEN d.description <> '' THEN d.description ELSE a.attname END,
                       format_type(t.oid, null) as typname
                  FROM pg_class c
            INNER JOIN pg_namespace AS n ON ( n.oid = c.relnamespace )
            INNER JOIN pg_attribute AS a ON ( a.attrelid = c.oid )
            INNER JOIN pg_type AS t ON ( a.atttypid = t.oid )
             LEFT JOIN pg_attrdef AS def ON ( def.adrelid = c.oid AND a.attnum = def.adnum )
             LEFT JOIN pg_description AS d ON ( d.objoid = c.oid AND d.objsubid = a.attnum )
                 WHERE c.relkind = ?
                   AND n.nspname NOT LIKE 'pg\\_%'
                   AND n.nspname != 'information_schema'
                   AND a.attnum > 0
                   AND NOT a.attisdropped
                   AND a.attname NOT IN ('username', 'datetime', 'ipaddress')
                   AND c.relname = ?";

        $params = array( $tipo, $tabela );

        if ( $esquema )
        {
            $sql .= " AND n.nspname ILIKE ?";
            $params[] = $esquema;
        }

        return SDatabase::query(SAGU::prepare($sql, $params, FALSE));
    }

    /**
     * Realiza consulta na VIEW desejada.
     *
     * @param string $visao View a qual deseja-se consultar.
     * @param array $colunas Colunas desejadas no resultado da consulta.
     * @param array $filtros Filtros a serem aplicados na consulta.
     * @return array Resultado da consulta.
     */
    public static function consultarVisao($visao, $colunas=array('*'), $filtros=array(), $agrupar='')
    {
        if ( strlen($agrupar) )
        {
            $colunas[] = $agrupar;
        }

        $colunas = implode(',', $colunas);

        if ( !$colunas )
        {
            $colunas = '*';
        }

        $sql = "SELECT $colunas
                  FROM $visao ";
        $where = '';
        $params = array();

        foreach ( (array) $filtros as $filtro )
        {
            $coluna = $filtro['coluna'];
            $condicao = $filtro['condicao'];
            $valor = $filtro['valor'];

            switch ( $condicao )
            {
                case 'ilike':
                case 'not ilike':
                    $params[] = "%$valor%";
                    break;
                
                case 'ilike%':
                    $params[] = "$valor%";
                    $condicao = 'ilike';
                    break;

                case '%ilike':
                    $params[] = "%$valor";
                    $condicao = 'ilike';
                    break;

                default:
                    $params[] = $valor;
                    break;
            }

            $where .= "$coluna $condicao ? AND ";
        }

        if ( $where != '' )
        {
            $where = substr($where, 0, (-strlen('AND') - 1));
            $sql .= " WHERE $where";
        }

        if ( strlen($agrupar) )
        {
            $sql .= " ORDER BY $agrupar";
        }

        return SDatabase::query(SAGU::prepare($sql, $params, FALSE));
    }

    /**
     * Busca as chaves primárias da tabela.
     *
     * @param string $tabela Tabela da qual se quer obter a lista de colunas.
     * @param string $esquema Esquema do qual a tabela faz parte. Padrão é public.
     * @param character $tipo Tipo de relação. Usar constantes TIPO_*.
     * @return array Matriz com os dados das chaves primárias.
     */
    public static function buscarChavesPrimariasDaTabela($tabela, $esquema='public', $tipo=self::TIPO_TABELA)
    {
        $sql = "SELECT DISTINCT fk_col.attname AS column_name, 
                                format_type(t.oid, null) as typname
                           FROM pg_catalog.pg_class AS c
                     INNER JOIN pg_catalog.pg_constraint AS rel
                             ON (c.oid = rel.conrelid)
                      LEFT JOIN pg_catalog.pg_attribute AS fk_col
                             ON fk_col.attrelid = rel.conrelid AND (position(fk_col.attnum::text in array_to_string(conkey, ' ')) <>0 )
                     INNER JOIN pg_type AS t ON (fk_col.atttypid = t.oid)
                      LEFT JOIN pg_attrdef AS def ON (def.adrelid = c.oid AND fk_col.attnum = def.adnum)
                      LEFT JOIN pg_namespace AS n ON (n.oid = c.relnamespace)
                          WHERE c.relkind = ?
                            AND n.nspname NOT LIKE 'pg\\_%'
                            AND n.nspname != 'information_schema'
                            AND c.relname = ?";

        $params = array( $tipo, $tabela );

        if ( $esquema )
        {
            $sql .= " AND n.nspname ILIKE ?";
            $params[] = $esquema;
        }

        return SDatabase::query(SAGU::prepare($sql, $params, FALSE));
    }

    /**
     * Busca as chaves estrangeiras da tabela.
     *
     * @param string $tabela Tabela da qual se quer obter a lista de colunas.
     * @param string $esquema Esquema do qual a tabela faz parte. Padrão é public.
     * @param character $tipo Tipo de relação. Usar constantes TIPO_*.
     * @return array Matriz com os dados das chaves estrangeiras.
     */
    public static function buscarChavesEstrangeirasDaTabela($tabela, $esquema='public', $tipo=self::TIPO_TABELA)
    {
        $sql = "SELECT DISTINCT n.nspname              AS from_schema_name,
                                c.relname              AS from_table_name,
                                fk_col.attname         AS from_column_name,
                                toSchemaName.nspname   AS to_schema_name,
                                toTable.relname        AS to_table_name,
                                fk_col2.attname        AS to_column_name
                           FROM pg_catalog.pg_class AS c
                      LEFT JOIN pg_namespace AS n 
                             ON (n.oid = c.relnamespace)
                     INNER JOIN pg_catalog.pg_constraint AS rel
                             ON (c.oid=rel.conrelid)
                      LEFT JOIN pg_catalog.pg_class AS toTable
                             ON (toTable.oid = rel.confrelid)
                      LEFT JOIN pg_namespace AS toSchemaName
                             ON (toSchemaName.oid = toTable.relnamespace)
                      LEFT JOIN pg_catalog.pg_attribute AS fk_col
                             ON fk_col.attrelid = rel.conrelid AND (conkey @> ARRAY[ fk_col.attnum ] AND position(fk_col.attnum::text in array_to_string(conkey, ' ')) <>0 )
                      LEFT JOIN pg_catalog.pg_attribute AS fk_col2
                             ON fk_col2.attrelid = rel.confrelid AND (conkey @> ARRAY[ fk_col.attnum ] AND position(fk_col2.attnum::text in array_to_string(confkey, ' ')) <>0 )
                          WHERE rel.contype='f'
                            AND c.relkind = ?
                            AND n.nspname NOT LIKE 'pg\\_%'
                            AND n.nspname != 'information_schema'
                            AND c.relname = ?";

        $params = array( $tipo, $tabela );

        if ( $esquema )
        {
            $sql .= " AND n.nspname ILIKE ?";
            $params[] = $esquema;
        }

        return SDatabase::query(SAGU::prepare($sql, $params, FALSE));
    }
}

?>