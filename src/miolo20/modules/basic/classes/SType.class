<?php
/**
 * <--- Copyright 2005-2010 de Solis - Cooperativa de Soluções Livres Ltda.
 *
 * Este arquivo é parte do programa Sagu.
 *
 * O Sagu é um software livre; você pode redistribuí-lo e/ou modificá-lo
 * dentro dos termos da Licença Pública Geral GNU como publicada pela Fundação
 * do Software Livre (FSF); na versão 2 da Licença.
 *
 * Este programa é distribuído na esperança que possa ser útil, mas SEM
 * NENHUMA GARANTIA; sem uma garantia implícita de ADEQUAÇÃO a qualquer MERCADO
 * ou APLICAÇÃO EM PARTICULAR. Veja a Licença Pública Geral GNU/GPL em
 * português para maiores detalhes.
 *
 * Você deve ter recebido uma cópia da Licença Pública Geral GNU, sob o título
 * "LICENCA.txt", junto com este programa, se não, acesse o Portal do Software
 * Público Brasileiro no endereço www.softwarepublico.gov.br ou escreva para a
 * Fundação do Software Livre (FSF) Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA --->
 *
 * Classe gerenciadora de types
 *
 * @author Moises Heberle [moises@solis.coop.br]
 *
 * @version $Id$
 *
 * \b Maintainers: \n
 * Equipe Solis [sagu2@solis.coop.br]
 *
 * @since
 * Class created on 01/04/2011
 */
class SType extends BasLog
{
    /**
     * Constante utilizada para dizer explicitamente que o valor de um campo deve ser limpo. 
     */
    const NULL_VALUE = 'STYPE_FORCE_NULL_VALUE';
    
    /**
     * Atributo reservado MSubDetail
     *
     * @var boolean
     */
    protected $removeData;

    /**
     * Atributo que armazena itens ja populados sob-demanda,
     * util para ser utilizado no metodo __get() do type.
     */
    protected $_checkedPopulate = array();
    
    /**
     * Colunas reservadas (basLog)
     */
    private static $reservedColumns = array('username', 'datetime', 'ipaddress');
    
    /**
     *
     * @var array
     */
    private $_aliases = array();
    
    /**
     * Clonar o type nos metodos find()
     * 
     * @var boolean
     */
    private $findCloneType = true;
    
    /**
     * Colunas da tabela
     *
     * @var array
     */
    private static $tableColumns = array();
    
    /**
     * @var string
     */
    private $_tableAlias;
    
    /**
     * Coluna chave primaria da tabela
     * 
     * @var string
     */
    protected static $_primaryKey;
    
    /**
     * Array de objetos sTypeAssociation
     *
     * @var array
     */
    private $_associationDefs = array();

    /**
     * Sobrescrever nome da tabela que deve ser utilizada
     *
     * @var string
     */
    protected $_tableName;
    
    /**
     * Alterar o nome do schema (default: public)
     *
     * @var string
     */
    protected $_schemaName;

    /**
     * Array associativo contendo colunas com campos "virtuais", ou seja,
     *  nao pertencem a tabela mas sao utilizados como expressao, ex.:
     * 
     * protected $virtualColumns = array(
     *     'tempodecorrido' => "NOW() - tabela.datainicio"
     * );
     * 
     * @var array
     */
    protected $_virtualColumns = array();

    /**
     * Array contendo associacoes deste type com outros types externos.
     * 
     * Ex.:
     * protected $_associations = array(
     *   'unit' => array(
     *       'mode' => 'one', // Use 'one' para ligacoes 1 -> 1 e 'many' para 1 -> N
     *       'typeClass' => 'BasUnit', // Define classe type a ser utilizada.
     *       'joinColumnLeft' => '', // Nome do campo da tabela do type origem que liga com a do type estrangeiro
     *       'joinColumnRight' => '', // Nome do campo da tabela do type estrangeiro que liga com o do type origem
     *   ),
     * );
     * 
     * @see sTypeAssociation
     *
     * @var array 
     */
    protected $_associations;
    
    /**
     * Array contendo validacoes que serao aplicadas ao chamar o metodo save().
     * 
     * Ex.:
     * protected $_validations = array(
     *     'campo' => array(
     *         array(
     *             'function' => 'required',
     *         ),
     *         array(
     *             'function' => 'rangeInt',
     *             'args' => array(10,20),
     *             'message' => 'O valor deve estar entre 10 e 20.',
     *         ),
     *         array(
     *             'function' => 'date',
     *             'on' => 'insert', // suporta insert e update , se deixar em branco vale para os dois.
     *             'message' => 'A data informada não é válida',
     *         ),
     *     ),
     *     'campo2' => array(...),
     * );
     */
    protected $_validations = array();
    
    /**
     * Coluna relativa a descricao/nome que é um descritivo principal da tabela (ex.: name, description).
     * Aceita colunas virtuais (virtualColumns) e expressoes puras SQL.
     *
     * @var string
     */
    protected $_descriptionColumn;
     
    /**
     * Coluna padrao que deve ser utilizada como ordenacao nas buscas caso nao tenha sido passada no metodo findMany().
     *
     * @var string
     */
    protected $_defaultOrder;
    
    /**
     * Define se deve utilizar novo padrao nas buscas (ssearchform) e outros.
     *
     * @var boolean
     */
    protected $_utilizaNovoPadrao = false;
    
    /**
     * Define se este type deve fazer logicas de multiunidade (unidade logada).
     * OBS: Quando definido TRUE, a tabela DEVE conter o campo unitId.
     * 
     * @var boolean
     */
    protected $_utilizaMultiUnidade = false;
    
    /**
     * Define se este type deve fazer logicas de multi centro (do funcionario logado).
     * OBS: Quando definido TRUE, a tabela DEVE conter o campo centerId.
     *
     * @var boolean
     */
    protected $_utilizaMultiCentro = false;
    
    /**
     * Conteudo vindo do AJAX do form.
     * Utilizado para o componente sEscolha.
     * 
     * @var stdClass
     */
    private $ajaxArgs;
    
    /**
     * Utiliza SELECT ... FROM ONLY na tabela.
     *
     * @var boolean
     */
    protected $_fromOnly = false;
    
    /**
     *
     * @var SValidator
     */
    private $validator;
    
    /**
     * Define se o registro da pk deve ser ingnorado na grid
     * @var type 
     */
    protected $filtrarPelaPk = false;
    
    /**
     * Quando definido como TRUE, este atributo inclui o valor da chave primaria da sequencia (NEXTVAL) no INSERT.
     * Isto e necessario para alguns casos, como por exemplo, para funcionar corretamente uma RULE ou TRIGGER definida.
     *
     * @var boolean
     */
    protected $insertWithPkey = false;
    
    /**
     *  Configuração que define se os dados serão gravados todos em upper case ou não.
     * 
     * @var boolean
     */
    protected $gravarMaiusculo = false;
    
    /**
     * View de multiunidade/multicentro para ser filtrada
     *
     * @var string
     */
    protected $_tableViewName;
    
    /**
     * Ações que desabilitam totalmente a multi-unidade no type.
     * Solução inicialmente tomada para resolver o ticket #39509.
     * Pode-ser utilizada também para outros propósitos gerais.
     * 
     * @var array
     */
    protected $acoesParaDesabilitarMultiUnidade = array('main:process:inscricaoturmaexterna',
                                                        'main:process:inscricaopagamentoexterna',
                                                        'main:process:inscricaoexterna',
                                                        'main:process:termodeinscricao',
                                                        'main:process:matriculasretroativas',
                                                        'main:process:mensageminicial',
                                                        'main:process:mensagemfinal');
    
    public function __construct($id = null)
    {
        if ( strlen($id) > 0 )
        {
            if ( in_array(MIOLO::_REQUEST('action'), $this->acoesParaDesabilitarMultiUnidade) )
            {
                $this->_utilizaMultiUnidade = false;
                $this->_utilizaMultiCentro = false;
                $this->_tableViewName = null;
            }
            
            $this->setPkeyValue($id);
            $this->populateData();
        }
    }
    
    public function __get($name)
    {
        $name = $this->checkName($name);
        $name = $this->findAttributeCaseInsensitive($name);
        
        if ( $name == null )
        {
            return null;
        }
        
        return $this->{$name};
    }


    public function __set($name, $value)
    {
        $name = $this->checkName($name);
        $name = $this->findAttributeCaseInsensitive($name);

        if ( strlen($name) > 0 )
        {
            $this->{$name} = $value;
        }
    }
    
    /**
     * Procura pelo atributo na classe, para suportar case-insensitive
     * 
     * @return string
     */
    private function findAttributeCaseInsensitive($name)
    {
        // Adiciona suporte a case-insensitive na definicao de atributos
        foreach ( array_keys(get_object_vars($this)) as $key )
        {
            if ( strtolower($key) == strtolower($name) )
            {
                $name = $key;
                break;
            }
        }
        
        return $name;
    }
    
    /**
     * Obtem variavel do metodo getter (caso nao existir, utiliza o atributo).
     * Utiliza a notacao padrao alias.campo, levando em consideracao associacoes 'one'.
     *
     * @param string $name 
     * @return string
     */
    public function getAttribute($name)
    {
        $field = $this->getColumnWithoutAlias($name);
        $type = $this->getTypeObjectByColumn($name); 
        $method = 'get' . ucfirst($field);
        
//        flog(get_class($type).'--'.$method);

        return method_exists($type, $method) ? call_user_method($method, $type) : $type->__get($field);
    }
    
    /**
     * Define uma variavel utilizando metodo setter (caso nao existir, utiliza o atributo).
     * Utiliza a notacao padrao alias.campo, levando em consideracao associacoes 'one'.
     * 
     * @return mixed
     */
    public function setAttribute($name, $value)
    {
        $field = $this->getColumnWithoutAlias($name);
        $type = $this->getTypeObjectByColumn($name); 
        $method = 'set' . ucfirst($field);
        
//        flog($name.'---'.$method);
        
        return method_exists($type, $method) ? call_user_method($method, $type, $value) : $type->__set($field, $value);
    }
    
    /**
     * Define um conjunto de valores para o type utilizando o array associativo passado
     *
     * @param array $values 
     */
    public function setValuesFromArray(array $values)
    {
        foreach ( $values as $key => $val )
        {
            $this->setAttribute($key, $val);
        }
        
        return $this;
    }
    
    /**
     * @deprecated Nao esta mais sendo utilizado
     */
    private function getValuesAsArray()
    {
        $data = array();
        $typeObjects = array();
        $reflections = array();
        
        $reflections['_this'] = new ReflectionClass($this);
        $typeObjects['_this'] = $this;
        
        foreach ( $this->getAssociationsRecursive() as $association )
        {
            $association instanceof sTypeAssociation;
            
            if ( $association->isModeOne() )
            {
                $reflections[$name] = new ReflectionClass($association->getTypeObject());
                $typeObjects[$name] = $association->getTypeObject();
            }
        }
        
        foreach ( $reflections as $key => $reflection )
        {
            $reflection instanceof ReflectionClass;
            
            $typeObject = $typeObjects[$key];
            $typeObject instanceof SType;
         
            foreach ( $reflection->getMethods() as $method )
            {
                $method instanceof ReflectionMethod;

                if ( $method->isPublic() && ( $method->getDeclaringClass()->getName() != __CLASS__ ) && substr($method->getName(), 0, 3) == 'get' )
                {
                    $varName = lcfirst(substr($method->getName(), 3));
                    $data[ $typeObject->getColumnWithAlias($varName) ] = $typeObject->getAttribute($varName);
                }
            }
        }

        return $data;
    }
    
    /**
     * @return SType
     */
    public static function instantiateType($className)
    {
        return new $className();
    }
    
    /**
     * @return boolean
     */
    public function utilizaNovoPadrao()
    {
        return $this->_utilizaNovoPadrao;
    }
    
    public function utilizaMultiUnidade()
    {
        return $this->_utilizaMultiUnidade && sMultiUnidade::estaHabilitada();
    }
    
    public function utilizaMultiCentro()
    {
        return $this->_utilizaMultiCentro;
    }
    
    /**
     * @return boolean
     */
    private function isFindCloneType()
    {
        return $this->findCloneType;
    }

    private function setFindCloneType($findCloneType)
    {
        $this->findCloneType = $findCloneType;
        
        return $this;
    }
        
    /**
     *
     * @param type $name
     * @return type 
     */
    private function checkName($name)
    {
        // Alias
        $alias = $this->_aliases[$name];
        if ( strlen($alias) > 0 )
        {
            $name = $alias;
        }
        
        return $name;
    }


    public function getObjectVars()
    {
        return get_object_vars($this);
    }
    
    
    /**
     * Define um pseudo atributo, que deve ser "redirecionado" para um outro atributo original.
     * Toda vez que for definido (Objeto->atributoAlias = 'valor') sera definido o valor para o atributo original.
     * Toda vez que for obtido (Objeto->atributoAlias) sera obtido o valor do atributo original.
     * Util para casos onde existam atributos na subdetail que sao diferentes do nome do atributo no SType.
     * 
     * Lembre-se que o pseudo atributo tambem deve estar declarado como protected na respectiva classe SType.
     * 
     * Exemplo pratico de uso na classe modules/training/types/TraTeam.class
     *
     * @param type $alias Pseudo nome de atributo
     * @param type $attribute Atributo fonte, que deve ser setado e obtido o valor
     */
    public function addAlias($alias, $attribute)
    {
        $this->_aliases[$alias] = $attribute;
    }


    /**
     * Verifica se deve popular dados sob demanda
     * Util para utilizar no __get() do type.
     *
     * CUIDADO: Ao utilizar esta funcao uma vez, o $name passado sera anotado como "ja populado"
     *
     * @param string $name
     */
    protected function needCheckPopulate($name)
    {
        $inArray = in_array($name, $this->_checkedPopulate);

        if ( !$inArray )
        {
            $this->_checkedPopulate[] = $name;
        }

        return ! $inArray;
    }
    
    /**
     * Obtem o nome da tabela, baseando-se no nome da classe por padrao.
     *
     * @return string
     */
    public function getTableName($forSelect = false)
    {
        $tableName = $this->_tableName ? $this->_tableName : get_class($this);
        
        if ( $forSelect && strlen($this->_tableViewName) > 0 )
        {
            $tableName = $this->_tableViewName;
        }
        
        return $tableName;
    }
    
    /**
     *
     * @return string
     */
    public function getTableAlias()
    {
        return $this->_tableAlias ? $this->_tableAlias : strtolower(get_class($this));
    }
    
    public function setTableAlias($alias)
    {
        $this->_tableAlias = $alias;
    }

    /**
     *
     * @return string
     */
    public function getTableAndAlias($forSelect = false)
    {
        return $this->getTableName($forSelect) . ' ' . $this->getTableAlias();
    }
    
    /**
     * @return string
     */
    public function getColumnWithAlias($column)
    {
        return $this->getTableAlias() . '.' . $column;
    }
    
    /**
     * @return string
     */
    public function getColumnAs($column)
    {
        return '"' . $this->getTableAlias() . '.' . $column . '"';
    }
    
    /**
     *
     * @return string
     */
    public function getColumnAlias($name)
    {
        if ( strpos($name, '.') )
        {
            list($alias, $field) = explode('.', $name);
        }
        else
        {
            $alias = $this->getTableAlias();
        }
        
        return $alias;
    }
    
    /**
     *
     * @return string
     */
    public function getColumnWithoutAlias($name)
    {
        $field = null;
        
        if ( strpos($name, '.') )
        {
            list($alias, $field) = explode('.', $name);
        }
        
        return strtolower($field ? $field : $name);
    }
    
    /**
     * @return boolean
     */
    public function isPrimaryKey($name)
    {
        return strtolower($this->getColumnWithoutAlias($name)) == strtolower($this->getPrimaryKey());
    }
    
    /**
     * Obtem a coluna padrao que pode ser utilizada para ordenacao, descricao etc
     *
     * @return string
     */
    private function getFriendlyColumn()
    {
        $tableColumns = $this->getTableColumnNames();
        $foundColumn = null;
        
        // Colunas padroes
        $commonColumns = array(
            'name',
            'description',
            'title',
            'descricao',
            'nome',
        );

        foreach ( $commonColumns as $name )
        {
            if ( in_array($name, $tableColumns) )
            {
                $foundColumn = $this->getColumnWithAlias($name);
                break;
            }
        }
        
        return $foundColumn;
    }
    
    /**
     * @return string
     */
    private function getDefaultOrderColumn()
    {
        return $this->_defaultOrder ? $this->_defaultOrder : $this->getFriendlyColumn();
    }
    
    /**
     *
     * @return string
     */
    private function getDescriptionColumn()
    {
        return $this->_descriptionColumn ? $this->_descriptionColumn : $this->getFriendlyColumn();
    }
    
    /**
     * @return string
     */
    public function getDescriptionValue()
    {
        return $this->getAttribute( $this->getDescriptionColumn() );
    }
    
    /**
     * @return string
     */
    private function getDescColumnExpr()
    {
        $dcol = $this->getDescriptionColumn();
        
        return $this->isVirtualColumn($dcol) ? $this->getVirtualColumn($dcol) : $dcol;
    }
    
    /**
     * Obtem ultimo id inserido
     * 
     * @return int
     */
    public function getLastInsertId()
    {
        return SDatabase::getLastInsertId($this->getTableName());
    }
    
    /**
     * Obtem nome da chave primaria
     */
    public function getPrimaryKey()
    {
        $class = get_class($this);
        
        if ( !self::$_primaryKey[$class] )
        {
            self::$_primaryKey[$class] = SDatabase::getTablePrimaryKey($this->getTableName());
            
            // Tenta obter o nome no padrao (camelCase)
            $ref = new ReflectionClass($this);
            $methodName = 'set' . $this->_primaryKey;
            
            if ( $ref->hasMethod($methodName) )
            {
                $obtainedName = $ref->getMethod($methodName)->getName();
                self::$_primaryKey[$class] = lcfirst(substr($obtainedName, 3));
            }
        }
        
        return self::$_primaryKey[$class];
    }
    
    /**
     *
     * @return string
     */
    public function getPkeyValue()
    {
        return $this->getAttribute( $this->getPrimaryKey() );
    }
    
    public function setPkeyValue($value)
    {
        $this->setAttribute($this->getPrimaryKey(), $value);
        
        return $this;
    }
    
    /**
     * @return boolean
     */
    public function hasPkeyValue()
    {
        return strlen($this->getPkeyValue()) > 0;
    }
    
    /**
     *
     * @return array
     */
    private function getPkeyCondition()
    {
        return array( $this->getPrimaryKey() => $this->getPkeyValue() );
    }
    
    /**
     *
     * @return string
     */
    public function getPkeyWithAlias()
    {
        return $this->getColumnWithAlias($this->getPrimaryKey());
    }
    
    /**
     *
     * @return array
     */
    public function getTableColumns()
    {
        $class = get_class($this);
        
        if ( !self::$tableColumns[$class] )
        {
            self::$tableColumns[$class] = SDatabase::obterColunasDaTabela( $this->getTableSchema(), $this->getTableNameWithoutSchema() );
        }
        
        return self::$tableColumns[$class];
    }
    
    public function getTableSchema()
    {
        $tableName = $this->getTableName();

        if (strpos($tableName, '.'))
        {
            $schema = current(explode('.', $tableName));
        }
        else
        {
            $schema = 'public';
        }
        
        return $schema;
    }
    
    public function getTableNameWithoutSchema()
    {
        $tableName = $this->getTableName();

        if (strpos($tableName, '.'))
        {
            $tableName = end(explode('.', $tableName));
        }

        return $tableName;
    }
    
    /**
     * @return array
     */
    private function getTableColumnNames()
    {
        $out = array();
        
        foreach ( $this->getTableColumns() as $column )
        {
            $out[] = $column->column;
        }
        
        return $out;
    }
    
    /**
     * @return stdClass
     */
    public function getTableColumn($name)
    {
        foreach ( $this->getTypeObjectByColumn($name)->getTableColumns() as $column )
        {
            if ( strtolower($column->column) == $this->getColumnWithoutAlias($name) )
            {
                return $column;
            }
        }
        
        return false;
    }
    
    /**
     * @return boolean
     */
    public function hasColumn($name)
    {
        return $this->getTypeObjectByColumn($name)->getTableColumn($name) != null;
    }
    
    /**
     * @return SType
     */
    public function getTypeObjectByColumn($column)
    {
        $type = $this;
        
        if ( strpos($column, '.') )
        {
            $alias = $this->getColumnAlias($column);
            $assoc = $this->getAssociationRecursive($alias);
            
            if ( $assoc )
            {    
                $type = $assoc->getTypeObject();
            }
        }
        
        return $type;
    }
    
    /**
     * Retorna se campo é obrigatorio na base de dados
     *
     * @return boolean
     */
    public function isColumnNotNull($column)
    {
        return $this->getTableColumn($column)->notnull == DB_TRUE;
    }
    
    /**
     * Retorna descricao de campo na base de dados
     *
     * @return string
     */
    public function getColumnDescription($column)
    {
        return $this->getTableColumn($column)->description;
    }
    
    /**
     * Retorna com o alias da tabela para consultas SQL nao darem conflito
     *
     * @return array
     */
    private function getSelectColumns(SType $type)
    {
        $out = array();
        
        foreach ( $type->getTableColumns() as $column )
        {
//            $column instanceof bInfoColuna;
            $formatCol = $type->getColumnWithAlias( $column->column );
            
            if ( $this->isTypeTimestamp($column->column) )
            {
                $formatCol = 'timestampToUser(' . $formatCol . ')';
            }
            if ( $this->isTypeDate($column->column) )
            {
                $formatCol = 'dateToUser(' . $formatCol . ')';
            }
            if ( $this->isTypeTime($column->column) )
            {
                $formatCol = 'timeToUser(' . $formatCol . ')';
            }

            $out[] = $formatCol . ' AS ' . $type->getColumnAs($column->column);
        }
        
        $out = array_merge($out, $this->getVirtualColumnsSql());
        
        // Obtem colunas recursivamente
        foreach ( $type->getAssociations() as $association )
        {
            $association instanceof sTypeAssociation;
            
            if ( $association->isModeOne() )
            {
                $out = array_merge($out, $this->getSelectColumns($association->getTypeObject()));
            }
        }
        
        return $out;
    }
    
    /**
     * Retorna array das colunas virtuais para ser passado ao MSQL
     * 
     * @return array 
     */
    private function getVirtualColumnsSql()
    {
        $out = array();
        
        foreach ( $this->getVirtualColumns() as $colName => $colExpr )
        {
            $out[] = $this->getVirtualColumn($colName) . ' AS ' . $this->getColumnAs($colName);
        }
        
        return $out;
    }
    
    public function isVirtualColumn($column)
    {
        return in_array($this->getColumnWithoutAlias($column), array_keys($this->getVirtualColumns()));
    }
    
    private function addVirtualColumn($name, $value)
    {
        $this->_virtualColumns[$name] = $value;
        
        return $this;
    }
    
    public function getVirtualColumns()
    {
        return $this->_virtualColumns;
    }
    
    private function getVirtualColumn($column)
    {
        $column = $this->getColumnWithoutAlias($column);
        
        return '(' . $this->_virtualColumns[$column] . ')';
    }
    
    public function clearAssociationDefs()
    {
        $this->_associationDefs = null;
    }
    
    /**
     * @return boolean
     */
    public function hasAssociation($name)
    {
        return isset($this->_associations[$name]);
    }
    
    /**
     *
     * @return sTypeAssociation
     */
    public function getAssociation($name)
    {
        $associations = $this->getAssociations();
        
        return $associations[$name];
    }
    
    /**
     *
     * @return array Objetos sTypeAssociations
     */
    public function getAssociations()
    {
        if ( !$this->_associationDefs )
        {
            if ( count($this->_associations) > 0 )
            {
                foreach ( $this->_associations as $name => $values )
                {
                    $this->addAssociation($name, $values);
                }
            }
        }
        
        return (array) $this->_associationDefs;
    }
    
    private function addAssociation($name, $values)
    {
        $association = new sTypeAssociation();
        $association->_setName($name);
        $association->setSourceType($this);
        
        // Define setters()
        $this->_associationDefs[$name] = SAGU::setFromArray($association, $values);
    }
    
    /**
     *
     * @return array Objetos sTypeAssociations
     */
    public function getAssociationsRecursive()
    {
        $associations = $this->getAssociations();
        
        foreach ( $associations as $association )
        {
            $association instanceof sTypeAssociation;
            $associations = array_merge($associations, $association->getTypeObject()->getAssociationsRecursive());
        }
        
        return $associations;
    }
    
    /**
     * Faz uma busca recursiva pela associacao
     * 
     * @return sTypeAssociation
     */
    public function getAssociationRecursive($name)
    {
        $associations = $this->getAssociationsRecursive();
        
        return $associations[$name];
    }
    
    /**
     * @return boolean
     */
    private function isReservedColumn($column)
    {
        return in_array($this->getColumnWithoutAlias($column), self::$reservedColumns);
    }
    
    public function cloneType()
    {
        $new = clone($this);
        $new instanceof SType;
        $new->clearAssociationDefs();
        
        return $new;
    }
    
    /**
     * Retorna novo objeto MSQL
     *
     * @return MSQL 
     */
    public function msql()
    {
        $msql = new MSQL();
        $msql->setDb( SDatabase::getInstance() );
        
        return $msql;
    }
    
    /**
     * Retorna os dados preparados para serem inseridos
     * 
     * @return array 
     */
    private function getSaveData()
    {
        $data = array();

        foreach ( $this->getTableColumns() as $column )
        {
//            $col instanceof bInfoColuna;
            
            $value = $this->getAttribute($column->column);
            
            if ( $value == SType::NULL_VALUE )
            {
                $data[$column->column] = NULL;
            }
            else if ( ( ( strlen($value) > 0 ) || ( $value instanceof MSQLExpr ) ) && !$this->isReservedColumn($column->column) )
            {
                if ( $column->type == 'timestamp' )
                {
                    $value = SDatabase::queryExpression('timestampToDb(?)', $value);
                }
                else if ( $column->type == 'date' )
                {
                    $value = SDatabase::queryExpression('dateToDb(?)', $value);
                }
                
                $data[$column->column] = $value;
            }
        }

        return $data;
    }
    
    /**
     * Metodo utilizado para tratamentos antes de realizar buscas
     */
    public function beforeFind(MSQL $sql)
    {
    }
    
    /**
     * Busca recursivamente nas associacoes ('many' e 'one').
     * Tenha em mente que isto custará muito mais processamento e consultas SQL.
     * 
     * @return array
     */
    public function findManyRecursive(MSQL $sql = null)
    {
        $rows = $this->findMany($sql);
        
        foreach ( $rows as $row )
        {
            $row instanceof SType;
            
            foreach ( $this->getAssociationsRecursive() as $association )
            {
                $association instanceof STypeAssociation;

                if ( $association->isModeOne() )
                {
                    $sourceType = $association->getSourceType();
                    $typeAssoc = $sourceType->getAssociation( $association->_getName() );

                    $type = $typeAssoc->getTypeObject();
                    $sourceType->setAttribute($association->_getName(), $type);
                }
                else if ( $association->isModeMany() )
                {
                    // Busca registros filhos
                    $joinCol = SAGU::NVL($association->getJoinColumnRight(), $association->getJoinColumn());
                    $foreignKey = $association->getTypeObject()->getColumnWithAlias( $joinCol );
                    
                    $subSql = $this->msql();
                    $subSql->addEqualCondition($foreignKey, $row->getPkeyValue());
                    
                    // Define no atributo
                    $subRows = $association->getTypeObject()->findManyRecursive( $subSql );
                    $row->setAttribute($association->_getName(), $subRows);
                }
            }
        }
        
        return $rows;
    }
    
    /**
     * Busca pelo id unico
     * 
     * @return SType
     */
    public function findByPk($id)
    {
        return $this->findOneRecursive( $this->msql()->addEqualCondition($this->getColumnWithAlias($this->getPrimaryKey()), $id) );
    }
    
    /**
     * Busca o primeiro resultado, recursivamente
     *      
     * @return SType
     */
    public function findOneRecursive(MSQL $sql = null)
    {
        if ( !$sql )
        {
            $sql = $this->msql();
        }
        
        $rows = $this->findManyRecursive($sql->setLimit(1));
        
        return $rows[0];
    }

    /**
     * Funcao central que trata buscas nos types.
     * Nao sobrescreva este metodo para personalizar buscas, sobrescreva apenas o getFindSql()
     *
     * @return array Array com objetos populados do type instanciado
     */
    public function findMany(MSQL $sql = null)
    {
        $rows = $this->findManyAsArray($sql);
        $out = array();
        
        foreach ( $rows as $row )
        {
            $type = $this->isFindCloneType() ? $this->cloneType() : $this;
            
            $out[] = $type->setValuesFromArray($row);
//            SAGU::setFromArray($type, $row, false);
        }
        
        return $out;
    }

    /**
     * Obtem primeiro registro da busca
     * 
     * @return SType Retorna objeto do type instanciado, caso exista
     */
    public function findOne(MSQL $sql = null)
    {
        if ( !$sql )
        {
            $sql = $this->msql();
        }
        
        $rows = $this->findMany( $sql->setLimit(1) );
        
        $row = $rows[0];
        $row instanceof SType;
        
        return $row;
    }
    
    /**
     * Obtem resultado como array associativo (utilizado em grids legadas e outros casos especiais)
     * 
     * @return array 
     */
    public function findManyAsArray(MSQL $sql = null)
    {
        $rows = SDatabase::queryAssociative( $this->getFindSql($sql) );
        
        return $rows;
    }
    
    /**
     * Obtem o resultado como array de objetos stdClass
     * 
     * @return array
     */
    public function findManyAsObject(MSQL $sql = null)
    {
        $rows = $this->findManyAsArray($sql);
        
        foreach ( $rows as &$row )
        {
            $row = (object) $row;
        }
        
        return $rows;
    }
    
    /**
     * Retorna o primeiro resultado como array associativo
     *
     * @return array
     */
    public function findOneAsArray(MSQL $sql = null)
    {
        if ( !$sql )
        {
            $sql = $this->msql();
        }

        $rows = $this->findManyAsArray( $sql->setLimit(1) );
        
        return $rows[0];
    }
    
    /**
     * Obtem o resultado como array de objetos stdClass
     * 
     * @return array
     */
    public function findOneAsObject(MSQL $sql = null)
    {
        $row = $this->findOneAsArray($sql);
        
        if ( $row )
        {
            $row = (object) $row;
        }
        
        return $row;
    }
    
    /**
     * Array associativo com id e descricao
     * Id: Chave primaria da tabela
     * Descricao: Atributo $_descriptionColumn definido no Type.
     * 
     * @return array
     */
    public function findList(MSQL $sql = null)
    {
        if ( !$sql )
        {
            $sql = $this->msql();
        }
        
        // Caso nao tenha sido especificado, usa o id e descricao para popular o array
        if ( !$sql->getColumns() )
        {
            $sql->setColumns( array( $this->getPkeyWithAlias(), $this->getDescColumnExpr() ) );
        }
        
        $sql = $this->getFindSql($sql);
        $out = array();
        
        foreach ( SDatabase::query($sql->select()) as $row )
        {
            $out[ $row[0] ] = $row[1];
        }
        
        return $out;
    }
    
    /**
     * Retorna o total de registros utilizando SELECT COUNT(*)
     * 
     * @return int
     */
    public function findCount(MSQL $sql = null)
    {
        $result = SDatabase::query( $this->getFindCountSql($sql) );
        
        return $result[0][0];
    }
    
    /**
     *
     * @return string
     */
    private function getFindCountSql(MSQL $sql = null)
    {
        return $this->getFindSql($sql)->selectCount();
    }
    
    /**
     * Retorna objeto MSQL para ser utilizado no findMany e podendo ser sobrescrito.
     * 
     * @return MSQL
     */
    private function getFindSql(MSQL $sql = null)
    {
        // Corrige problema de em certos casos estar deixando a ultima coluna em branco
        if ( $sql )
        {
            if ( is_array($sql->getColumns()) )
            {
                $cols = array_filter($sql->getColumns());
                $sql->clearColumns();
                $sql->setColumns($cols);  
            }
        }
        
        $sql = $this->getSelectSql($sql);
        
        $this->addDefaultFindConditions($sql, $this);
        $this->beforeFind($sql);
        
        // Adiciona ordenacao padrao
        if ( !$sql->getOrderBy() && $this->getDefaultOrderColumn() )
        {
            $sql->setOrderBy( $this->getDefaultOrderColumn() );
        }

        return $sql;
    }
    
    /**
     * @return MSQL
     */
    public function getSQLForLookup(MSQL $sql = null)
    {
        return $this->getFindSql($sql);
    }
    
    /**
     * Aplica paginacao, ordenacao, offset para grids
     * 
     * @return array
     */
        public function findForGrid(SGrid $grid)
    {
        // Column defaults
        foreach ( $grid->columns as $name => $column )
        {
            $column instanceof MGridColumn;
            $this->setGridColumnDefaults($name, $column);
        }
        
        $sql = $this->msql()
                ->setLimit($grid->pageLength)
                ->setOffsetSQL($grid->getOffset());        
        
        if( $this->filtrarPelaPk )
        {
            $sql->addNotEqualCondition($this->getPkeyWithAlias(), MIOLO::_REQUEST($this->getPrimaryKey()));
        }
        
        $orderBy = $grid->page->request('orderby');
                
        if ( $orderBy )
        {
            if ( $this->isVirtualColumn($orderBy) )
            {
                $orderBy = $this->getVirtualColumn($orderBy);
            }
            
            // Direcao de ordenacao (crescente / decrescente)
            if ( in_array($grid->getOrderMode(), array('asc', 'desc')) )
            {
                $orderBy .= ' ' . $grid->getOrderMode();
            }
            
            $sql->clearOrderBy()->setOrderBy($orderBy);
        }
        
        $rows = $this->findManyAsArray( $sql );

        return $rows;
    }
    
    /**
     * Realiza busca para o componente sEscolha
     */
    public function findForChoiceComponent($argument = null, $id = null)
    {
        $sql = $this->getChoiceComponentSQL($argument, $id);
        $sql->setLimit(15);
        
        return $this->findList( $sql );
    }
    
    /**
     * Obtem SQL para componente sEscolha
     */
    public function getChoiceComponentSQL($argument = null, $id = null)
    {
        $descColumn = $this->getDescColumnExpr();
        $sql = $this->msql();
        
        if ( strlen($argument) > 0 )
        {
            $sql->addIlikeConditionUnaccent($descColumn, '%' . $argument . '%');
        }
        
        if ( strlen($id) > 0 )
        {
            $sql->addEqualCondition($this->getPkeyWithAlias(), $id);
        }
        
        return $sql;
    }
    
    /**
     * @return string
     */
    public function getClassName()
    {
        return get_class($this);
    }
    
    /**
     * Aplica padroes do SAGU em visualizacoes da coluna (alinhamento, ordenacao, etc..)
     */
    private function setGridColumnDefaults($name, MGridColumn $column)
    {
        //Se coluna nao tem nowrap, nao faz
        if ( $column->nowrap )
        {
            $column->nowrap = true;
        }
        else
        {
            $column->nowrap = false;
        }
        
        if ( $this->hasColumn($name) || $this->isVirtualColumn($name) )
        {
            $column->order = true;
        }

        if ( !$column->align )
        {
            if ( $this->isTypeNumeric($name) )
            {
                $column->align = 'right';
            }
            else if ( $this->isTypeBoolean($name) )
            {
                $column->align = 'center';
            }
            else if ( $this->isTypeDate($name) || $this->isTypeTimestamp($name) || $this->isTypeTime($name) )
            {
                $column->align = 'center';
            }
        }
        
        
        if ( $this->isTypeBoolean($name) )
        {
            $column->options = SAGU::listYesNo();
        }
    }
    
    /**
     * Aplica filtros padroes para campos da tabela (que nao sao complexos e/ou especificos)
     */
    public function addDefaultFindConditions(MSQL $sql, SType $type)
    {
        $columns = array_merge(array_keys($type->getTableColumns()), array_keys($type->getVirtualColumns()));

        foreach ( $columns as $column )
        {
            // $column instanceof bInfoColuna
            $value = $type->getAttribute($column);

            if ( ( strlen($value) <= 0 ) || ( $value == SType::NULL_VALUE ) )
            {
                continue;
            }

            $type->addDefaultColumnCondition($sql, $column, $value);
        }
        
        //Percorre e aplica a busca automatica
        $buscaGeral = $type->getAttribute('busca');
        $buscaGeral = str_replace('#', '%', $buscaGeral);
        
        if( strlen($buscaGeral) > 0 )
        {
            foreach ( $columns as $key => $column )
            {   
                // Adiciona condicao por fora
                if ( $key == 0 )
                {
                    if ( strlen($sql->where) > 0 )
                    {
                        $sql->where .= ' AND ';
                    }
                    
                    $sql->where .= ' ( FALSE ';
                }
                
                $type->addDefaultColumnConditionBusca($sql, $column, $buscaGeral);
                
                foreach ( $this->getAssociations() as $association )
                {
                    $association instanceof sTypeAssociation;
                    if ( $association->isModeOne() )
                    {
                        $assocType = $association->getTypeObject();
                        $assocColumns = array_merge(array_keys($assocType->getTableColumns()), array_keys($assocType->getVirtualColumns()));
                        foreach ( $assocColumns as $assocColum )
                        {  
                            $assocType->addDefaultColumnConditionBusca($sql, $assocColum, $buscaGeral);
                        }
                    }
                }
                
                // Adiciona condicao por fora
                if ( !isset($columns[$key+1]) )
                {
                    $sql->where .= ' ) ';
                }
            }
        }
                
        // Adiciona condicoes para associacoes do tipo 'one' recursivamente
        foreach ( $type->getAssociations() as $association )
        {
            $association instanceof sTypeAssociation;
            
            if ( $association->isModeOne() )
            {
                $this->addDefaultFindConditions($sql, $association->getTypeObject());
                // ->beforeFind($sql); // INSEGURO
            }
        }
        
        return $this;
    }
    
    /**
     * Adiciona condicoes padrao no WHERE filtrando em todos campos
     */
    public function addDefaultColumnConditionBusca(MSQL $sql, $column, $value)
    {
        $colAlias = $this->getColumnWithAlias( $column );

        if ( $this->isTypeString($column) )
        {
            $sql->setWhereOr("UNACCENT({$colAlias})".' ILIKE UNACCENT(?)', array('%'.$value.'%'));
        }        
        else if ( ( $this->isTypeNumeric($column) || $this->isTypeCharacter($column) ) && is_numeric($value) && strlen($value) < 11 )
        {            
            $sql->setWhereOr($colAlias.' = ?', array($value));
        }   
        else if ( $this->isTypeDate($column) )
        {
            $vl = explode(' ', $value);
            foreach($vl as $cod=>$dateValue)
            {
                //Filtra por data específica passada no formato padrão dd/mm/yyyy
                $checkDate = date_parse_from_format('d/m/Y', $dateValue);
                if( !$checkDate['error_count'] )
                {
                    $sql->setWhereOr($colAlias . ' = dateToDb(?)', array($dateValue));
                }
            }
        }
    }
    
    /**
     * Adiciona condicoes padrao no WHERE
     */
    public function addDefaultColumnCondition(MSQL $sql, $column, $value)
    {
        $colAlias = $this->getColumnWithAlias( $column );
             
        if ( $this->isVirtualColumn($column) )
        {
            $sql->addEqualCondition($this->getVirtualColumn($column), $value);
        }
        else if ( $this->isTypeString($column) )
        {
            $sql->addIlikeConditionUnaccent($colAlias, $value . '%');
        }
        else if ( $this->isTypeNumeric($column) || $this->isTypeCharacter($column) )
        {
            $sql->addEqualCondition($colAlias, $value);
        }
        else if ( $this->isTypeDate($column) )
        {
            // Obs: Isto nao servira para realidade pois filtros de data geralmente requerem >= datainicial e <= datafinal...
            // Pensar em forma de aplicar um padrao mas poder sobrescrever (ex.: dar unset() no filters e utilizar outro nome de campo no Form de busca.)
            $sql->setWhere($colAlias . ' = dateToDb(?)', array($value));
        }
        else if ( $this->isTypeTimestamp($column) )
        {
            // Obs: Isto nao servira para realidade pois filtros de data geralmente requerem >= datainicial e <= datafinal...
            // Pensar em forma de aplicar um padrao mas poder sobrescrever (ex.: dar unset() no filters e utilizar outro nome de campo no Form de busca.)
            $sql->setWhere($colAlias . ' = timestampToDb(?)', array($value));
        }
    }
    
    public function isTypeCharacter($column)
    {
        return in_array($this->getTableColumn($column)->type, array('bpchar'));
    }
    
    /**
     * @return boolean
     */
    public function isTypeInteger($column)
    {
        return in_array($this->getTableColumn($column)->type, array('int4', 'integer', 'bigint'));
    }

    /**
     * @return boolean
     */
    public function isTypeDouble($column)
    {
        return in_array($this->getTableColumn($column)->type, array('double'));
    }
    
    /**
     * @return boolean
     */
    public function isTypeNumeric($column)
    {
        return in_array($this->getTableColumn($column)->type, array('numeric', 'int4', 'integer', 'bigint', 'double', 'decimal'));
    }
    
    /**
     * @return boolean
     */
    public function isTypeBoolean($column)
    {
        return in_array($this->getTableColumn($column)->type, array('bool'));
    }
    
    /**
     * @return boolean
     */
    public function isTypeString($column)
    {
        return in_array($this->getTableColumn($column)->type, array('text', 'varchar'));
    }
    
    /**
     * @return boolean
     */
    public function isTypeDate($column)
    {
        return in_array($this->getTableColumn($column)->type, array('date'));
    }
    
    /**
     * @return boolean
     */
    public function isTypeTime($column)
    {
        return in_array($this->getTableColumn($column)->type, array('time'));
    }
    
    /**
     * @return boolean
     */
    public function isTypeTimestamp($column)
    {
        return in_array($this->getTableColumn($column)->type, array('timestamp'));
    }
    
    /**
     * @return MSQL
     */
    private function getSelectSql(MSQL $sql = null)
    {
        if ( !$sql )
        {
            $sql = $this->getPopulateSql();
        }
        
        $fromOnly = $this->_fromOnly ? ' ONLY ' : null;
        
        $sql->setTables( $fromOnly . $this->getTableAndAlias(true) );

        if ( !$sql->getColumns() )
        {
            $sql->setColumns( $this->getSelectColumns($this) );
        }
        
        // Adiciona JOIN's para tabelas de associacoes tipo 'one'
        foreach ( $this->getAssociations() as $association )
        {
            $association instanceof sTypeAssociation;
            
            // Multiunidade
//            $association->setCondition();
            
            if ( $association->isModeOne() )
            {
                $association->addJoinSql($sql);
            }
        }
        
        if ( !$this->_tableViewName )
        {
            // Multiunidade
            if ( $this->utilizaMultiUnidade() && strlen(sMultiUnidade::obterUnidadeLogada()) > 0 ) 
            {
                // FIXME Talvez aqui deve verificar entre as unidades em que o usuario logado tem permissao (mais de uma)
    //            $sql->addWhereIn($column, $values);

                $unitIdCol = $this->getColumnWithAlias('unitId');
                $sql->setWhereAnd("({$unitIdCol} = ? OR {$unitIdCol} IS NULL)", array(sMultiUnidade::obterUnidadeLogada()));
            }

            // Multicentro
            if ( $this->utilizaMultiCentro() && ( count(sMultiCentro::obterCentrosPessoa()) > 0 ) )
            {
                $centerIdCol = $this->getColumnWithAlias('centerId');
                $sql->addWhereIn($centerIdCol, sMultiCentro::obterCentrosPessoa());
            }
        }
        
        return $sql;
    }
    
    /**
     * Metodo que pode ser sobrescrito.
     * 
     * @return MSQL
     */
    public function getPopulateSql()
    {
        return $this->msql();
    }
    
    /**
     * Save automatico para types
     *
     * @return boolean
     */
    public function save()
    {
        $MIOLO = MIOLO::getInstance();
        $sql = '';
        $data = array();
  
        // Comentado devido ao SAGU::prepare() fazer isto
        if ( $this->hasColumn('username') && $this->hasColumn('datetime') )
        {
            $data = array(
                'username' => SAGU::NVL($MIOLO->getLogin()->id, 'sagu2'),
                'datetime' => SDatabase::queryExpression('NOW()'),
            );
        }
        
        if ( $this->gravarMaiusculo )
        {
            $data += array_map('stype_strtoupper', $this->getSaveData());
        }
        else
        {
            $data += $this->getSaveData();
        }
        
        // Multiunidade
        if ( $this->utilizaMultiUnidade() && strlen(sMultiUnidade::obterUnidadeLogada()) > 0 && !$this->getAttribute('unitid') )
        {
            $data['unitid'] = sMultiUnidade::obterUnidadeLogada();
        }
        
        // Se tiver valor na chave primaria, atualiza, senao , insere
        if ( strlen( $this->getPkeyValue() ) > 0 )
        {
            $sql = MSQL::updateTable($this->getTableName(), $data, $this->getPkeyCondition() );
            $ok = SDatabase::getInstance()->execute($sql);
        }
        else
        {
            // Insere passando o valor da sequencia chave primaria
            if ( $this->insertWithPkey )
            {
                $data[ $this->getPrimaryKey() ] = $this->getPkeyNextValue();
            }
            
            $sql = MSQL::insertTable($this->getTableName(), $data);
            $ok = SDatabase::getInstance()->execute($sql);
            
            if ( $ok )
            {
                $this->setPkeyValue($this->getLastInsertId());
            }
        }
        
        // Salva registros de types associados
        if ( strlen($this->getPkeyValue()) > 0 )
        {
            foreach ( $this->getAssociations() as $name => $association )
            {
                $association instanceof sTypeAssociation;
                $association->saveRelateds();
            }
        }
        
        return $ok;
    }
    
    /**
     *
     * @return boolean
     */
    public function delete()
    {
        $module = SAGU::getFileModule(__FILE__);
        
        if ( strlen($this->getPkeyValue()) <= 0 )
        {
            // Comentado pois estava causando erro ao excluir quando relacao era do tipo one sem registro populado.
//            throw new Exception( _M('Chave primaria nao definida para exclusao.', $module) );
        }
        
        // FIXME A transacao tera que sair daqui , ou ser feito uma flag que define se deve ser executada ou nao
        SDatabase::beginTransaction();
        
        // Remove registros associados
        foreach ( $this->getAssociations() as $association )
        {
            $association instanceof sTypeAssociation;
            $association->deleteRelateds();
        }
        
        $sql = MSQL::deleteTable($this->getTableName(), $this->getPkeyCondition() );

        $ok = SDatabase::execute($sql);
        
        // FIXME A transacao tera que sair daqui , ou ser feito uma flag que define se deve ser executada ou nao
        SDatabase::commit();
        
        return $ok;
    }
    
    /**
     * Popula os dados utilizando a chave primaria
     * Foi renomeado o metodo para nao conflitar com types no padrao antigo. 
     */
    public function populateData()
    {
        $module = SAGU::getFileModule(__FILE__);
        
        $sql = $this->msql()->addEqualCondition( $this->getPkeyWithAlias(), $this->getPkeyValue() );
        $row = $this->setFindCloneType(false)->findOneRecursive($sql);
        
        $this->setFindCloneType(true);
        
        if ( !$row )
        {
            throw new Exception( _M('Nenhum registro foi encontrado.', $module) );
        }
    }
    
    public function duplicate()
    {
        $new = $this->cloneType();
        $new instanceof SType;
        $new->setPkeyValue(null);
        
        // Duplica registros associados
        foreach ( $new->getAssociations() as $name => $association )
        {
            $association instanceof sTypeAssociation;
            $association->duplicateRelateds();
        }
        
        return $new;
    }
    
    public function getAjaxArgs()
    {
        return $this->ajaxArgs;
    }

    public function setAjaxArgs($ajaxArgs)
    {
        $this->ajaxArgs = $ajaxArgs;
    }
    
    private function doValidation()
    {
        $valid = true;
        
        foreach ( $this->_validations as $field => $validations )
        {
            foreach ( $validations as $validation )
            {
//                $validation['function'];
//                $validation['args'] = array();
//                $validation['message'];
//                $validation['on'];
            }
        }
    }
    
    /**
     * Valida os dados atuais definidos e retorna se a validação passou.
     * 
     * @return boolean
     */
    public function isValid()
    {
    }
    
    /**
     * Retorna os erros de validacoes ocorridos.
     * 
     * @return array
     */
    public function validationErrors()
    {
        
    }
    
    /**
     * @return boolean
     */
    public function checkFieldValid($field, $function, $args = array())
    {
        $value = $this->getAttribute($field);
        
        if ( method_exists($this->validator(), $function) )
        {
            $this->validator()->setSourceType($this);
            $this->validator()->setCurrentField($field);
            $this->validator()->setArgs($args);
            
            $result = call_user_method($function, $this->validator(), $value);
        }
        else
        {
            $result = call_user_method($function, $this, $value);
        }
        
        return $result;
    }
    
    /**
     * @return SValidator
     */
    public function validator()
    {
        if ( !$this->validator )
        {
            $this->validator = new SValidator();
        }
        
        return $this->validator;
    }
    
    /**
     * Define se o registro da pk deve ser ingnorado na grid
     * @param type $value
     */
    public function setfiltrarPelaPk($value)
    {
        $this->filtrarPelaPk = $value;
    }
    
    private function getPkeySequence()
    {
        return SDatabase::queryExpression('pg_get_serial_sequence(?, lower(?))', array($this->getTableName(), $this->getPrimaryKey()));
    }
    
    public function getPkeyNextValue()
    {
        return SDatabase::queryExpression('nextval(?)', array($this->getPkeySequence()));
    }
    
    /**
     * Método que define a estrutura dos campos da tabela que estão mapeados no tipo
     * 
     */
    public function obterEstruturaDaTabelaDoCatalogo()
    {
        // Obtém colunas que estão na tabela
        return bCatalogo::obterObjetosDasColunasDaTabela($this->getTableSchema(), $this->getTableNameWithoutSchema());
    }
    
    /**
     * Instancia um tipo pelo nome
     * 
     * @param String $nomeDoTipo Nome do tipo a ser instanciado
     * @param String $id Valor da primary key do tipo
     * @return Object Instância do tipo
     * @throws Exception Caso o tipo não exista
     */
    public static function obterInstanciaDoTipoPeloNome($nomeDoTipo, $id = NULL)
    {
        if ( class_exists($nomeDoTipo) )
        {
            return new $nomeDoTipo($id);
        }
        else
        {
            throw new Exception("Não foi possível realizar o carregamento do type {$nomeDoTipo}");
        }

    }
    
    /**
     * Obtém o comentário da tabela.
     * 
     * @return String comentário da tabela. 
     */
    public function obterComentarioDaTabela()
    {
        $comentario = bCatalogo::obterComentarioDaTabela($this->getTableNameWithoutSchema());
        
        return $comentario ? $comentario : ucfirst($this->getTableAlias());
    }
    
}

function stype_strtoupper($value)
{
    if ( is_scalar($value) && strlen($value) > 0 )
    {
        $bs = new BString($value);
        return (string) $bs->toUpper();
    }
    else
    {
        return NULL;
    }
}
?>