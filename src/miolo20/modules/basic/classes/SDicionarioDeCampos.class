<?php

/**
 * <--- Copyright 2005-2015 de Solis - Cooperativa de Soluções Livres Ltda.
 *
 * Este arquivo é parte do programa Sagu.
 *
 * O Sagu é um software livre; você pode redistribuí-lo e/ou modificá-lo
 * dentro dos termos da Licença Pública Geral GNU como publicada pela Fundação
 * do Software Livre (FSF); na versão 2 da Licença.
 *
 * Este programa é distribuído na esperança que possa ser útil, mas SEM
 * NENHUMA GARANTIA; sem uma garantia implícita de ADEQUAÇÃO a qualquer MERCADO
 * ou APLICAÇÃO EM PARTICULAR. Veja a Licença Pública Geral GNU/GPL em
 * português para maiores detalhes.
 *
 * Você deve ter recebido uma cópia da Licença Pública Geral GNU, sob o título
 * "LICENCA.txt", junto com este programa, se não, acesse o Portal do Software
 * Público Brasileiro no endereço www.softwarepublico.gov.br ou escreva para a
 * Fundação do Software Livre (FSF) Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA --->
 *
 * Classes referentes ao dicionário de campos do SAGU
 *
 * @author Luís Augusto Weber Mercado [luis_augusto@solis.com.br]
 *
 * @version $Id$
 *
 * \b Maintainers: \n
 * Luís Augusto Weber Mercado [luis_augusto@solis.com.br]
 *
 * @since
 * Arquivo criado em 03/06/2015
 * 
 */
$MIOLO = MIOLO::getInstance();
$MIOLO->uses("classes/bBaseDeDados.class.php", "base");
$MIOLO->uses("classes/bCatalogo.class.php", "base");
$MIOLO->uses("classes/bInfoColuna.class.php", "base");

/**
 * Classe que abstrai o uso do dicionário de campos
 * 
 * @author Luís Augusto Weber Mercado [luis_augusto@solis.com.br]
 */
class SDicionarioDeCampos
{

    /**
     * Obtém campo personalizado pelo nome deste
     * 
     * @param String $campo Nome do campo
     * @return Array Lista com o campo gerado e seu validador
     * 
     * @throws Exception Caso o campo personalizado não tenha sido encontrado
     */
    public static function obterCampo($campo)
    {
        // Verificar se existe campo personalizado
        if ( !SDicionarioDeCampos::verificarExistenciaCampoPersonalizado($campo) )
        {
            throw new Exception(_M("Campo personalizado não econtrado"));
        }

        $campoDoDicionario = new SCampoPersonalizado($campo);

        return $campoDoDicionario->gerar();

    }

    /**
     * Verifica, previamente, a existência do campo personalizado
     * 
     * @param String $campo Nome do campo
     * @return Boolean Se o campo existe ou não
     */
    private static function verificarExistenciaCampoPersonalizado($campo)
    {
        $filtros = new stdClass();
        $filtros->name = $campo;

        $tipo = new BasCustomField();
        $resultadoPesquisa = $tipo->procurarCampoParaDicionarioDeCampos($filtros);

        return count($resultadoPesquisa) > 0;

    }

    /**
     * Obtém campo personalizado pelo nome deste
     * 
     * @param String $coluna Coluna relacionada ao campo
     * @param String $tabela Tabela relacionada ao campo
     * @return Array Lista com o campo gerado e seu validador
     * 
     * @throws Exception Caso o campo personalizado não tenha sido encontrado
     */
    public static function obterCampoDeTabela($coluna, $tabela)
    {
        $campoDoDicionario = null;

        $detalhesTabela = SDicionarioDeCampos::normalizarNomeDaTabela($tabela);
        $tabelaNoramlizada = $detalhesTabela->esquemaTabela . "." . $detalhesTabela->tabela;

        // Verificar se existe campo personalizado com as informações
        if ( SDicionarioDeCampos::verificarExistenciaCampoPersonalizadoDeTabela($coluna, $tabelaNoramlizada) )
        {
            $campoDoDicionario = new SCampoPersonalizadoDeTabela($coluna, $tabelaNoramlizada);
        }
        else
        {
            $campoDoDicionario = new SCampoDoCatalogo($coluna, $tabelaNoramlizada);
        }

        return $campoDoDicionario->gerar();

    }

    /**
     * Verifica, previamente, a existência do campo personalizado
     * 
     * @param String $coluna Coluna relacionada ao campo
     * @param String $tabela Tabela relacionada ao campo
     * @return Boolean Se o campo existe ou não
     */
    private static function verificarExistenciaCampoPersonalizadoDeTabela($coluna, $tabela)
    {
        $filtros = new stdClass();
        $filtros->coluna = $coluna;
        $filtros->tabela = $tabela;

        $tipo = new BasCustomField();
        $resultadoPesquisa = $tipo->procurarCampoParaDicionarioDeCampos($filtros);

        return count($resultadoPesquisa) > 0;

    }

    /**
     * A partir de uma string indicando o nome da tabela, normaliza as informações
     * de localização desta (esquema e nome)
     * 
     * @param String $tabela Nome da tabela (com ou sem esquema)
     * @return stdClass Objeto com as informações da tabela: <br/>
     * - $informacao->tabela = "nome da tabela";<br/>
     * - $informacao->esquemaTabela = "esquema da tabela"
     */
    public static function normalizarNomeDaTabela($tabela)
    {
        $retorno = new stdClass();

        if ( strpos($tabela, ".") !== false )
        {
            $especificacaoTabela = explode(".", $tabela);

            $retorno->esquemaTabela = $especificacaoTabela[0];
            $retorno->tabela = $especificacaoTabela[1];
        }
        else
        {
            $retorno->esquemaTabela = "public";
            $retorno->tabela = $tabela;
        }

        return $retorno;

    }

}

/**
 * Classe base para os tipos de campo suportados pelo dicionário de dados
 * 
 * @author Luís Augusto Weber Mercado [luis_augusto@solis.com.br]
 * 
 * @access private
 */
abstract class SCampoDoDicionario
{

    abstract function gerar();

}

/**
 * Classe que abstrai os métodos para geração de campos personalizados
 * 
 * @author Luís Augusto Weber Mercado [luis_augusto@solis.com.br]
 * 
 * @access private
 */
class SCampoPersonalizado extends SCampoDoDicionario
{

    protected $campo;

    public function __construct($campo)
    {
        $this->campo = $campo;

    }

    public function gerar()
    {
        $campo = $this->obterCampoPersonalizado();

        $campoGenerico = $this->obterCampoGenericoPopuladoComCampoPersonalizado($campo);

        return $campoGenerico->gerar();

    }

    /**
     * Busca dos dados dos campos personalizados para considerar apenas a
     * coluna e a tabela
     * 
     * @return Array Lista associativa das propriedades do campo personalizado
     * 
     * @throws Exception Caso não tenha sido possível encontrar os dados do campo
     * personalizado
     */
    protected function obterCampoPersonalizado()
    {
        $filtros = new stdClass();
        $filtros->name = $this->campo;

        $tipo = new BasCustomField();
        $resultadoPesquisa = $tipo->procurarCampoParaDicionarioDeCampos($filtros);

        if ( count($resultadoPesquisa) > 0 )
        {
            return $resultadoPesquisa[0];
        }
        else
        {
            throw new Exception(_M("Não foi encontrado nenhum campo personalizado com esse nome"));
        }

    }

    protected function obterCampoGenericoPopuladoComCampoPersonalizado($campo)
    {
        $tipo = $campo["field_format"];
        
        $campoGenerico = SCampoGenerico::obterClasseDeCampoConformeTipo($tipo, SCampoGenerico::MODO_CAMPO_PERSONALIZADO);
        $campoGenerico->id = $this->campo;
        $campoGenerico->obrigatorio = $campo["required"] === DB_TRUE;
        $campoGenerico->rotulo = $campo["label"];
        $campoGenerico->valor = $campo["default_value"];
        $campoGenerico->tamanho = $campo["max_length"];
        $campoGenerico->tamanhoMinimo = $campo["min_length"];
        $campoGenerico->valoresPossiveis = $campo["possible_values"];
        $campoGenerico->parametros = $campo["possible_parameters"];

        return $campoGenerico;

    }

}

/**
 * Classe que abstrai os métodos para geração de campos personalizados relacionados
 * a campos (colunas) de tabela
 * 
 * @author Luís Augusto Weber Mercado [luis_augusto@solis.com.br]
 * 
 * @access private
 */
class SCampoPersonalizadoDeTabela extends SCampoPersonalizado
{

    protected $tabela;

    public function __construct($campo, $tabela)
    {
        parent::__construct($campo);
        $this->tabela = $tabela;

    }

    /**
     * OVERWRITE do método pai
     * 
     * Altera busca dos dados dos campos personalizados para considerar apenas a
     * coluna e a tabela
     * 
     * @return Array Lista associativa das propriedades do campo personalizado
     * 
     * @throws Exception Caso não tenha sido possível encontrar os dados do campo
     * personalizado
     */
    protected function obterCampoPersonalizado()
    {
        $filtros = new stdClass();
        $filtros->coluna = $this->campo;
        $filtros->tabela = $this->tabela;

        $tipo = new BasCustomField();
        $resultadoPesquisa = $tipo->procurarCampoParaDicionarioDeCampos($filtros);

        if ( count($resultadoPesquisa) > 0 )
        {
            return $resultadoPesquisa[0];
        }
        else
        {
            throw new Exception(_M("Não foi encontrado nenhum campo personalizado com esse nome"));
        }

    }

}

/**
 * Classe que abstrai os métodos para geração de campos a partir do catálogo
 * 
 * @author Luís Augusto Weber Mercado [luis_augusto@solis.com.br]
 * 
 * @access private
 */
class SCampoDoCatalogo extends SCampoDoDicionario
{

    protected $coluna;
    protected $tabela;

    public function __construct($coluna, $tabela)
    {
        $this->coluna = $coluna;
        $this->tabela = $tabela;

    }

    public function gerar()
    {
        $informacaoColuna = $this->obterInformacoesDoCampoDaTabela($this->coluna, $this->tabela);

        return $this->gerarCampoBaseadoNaColuna($informacaoColuna);

    }

    /**
     * Obtém as informações do campo de uma dada tabela a partir do catálogo
     * 
     * @param String $campo Campo a ser obtido
     * @param String $tabela Nome da tabela (com ou sem esquema)
     * @return Object Campo com as informações do catálogo
     * @throws Exception Caso o campo informado não esteja vinculado a tabela informada
     */
    private function obterInformacoesDoCampoDaTabela($campo, $tabela)
    {
        $especificacaoTabela = SDicionarioDeCampos::normalizarNomeDaTabela($tabela);

        // Obtém colunas que estão na tabela.
        $colunas = bCatalogo::obterObjetosDasColunasDaTabela($especificacaoTabela->esquemaTabela, $especificacaoTabela->tabela);

        if ( is_array($colunas) )
        {
            $informacoes = $colunas[$campo];

            if ( is_null($informacoes) )
            {
                throw new Exception("O campo requisitado não está vinculado a tabela informada.");
            }

            // Corrige o identificador da coluna
            $idColuna = explode('__', $informacoes->campo);
            $informacoes->campo = end($idColuna);

            return $informacoes;
        }
        else
        {
            throw new Exception("Não existe {$campo} vinculado à tabela {$tabela}!");
        }

    }

    /**
     * Gera um campo e um validador baseados nas informações da coluna
     * 
     * @param bInfoColuna $coluna
     * @return Array Array com o campo e o validador gerado
     */
    private function gerarCampoBaseadoNaColuna(bInfoColuna $coluna)
    {
        $campo = NULL;

        if ( !$campo )
        {
            $campoGenerico = SCampoGenerico::obterClasseDeCampoConformeTipo($coluna->tipo, SCampoGenerico::MODO_CAMPO_DO_CATALOGO);
            $campoGenerico->id = $coluna->campo;
            $campoGenerico->rotulo = _M($coluna->titulo, $this->modulo);
            $campoGenerico->valor = substr($coluna->valorPadrao, 0, 7) != "nextval" ? $coluna->valorPadrao : "";
            $campoGenerico->obrigatorio = $coluna->obrigatorio === DB_TRUE;
            $campoGenerico->tamanho = $coluna->tamanho;

            list($campo, $validador) = $campoGenerico->gerar();
        }

        // Se é uma coluna sequencial
        if ( $coluna->restricao == 'p' && substr($coluna->valorPadrao, 0, 7) == "nextval" )
        {
            $validador = NULL;
        }

        return array($campo, $validador);

    }

}

/**
 * Classe base para os tipos de campos suportados pelo dicionário de campos
 * 
 * @author Luís Augusto Weber Mercado [luis_augusto@solis.com.br]
 * 
 * @access private
 */
abstract class SCampoGenerico
{

    public $id;
    public $rotulo;
    public $valor;
    public $tamanho;
    public $tamanhoMinimo;
    public $obrigatorio;
    public $valoresPossiveis;
    public $parametros;

    const MODO_CAMPO_PERSONALIZADO = "p";
    const MODO_CAMPO_DO_CATALOGO = "c";

    abstract function gerar();

    /**
     * Obtém a instância da classe relacionada a um dado tipo de campo
     * 
     * @param String $tipo Tipo do campo
     * @param String $modo Modo do campo (personalizado ou do catálogo). <b>Para
     * este parâmetro utilizar as constantes da classe: MODO_CAMPO_PERSONALIZADO
     * ou MODO_CAMPO_DO_CATALOGO</b>
     * @return SCampoGenerico Intância do campo conforme o tipo
     * 
     * @throws Exception Caso o tipo informado não seja válido
     */
    public static function obterClasseDeCampoConformeTipo($tipo, $modo)
    {
        $tiposSuportados = self::obterTiposSuportados();

        $tipoComModo = $modo . $tipo;

        if ( isset($tiposSuportados[$tipoComModo]) )
        {
            return $tiposSuportados[$tipoComModo];
        }
        else
        {
            throw new Exception("Tipo informado não está implementado");
        }

    }

    private static function obterTiposSuportados()
    {
        $booleanos = self::obterMapeamentoParaCamposBooleanos();
        $datas = self::obterMapeamentoParaCamposData();
        $timestamp = self::obterMapeamentoParaCamposTimestamp();
        $decimais = self::obterMapeamentoParaCamposDecimais();
        $inteiros = self::obterMapeamentoParaCamposInteiros();
        $textos = self::obterMapeamentoParaCamposTextuais();
        $textosLongos = self::obterMapeamentoParaCamposTextuaisLongos();
        $listas = self::obterMapeamentoParaCamposListagem();
        $listaSQLs = self::obterMapeamentoParaCamposListagemSQL();

        $tipos = array_merge($booleanos, $datas, $timestamp, $decimais, $inteiros, $textos, $textosLongos, $listas, $listaSQLs);

        return $tipos;

    }

    private static function obterMapeamentoParaCamposBooleanos()
    {
        return array_fill_keys(array(
            self::MODO_CAMPO_PERSONALIZADO . MCustomField::FORMAT_BOOLEAN,
            self::MODO_CAMPO_DO_CATALOGO . bInfoColuna::TIPO_BOOLEAN
        ), new SCampoGenericoBooleano());

    }

    private static function obterMapeamentoParaCamposData()
    {
        return array_fill_keys(array(
            self::MODO_CAMPO_PERSONALIZADO . MCustomField::FORMAT_DATE,
            self::MODO_CAMPO_DO_CATALOGO . bInfoColuna::TIPO_DATA
        ), new SCampoGenericoData());

    }

    private static function obterMapeamentoParaCamposTimestamp()
    {
        return array_fill_keys(array(
            self::MODO_CAMPO_DO_CATALOGO . bInfoColuna::TIPO_TIMESTAMP
        ), new SCampoGenericoTexto()); // Ainda não há suporte para tipos timestamp no MIOLO20

    }

    private static function obterMapeamentoParaCamposDecimais()
    {
        return array_fill_keys(array(
            self::MODO_CAMPO_PERSONALIZADO . MCustomField::FORMAT_DECIMAL,
            self::MODO_CAMPO_DO_CATALOGO . bInfoColuna::TIPO_DECIMAL,
            self::MODO_CAMPO_DO_CATALOGO . bInfoColuna::TIPO_NUMERIC,
            self::MODO_CAMPO_DO_CATALOGO . bInfoColuna::TIPO_DOUBLE
        ), new SCampoGenericoDecimal());

    }

    private static function obterMapeamentoParaCamposInteiros()
    {
        return array_fill_keys(array(
            self::MODO_CAMPO_PERSONALIZADO . MCustomField::FORMAT_INTEGER,
            self::MODO_CAMPO_DO_CATALOGO . bInfoColuna::TIPO_INTEIRO,
            self::MODO_CAMPO_DO_CATALOGO . bInfoColuna::TIPO_INTEIRO_LONGO
        ), new SCampoGenericoInteiro());

    }

    private static function obterMapeamentoParaCamposTextuais()
    {
        return array_fill_keys(array(
            self::MODO_CAMPO_PERSONALIZADO . MCustomField::FORMAT_TEXT,
            self::MODO_CAMPO_DO_CATALOGO . bInfoColuna::TIPO_TEXTO
        ), new SCampoGenericoTexto());

    }

    private static function obterMapeamentoParaCamposTextuaisLongos()
    {
        return array_fill_keys(array(
            self::MODO_CAMPO_PERSONALIZADO . MCustomField::FORMAT_LONG_TEXT,
            self::MODO_CAMPO_DO_CATALOGO . bInfoColuna::TIPO_TEXTO_LONGO
        ), new SCampoGenericoTextoLongo());

    }

    private static function obterMapeamentoParaCamposListagem()
    {
        return array_fill_keys(array(
            self::MODO_CAMPO_PERSONALIZADO . MCustomField::FORMAT_LIST
        ), new SCampoGenericoLista());

    }

    private static function obterMapeamentoParaCamposListagemSQL()
    {
        return array_fill_keys(array(
            self::MODO_CAMPO_PERSONALIZADO . MCustomField::FORMAT_LISTSQL
        ), new SCampoGenericoListaSQL());

    }

    protected function obterValidador()
    {
        $validador = $this->obterValidadorRequeridoSeNecessario();

        if ( !$validador )
        {
            $validador = new MRegExpValidator($this->id, $this->rotulo);
        }

        if ( $this->tamanho !== 0 )
        {
            if ( $this->tamanhoMinimo )
            {
                $validador->min = $this->tamanhoMinimo;
            }

            $validador->max = $this->tamanho;
        }

        return $validador;

    }

    private function obterValidadorRequeridoSeNecessario()
    {
        return $this->obrigatorio ? new MRequiredValidator($this->id, "", $this->tamanho) : null;

    }

}

/**
 * Classe referente ao tipo genérico booleano
 * 
 * Implementa os métodos para gerar campos booleandos
 * 
 * @author Luís Augusto Weber Mercado [luis_augusto@solis.com.br]
 * 
 * @access private
 */
class SCampoGenericoBooleano extends SCampoGenerico
{

    public function gerar()
    {
        if ( $this->valor === NULL )
        {
            $this->valor = DB_FALSE;
        }

        $campo = new MSelection($this->id, $this->valor, $this->rotulo, SAGU::getYesNo(), NULL, "", "", FALSE);

        return array($campo, null);

    }

}

/**
 * Classe referente ao tipo genérico data
 * 
 * Implementa os métodos para gerar campos de data
 * 
 * @author Luís Augusto Weber Mercado [luis_augusto@solis.com.br]
 * 
 * @access private
 */
class SCampoGenericoData extends SCampoGenerico
{

    public function gerar()
    {
        $campo = new MCalendarField($this->id, $this->valor, $this->rotulo, SAGU::getParameter("basic", "FIELD_DESCRIPTION_SIZE"));

        if ( $this->obrigatorio )
        {
            $campo->validador->type = "required";
        }

        return array($campo, null);

    }

}

/**
 * Classe referente ao tipo genérico de timestamp
 * 
 * Implementa os métodos para gerar campos de timestamp
 * 
 * @author Luís Augusto Weber Mercado [luis_augusto@solis.com.br]
 * 
 * @access private
 */
class SCampoGenericoTimestamp extends SCampoGenerico
{

    public function gerar()
    {
        $campo = new MTimestampField($this->id, NULL, $this->rotulo);

        return array($campo, $this->obterValidador());

    }

}

/**
 * Classe referente ao tipo genérico decimal
 * 
 * Implementa os métodos para gerar campos flutuantes (decimais)
 * 
 * @author Luís Augusto Weber Mercado [luis_augusto@solis.com.br]
 * 
 * @access private
 */
class SCampoGenericoDecimal extends SCampoGenerico
{

    public function gerar()
    {
        $campo = new MFloatField($this->id, $this->valor, $this->rotulo, SAGU::getParameter("basic", "FIELD_DESCRIPTION_SIZE"));
        $validador = new MFloatValidator($this->id, $this->rotulo, SAGU::getParameter("BASIC", "FLOAT_SEPARATOR"), SAGU::getParameter("BASIC", "REAL_ROUND_VALUE"));

        if ( $this->obrigatorio )
        {
            $validador->type = "required";
        }

        $campo->setSeparator(SAGU::getParameter("BASIC", "FLOAT_SEPARATOR"));

        return array($campo, $validador);

    }

}

/**
 * Classe referente ao tipo genérico inteiro
 * 
 * Implementa os métodos para gerar campos de números inteiros
 * 
 * @author Luís Augusto Weber Mercado [luis_augusto@solis.com.br]
 * 
 * @access private
 */
class SCampoGenericoInteiro extends SCampoGenerico
{

    public function gerar()
    {
        $campo = new MIntegerField($this->id, $this->valor, $this->rotulo, SAGU::getParameter("basic", "FIELD_ID_SIZE"));
        $validador = new MIntegerValidator($this->id, $this->rotulo);

        if ( $this->obrigatorio )
        {
            $validador->type = "required";
        }

        return array($campo, $validador);

    }

}

/**
 * Classe referente ao tipo genérico de texto
 * 
 * Implementa os métodos para gerar campos de texto
 * 
 * @author Luís Augusto Weber Mercado [luis_augusto@solis.com.br]
 * 
 * @access private
 */
class SCampoGenericoTexto extends SCampoGenerico
{

    public function gerar()
    {
        $campo = new MTextField($this->id, $this->valor, $this->rotulo, SAGU::getParameter("basic", "FIELD_DESCRIPTION_SIZE"));

        return array($campo, $this->obterValidador());

    }

}

/**
 * Classe referente ao tipo genérico de texto longo
 * 
 * Implementa os métodos para gerar campos de textos longos
 * 
 * @author Luís Augusto Weber Mercado [luis_augusto@solis.com.br]
 * 
 * @access private
 */
class SCampoGenericoTextoLongo extends SCampoGenerico
{

    public function gerar()
    {
        $campo = new MMultiLineField($this->id, $this->valor, $this->rotulo, NULL, SAGU::getParameter("basic", "FIELD_MULTILINE_NUM_ROWS"), SAGU::getParameter("basic", "FIELD_MULTILINE_NUM_COLS"));

        return array($campo, $this->obterValidador());

    }

}

/**
 * Classe referente ao tipo genérico de lista
 * 
 * Implementa os métodos para gerar campos de lista
 * 
 * @author Luís Augusto Weber Mercado [luis_augusto@solis.com.br]
 * 
 * @access private
 */
class SCampoGenericoLista extends SCampoGenerico
{

    public function gerar()
    {
        $campo = new MSelection($this->id, $this->valor, $this->rotulo, $this->transformarValoresPossiveisParaLista());

        return array($campo, $this->obterValidador());

    }

    private function transformarValoresPossiveisParaLista()
    {
        $valoresPossiveis = explode("\n", trim($this->valoresPossiveis));

        $lista = array();

        foreach ( $valoresPossiveis as $valor )
        {
            $valorNormalizado = trim($valor);
            $lista[$valorNormalizado] = $valorNormalizado;
        }

        return $lista;

    }

}

/**
 * Classe referente ao tipo genérico de lista SQL
 * 
 * Implementa os métodos para gerar campos de lista a partir de um SQL
 * 
 * @author Luís Augusto Weber Mercado [luis_augusto@solis.com.br]
 * 
 * @access private
 */
class SCampoGenericoListaSQL extends SCampoGenerico
{

    public function gerar()
    {
        $campo = new MSelection($this->id, $this->valor, $this->rotulo, $this->transformarValoresPossiveisParaListaDeConsulta());

        return array($campo, $this->obterValidador());

    }

    private function transformarValoresPossiveisParaListaDeConsulta()
    {
        $lista = array();

        if ( strlen($this->valoresPossiveis) > 0 )
        {
            $sql = SAGU::prepare($this->valoresPossiveis, $this->transformarParametrosParaLista(), false);

            $query = SDatabase::query($sql);

            foreach ( (array) $query as $row )
            {
                $lista[$row[0]] = $row[1];
            }
        }

        return $lista;

    }

    private function transformarParametrosParaLista()
    {
        if ( strlen($this->parametros) > 0 )
        {
            return (array) explode(',', $this->parametros);
        }
        else
        {
            return array();
        }

    }

}

?>