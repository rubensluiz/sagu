<?php
/**
 * <--- Copyright 2005-2010 de Solis - Cooperativa de Soluções Livres Ltda.
 *
 * Este arquivo é parte do programa Sagu.
 *
 * O Sagu é um software livre; você pode redistribuí-lo e/ou modificá-lo
 * dentro dos termos da Licença Pública Geral GNU como publicada pela Fundação
 * do Software Livre (FSF); na versão 2 da Licença.
 *
 * Este programa é distribuído na esperança que possa ser útil, mas SEM
 * NENHUMA GARANTIA; sem uma garantia implícita de ADEQUAÇÃO a qualquer MERCADO
 * ou APLICAÇÃO EM PARTICULAR. Veja a Licença Pública Geral GNU/GPL em
 * português para maiores detalhes.
 *
 * Você deve ter recebido uma cópia da Licença Pública Geral GNU, sob o título
 * "LICENCA.txt", junto com este programa, se não, acesse o Portal do Software
 * Público Brasileiro no endereço www.softwarepublico.gov.br ou escreva para a
 * Fundação do Software Livre (FSF) Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA --->
 *
 * @author Luís Augusto Weber Mercado [luis_augusto@solis.com.br]
 *
 * @version $Id$
 *
 * \b Maintainers: \n
 * Luís Augusto Weber Mercado [luis_augusto@solis.com.br]
 * 
 * @since
 * Class created on 13/10/2014
 *
 **/
class BasConstrutorDeRelatorios extends SType
{
    /**
     * Constante que define o nome da tabela do qual esse type trabalha
     * 
     */
    const TABELA = "basconstrutorderelatorios";
    
    /**
     * Sufixo que determina se é uma função
     * 
     */
    const SUFIXO_FUNCAO = "fn";
    
    /**
     * Sufixo que determina se é uma visão
     * 
     */
    const SUFIXO_VISAO = "vi";
    
    /**
     * Contém a relação do nome dos módulos com as siglas
     * 
     * @var Array
     */
    public static $SIGLAS = array(
        "academic" => "acd",
        "basic" => "bas",
        "finance" => "fin",
        "accountancy" => "acc",
        "humanResources" => "hur",
        "institutional" => "ins",
        "pedagogico" => "acp",
        "residency" => "res",
        "resmedica" => "med"
        
    );
    
    /**
     *
     * @var Boolean 
     */
    protected $_utilizaNovoPadrao = true;
    
    /**
     * Identificador do relatório
     * 
     * @param Integer $idTransaction
     */
    protected $relatorioid;

    /**
     * Nome do relatório
     * 
     * @param String $nome
     */
    protected $nome;

    /**
     * Visão (agora também função) em que este é baseado
     * 
     * @param String $viewbaseada
     */
    protected $viewbaseada;
    
    /**
     * Consulta geratriz do relatório
     * 
     * @param String $consulta
     */
    protected $consulta;
    
    /**
     * Dados do relatório no formato JSON
     * 
     * @param String $dados
     */
    protected $dados;
    
    /**
     * Se este relatório está publicado('t') ou não('f')
     * 
     * @param Boolean $publicado
     */
    protected $publicado;
    
    /**
     * Descrição do relatório
     * 
     * @param Boolean $descricao
     */
    protected $descricao;
    
    /**
     * Construtor da classe
     * 
     * @param Integer $relatorioid
     */
    public function __construct($relatorioid = NULL)
    {
        if ( (strlen($relatorioid)  >  0) )
        {
            $this->relatorioid = $relatorioid;
            $this->populate();
        }
        
        parent::__construct();
        
    }
    
    /**
     * Popula o type
     * 
     */
    private function populate()
    {
        $sql = ""
            . "SELECT "
                . "relatorioid, "
                . "nome, "
                . "viewbaseada, "
                . "consulta, "
                . "dados, "
                . "publicado, "
                . "descricao "
            . "FROM " . self::TABELA . " "
            . "WHERE relatorioid = ?";
        
        $result = SDatabase::query($sql, array($this->relatorioid));

        if ( !strlen($result[0][0]) )
        {
            return false;
            
        }

        list(
            $this->relatorioid,
            $this->nome,
            $this->viewbaseada,
            $this->consulta,
            $this->dados,
            $this->publicado,
            $this->descricao
                
        ) = $result[0];
        
    }
    
    /**
     * Salva as operações realizadas com o type
     * 
     * @return Boolean
     */
    public function save()
    {
        if ( strlen($this->relatorioid)  ==  0 )
        {
            $retVal = $this->insert();
            
        }
        else
        {
            $retVal = $this->update();
            
        }

        return $retVal;
        
    }
    
    /**
     * Insere as informações na tabela
     * 
     * @return Boolean TRUE se foi possível inserir o relatório
     */
    private function insert()
    {
        $sqlPK = "SELECT nextval('basconstrutorderelatorios_relatorioid_seq'::regclass)";
        $resulConsultaPK = SDatabase::query($sqlPK);
   
        $sql = ""
            . "INSERT INTO " . self::TABELA . " ("
                . "relatorioid, "
                . "nome, "
                . "viewbaseada, "
                . "consulta, "
                . "dados, "
                . "publicado, "
                . "descricao "
            . ") VALUES (?, ?, ?, ?, ?, ?, ?)";
        
        $relatorioid = $resulConsultaPK[0][0];
        $params = array(
            $relatorioid,
            $this->nome,
            $this->viewbaseada,
            $this->consulta,
            $this->dados,
            $this->publicado,
            $this->descricao
            
        );
        
        $this->relatorioid = $relatorioid;
        
        return SDatabase::execute($sql, $params, false);
        
    }
    
    /**
     * Atualiza o relatório
     * 
     * @return Boolean TRUE se foi possível atualizar o relatório
     */
    private function update()
    {
        $sql = ""
            . "UPDATE " . self::TABELA . " "
            . "SET "
                . "nome = ?, "
                . "viewbaseada = ?, "
                . "consulta = ?, "
                . "dados = ?, "
                . "publicado = ?, "
                . "descricao = ? "
            . "WHERE relatorioid = ?";
        
        $params = array(
            $this->nome,
            $this->viewbaseada,
            $this->consulta,
            $this->dados,
            $this->publicado,
            $this->descricao,
            $this->relatorioid
            
            
        );
        
        return SDatabase::execute($sql, $params, false);
        
    }

    /**
     * Deleta o relatório
     * 
     * @return Boolean TRUE se foi possível excluir o relatório
     * @throws Exception Caso não seja possível excluir o relatório
     */
    public function delete()
    {
        if ( strlen($this->relatorioid)  ==  0 )
        {
            throw new Exception(_M("Não é possível excluir um registro que ainda não foi salvo."));
            
        }

        $sql = ""
            . "DELETE FROM " . self::TABELA . " "
            . "WHERE relatorioid = ?";
        
        $params = array($this->relatorioid);
        
        $result = SDatabase::execute($sql, $params);

        if ( $result )
        {
            $this->relatorioid = null;
            
        }

        return $result;
        
    }
    
    /**
     * Carrega a lista de views disponíveis para se gerar o relatório
     * 
     * @return {Array} Nomes das views
     */
    public static function listaVisoes()
    {
        $sql = "
              SELECT c.relname as viewname,
                     des.description as descricao  
              FROM pg_class c
              INNER JOIN pg_namespace AS n
                  ON ( n.oid = c.relnamespace )
              INNER JOIN pg_attribute AS a
                  ON ( a.attrelid = c.oid )
              INNER JOIN pg_type AS t
                  ON ( a.atttypid = t.oid )
              LEFT JOIN pg_attrdef AS def
                  ON ( def.adrelid = c.oid AND a.attnum = def.adnum )
              LEFT JOIN pg_description AS d
                  ON ( d.objoid = c.oid AND d.objsubid = a.attnum )
              INNER JOIN pg_views AS vi
                  ON (vi.viewname = c.relname)
              LEFT JOIN pg_description AS des
	          ON (des.objoid = c.oid)
              WHERE c.relname LIKE 'cr\\_%'
              GROUP BY c.relname, des.description
              ORDER BY c.relname;";
        
        $query = SDatabase::query($sql);
        
        $resultado = array();
        
        // Normaliza os resultados para um único array
        foreach($query as $item)
        {
            $resultado[] = array($item[0] => !is_null($item[1]) ? $item[1] : $item[0]);
            
        }
                
        $listaModulos = BasConstrutorDeRelatorios::listaModulosPermitidos();
        $modulosPermitidos = array();
        
        $siglas = BasConstrutorDeRelatorios::$SIGLAS;
        
        // Pega as siglas dos módulos que o usuário possui permissão
        foreach( $listaModulos as $modulo )
        {
            if( isset($siglas[$modulo]) )
            {
                $modulosPermitidos[] = $siglas[$modulo];
                
            }
            
        }
        
        $retorno = array();
        
        // Retorna apenas os itens que o usuário tem permissão
        foreach( $resultado as $item )
        {
            $key = array_keys($item);
            
            $data = explode("_", $key[0]);
            
            // Se a sigla presente no nome da view está presente na de módulos permitidos
            // data[1] = sigla do módulo
            if( in_array($data[1], $modulosPermitidos) )
            {
                $retorno[$key[0]. ";" . BasConstrutorDeRelatorios::SUFIXO_VISAO] = $item[$key[0]];
                
            }
            
        }
        
        return $retorno;
        
    }
    
    /**
     * Lista as funções disponíveis na aplicação
     * 
     * @return Array Lista de funções
     */
    public static function listaFuncoes()
    {
        $sql = "SELECT 
                    pp.proname AS nome,
                    d.description as descricao
                FROM pg_proc pp
                    INNER JOIN pg_namespace pn ON (pp.pronamespace = pn.oid)
                    INNER JOIN pg_language pl ON (pp.prolang = pl.oid)
                    INNER JOIN pg_type pt ON (pp.prorettype = pt.oid)
                    LEFT JOIN pg_description AS d ON (d.objoid = pp.oid)
                WHERE pl.lanname NOT IN ('c','internal') 
                    AND pn.nspname NOT LIKE 'pg_%'
                    AND pn.nspname <> 'information_schema'
                    AND pp.proname LIKE 'cr\\_%'
                ORDER BY pp.proname";
        
        $query = SDatabase::query($sql);
        
        $resultado = array();
        
        // Normaliza os resultados para um único array
        foreach($query as $item)
        {
            $resultado[] = array($item[0] => !is_null($item[1]) ? $item[1] : $item[0]);
            
        }
                
        $listaModulos = BasConstrutorDeRelatorios::listaModulosPermitidos();
        $modulosPermitidos = array();
        $siglas = BasConstrutorDeRelatorios::$SIGLAS;
        
        // Pega as siglas dos módulos que o usuário possui permissão
        foreach( $listaModulos as $modulo )
        {
            if( isset($siglas[$modulo]) )
            {
                $modulosPermitidos[] = $siglas[$modulo];
                
            }
            
        }
        
        $retorno = array();
        
        // Retorna apenas os itens que o usuário tem permissão
        foreach( $resultado as $item )
        {
            $key = array_keys($item);
            
            $data = explode("_", $key[0]);
            
            // Se a sigla presente no nome da view está presente na de módulos permitidos
            // data[1] = sigla do módulo
            if( in_array($data[1], $modulosPermitidos) )
            {
                $retorno[$key[0]. ";" . BasConstrutorDeRelatorios::SUFIXO_FUNCAO] = $item[$key[0]];
                
            }
            
        }
        
        return $retorno;
        
    }
    
    /**
     * Lista os módulos que o usuário possui alguma permissão
     * 
     * @return {Array} Módulos permitidos
     */
    public static function listaModulosPermitidos()
    {
        $MIOLO = MIOLO::getInstance();
        $login = $MIOLO->GetLogin()->id;
        $unidade = sMultiUnidade::obterUnidadeLogada();
        
        $sqlCompl = "";
        
        if( $unidade )
        {
            $sqlCompl = " AND grupo_user.unitid = '{$unidade}'";
            
        }
        
        $sql = "
             SELECT transaction.idmodule
             FROM miolo_user users
             INNER JOIN miolo_groupuser AS grupo_user
                     ON (grupo_user.iduser = users.iduser)
             INNER JOIN miolo_access AS acesso
                     ON (acesso.idgroup = grupo_user.idgroup)
             INNER JOIN miolo_transaction AS transaction
                     ON (transaction.idtransaction = acesso.idtransaction)
             WHERE users.login = '{$login}'
             AND transaction.parentm_transaction = ''";
        
        $sql .= $sqlCompl;
             
        $result = SDatabase::query($sql);
        
        $return = array();
        
        foreach($result as $resultado)
        {
            $return[] = $resultado[0];
            
        }
        
        return $return;
        
    }
    
    /**
     * Lista os campos das views
     * 
     * @param {String} $viewName Nome da view
     * @return {Array} Informações dos campos relacionados a view
     */
    public static function listaCamposView($viewName)
    {
        $sql = "
                SELECT a.attname::varchar as coluna,
                       format_type(t.oid, null) as tipo_coluna
                  FROM pg_class c
            INNER JOIN pg_namespace AS n
                    ON ( n.oid = c.relnamespace )
            INNER JOIN pg_attribute AS a
                    ON ( a.attrelid = c.oid )
            INNER JOIN pg_type AS t
                    ON ( a.atttypid = t.oid )
             LEFT JOIN pg_attrdef AS def
                    ON ( def.adrelid = c.oid AND a.attnum = def.adnum )
             LEFT JOIN pg_description AS d
                    ON ( d.objoid = c.oid AND d.objsubid = a.attnum )
            INNER JOIN pg_views AS vi
                    ON (vi.viewname = c.relname)
                 WHERE c.relname LIKE 'cr_%' AND c.relname = '{$viewName}'";
                     
        $result = SDatabase::query($sql);
        
        $return = array();
        
        unset($sql);
        $sql = " SELECT * FROM {$viewName} LIMIT 1 ";
        $dados = SDatabase::query($sql);
        $dadosExemplo = $dados[0];
                
        foreach($result as $key => $resultado)
        {
            // Verifica cada registro se é uma data
            if ( preg_match("/[0-9]{2}\/[0-9]{2}\/[0-9]{4}/", $dadosExemplo[$key]) )
            {
                $resultado[1] = 'date';
            }
            
            $return[] = array("nome" => $resultado[0], "tipo" => $resultado[1]);
        }
        
        return $return;
    }
    
    /**
     * Procura os campos da função
     * 
     * @param String $nome Nome da função selecionada
     * @return Array Campos da função
     */
    public static function listaCamposFuncao($nome)
    {
        // SQL que pega os parâmetros e o retorno de uma função
        $sql = "
                SELECT
                    pg_get_function_arguments(pp.oid) AS argumentos,
                    pg_get_function_result(pp.oid) AS retorno,
                    pg_get_function_identity_arguments(pp.oid) AS argumentos_resumidos
                FROM pg_proc pp
                WHERE pp.proname = '{$nome}'";
                     
        $result = SDatabase::query($sql);
        
        $retorno = array();
        $parametros = array();
        $matches = array();
        $campos = array();
        
        // Se o retorno da função é um SETOF de um type
        if( strpos($result[0][1], "SETOF") === 0 )
        {
            $type = str_replace("SETOF ", "", $result[0][1]);
            
            $sqlInfoSETOF = "
                SELECT attname || ' ' || format_type(atttypid, atttypmod) as campo
                FROM pg_type
                     JOIN pg_class ON pg_class.oid = pg_type.typrelid
                     JOIN pg_attribute ON pg_attribute.attrelid = pg_class.oid
                WHERE typname = '{$type}'
                ORDER BY attnum";
         
            $resultadoSETOF = SDatabase::query($sqlInfoSETOF);
            
            foreach( $resultadoSETOF as $row )
            {
                $campos[] = trim($row[0]);
                
            }
        }
        // Se o retorno de uma função é uma TABLE
        else if(strpos($result[0][1], "TABLE") === 0)
        {
            preg_match("/\(.*\)/", $result[0][1], $matches);
        
            if( count($matches) > 0 )
            {
                $campos = explode(",", trim($matches[0], "\(\)"));

            }
        }
        
        $argumentos = explode(",", $result[0][2]);
        $defaults = array();
        
        // Verifica a partir de qual parâmetro há DEFAULTS
        $attrDefault = strpos($result[0][0], "DEFAULT");
        $temAtributosDefaultPartindoDe = null;
        
        // Se tem algum valor default
        if( $attrDefault !== false )
        {
            $defs = array();
            
            // Pega os valores default
            preg_match_all("/(?!( DEFAULT ))((?<=\').*(?=\'))|([0-9]+(\.[0-9]+)?)|(true|false)(?=(\,|$))/", $result[0][0], $defs);

            $defaults = $defs[0];
            
            // Conta o número de ',' da string até a posição da primeira string default
            $temAtributosDefaultPartindoDe = substr_count($result[0][0], ",", 0, $attrDefault);
                        
        }
        
        // Define a key para acesso ao vetor de valores default
        $keyAttrDefault = 0;
        
        foreach( $argumentos as $key => $argumento )
        {
            $props = explode(" ", trim($argumento));
            $default = null;
            
            if( !is_null($temAtributosDefaultPartindoDe) )
            {
                // Considera os valores defaults se a chave for maior ou igual
                // a primeira ocorrencia de um atributo default
                if( $key >= $temAtributosDefaultPartindoDe )
                {
                    $default = $defaults[$keyAttrDefault];
                    
                    // Se é um campo booleano, altera seu valor para ficar no padrão
                    // do CR
                    if( $props[1] === "boolean" )
                    {
                        $default = $default === "true" ? "t" : "f";
                        
                    }
                                        
                    $keyAttrDefault++;
                    
                    
                }
                
            }
            
            $parametros[] = array(
                "nome" => str_replace("p_", "", $props[0]),
                "tipo" => $props[1],
                "valorDefault" => $default
            );
        }
                
        // Navega entre os campos (valores de retorno da fun??o)
        foreach( $campos as $campo )
        {
            $campo = trim($campo);
            $crop = strpos($campo, " ");

            $nome = substr($campo, 0, $crop); 

            $retorno[] = array(
                "nome" => $nome,
                "tipo" => substr($campo, $crop + 1)
                
            );
            
        }
                
        return array($retorno, $parametros); 
    }
    
    /**
     * Faz a consulta do SQL filtrado na base
     * 
     * @return Integer Total de dados
     */
    public static function getTotalDados($sql)
    {
        $MIOLO = MIOLO::getInstance();
        
        $msql = new MSQL();
        $msql->setDb($MIOLO->GetDatabase());
        $msql->createFrom($sql);
        $msql->clearColumns();
        $msql->setColumns('*');
        $select = $msql->select();
        
        $result = SDatabase::query("SELECT COUNT(*) FROM ($select) AS MGRID_COUNT");

        return intval($result[0][0]);
                
    }
    
    /**
     * Procura a transação pai para o relatório
     * Tenta primeiro moduloReport depois moduloDocument
     * 
     * @param String $modulo
     * 
     * @return Object Objeto com o resultado da consulta
     */
    public static function getParentTransactionPeloModulo($modulo)
    {
        $parametros = array(strtoupper($modulo), strtoupper($modulo));
        
        $sql = ""
             . "SELECT COALESCE( "
                . "( SELECT m_transaction "
                . "FROM miolo_transaction "
                . "WHERE parentm_transaction = ? "
                . "AND action = 'main:report' ), "

                . "( SELECT m_transaction "
                . "FROM miolo_transaction "
                . "WHERE parentm_transaction = ? "
                . "AND action = 'main:document' )" 
             . " )";
        
        $resultado = SDatabase::query(SAGU::prepare($sql, $parametros, false));
        
        return $resultado[0][0];
        
    }
    
    /**
     * Gera a consulta SQL
     * 
     * @param {Object} $data Objeto com os dados
     * @return {String} Consulta usada no relatório
     */
    public static function geraSQL($data)
    {
        $info = $data->selectedView;
                
        $explode = explode(";", $info);
        
        $isFuncao = $explode[1] === BasConstrutorDeRelatorios::SUFIXO_FUNCAO;        
        
        $sql = "SELECT ";
        $where = "";
        $ordem = "";
        
        $campos = array();
        $filtros = array();
        $listaOrdem = array();
              
        $from = $explode[0];
        
        if( $isFuncao )
        {
            $params = array();
            
            for( $i = 0; $i < count($data->parametros); $i++ )
            {
                $valorParam = utf8_decode($data->parametrosValor[$i]);
                
                if ( in_array($data->parametros[$i]->tipo, array("numeric", "integer")) )
                {
                    $params[] = $valorParam;
                    
                }
                else if ( $data->parametros[$i]->tipo == "date" )
                {
                    $params[] = "TO_DATE('{$valorParam}', 'dd/mm/yyyy')";
                    
                }
                else
                {
                    $params[] = "'{$valorParam}'";
                    
                }
                                
            }
            
            $funcArgs = implode(", ", $params);
            
            $from .= "({$funcArgs})";
            
        }
        
        // Navega entre os campos
        for( $i = 0; $i < $data->countCampo; $i++ )
        {
            $add = "";
                        
            $tipo = $data->ordemCampo[$i]->tipo;
            $nome = $data->ordemCampo[$i]->nome;
            
            $filtro = !is_null($data->filtrosCampo[$i]) ? $data->filtrosCampo[$i] : false;
            
            // Garante que o filtro no caso do campo númerico seja mesmo um número
            if ( in_array($tipo, array("numeric", "integer")) )
            {
                $filtro = is_numeric($filtro) ? $filtro : false;
                
            }
            
            $operacao = $data->operacoesCampo[$i];
                        
            if( $operacao )
            {
                $add = "{$nome} AS \"{$nome}@{$operacao}\"";
                                
            }
            else
            {
                $add = "{$nome}";
                
            }
            
            $coluna = $nome;
            
            $apelido = $data->apelidosCampo[$i] ? utf8_decode($data->apelidosCampo[$i]) : $coluna;
            
            $posicaoGrupo = array_search($data->ordemCampo[$i], $data->ordemGrupo);
            $posicaoGrupo++; // A posição do array +1
            $campos[] = $posicaoGrupo !== false ? "{$coluna} AS \"{$apelido}@GROUP{$posicaoGrupo}\"" : "{$coluna} AS \"{$apelido}\"" ;
            
            if( $filtro )
            {
                // Se for um array, estamos tratando de datas
                if( is_array($filtro) )
                {
                    $explode = explode("/", $filtro[0]);
                    
                    $dti = implode("-", array_reverse($explode));
                    $dtf = null;
                    $operador = "";
                    
                    // Se o campo 'Até' foi informado
                    if( $filtro[1] )
                    {
                        $explode = explode("/", $filtro[1]);
                        $dtf = implode("-", array_reverse($explode));
                        
                        $operador = "dataestanointervalo({$nome}::date, '{$dti}'::date, '{$dtf}'::date) = TRUE";
                        
                    }
                    else
                    {
                        $operador = "{$nome}::date = '{$dti}'::date";
                        
                    }
                    
                    
                    $filtros[] = $operador;
                    
                }
                else
                {
                    $filtro = utf8_decode($filtro);
                    
                    $operador = $tipo === "text" ? " ILIKE '%{$filtro}%'" : " = '{$filtro}'";

                    $filtros[] = $nome . $operador;
                    
                }
                                
            }
                                    
        }
        
        $listaCampos = implode(", ", $campos);
        
        if( count($filtros) > 0 )
        {
            $where = " WHERE " . implode(" AND ", $filtros);
            
        }
        
        // Ordem
        for( $i = 0; $i < $data->countOrdem; $i++ )
        {
            if ( $data->ordemOrdem[$i]->tipo == "date" )
            {
                $data->ordemOrdem[$i]->nome .= '::DATE';
            }
            
            $listaOrdem[] = "{$data->ordemOrdem[$i]->nome} {$data->sentidoOrdem[$i]}";
            
        }
        
        if( count($listaOrdem) > 0 )
        {
            $ordem = " ORDER BY " . implode(", ", $listaOrdem);
            
        }
        
        // Adiciona tudo ao SQL
        $sql .= "{$listaCampos} FROM {$from}{$where}{$ordem}";
        
        return $sql;
        
    }

}
?>