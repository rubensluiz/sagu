<?php

/**
 * <--- Copyright 2005-2012 de Solis - Cooperativa de Soluções Livres Ltda.
 *
 * Este arquivo é parte do programa Sagu.
 *
 * O Sagu é um software livre; você pode redistribuí-lo e/ou modificá-lo
 * dentro dos termos da Licença Pública Geral GNU como publicada pela Fundação
 * do Software Livre (FSF); na versão 2 da Licença.
 *
 * Este programa é distribuído na esperança que possa ser útil, mas SEM
 * NENHUMA GARANTIA; sem uma garantia implícita de ADEQUAÇÃO a qualquer MERCADO
 * ou APLICAÇÃO EM PARTICULAR. Veja a Licença Pública Geral GNU/GPL em
 * português para maiores detalhes.
 *
 * Você deve ter recebido uma cópia da Licença Pública Geral GNU, sob o título
 * "LICENCA.txt", junto com este programa, se não, acesse o Portal do Software
 * Público Brasileiro no endereço www.softwarepublico.gov.br ou escreva para a
 * Fundação do Software Livre (FSF) Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA --->
 *
 * Classe que representa a tabela de busca dinâmica.
 *
 * @author Daniel Hartmann [daniel@solis.coop.br]
 *
 * \b Maintainers: \n
 * Daniel Hartmann [daniel@solis.coop.br]
 *
 * @since
 * Class created on 09/02/2012
 *
 */
class BasBuscaDinamica extends SType
{
    /**
     * @AttributeType integer
     */
    protected $codigo;

    /**
     * @AttributeType integer
     */
    protected $identificador;

    /**
     * @AttributeType character varying
     */
    protected $tipo;

    /**
     * @AttributeType character varying
     */
    protected $nome;

    /**
     * @AttributeType text
     */
    protected $valoresPossiveis;

    /**
     * @AttributeType integer
     */
    protected $posicao;

    /**
     * @AttributeType text
     */
    protected $valorPadrao;

    /**
     * @AttributeType boolean
     */
    protected $editavel;

    /**
     * @AttributeType boolean
     */
    protected $visivel;

    /**
     * @AttributeType text
     */
    protected $referencia;

    /**
     * @AttributeType boolean
     */
    protected $filtravel;

    /**
     * @AttributeType boolean
     */
    protected $exibirNaGrid;

    /**
     * @AttributeType text
     */
    protected $parametros;

    /**
     * @AttributeType boolean
     */
    protected $chave;

    /**
     * @AttributeType character varying
     */
    protected $modulo;

    public function __construct($codigo = NULL)
    {
        if ( strlen($codigo) > 0 )
        {
            $this->codigo = $codigo;
            $this->populate();
        }
    }

    public static function search($filters)
    {
        $sql = 'SELECT codigo
                  FROM basbuscadinamica';
        $where = '';

        foreach ( $filters as $key => $value )
        {
            if ( (is_scalar($value)) && (strlen($value) > 0) )
            {
                $where.=" AND {$key} = '{$value}'";
            }
        }

        if ( strlen($where) > 0 )
        {
            $sql.=' WHERE ' . substr($where, 5);
        }

        $sql.=' ORDER BY codigo ';
        $result = SDatabase::query($sql);
        $retVal = array( );

        for ( $i = 0; $i < count($result); $i++ )
        {
            $retVal[] = new BasBuscaDinamica($result[$i][0]);
        }

        return $retVal;
    }

    public static function searchGrid($filters = null)
    {
        $sql = 'SELECT codigo,
                       identificador,
                       tipo,
                       nome,
                       valorespossiveis,
                       posicao,
                       valorpadrao,
                       editavel,
                       visivel,
                       referencia,
                       filtravel,
                       exibirnagrid,
                       parametros,
                       chave,
                       modulo
                  FROM basbuscadinamica';
        $params = array( );

        if ( strlen($filters->codigo) > 0 )
        {
            $where.=' AND codigo = ? ';
            $params[] = $filters->codigo;
        }

        if ( strlen($filters->identificador) > 0 )
        {
            $where.=' AND UNACCENT(identificador) ILIKE UNACCENT(?) ';
            $params[] = $filters->identificador . '%';
        }

        if ( strlen($filters->tipo) > 0 )
        {
            $where.=' AND UNACCENT(tipo) ILIKE UNACCENT(?) ';
            $params[] = $filters->tipo . '%';
        }

        if ( strlen($filters->nome) > 0 )
        {
            $where.=' AND UNACCENT(nome) ILIKE UNACCENT(?) ';
            $params[] = $filters->nome . '%';
        }

        if ( strlen($filters->valoresPossiveis) > 0 )
        {
            $where.=' AND UNACCENT(valorespossiveis) ILIKE UNACCENT(?) ';
            $params[] = $filters->valoresPossiveis . '%';
        }

        if ( strlen($filters->posicao) > 0 )
        {
            $where.=' AND posicao = ?';
            $params[] = $filters->posicao;
        }

        if ( strlen($filters->valorPadrao) > 0 )
        {
            $where.=' AND UNACCENT(valorpadrao) ILIKE UNACCENT(?) ';
            $params[] = $filters->valorPadrao . '%';
        }

        if ( strlen($filters->editavel) > 0 )
        {
            $where.=' AND editavel = ?';
            $params[] = $filters->editavel;
        }

        if ( strlen($filters->visivel) > 0 )
        {
            $where.=' AND visivel = ?';
            $params[] = $filters->visivel;
        }

        if ( strlen($filters->referencia) > 0 )
        {
            $where.=' AND UNACCENT(referencia) ILIKE UNACCENT(?) ';
            $params[] = $filters->referencia . '%';
        }

        if ( strlen($filters->filtravel) > 0 )
        {
            $where.=' AND filtravel = ?';
            $params[] = $filters->filtravel;
        }

        if ( strlen($filters->exibirNaGrid) > 0 )
        {
            $where.=' AND exibirnagrid = ?';
            $params[] = $filters->exibirNaGrid;
        }

        if ( strlen($filters->modulo) > 0 )
        {
            $where.=' AND UNACCENT(modulo) ILIKE UNACCENT(?) ';
            $params[] = $filters->modulo . '%';
        }

        if ( strlen($where) > 0 )
        {
            $sql.=' WHERE ' . substr($where, 4) . '
                   ORDER BY codigo';
            $result = SDatabase::query(SAGU::prepare($sql, $params, FALSE));
        }

        return $result;
    }

    private function populate()
    {
        $MIOLO = MIOLO::getInstance();
        $module = SAGU::getFileModule(__FILE__);
        $sql = 'SELECT codigo,
                       identificador,
                       tipo,
                       nome,
                       valorespossiveis,
                       posicao,
                       valorpadrao,
                       editavel,
                       visivel,
                       referencia,
                       filtravel,
                       exibirnagrid,
                       parametros,
                       chave,
                       modulo,
                       userName,
                       ipAddress,
                       TO_CHAR(dateTime,\'' . SAGU::getParameter('BASIC', 'MASK_TIMESTAMP') . '\')
                  FROM basbuscadinamica
                 WHERE codigo = ?';
        $result = SDatabase::query($sql, array( $this->codigo ), FALSE);

        if ( !strlen($result[0][0]) )
        {
            throw new Exception(_M('Registro inexistente.', $module));
        }

        list(
            $this->codigo,
            $this->identificador,
            $this->tipo,
            $this->nome,
            $this->valoresPossiveis,
            $this->posicao,
            $this->valorPadrao,
            $this->editavel,
            $this->visivel,
            $this->referencia,
            $this->filtravel,
            $this->exibirNaGrid,
            $this->parametros,
            $this->chave,
            $this->modulo,
            $this->userName,
            $this->ipAddress,
            $this->dateTime ) = $result[0];
    }

    public function save()
    {
        if ( strlen($this->codigo) == 0 )
        {
            $retVal = $this->insert();
        }
        else
        {
            $retVal = $this->update();
        }

        return $retVal;
    }

    private function insert()
    {
        $sql = 'INSERT INTO basbuscadinamica 
                            (identificador, tipo, nome, valorespossiveis, posicao, valorpadrao, editavel, visivel, referencia, filtravel, exibirnagrid, parametros, chave, modulo)
                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)';
        $params = array(
            $this->identificador,
            $this->tipo,
            $this->nome,
            $this->valoresPossiveis,
            $this->posicao,
            $this->valorPadrao,
            $this->editavel,
            $this->visivel,
            $this->referencia,
            $this->filtravel,
            $this->exibirNaGrid,
            $this->parametros,
            $this->chave,
            $this->modulo
        );
        $result = SDatabase::execute($sql, $params, FALSE);
        return $result;
    }

    private function update()
    {
        $sql = 'UPDATE basbuscadinamica
                   SET identificador = ?,
                       tipo = ?,
                       nome = ?,
                       valorespossiveis = ?,
                       posicao = ?,
                       valorpadrao = ?,
                       editavel = ?,
                       visivel = ?,
                       referencia = ?,
                       filtravel = ?,
                       exibirnagrid = ?,
                       parametros = ?,
                       chave = ?,
                       modulo = ?
                 WHERE codigo = ?';
        $params = array(
            $this->cadastroDinamicoCodigo,
            $this->tipo,
            $this->nome,
            $this->valoresPossiveis,
            $this->posicao,
            $this->valorPadrao,
            $this->editavel,
            $this->visivel,
            $this->referencia,
            $this->filtravel,
            $this->exibirNaGrid,
            $this->parametros,
            $this->chave,
            $this->modulo,
            $this->codigo
        );
        return SDatabase::execute($sql, $params, FALSE);
    }

    public function delete()
    {
        if ( strlen($this->codigo) == 0 )
        {
            throw new Exception(_M('Não é possível excluir um registro que ainda não foi salvo.', $module));
        }

        $sql = 'DELETE FROM basbuscadinamica
                      WHERE codigo = ?';
        $params = array( $this->codigo );
        $result = SDatabase::execute($sql, $params, FALSE);

        if ( $result )
        {
            $this->identificador = null;
            $this->codigo = null;
        }

        return $result;
    }

    public static function buscarPorIdentificador($modulo, $identificador)
    {
        $sql = 'SELECT codigo,
                       identificador,
                       tipo,
                       nome,
                       valorespossiveis,
                       posicao,
                       valorpadrao,
                       editavel,
                       visivel,
                       referencia,
                       filtravel,
                       exibirnagrid,
                       parametros,
                       chave,
                       modulo
                  FROM basbuscadinamica
                 WHERE modulo = ?
                   AND identificador = ?
                  ORDER BY posicao, nome';

        $resultado = SDatabase::query(SAGU::prepare($sql, array( $modulo, $identificador ), FALSE));
        $buscas = array();

        foreach ( $resultado as $linha )
        {
            $busca = new BasBuscaDinamica();
            list(
                $busca->codigo,
                $busca->identificador,
                $busca->tipo,
                $busca->nome,
                $busca->valoresPossiveis,
                $busca->posicao,
                $busca->valorPadrao,
                $busca->editavel,
                $busca->visivel,
                $busca->referencia,
                $busca->filtravel,
                $busca->exibirNaGrid,
                $busca->parametros,
                $busca->chave,
                $busca->modulo
            ) = $linha;

            $buscas[] = $busca;
        }

        return $buscas;
    }

    /**
     * Busca registros na tabela e retorna em formato compatível com subdetail.
     *
     * @param string $modulo Módulo.
     * @param string $identificador Identificador.
     * @return array Vetor de objetos stdClass.
     */
    public static function buscarPorIdentificadorComoObjeto($modulo, $identificador)
    {
        $sql = 'SELECT codigo,
                       identificador,
                       tipo,
                       nome,
                       valorespossiveis,
                       posicao,
                       valorpadrao,
                       editavel,
                       visivel,
                       referencia,
                       filtravel,
                       exibirnagrid,
                       parametros,
                       chave,
                       modulo
                  FROM basbuscadinamica
                 WHERE modulo = ?
                   AND identificador = ? 
                  ORDER BY identificador, codigo';

        $resultado = SDatabase::query(SAGU::prepare($sql, array( $modulo, $identificador ), FALSE));
        $buscas = array();

        foreach ( (array) $resultado as $linha )
        {
            $busca = new stdClass();

            list(
                $busca->codigo,
                $busca->identificador,
                $busca->tipo,
                $busca->nome,
                $busca->valoresPossiveis,
                $busca->posicao,
                $busca->valorPadrao,
                $busca->editavel,
                $busca->visivel,
                $busca->referencia,
                $busca->filtravel,
                $busca->exibirNaGrid,
                $busca->parametros,
                $busca->chave,
                $busca->modulo
            ) = $linha;

            list(
                $busca->referenciaEsquema,
                $busca->referenciaTabela,
                $busca->referenciaColuna
            ) = explode('.', $busca->referencia);

            $buscas[] = $busca;
        }

        return $buscas;
    }

    /**
     * Verifica se identificador existe na base.
     *
     * @param type $identificador 
     * @return boolean 
     */
    public static function verificarIdentificador($modulo, $identificador)
    {
        $sql = "SELECT identificador, codigo
                  FROM basbuscadinamica
                 WHERE identificador = '$identificador'
                   AND modulo = '$modulo'";

        return count(SDatabase::query($sql)) > 0;
    }

    /**
     * Realiza consulta baseada nas colunas de referência.
     *
     * @param array $colunas Vetor de objetos SInfoColuna.
     * @param array $filtros Filtros a serem aplicados na consulta.
     * @return array Resultado da consulta.
     */
    public static function buscarNaReferencia($colunas, $filtros=array())
    {
        $params = array();
        $condicao = '';

        $colunasString = array();
        $tabelas = array();
        $tabelasString = '';
        $esquemaAnterior = '';
        $tabelaAnterior = '';
        
        // $chave é esquema.tabela.coluna
        foreach ( $colunas as $chave => $coluna )
        {
            if ( !in_array("$coluna->esquema.$coluna->tabela", $tabelas) )
            {
                $tabelas[] = "$coluna->esquema.$coluna->tabela";
                $colunasString[] = "$coluna->esquema.$coluna->tabela.$coluna->nome";

                if ( $tabelaAnterior == '' )
                {
                    $esquemaAnterior = $coluna->esquema;
                    $tabelaAnterior = $coluna->tabela;
                }

                if ( $tabelasString == '' )
                {
                    $tabelasString .= "$coluna->esquema.$coluna->tabela ";
                }
                else
                {
                    $join = $coluna->obrigatorio == 't' ? 'INNER' : 'LEFT';
                    $tabelasString .= "$join JOIN $coluna->esquema.$coluna->tabela ON ";

                    $dadosDaTabela = SInfoTabela::buscarChavesPrimariasDaTabela($coluna->tabela, $coluna->esquema);
                    $dadosDaTabelaAnterior = SInfoTabela::buscarChavesEstrangeirasDaTabela($tabelaAnterior, $esquemaAnterior);
                    
                    foreach ( $dadosDaTabela as $pk )
                    {
                        list($pkColuna, $pkTipo) = $pk;

                        foreach ( $dadosDaTabelaAnterior as $fk )
                        {
                            list($fkFromSchema, $fkFromTable, $fkFromColumn, $fkToSchema, $fkToTable, $fkToColumn) = $fk;

                            if ( $fkToColumn == $pkColuna )
                            {
                                $tabelasString .= "$fkToSchema.$fkToTable.$fkToColumn = $fkFromSchema.$fkFromTable.$fkFromColumn";
                            }
                        }
                    }

                    $esquemaAnterior = $coluna->esquema;
                    $tabelaAnterior = $coluna->tabela;
                }
            }
            else
            {
                if ( $coluna->tipo == SInfoColuna::TIPO_DATA )
                {
                    $colunasString[] = "TO_CHAR($coluna->esquema.$coluna->tabela.$coluna->nome, '" . SAGU::getParameter('BASIC', 'MASK_DATE') . "')";
                }
                else
                {
                    $colunasString[] = "$coluna->esquema.$coluna->tabela.$coluna->nome";
                }
            }
        }

        $colunasString = implode(',', $colunasString);

        $sql = "SELECT $colunasString
                  FROM $tabelasString";

        foreach ( $filtros as $chave => $valor )
        {
            if ( (is_scalar($valor)) && (strlen($valor) > 0) )
            {
                $chave = str_replace('__', '.', $chave);

                switch( $colunas[$chave]->tipo )
                {
                    case SInfoColuna::TIPO_TEXTO:
                    case SInfoColuna::TIPO_TEXTO_LONGO:
                        $condicao .= " AND UNACCENT($chave) ILIKE UNACCENT(?)";
                        $params[] = $valor . '%';
                        break;

                    case SInfoColuna::TIPO_DATA:
                        $condicao .= " AND $chave = TO_DATE(?, '" . SAGU::getParameter('BASIC', 'MASK_DATE') . "')";
                        $params[] = $valor;
                        break;

                    default:
                        $condicao .= " AND $chave = ?";
                        $params[] = $valor;
                        break;
                }
            }
        }
        
        // O padrão do SAGU é não exibir resultados quando não há filtros
        if ( strlen($condicao) > 0 )
        {
            $sql .= ' WHERE ' . substr($condicao, 4);
            $resultado = SDatabase::query(SAGU::prepare($sql, $params));
        }

        return $resultado;
    }

    /**
     * Obtém os dados das colunas a serem utilizadas pela busca dinâmica.
     *
     * @param string $modulo Módulo.
     * @param string $identificador Identificador.
     * @return array Vetor com objetos do tipo SInfoColuna.
     */
    public static function buscarDadosDasColunas($modulo, $identificador)
    {
        $sql = "SELECT pg_attribute.attname AS id,
                       basbuscadinamica.tipo,
                       basbuscadinamica.nome AS titulo,
                       pg_attribute.attnotnull AS obrigatorio,
                       basbuscadinamica.valorPadrao,
                       CASE WHEN pg_attribute.atttypmod > 4 THEN ( pg_attribute.atttypmod - 4 ) ELSE NULL END AS tamanho,
                       pg_constraint.contype AS restricao,
                       toSchema.nspname AS fkEsquema,
                       toTable.relname AS fkTabela,
                       toColumn.attname AS fkColuna,
                       basbuscadinamica.valoresPossiveis,
                       basbuscadinamica.editavel,
                       basbuscadinamica.visivel,
                       basbuscadinamica.filtravel,
                       basbuscadinamica.exibirNaGrid,
                       basbuscadinamica.parametros,
                       basbuscadinamica.chave,
                       basbuscadinamica.modulo,
                       pg_namespace.nspname AS esquema,
                       pg_class.relname AS tabela,
                       pg_namespace.nspname || '__' || pg_class.relname || '__' || pg_attribute.attname AS campo
                  FROM pg_attribute 
            INNER JOIN pg_class 
                    ON pg_class.oid = pg_attribute.attrelid
                   AND pg_class.relkind = 'r'
            INNER JOIN pg_namespace
                    ON pg_namespace.oid = pg_class.relnamespace
            INNER JOIN basbuscadinamica
                    ON pg_namespace.nspname = split_part(basbuscadinamica.referencia, '.', 1)
                   AND pg_class.relname = split_part(basbuscadinamica.referencia, '.', 2)
                   AND pg_attribute.attname = split_part(basbuscadinamica.referencia, '.', 3)
-- TYPE
            INNER JOIN pg_type 
                    ON pg_type.oid = pg_attribute.atttypid 
                   AND pg_type.typname NOT IN ('oid', 'tid', 'xid', 'cid')
-- DEFAULT VALUE
             LEFT JOIN pg_attrdef 
                    ON pg_attrdef.adrelid = pg_attribute.attrelid 
                   AND pg_attrdef.adnum = pg_attribute.attnum

-- FKS
             LEFT JOIN pg_constraint
                    ON pg_constraint.conrelid = pg_attribute.attrelid
                   AND pg_attribute.attnum = ANY(pg_constraint.conkey)
             LEFT JOIN pg_class AS toTable
                    ON toTable.oid = pg_constraint.confrelid
             LEFT JOIN pg_namespace AS toSchema
                    ON toSchema.oid = toTable.relnamespace
             LEFT JOIN pg_attribute AS toColumn
                    ON toColumn.attrelid = toTable.oid 
                   AND conkey @> ARRAY[ pg_attribute.attnum ]
                   AND position(toColumn.attnum::text IN array_to_string(confkey, ' ')) <> 0

-- COMMENT
             LEFT JOIN pg_description
                    ON pg_description.objoid = pg_class.oid
                   AND pg_description.objsubid = pg_attribute.attnum

                 WHERE basbuscadinamica.modulo = ?
                   AND basbuscadinamica.identificador = ?
                  
        ";

        $params = array( $modulo, $identificador );

        $sql .= " ORDER BY basbuscadinamica.posicao,
                           basbuscadinamica.nome";

        $resultado = SDatabase::query(SAGU::prepare($sql, $params, FALSE));

        $colunas = array();
        
        foreach ( $resultado as $linha )
        {
            $coluna = new SInfoColuna();
            list(
                $coluna->nome,
                $coluna->tipo,
                $coluna->titulo,
                $coluna->obrigatorio,
                $coluna->valorPadrao,
                $coluna->tamanho,
                $coluna->restricao,
                $coluna->fkEsquema,
                $coluna->fkTabela,
                $coluna->fkColuna,
                $coluna->valoresPossiveis,
                $coluna->editavel,
                $coluna->visivel,
                $coluna->filtravel,
                $coluna->exibirNaGrid,
                $coluna->parametros,
                $coluna->chave,
                $coluna->modulo,
                $coluna->esquema,
                $coluna->tabela,
                $coluna->campo
            ) = $linha;

            $chave = "$coluna->esquema.$coluna->tabela.$coluna->nome";
            $colunas[$chave] = $coluna;
        }

        return $colunas;
    }
}

?>